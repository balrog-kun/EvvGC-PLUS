
build/evvgc_plus.elf:     file format elf32-littlearm


Disassembly of section .text:

08000160 <Reset_Handler>:
 8000160:	b672      	cpsid	i
 8000162:	4822      	ldr	r0, [pc, #136]	; (80001ec <endfiniloop+0x4>)
 8000164:	f380 8809 	msr	PSP, r0
 8000168:	2002      	movs	r0, #2
 800016a:	f380 8814 	msr	CONTROL, r0
 800016e:	f3bf 8f6f 	isb	sy
 8000172:	f001 f9bd 	bl	80014f0 <__core_init>
 8000176:	f005 fb8b 	bl	8005890 <__early_init>
 800017a:	481d      	ldr	r0, [pc, #116]	; (80001f0 <endfiniloop+0x8>)
 800017c:	491d      	ldr	r1, [pc, #116]	; (80001f4 <endfiniloop+0xc>)
 800017e:	4a1e      	ldr	r2, [pc, #120]	; (80001f8 <endfiniloop+0x10>)

08000180 <msloop>:
 8000180:	4291      	cmp	r1, r2
 8000182:	bf3c      	itt	cc
 8000184:	f841 0b04 	strcc.w	r0, [r1], #4
 8000188:	e7fa      	bcc.n	8000180 <msloop>
 800018a:	491c      	ldr	r1, [pc, #112]	; (80001fc <endfiniloop+0x14>)
 800018c:	4a17      	ldr	r2, [pc, #92]	; (80001ec <endfiniloop+0x4>)

0800018e <psloop>:
 800018e:	4291      	cmp	r1, r2
 8000190:	bf3c      	itt	cc
 8000192:	f841 0b04 	strcc.w	r0, [r1], #4
 8000196:	e7fa      	bcc.n	800018e <psloop>
 8000198:	4919      	ldr	r1, [pc, #100]	; (8000200 <endfiniloop+0x18>)
 800019a:	4a1a      	ldr	r2, [pc, #104]	; (8000204 <endfiniloop+0x1c>)
 800019c:	4b1a      	ldr	r3, [pc, #104]	; (8000208 <endfiniloop+0x20>)

0800019e <dloop>:
 800019e:	429a      	cmp	r2, r3
 80001a0:	bf3e      	ittt	cc
 80001a2:	f851 0b04 	ldrcc.w	r0, [r1], #4
 80001a6:	f842 0b04 	strcc.w	r0, [r2], #4
 80001aa:	e7f8      	bcc.n	800019e <dloop>
 80001ac:	2000      	movs	r0, #0
 80001ae:	4917      	ldr	r1, [pc, #92]	; (800020c <endfiniloop+0x24>)
 80001b0:	4a17      	ldr	r2, [pc, #92]	; (8000210 <endfiniloop+0x28>)

080001b2 <bloop>:
 80001b2:	4291      	cmp	r1, r2
 80001b4:	bf3c      	itt	cc
 80001b6:	f841 0b04 	strcc.w	r0, [r1], #4
 80001ba:	e7fa      	bcc.n	80001b2 <bloop>
 80001bc:	f001 f9b0 	bl	8001520 <__init_ram_areas>
 80001c0:	f001 f99e 	bl	8001500 <__late_init>
 80001c4:	4c13      	ldr	r4, [pc, #76]	; (8000214 <endfiniloop+0x2c>)
 80001c6:	4d14      	ldr	r5, [pc, #80]	; (8000218 <endfiniloop+0x30>)

080001c8 <initloop>:
 80001c8:	42ac      	cmp	r4, r5
 80001ca:	da03      	bge.n	80001d4 <endinitloop>
 80001cc:	f854 1b04 	ldr.w	r1, [r4], #4
 80001d0:	4788      	blx	r1
 80001d2:	e7f9      	b.n	80001c8 <initloop>

080001d4 <endinitloop>:
 80001d4:	f00a ffcc 	bl	800b170 <main>
 80001d8:	4c10      	ldr	r4, [pc, #64]	; (800021c <endfiniloop+0x34>)
 80001da:	4d11      	ldr	r5, [pc, #68]	; (8000220 <endfiniloop+0x38>)

080001dc <finiloop>:
 80001dc:	42ac      	cmp	r4, r5
 80001de:	da03      	bge.n	80001e8 <endfiniloop>
 80001e0:	f854 1b04 	ldr.w	r1, [r4], #4
 80001e4:	4788      	blx	r1
 80001e6:	e7f9      	b.n	80001dc <finiloop>

080001e8 <endfiniloop>:
 80001e8:	f001 b992 	b.w	8001510 <__default_exit>
 80001ec:	20000800 	.word	0x20000800
 80001f0:	55555555 	.word	0x55555555
 80001f4:	20000000 	.word	0x20000000
 80001f8:	20000400 	.word	0x20000400
 80001fc:	20000400 	.word	0x20000400
 8000200:	0800ed40 	.word	0x0800ed40
 8000204:	20000800 	.word	0x20000800
 8000208:	2000115c 	.word	0x2000115c
 800020c:	20001160 	.word	0x20001160
 8000210:	200030d0 	.word	0x200030d0
 8000214:	08000160 	.word	0x08000160
 8000218:	08000160 	.word	0x08000160
 800021c:	08000160 	.word	0x08000160
 8000220:	08000160 	.word	0x08000160
	...

08000230 <_port_switch>:
 8000230:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000234:	f8c1 d00c 	str.w	sp, [r1, #12]
 8000238:	68c3      	ldr	r3, [r0, #12]
 800023a:	469d      	mov	sp, r3
 800023c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000240 <_port_thread_start>:
 8000240:	2300      	movs	r3, #0
 8000242:	f383 8811 	msr	BASEPRI, r3
 8000246:	4628      	mov	r0, r5
 8000248:	47a0      	blx	r4
 800024a:	2000      	movs	r0, #0
 800024c:	f001 fcf8 	bl	8001c40 <chThdExit>

08000250 <_port_switch_from_isr>:
 8000250:	f001 fbe6 	bl	8001a20 <chSchDoReschedule>

08000254 <_port_exit_from_isr>:
 8000254:	df00      	svc	0
 8000256:	e7fe      	b.n	8000256 <_port_exit_from_isr+0x2>
	...

08000260 <__aeabi_drsub>:
 8000260:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8000264:	e002      	b.n	800026c <__adddf3>
 8000266:	bf00      	nop

08000268 <__aeabi_dsub>:
 8000268:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800026c <__adddf3>:
 800026c:	b530      	push	{r4, r5, lr}
 800026e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8000272:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000276:	ea94 0f05 	teq	r4, r5
 800027a:	bf08      	it	eq
 800027c:	ea90 0f02 	teqeq	r0, r2
 8000280:	bf1f      	itttt	ne
 8000282:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000286:	ea55 0c02 	orrsne.w	ip, r5, r2
 800028a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800028e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000292:	f000 80e2 	beq.w	800045a <__adddf3+0x1ee>
 8000296:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800029a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800029e:	bfb8      	it	lt
 80002a0:	426d      	neglt	r5, r5
 80002a2:	dd0c      	ble.n	80002be <__adddf3+0x52>
 80002a4:	442c      	add	r4, r5
 80002a6:	ea80 0202 	eor.w	r2, r0, r2
 80002aa:	ea81 0303 	eor.w	r3, r1, r3
 80002ae:	ea82 0000 	eor.w	r0, r2, r0
 80002b2:	ea83 0101 	eor.w	r1, r3, r1
 80002b6:	ea80 0202 	eor.w	r2, r0, r2
 80002ba:	ea81 0303 	eor.w	r3, r1, r3
 80002be:	2d36      	cmp	r5, #54	; 0x36
 80002c0:	bf88      	it	hi
 80002c2:	bd30      	pophi	{r4, r5, pc}
 80002c4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80002c8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80002cc:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80002d0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80002d4:	d002      	beq.n	80002dc <__adddf3+0x70>
 80002d6:	4240      	negs	r0, r0
 80002d8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80002dc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80002e0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80002e4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80002e8:	d002      	beq.n	80002f0 <__adddf3+0x84>
 80002ea:	4252      	negs	r2, r2
 80002ec:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80002f0:	ea94 0f05 	teq	r4, r5
 80002f4:	f000 80a7 	beq.w	8000446 <__adddf3+0x1da>
 80002f8:	f1a4 0401 	sub.w	r4, r4, #1
 80002fc:	f1d5 0e20 	rsbs	lr, r5, #32
 8000300:	db0d      	blt.n	800031e <__adddf3+0xb2>
 8000302:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000306:	fa22 f205 	lsr.w	r2, r2, r5
 800030a:	1880      	adds	r0, r0, r2
 800030c:	f141 0100 	adc.w	r1, r1, #0
 8000310:	fa03 f20e 	lsl.w	r2, r3, lr
 8000314:	1880      	adds	r0, r0, r2
 8000316:	fa43 f305 	asr.w	r3, r3, r5
 800031a:	4159      	adcs	r1, r3
 800031c:	e00e      	b.n	800033c <__adddf3+0xd0>
 800031e:	f1a5 0520 	sub.w	r5, r5, #32
 8000322:	f10e 0e20 	add.w	lr, lr, #32
 8000326:	2a01      	cmp	r2, #1
 8000328:	fa03 fc0e 	lsl.w	ip, r3, lr
 800032c:	bf28      	it	cs
 800032e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000332:	fa43 f305 	asr.w	r3, r3, r5
 8000336:	18c0      	adds	r0, r0, r3
 8000338:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800033c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000340:	d507      	bpl.n	8000352 <__adddf3+0xe6>
 8000342:	f04f 0e00 	mov.w	lr, #0
 8000346:	f1dc 0c00 	rsbs	ip, ip, #0
 800034a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800034e:	eb6e 0101 	sbc.w	r1, lr, r1
 8000352:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8000356:	d31b      	bcc.n	8000390 <__adddf3+0x124>
 8000358:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800035c:	d30c      	bcc.n	8000378 <__adddf3+0x10c>
 800035e:	0849      	lsrs	r1, r1, #1
 8000360:	ea5f 0030 	movs.w	r0, r0, rrx
 8000364:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000368:	f104 0401 	add.w	r4, r4, #1
 800036c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000370:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000374:	f080 809a 	bcs.w	80004ac <__adddf3+0x240>
 8000378:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800037c:	bf08      	it	eq
 800037e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000382:	f150 0000 	adcs.w	r0, r0, #0
 8000386:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800038a:	ea41 0105 	orr.w	r1, r1, r5
 800038e:	bd30      	pop	{r4, r5, pc}
 8000390:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000394:	4140      	adcs	r0, r0
 8000396:	eb41 0101 	adc.w	r1, r1, r1
 800039a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800039e:	f1a4 0401 	sub.w	r4, r4, #1
 80003a2:	d1e9      	bne.n	8000378 <__adddf3+0x10c>
 80003a4:	f091 0f00 	teq	r1, #0
 80003a8:	bf04      	itt	eq
 80003aa:	4601      	moveq	r1, r0
 80003ac:	2000      	moveq	r0, #0
 80003ae:	fab1 f381 	clz	r3, r1
 80003b2:	bf08      	it	eq
 80003b4:	3320      	addeq	r3, #32
 80003b6:	f1a3 030b 	sub.w	r3, r3, #11
 80003ba:	f1b3 0220 	subs.w	r2, r3, #32
 80003be:	da0c      	bge.n	80003da <__adddf3+0x16e>
 80003c0:	320c      	adds	r2, #12
 80003c2:	dd08      	ble.n	80003d6 <__adddf3+0x16a>
 80003c4:	f102 0c14 	add.w	ip, r2, #20
 80003c8:	f1c2 020c 	rsb	r2, r2, #12
 80003cc:	fa01 f00c 	lsl.w	r0, r1, ip
 80003d0:	fa21 f102 	lsr.w	r1, r1, r2
 80003d4:	e00c      	b.n	80003f0 <__adddf3+0x184>
 80003d6:	f102 0214 	add.w	r2, r2, #20
 80003da:	bfd8      	it	le
 80003dc:	f1c2 0c20 	rsble	ip, r2, #32
 80003e0:	fa01 f102 	lsl.w	r1, r1, r2
 80003e4:	fa20 fc0c 	lsr.w	ip, r0, ip
 80003e8:	bfdc      	itt	le
 80003ea:	ea41 010c 	orrle.w	r1, r1, ip
 80003ee:	4090      	lslle	r0, r2
 80003f0:	1ae4      	subs	r4, r4, r3
 80003f2:	bfa2      	ittt	ge
 80003f4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80003f8:	4329      	orrge	r1, r5
 80003fa:	bd30      	popge	{r4, r5, pc}
 80003fc:	ea6f 0404 	mvn.w	r4, r4
 8000400:	3c1f      	subs	r4, #31
 8000402:	da1c      	bge.n	800043e <__adddf3+0x1d2>
 8000404:	340c      	adds	r4, #12
 8000406:	dc0e      	bgt.n	8000426 <__adddf3+0x1ba>
 8000408:	f104 0414 	add.w	r4, r4, #20
 800040c:	f1c4 0220 	rsb	r2, r4, #32
 8000410:	fa20 f004 	lsr.w	r0, r0, r4
 8000414:	fa01 f302 	lsl.w	r3, r1, r2
 8000418:	ea40 0003 	orr.w	r0, r0, r3
 800041c:	fa21 f304 	lsr.w	r3, r1, r4
 8000420:	ea45 0103 	orr.w	r1, r5, r3
 8000424:	bd30      	pop	{r4, r5, pc}
 8000426:	f1c4 040c 	rsb	r4, r4, #12
 800042a:	f1c4 0220 	rsb	r2, r4, #32
 800042e:	fa20 f002 	lsr.w	r0, r0, r2
 8000432:	fa01 f304 	lsl.w	r3, r1, r4
 8000436:	ea40 0003 	orr.w	r0, r0, r3
 800043a:	4629      	mov	r1, r5
 800043c:	bd30      	pop	{r4, r5, pc}
 800043e:	fa21 f004 	lsr.w	r0, r1, r4
 8000442:	4629      	mov	r1, r5
 8000444:	bd30      	pop	{r4, r5, pc}
 8000446:	f094 0f00 	teq	r4, #0
 800044a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800044e:	bf06      	itte	eq
 8000450:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8000454:	3401      	addeq	r4, #1
 8000456:	3d01      	subne	r5, #1
 8000458:	e74e      	b.n	80002f8 <__adddf3+0x8c>
 800045a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800045e:	bf18      	it	ne
 8000460:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000464:	d029      	beq.n	80004ba <__adddf3+0x24e>
 8000466:	ea94 0f05 	teq	r4, r5
 800046a:	bf08      	it	eq
 800046c:	ea90 0f02 	teqeq	r0, r2
 8000470:	d005      	beq.n	800047e <__adddf3+0x212>
 8000472:	ea54 0c00 	orrs.w	ip, r4, r0
 8000476:	bf04      	itt	eq
 8000478:	4619      	moveq	r1, r3
 800047a:	4610      	moveq	r0, r2
 800047c:	bd30      	pop	{r4, r5, pc}
 800047e:	ea91 0f03 	teq	r1, r3
 8000482:	bf1e      	ittt	ne
 8000484:	2100      	movne	r1, #0
 8000486:	2000      	movne	r0, #0
 8000488:	bd30      	popne	{r4, r5, pc}
 800048a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800048e:	d105      	bne.n	800049c <__adddf3+0x230>
 8000490:	0040      	lsls	r0, r0, #1
 8000492:	4149      	adcs	r1, r1
 8000494:	bf28      	it	cs
 8000496:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800049a:	bd30      	pop	{r4, r5, pc}
 800049c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80004a0:	bf3c      	itt	cc
 80004a2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80004a6:	bd30      	popcc	{r4, r5, pc}
 80004a8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80004ac:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80004b0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80004b4:	f04f 0000 	mov.w	r0, #0
 80004b8:	bd30      	pop	{r4, r5, pc}
 80004ba:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004be:	bf1a      	itte	ne
 80004c0:	4619      	movne	r1, r3
 80004c2:	4610      	movne	r0, r2
 80004c4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80004c8:	bf1c      	itt	ne
 80004ca:	460b      	movne	r3, r1
 80004cc:	4602      	movne	r2, r0
 80004ce:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80004d2:	bf06      	itte	eq
 80004d4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80004d8:	ea91 0f03 	teqeq	r1, r3
 80004dc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80004e0:	bd30      	pop	{r4, r5, pc}
 80004e2:	bf00      	nop

080004e4 <__aeabi_ui2d>:
 80004e4:	f090 0f00 	teq	r0, #0
 80004e8:	bf04      	itt	eq
 80004ea:	2100      	moveq	r1, #0
 80004ec:	4770      	bxeq	lr
 80004ee:	b530      	push	{r4, r5, lr}
 80004f0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80004f4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80004f8:	f04f 0500 	mov.w	r5, #0
 80004fc:	f04f 0100 	mov.w	r1, #0
 8000500:	e750      	b.n	80003a4 <__adddf3+0x138>
 8000502:	bf00      	nop

08000504 <__aeabi_i2d>:
 8000504:	f090 0f00 	teq	r0, #0
 8000508:	bf04      	itt	eq
 800050a:	2100      	moveq	r1, #0
 800050c:	4770      	bxeq	lr
 800050e:	b530      	push	{r4, r5, lr}
 8000510:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000514:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000518:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800051c:	bf48      	it	mi
 800051e:	4240      	negmi	r0, r0
 8000520:	f04f 0100 	mov.w	r1, #0
 8000524:	e73e      	b.n	80003a4 <__adddf3+0x138>
 8000526:	bf00      	nop

08000528 <__aeabi_f2d>:
 8000528:	0042      	lsls	r2, r0, #1
 800052a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800052e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000532:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000536:	bf1f      	itttt	ne
 8000538:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800053c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000540:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000544:	4770      	bxne	lr
 8000546:	f092 0f00 	teq	r2, #0
 800054a:	bf14      	ite	ne
 800054c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000550:	4770      	bxeq	lr
 8000552:	b530      	push	{r4, r5, lr}
 8000554:	f44f 7460 	mov.w	r4, #896	; 0x380
 8000558:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800055c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000560:	e720      	b.n	80003a4 <__adddf3+0x138>
 8000562:	bf00      	nop

08000564 <__aeabi_ul2d>:
 8000564:	ea50 0201 	orrs.w	r2, r0, r1
 8000568:	bf08      	it	eq
 800056a:	4770      	bxeq	lr
 800056c:	b530      	push	{r4, r5, lr}
 800056e:	f04f 0500 	mov.w	r5, #0
 8000572:	e00a      	b.n	800058a <__aeabi_l2d+0x16>

08000574 <__aeabi_l2d>:
 8000574:	ea50 0201 	orrs.w	r2, r0, r1
 8000578:	bf08      	it	eq
 800057a:	4770      	bxeq	lr
 800057c:	b530      	push	{r4, r5, lr}
 800057e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8000582:	d502      	bpl.n	800058a <__aeabi_l2d+0x16>
 8000584:	4240      	negs	r0, r0
 8000586:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800058a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800058e:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000592:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000596:	f43f aedc 	beq.w	8000352 <__adddf3+0xe6>
 800059a:	f04f 0203 	mov.w	r2, #3
 800059e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005a2:	bf18      	it	ne
 80005a4:	3203      	addne	r2, #3
 80005a6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005aa:	bf18      	it	ne
 80005ac:	3203      	addne	r2, #3
 80005ae:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80005b2:	f1c2 0320 	rsb	r3, r2, #32
 80005b6:	fa00 fc03 	lsl.w	ip, r0, r3
 80005ba:	fa20 f002 	lsr.w	r0, r0, r2
 80005be:	fa01 fe03 	lsl.w	lr, r1, r3
 80005c2:	ea40 000e 	orr.w	r0, r0, lr
 80005c6:	fa21 f102 	lsr.w	r1, r1, r2
 80005ca:	4414      	add	r4, r2
 80005cc:	e6c1      	b.n	8000352 <__adddf3+0xe6>
 80005ce:	bf00      	nop

080005d0 <__aeabi_dmul>:
 80005d0:	b570      	push	{r4, r5, r6, lr}
 80005d2:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80005d6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80005da:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80005de:	bf1d      	ittte	ne
 80005e0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80005e4:	ea94 0f0c 	teqne	r4, ip
 80005e8:	ea95 0f0c 	teqne	r5, ip
 80005ec:	f000 f8de 	bleq	80007ac <__aeabi_dmul+0x1dc>
 80005f0:	442c      	add	r4, r5
 80005f2:	ea81 0603 	eor.w	r6, r1, r3
 80005f6:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 80005fa:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 80005fe:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000602:	bf18      	it	ne
 8000604:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000608:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800060c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000610:	d038      	beq.n	8000684 <__aeabi_dmul+0xb4>
 8000612:	fba0 ce02 	umull	ip, lr, r0, r2
 8000616:	f04f 0500 	mov.w	r5, #0
 800061a:	fbe1 e502 	umlal	lr, r5, r1, r2
 800061e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8000622:	fbe0 e503 	umlal	lr, r5, r0, r3
 8000626:	f04f 0600 	mov.w	r6, #0
 800062a:	fbe1 5603 	umlal	r5, r6, r1, r3
 800062e:	f09c 0f00 	teq	ip, #0
 8000632:	bf18      	it	ne
 8000634:	f04e 0e01 	orrne.w	lr, lr, #1
 8000638:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800063c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8000640:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8000644:	d204      	bcs.n	8000650 <__aeabi_dmul+0x80>
 8000646:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800064a:	416d      	adcs	r5, r5
 800064c:	eb46 0606 	adc.w	r6, r6, r6
 8000650:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8000654:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000658:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 800065c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8000660:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8000664:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000668:	bf88      	it	hi
 800066a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800066e:	d81e      	bhi.n	80006ae <__aeabi_dmul+0xde>
 8000670:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8000674:	bf08      	it	eq
 8000676:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800067a:	f150 0000 	adcs.w	r0, r0, #0
 800067e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000682:	bd70      	pop	{r4, r5, r6, pc}
 8000684:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8000688:	ea46 0101 	orr.w	r1, r6, r1
 800068c:	ea40 0002 	orr.w	r0, r0, r2
 8000690:	ea81 0103 	eor.w	r1, r1, r3
 8000694:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000698:	bfc2      	ittt	gt
 800069a:	ebd4 050c 	rsbsgt	r5, r4, ip
 800069e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80006a2:	bd70      	popgt	{r4, r5, r6, pc}
 80006a4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80006a8:	f04f 0e00 	mov.w	lr, #0
 80006ac:	3c01      	subs	r4, #1
 80006ae:	f300 80ab 	bgt.w	8000808 <__aeabi_dmul+0x238>
 80006b2:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80006b6:	bfde      	ittt	le
 80006b8:	2000      	movle	r0, #0
 80006ba:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 80006be:	bd70      	pople	{r4, r5, r6, pc}
 80006c0:	f1c4 0400 	rsb	r4, r4, #0
 80006c4:	3c20      	subs	r4, #32
 80006c6:	da35      	bge.n	8000734 <__aeabi_dmul+0x164>
 80006c8:	340c      	adds	r4, #12
 80006ca:	dc1b      	bgt.n	8000704 <__aeabi_dmul+0x134>
 80006cc:	f104 0414 	add.w	r4, r4, #20
 80006d0:	f1c4 0520 	rsb	r5, r4, #32
 80006d4:	fa00 f305 	lsl.w	r3, r0, r5
 80006d8:	fa20 f004 	lsr.w	r0, r0, r4
 80006dc:	fa01 f205 	lsl.w	r2, r1, r5
 80006e0:	ea40 0002 	orr.w	r0, r0, r2
 80006e4:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 80006e8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80006ec:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80006f0:	fa21 f604 	lsr.w	r6, r1, r4
 80006f4:	eb42 0106 	adc.w	r1, r2, r6
 80006f8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80006fc:	bf08      	it	eq
 80006fe:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000702:	bd70      	pop	{r4, r5, r6, pc}
 8000704:	f1c4 040c 	rsb	r4, r4, #12
 8000708:	f1c4 0520 	rsb	r5, r4, #32
 800070c:	fa00 f304 	lsl.w	r3, r0, r4
 8000710:	fa20 f005 	lsr.w	r0, r0, r5
 8000714:	fa01 f204 	lsl.w	r2, r1, r4
 8000718:	ea40 0002 	orr.w	r0, r0, r2
 800071c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000720:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000724:	f141 0100 	adc.w	r1, r1, #0
 8000728:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800072c:	bf08      	it	eq
 800072e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000732:	bd70      	pop	{r4, r5, r6, pc}
 8000734:	f1c4 0520 	rsb	r5, r4, #32
 8000738:	fa00 f205 	lsl.w	r2, r0, r5
 800073c:	ea4e 0e02 	orr.w	lr, lr, r2
 8000740:	fa20 f304 	lsr.w	r3, r0, r4
 8000744:	fa01 f205 	lsl.w	r2, r1, r5
 8000748:	ea43 0302 	orr.w	r3, r3, r2
 800074c:	fa21 f004 	lsr.w	r0, r1, r4
 8000750:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000754:	fa21 f204 	lsr.w	r2, r1, r4
 8000758:	ea20 0002 	bic.w	r0, r0, r2
 800075c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8000760:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000764:	bf08      	it	eq
 8000766:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800076a:	bd70      	pop	{r4, r5, r6, pc}
 800076c:	f094 0f00 	teq	r4, #0
 8000770:	d10f      	bne.n	8000792 <__aeabi_dmul+0x1c2>
 8000772:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8000776:	0040      	lsls	r0, r0, #1
 8000778:	eb41 0101 	adc.w	r1, r1, r1
 800077c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000780:	bf08      	it	eq
 8000782:	3c01      	subeq	r4, #1
 8000784:	d0f7      	beq.n	8000776 <__aeabi_dmul+0x1a6>
 8000786:	ea41 0106 	orr.w	r1, r1, r6
 800078a:	f095 0f00 	teq	r5, #0
 800078e:	bf18      	it	ne
 8000790:	4770      	bxne	lr
 8000792:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8000796:	0052      	lsls	r2, r2, #1
 8000798:	eb43 0303 	adc.w	r3, r3, r3
 800079c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80007a0:	bf08      	it	eq
 80007a2:	3d01      	subeq	r5, #1
 80007a4:	d0f7      	beq.n	8000796 <__aeabi_dmul+0x1c6>
 80007a6:	ea43 0306 	orr.w	r3, r3, r6
 80007aa:	4770      	bx	lr
 80007ac:	ea94 0f0c 	teq	r4, ip
 80007b0:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80007b4:	bf18      	it	ne
 80007b6:	ea95 0f0c 	teqne	r5, ip
 80007ba:	d00c      	beq.n	80007d6 <__aeabi_dmul+0x206>
 80007bc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80007c0:	bf18      	it	ne
 80007c2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80007c6:	d1d1      	bne.n	800076c <__aeabi_dmul+0x19c>
 80007c8:	ea81 0103 	eor.w	r1, r1, r3
 80007cc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007d0:	f04f 0000 	mov.w	r0, #0
 80007d4:	bd70      	pop	{r4, r5, r6, pc}
 80007d6:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80007da:	bf06      	itte	eq
 80007dc:	4610      	moveq	r0, r2
 80007de:	4619      	moveq	r1, r3
 80007e0:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80007e4:	d019      	beq.n	800081a <__aeabi_dmul+0x24a>
 80007e6:	ea94 0f0c 	teq	r4, ip
 80007ea:	d102      	bne.n	80007f2 <__aeabi_dmul+0x222>
 80007ec:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80007f0:	d113      	bne.n	800081a <__aeabi_dmul+0x24a>
 80007f2:	ea95 0f0c 	teq	r5, ip
 80007f6:	d105      	bne.n	8000804 <__aeabi_dmul+0x234>
 80007f8:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 80007fc:	bf1c      	itt	ne
 80007fe:	4610      	movne	r0, r2
 8000800:	4619      	movne	r1, r3
 8000802:	d10a      	bne.n	800081a <__aeabi_dmul+0x24a>
 8000804:	ea81 0103 	eor.w	r1, r1, r3
 8000808:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800080c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000810:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000814:	f04f 0000 	mov.w	r0, #0
 8000818:	bd70      	pop	{r4, r5, r6, pc}
 800081a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800081e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8000822:	bd70      	pop	{r4, r5, r6, pc}

08000824 <__aeabi_ddiv>:
 8000824:	b570      	push	{r4, r5, r6, lr}
 8000826:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800082a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800082e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000832:	bf1d      	ittte	ne
 8000834:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000838:	ea94 0f0c 	teqne	r4, ip
 800083c:	ea95 0f0c 	teqne	r5, ip
 8000840:	f000 f8a7 	bleq	8000992 <__aeabi_ddiv+0x16e>
 8000844:	eba4 0405 	sub.w	r4, r4, r5
 8000848:	ea81 0e03 	eor.w	lr, r1, r3
 800084c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000850:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000854:	f000 8088 	beq.w	8000968 <__aeabi_ddiv+0x144>
 8000858:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800085c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8000860:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8000864:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8000868:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800086c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8000870:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8000874:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8000878:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 800087c:	429d      	cmp	r5, r3
 800087e:	bf08      	it	eq
 8000880:	4296      	cmpeq	r6, r2
 8000882:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8000886:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800088a:	d202      	bcs.n	8000892 <__aeabi_ddiv+0x6e>
 800088c:	085b      	lsrs	r3, r3, #1
 800088e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000892:	1ab6      	subs	r6, r6, r2
 8000894:	eb65 0503 	sbc.w	r5, r5, r3
 8000898:	085b      	lsrs	r3, r3, #1
 800089a:	ea4f 0232 	mov.w	r2, r2, rrx
 800089e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80008a2:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80008a6:	ebb6 0e02 	subs.w	lr, r6, r2
 80008aa:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008ae:	bf22      	ittt	cs
 80008b0:	1ab6      	subcs	r6, r6, r2
 80008b2:	4675      	movcs	r5, lr
 80008b4:	ea40 000c 	orrcs.w	r0, r0, ip
 80008b8:	085b      	lsrs	r3, r3, #1
 80008ba:	ea4f 0232 	mov.w	r2, r2, rrx
 80008be:	ebb6 0e02 	subs.w	lr, r6, r2
 80008c2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008c6:	bf22      	ittt	cs
 80008c8:	1ab6      	subcs	r6, r6, r2
 80008ca:	4675      	movcs	r5, lr
 80008cc:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80008d0:	085b      	lsrs	r3, r3, #1
 80008d2:	ea4f 0232 	mov.w	r2, r2, rrx
 80008d6:	ebb6 0e02 	subs.w	lr, r6, r2
 80008da:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008de:	bf22      	ittt	cs
 80008e0:	1ab6      	subcs	r6, r6, r2
 80008e2:	4675      	movcs	r5, lr
 80008e4:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80008e8:	085b      	lsrs	r3, r3, #1
 80008ea:	ea4f 0232 	mov.w	r2, r2, rrx
 80008ee:	ebb6 0e02 	subs.w	lr, r6, r2
 80008f2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008f6:	bf22      	ittt	cs
 80008f8:	1ab6      	subcs	r6, r6, r2
 80008fa:	4675      	movcs	r5, lr
 80008fc:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000900:	ea55 0e06 	orrs.w	lr, r5, r6
 8000904:	d018      	beq.n	8000938 <__aeabi_ddiv+0x114>
 8000906:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800090a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800090e:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000912:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000916:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800091a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800091e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8000922:	d1c0      	bne.n	80008a6 <__aeabi_ddiv+0x82>
 8000924:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000928:	d10b      	bne.n	8000942 <__aeabi_ddiv+0x11e>
 800092a:	ea41 0100 	orr.w	r1, r1, r0
 800092e:	f04f 0000 	mov.w	r0, #0
 8000932:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8000936:	e7b6      	b.n	80008a6 <__aeabi_ddiv+0x82>
 8000938:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800093c:	bf04      	itt	eq
 800093e:	4301      	orreq	r1, r0
 8000940:	2000      	moveq	r0, #0
 8000942:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000946:	bf88      	it	hi
 8000948:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800094c:	f63f aeaf 	bhi.w	80006ae <__aeabi_dmul+0xde>
 8000950:	ebb5 0c03 	subs.w	ip, r5, r3
 8000954:	bf04      	itt	eq
 8000956:	ebb6 0c02 	subseq.w	ip, r6, r2
 800095a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800095e:	f150 0000 	adcs.w	r0, r0, #0
 8000962:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000966:	bd70      	pop	{r4, r5, r6, pc}
 8000968:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 800096c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8000970:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8000974:	bfc2      	ittt	gt
 8000976:	ebd4 050c 	rsbsgt	r5, r4, ip
 800097a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800097e:	bd70      	popgt	{r4, r5, r6, pc}
 8000980:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000984:	f04f 0e00 	mov.w	lr, #0
 8000988:	3c01      	subs	r4, #1
 800098a:	e690      	b.n	80006ae <__aeabi_dmul+0xde>
 800098c:	ea45 0e06 	orr.w	lr, r5, r6
 8000990:	e68d      	b.n	80006ae <__aeabi_dmul+0xde>
 8000992:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000996:	ea94 0f0c 	teq	r4, ip
 800099a:	bf08      	it	eq
 800099c:	ea95 0f0c 	teqeq	r5, ip
 80009a0:	f43f af3b 	beq.w	800081a <__aeabi_dmul+0x24a>
 80009a4:	ea94 0f0c 	teq	r4, ip
 80009a8:	d10a      	bne.n	80009c0 <__aeabi_ddiv+0x19c>
 80009aa:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80009ae:	f47f af34 	bne.w	800081a <__aeabi_dmul+0x24a>
 80009b2:	ea95 0f0c 	teq	r5, ip
 80009b6:	f47f af25 	bne.w	8000804 <__aeabi_dmul+0x234>
 80009ba:	4610      	mov	r0, r2
 80009bc:	4619      	mov	r1, r3
 80009be:	e72c      	b.n	800081a <__aeabi_dmul+0x24a>
 80009c0:	ea95 0f0c 	teq	r5, ip
 80009c4:	d106      	bne.n	80009d4 <__aeabi_ddiv+0x1b0>
 80009c6:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80009ca:	f43f aefd 	beq.w	80007c8 <__aeabi_dmul+0x1f8>
 80009ce:	4610      	mov	r0, r2
 80009d0:	4619      	mov	r1, r3
 80009d2:	e722      	b.n	800081a <__aeabi_dmul+0x24a>
 80009d4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80009d8:	bf18      	it	ne
 80009da:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80009de:	f47f aec5 	bne.w	800076c <__aeabi_dmul+0x19c>
 80009e2:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 80009e6:	f47f af0d 	bne.w	8000804 <__aeabi_dmul+0x234>
 80009ea:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 80009ee:	f47f aeeb 	bne.w	80007c8 <__aeabi_dmul+0x1f8>
 80009f2:	e712      	b.n	800081a <__aeabi_dmul+0x24a>
	...

08000a00 <__gedf2>:
 8000a00:	f04f 3cff 	mov.w	ip, #4294967295
 8000a04:	e006      	b.n	8000a14 <__cmpdf2+0x4>
 8000a06:	bf00      	nop

08000a08 <__ledf2>:
 8000a08:	f04f 0c01 	mov.w	ip, #1
 8000a0c:	e002      	b.n	8000a14 <__cmpdf2+0x4>
 8000a0e:	bf00      	nop

08000a10 <__cmpdf2>:
 8000a10:	f04f 0c01 	mov.w	ip, #1
 8000a14:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000a18:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000a1c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000a20:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000a24:	bf18      	it	ne
 8000a26:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000a2a:	d01b      	beq.n	8000a64 <__cmpdf2+0x54>
 8000a2c:	b001      	add	sp, #4
 8000a2e:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000a32:	bf0c      	ite	eq
 8000a34:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000a38:	ea91 0f03 	teqne	r1, r3
 8000a3c:	bf02      	ittt	eq
 8000a3e:	ea90 0f02 	teqeq	r0, r2
 8000a42:	2000      	moveq	r0, #0
 8000a44:	4770      	bxeq	lr
 8000a46:	f110 0f00 	cmn.w	r0, #0
 8000a4a:	ea91 0f03 	teq	r1, r3
 8000a4e:	bf58      	it	pl
 8000a50:	4299      	cmppl	r1, r3
 8000a52:	bf08      	it	eq
 8000a54:	4290      	cmpeq	r0, r2
 8000a56:	bf2c      	ite	cs
 8000a58:	17d8      	asrcs	r0, r3, #31
 8000a5a:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000a5e:	f040 0001 	orr.w	r0, r0, #1
 8000a62:	4770      	bx	lr
 8000a64:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000a68:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000a6c:	d102      	bne.n	8000a74 <__cmpdf2+0x64>
 8000a6e:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000a72:	d107      	bne.n	8000a84 <__cmpdf2+0x74>
 8000a74:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000a78:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000a7c:	d1d6      	bne.n	8000a2c <__cmpdf2+0x1c>
 8000a7e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000a82:	d0d3      	beq.n	8000a2c <__cmpdf2+0x1c>
 8000a84:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000a88:	4770      	bx	lr
 8000a8a:	bf00      	nop

08000a8c <__aeabi_cdrcmple>:
 8000a8c:	4684      	mov	ip, r0
 8000a8e:	4610      	mov	r0, r2
 8000a90:	4662      	mov	r2, ip
 8000a92:	468c      	mov	ip, r1
 8000a94:	4619      	mov	r1, r3
 8000a96:	4663      	mov	r3, ip
 8000a98:	e000      	b.n	8000a9c <__aeabi_cdcmpeq>
 8000a9a:	bf00      	nop

08000a9c <__aeabi_cdcmpeq>:
 8000a9c:	b501      	push	{r0, lr}
 8000a9e:	f7ff ffb7 	bl	8000a10 <__cmpdf2>
 8000aa2:	2800      	cmp	r0, #0
 8000aa4:	bf48      	it	mi
 8000aa6:	f110 0f00 	cmnmi.w	r0, #0
 8000aaa:	bd01      	pop	{r0, pc}

08000aac <__aeabi_dcmpeq>:
 8000aac:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000ab0:	f7ff fff4 	bl	8000a9c <__aeabi_cdcmpeq>
 8000ab4:	bf0c      	ite	eq
 8000ab6:	2001      	moveq	r0, #1
 8000ab8:	2000      	movne	r0, #0
 8000aba:	f85d fb08 	ldr.w	pc, [sp], #8
 8000abe:	bf00      	nop

08000ac0 <__aeabi_dcmplt>:
 8000ac0:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000ac4:	f7ff ffea 	bl	8000a9c <__aeabi_cdcmpeq>
 8000ac8:	bf34      	ite	cc
 8000aca:	2001      	movcc	r0, #1
 8000acc:	2000      	movcs	r0, #0
 8000ace:	f85d fb08 	ldr.w	pc, [sp], #8
 8000ad2:	bf00      	nop

08000ad4 <__aeabi_dcmple>:
 8000ad4:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000ad8:	f7ff ffe0 	bl	8000a9c <__aeabi_cdcmpeq>
 8000adc:	bf94      	ite	ls
 8000ade:	2001      	movls	r0, #1
 8000ae0:	2000      	movhi	r0, #0
 8000ae2:	f85d fb08 	ldr.w	pc, [sp], #8
 8000ae6:	bf00      	nop

08000ae8 <__aeabi_dcmpge>:
 8000ae8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000aec:	f7ff ffce 	bl	8000a8c <__aeabi_cdrcmple>
 8000af0:	bf94      	ite	ls
 8000af2:	2001      	movls	r0, #1
 8000af4:	2000      	movhi	r0, #0
 8000af6:	f85d fb08 	ldr.w	pc, [sp], #8
 8000afa:	bf00      	nop

08000afc <__aeabi_dcmpgt>:
 8000afc:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b00:	f7ff ffc4 	bl	8000a8c <__aeabi_cdrcmple>
 8000b04:	bf34      	ite	cc
 8000b06:	2001      	movcc	r0, #1
 8000b08:	2000      	movcs	r0, #0
 8000b0a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b0e:	bf00      	nop

08000b10 <__aeabi_d2iz>:
 8000b10:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000b14:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000b18:	d215      	bcs.n	8000b46 <__aeabi_d2iz+0x36>
 8000b1a:	d511      	bpl.n	8000b40 <__aeabi_d2iz+0x30>
 8000b1c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000b20:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000b24:	d912      	bls.n	8000b4c <__aeabi_d2iz+0x3c>
 8000b26:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000b2a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000b2e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000b32:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000b36:	fa23 f002 	lsr.w	r0, r3, r2
 8000b3a:	bf18      	it	ne
 8000b3c:	4240      	negne	r0, r0
 8000b3e:	4770      	bx	lr
 8000b40:	f04f 0000 	mov.w	r0, #0
 8000b44:	4770      	bx	lr
 8000b46:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000b4a:	d105      	bne.n	8000b58 <__aeabi_d2iz+0x48>
 8000b4c:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8000b50:	bf08      	it	eq
 8000b52:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000b56:	4770      	bx	lr
 8000b58:	f04f 0000 	mov.w	r0, #0
 8000b5c:	4770      	bx	lr
 8000b5e:	bf00      	nop

08000b60 <__aeabi_d2f>:
 8000b60:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000b64:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000b68:	bf24      	itt	cs
 8000b6a:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000b6e:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000b72:	d90d      	bls.n	8000b90 <__aeabi_d2f+0x30>
 8000b74:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000b78:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000b7c:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000b80:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000b84:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000b88:	bf08      	it	eq
 8000b8a:	f020 0001 	biceq.w	r0, r0, #1
 8000b8e:	4770      	bx	lr
 8000b90:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000b94:	d121      	bne.n	8000bda <__aeabi_d2f+0x7a>
 8000b96:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000b9a:	bfbc      	itt	lt
 8000b9c:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000ba0:	4770      	bxlt	lr
 8000ba2:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000ba6:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000baa:	f1c2 0218 	rsb	r2, r2, #24
 8000bae:	f1c2 0c20 	rsb	ip, r2, #32
 8000bb2:	fa10 f30c 	lsls.w	r3, r0, ip
 8000bb6:	fa20 f002 	lsr.w	r0, r0, r2
 8000bba:	bf18      	it	ne
 8000bbc:	f040 0001 	orrne.w	r0, r0, #1
 8000bc0:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000bc4:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000bc8:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000bcc:	ea40 000c 	orr.w	r0, r0, ip
 8000bd0:	fa23 f302 	lsr.w	r3, r3, r2
 8000bd4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000bd8:	e7cc      	b.n	8000b74 <__aeabi_d2f+0x14>
 8000bda:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000bde:	d107      	bne.n	8000bf0 <__aeabi_d2f+0x90>
 8000be0:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000be4:	bf1e      	ittt	ne
 8000be6:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000bea:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000bee:	4770      	bxne	lr
 8000bf0:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000bf4:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000bf8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000bfc:	4770      	bx	lr
 8000bfe:	bf00      	nop

08000c00 <__aeabi_frsub>:
 8000c00:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 8000c04:	e002      	b.n	8000c0c <__addsf3>
 8000c06:	bf00      	nop

08000c08 <__aeabi_fsub>:
 8000c08:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

08000c0c <__addsf3>:
 8000c0c:	0042      	lsls	r2, r0, #1
 8000c0e:	bf1f      	itttt	ne
 8000c10:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 8000c14:	ea92 0f03 	teqne	r2, r3
 8000c18:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 8000c1c:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000c20:	d06a      	beq.n	8000cf8 <__addsf3+0xec>
 8000c22:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8000c26:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 8000c2a:	bfc1      	itttt	gt
 8000c2c:	18d2      	addgt	r2, r2, r3
 8000c2e:	4041      	eorgt	r1, r0
 8000c30:	4048      	eorgt	r0, r1
 8000c32:	4041      	eorgt	r1, r0
 8000c34:	bfb8      	it	lt
 8000c36:	425b      	neglt	r3, r3
 8000c38:	2b19      	cmp	r3, #25
 8000c3a:	bf88      	it	hi
 8000c3c:	4770      	bxhi	lr
 8000c3e:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 8000c42:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000c46:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 8000c4a:	bf18      	it	ne
 8000c4c:	4240      	negne	r0, r0
 8000c4e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000c52:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8000c56:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8000c5a:	bf18      	it	ne
 8000c5c:	4249      	negne	r1, r1
 8000c5e:	ea92 0f03 	teq	r2, r3
 8000c62:	d03f      	beq.n	8000ce4 <__addsf3+0xd8>
 8000c64:	f1a2 0201 	sub.w	r2, r2, #1
 8000c68:	fa41 fc03 	asr.w	ip, r1, r3
 8000c6c:	eb10 000c 	adds.w	r0, r0, ip
 8000c70:	f1c3 0320 	rsb	r3, r3, #32
 8000c74:	fa01 f103 	lsl.w	r1, r1, r3
 8000c78:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000c7c:	d502      	bpl.n	8000c84 <__addsf3+0x78>
 8000c7e:	4249      	negs	r1, r1
 8000c80:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 8000c84:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 8000c88:	d313      	bcc.n	8000cb2 <__addsf3+0xa6>
 8000c8a:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000c8e:	d306      	bcc.n	8000c9e <__addsf3+0x92>
 8000c90:	0840      	lsrs	r0, r0, #1
 8000c92:	ea4f 0131 	mov.w	r1, r1, rrx
 8000c96:	f102 0201 	add.w	r2, r2, #1
 8000c9a:	2afe      	cmp	r2, #254	; 0xfe
 8000c9c:	d251      	bcs.n	8000d42 <__addsf3+0x136>
 8000c9e:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 8000ca2:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000ca6:	bf08      	it	eq
 8000ca8:	f020 0001 	biceq.w	r0, r0, #1
 8000cac:	ea40 0003 	orr.w	r0, r0, r3
 8000cb0:	4770      	bx	lr
 8000cb2:	0049      	lsls	r1, r1, #1
 8000cb4:	eb40 0000 	adc.w	r0, r0, r0
 8000cb8:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
 8000cbc:	f1a2 0201 	sub.w	r2, r2, #1
 8000cc0:	d1ed      	bne.n	8000c9e <__addsf3+0x92>
 8000cc2:	fab0 fc80 	clz	ip, r0
 8000cc6:	f1ac 0c08 	sub.w	ip, ip, #8
 8000cca:	ebb2 020c 	subs.w	r2, r2, ip
 8000cce:	fa00 f00c 	lsl.w	r0, r0, ip
 8000cd2:	bfaa      	itet	ge
 8000cd4:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 8000cd8:	4252      	neglt	r2, r2
 8000cda:	4318      	orrge	r0, r3
 8000cdc:	bfbc      	itt	lt
 8000cde:	40d0      	lsrlt	r0, r2
 8000ce0:	4318      	orrlt	r0, r3
 8000ce2:	4770      	bx	lr
 8000ce4:	f092 0f00 	teq	r2, #0
 8000ce8:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 8000cec:	bf06      	itte	eq
 8000cee:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 8000cf2:	3201      	addeq	r2, #1
 8000cf4:	3b01      	subne	r3, #1
 8000cf6:	e7b5      	b.n	8000c64 <__addsf3+0x58>
 8000cf8:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000cfc:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000d00:	bf18      	it	ne
 8000d02:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000d06:	d021      	beq.n	8000d4c <__addsf3+0x140>
 8000d08:	ea92 0f03 	teq	r2, r3
 8000d0c:	d004      	beq.n	8000d18 <__addsf3+0x10c>
 8000d0e:	f092 0f00 	teq	r2, #0
 8000d12:	bf08      	it	eq
 8000d14:	4608      	moveq	r0, r1
 8000d16:	4770      	bx	lr
 8000d18:	ea90 0f01 	teq	r0, r1
 8000d1c:	bf1c      	itt	ne
 8000d1e:	2000      	movne	r0, #0
 8000d20:	4770      	bxne	lr
 8000d22:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 8000d26:	d104      	bne.n	8000d32 <__addsf3+0x126>
 8000d28:	0040      	lsls	r0, r0, #1
 8000d2a:	bf28      	it	cs
 8000d2c:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 8000d30:	4770      	bx	lr
 8000d32:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 8000d36:	bf3c      	itt	cc
 8000d38:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 8000d3c:	4770      	bxcc	lr
 8000d3e:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000d42:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 8000d46:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000d4a:	4770      	bx	lr
 8000d4c:	ea7f 6222 	mvns.w	r2, r2, asr #24
 8000d50:	bf16      	itet	ne
 8000d52:	4608      	movne	r0, r1
 8000d54:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 8000d58:	4601      	movne	r1, r0
 8000d5a:	0242      	lsls	r2, r0, #9
 8000d5c:	bf06      	itte	eq
 8000d5e:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 8000d62:	ea90 0f01 	teqeq	r0, r1
 8000d66:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 8000d6a:	4770      	bx	lr

08000d6c <__aeabi_ui2f>:
 8000d6c:	f04f 0300 	mov.w	r3, #0
 8000d70:	e004      	b.n	8000d7c <__aeabi_i2f+0x8>
 8000d72:	bf00      	nop

08000d74 <__aeabi_i2f>:
 8000d74:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 8000d78:	bf48      	it	mi
 8000d7a:	4240      	negmi	r0, r0
 8000d7c:	ea5f 0c00 	movs.w	ip, r0
 8000d80:	bf08      	it	eq
 8000d82:	4770      	bxeq	lr
 8000d84:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 8000d88:	4601      	mov	r1, r0
 8000d8a:	f04f 0000 	mov.w	r0, #0
 8000d8e:	e01c      	b.n	8000dca <__aeabi_l2f+0x2a>

08000d90 <__aeabi_ul2f>:
 8000d90:	ea50 0201 	orrs.w	r2, r0, r1
 8000d94:	bf08      	it	eq
 8000d96:	4770      	bxeq	lr
 8000d98:	f04f 0300 	mov.w	r3, #0
 8000d9c:	e00a      	b.n	8000db4 <__aeabi_l2f+0x14>
 8000d9e:	bf00      	nop

08000da0 <__aeabi_l2f>:
 8000da0:	ea50 0201 	orrs.w	r2, r0, r1
 8000da4:	bf08      	it	eq
 8000da6:	4770      	bxeq	lr
 8000da8:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 8000dac:	d502      	bpl.n	8000db4 <__aeabi_l2f+0x14>
 8000dae:	4240      	negs	r0, r0
 8000db0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000db4:	ea5f 0c01 	movs.w	ip, r1
 8000db8:	bf02      	ittt	eq
 8000dba:	4684      	moveq	ip, r0
 8000dbc:	4601      	moveq	r1, r0
 8000dbe:	2000      	moveq	r0, #0
 8000dc0:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 8000dc4:	bf08      	it	eq
 8000dc6:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 8000dca:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 8000dce:	fabc f28c 	clz	r2, ip
 8000dd2:	3a08      	subs	r2, #8
 8000dd4:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8000dd8:	db10      	blt.n	8000dfc <__aeabi_l2f+0x5c>
 8000dda:	fa01 fc02 	lsl.w	ip, r1, r2
 8000dde:	4463      	add	r3, ip
 8000de0:	fa00 fc02 	lsl.w	ip, r0, r2
 8000de4:	f1c2 0220 	rsb	r2, r2, #32
 8000de8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000dec:	fa20 f202 	lsr.w	r2, r0, r2
 8000df0:	eb43 0002 	adc.w	r0, r3, r2
 8000df4:	bf08      	it	eq
 8000df6:	f020 0001 	biceq.w	r0, r0, #1
 8000dfa:	4770      	bx	lr
 8000dfc:	f102 0220 	add.w	r2, r2, #32
 8000e00:	fa01 fc02 	lsl.w	ip, r1, r2
 8000e04:	f1c2 0220 	rsb	r2, r2, #32
 8000e08:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 8000e0c:	fa21 f202 	lsr.w	r2, r1, r2
 8000e10:	eb43 0002 	adc.w	r0, r3, r2
 8000e14:	bf08      	it	eq
 8000e16:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000e1a:	4770      	bx	lr
 8000e1c:	0000      	movs	r0, r0
	...

08000e20 <__aeabi_fmul>:
 8000e20:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000e24:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8000e28:	bf1e      	ittt	ne
 8000e2a:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8000e2e:	ea92 0f0c 	teqne	r2, ip
 8000e32:	ea93 0f0c 	teqne	r3, ip
 8000e36:	d06f      	beq.n	8000f18 <__aeabi_fmul+0xf8>
 8000e38:	441a      	add	r2, r3
 8000e3a:	ea80 0c01 	eor.w	ip, r0, r1
 8000e3e:	0240      	lsls	r0, r0, #9
 8000e40:	bf18      	it	ne
 8000e42:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 8000e46:	d01e      	beq.n	8000e86 <__aeabi_fmul+0x66>
 8000e48:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8000e4c:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 8000e50:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 8000e54:	fba0 3101 	umull	r3, r1, r0, r1
 8000e58:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8000e5c:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8000e60:	bf3e      	ittt	cc
 8000e62:	0049      	lslcc	r1, r1, #1
 8000e64:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 8000e68:	005b      	lslcc	r3, r3, #1
 8000e6a:	ea40 0001 	orr.w	r0, r0, r1
 8000e6e:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 8000e72:	2afd      	cmp	r2, #253	; 0xfd
 8000e74:	d81d      	bhi.n	8000eb2 <__aeabi_fmul+0x92>
 8000e76:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8000e7a:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000e7e:	bf08      	it	eq
 8000e80:	f020 0001 	biceq.w	r0, r0, #1
 8000e84:	4770      	bx	lr
 8000e86:	f090 0f00 	teq	r0, #0
 8000e8a:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8000e8e:	bf08      	it	eq
 8000e90:	0249      	lsleq	r1, r1, #9
 8000e92:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8000e96:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 8000e9a:	3a7f      	subs	r2, #127	; 0x7f
 8000e9c:	bfc2      	ittt	gt
 8000e9e:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8000ea2:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8000ea6:	4770      	bxgt	lr
 8000ea8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000eac:	f04f 0300 	mov.w	r3, #0
 8000eb0:	3a01      	subs	r2, #1
 8000eb2:	dc5d      	bgt.n	8000f70 <__aeabi_fmul+0x150>
 8000eb4:	f112 0f19 	cmn.w	r2, #25
 8000eb8:	bfdc      	itt	le
 8000eba:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 8000ebe:	4770      	bxle	lr
 8000ec0:	f1c2 0200 	rsb	r2, r2, #0
 8000ec4:	0041      	lsls	r1, r0, #1
 8000ec6:	fa21 f102 	lsr.w	r1, r1, r2
 8000eca:	f1c2 0220 	rsb	r2, r2, #32
 8000ece:	fa00 fc02 	lsl.w	ip, r0, r2
 8000ed2:	ea5f 0031 	movs.w	r0, r1, rrx
 8000ed6:	f140 0000 	adc.w	r0, r0, #0
 8000eda:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 8000ede:	bf08      	it	eq
 8000ee0:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000ee4:	4770      	bx	lr
 8000ee6:	f092 0f00 	teq	r2, #0
 8000eea:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8000eee:	bf02      	ittt	eq
 8000ef0:	0040      	lsleq	r0, r0, #1
 8000ef2:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8000ef6:	3a01      	subeq	r2, #1
 8000ef8:	d0f9      	beq.n	8000eee <__aeabi_fmul+0xce>
 8000efa:	ea40 000c 	orr.w	r0, r0, ip
 8000efe:	f093 0f00 	teq	r3, #0
 8000f02:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000f06:	bf02      	ittt	eq
 8000f08:	0049      	lsleq	r1, r1, #1
 8000f0a:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8000f0e:	3b01      	subeq	r3, #1
 8000f10:	d0f9      	beq.n	8000f06 <__aeabi_fmul+0xe6>
 8000f12:	ea41 010c 	orr.w	r1, r1, ip
 8000f16:	e78f      	b.n	8000e38 <__aeabi_fmul+0x18>
 8000f18:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8000f1c:	ea92 0f0c 	teq	r2, ip
 8000f20:	bf18      	it	ne
 8000f22:	ea93 0f0c 	teqne	r3, ip
 8000f26:	d00a      	beq.n	8000f3e <__aeabi_fmul+0x11e>
 8000f28:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8000f2c:	bf18      	it	ne
 8000f2e:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8000f32:	d1d8      	bne.n	8000ee6 <__aeabi_fmul+0xc6>
 8000f34:	ea80 0001 	eor.w	r0, r0, r1
 8000f38:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8000f3c:	4770      	bx	lr
 8000f3e:	f090 0f00 	teq	r0, #0
 8000f42:	bf17      	itett	ne
 8000f44:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 8000f48:	4608      	moveq	r0, r1
 8000f4a:	f091 0f00 	teqne	r1, #0
 8000f4e:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 8000f52:	d014      	beq.n	8000f7e <__aeabi_fmul+0x15e>
 8000f54:	ea92 0f0c 	teq	r2, ip
 8000f58:	d101      	bne.n	8000f5e <__aeabi_fmul+0x13e>
 8000f5a:	0242      	lsls	r2, r0, #9
 8000f5c:	d10f      	bne.n	8000f7e <__aeabi_fmul+0x15e>
 8000f5e:	ea93 0f0c 	teq	r3, ip
 8000f62:	d103      	bne.n	8000f6c <__aeabi_fmul+0x14c>
 8000f64:	024b      	lsls	r3, r1, #9
 8000f66:	bf18      	it	ne
 8000f68:	4608      	movne	r0, r1
 8000f6a:	d108      	bne.n	8000f7e <__aeabi_fmul+0x15e>
 8000f6c:	ea80 0001 	eor.w	r0, r0, r1
 8000f70:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8000f74:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000f78:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000f7c:	4770      	bx	lr
 8000f7e:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000f82:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 8000f86:	4770      	bx	lr

08000f88 <__aeabi_fdiv>:
 8000f88:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000f8c:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8000f90:	bf1e      	ittt	ne
 8000f92:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8000f96:	ea92 0f0c 	teqne	r2, ip
 8000f9a:	ea93 0f0c 	teqne	r3, ip
 8000f9e:	d069      	beq.n	8001074 <__aeabi_fdiv+0xec>
 8000fa0:	eba2 0203 	sub.w	r2, r2, r3
 8000fa4:	ea80 0c01 	eor.w	ip, r0, r1
 8000fa8:	0249      	lsls	r1, r1, #9
 8000faa:	ea4f 2040 	mov.w	r0, r0, lsl #9
 8000fae:	d037      	beq.n	8001020 <__aeabi_fdiv+0x98>
 8000fb0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8000fb4:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 8000fb8:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 8000fbc:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8000fc0:	428b      	cmp	r3, r1
 8000fc2:	bf38      	it	cc
 8000fc4:	005b      	lslcc	r3, r3, #1
 8000fc6:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 8000fca:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 8000fce:	428b      	cmp	r3, r1
 8000fd0:	bf24      	itt	cs
 8000fd2:	1a5b      	subcs	r3, r3, r1
 8000fd4:	ea40 000c 	orrcs.w	r0, r0, ip
 8000fd8:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 8000fdc:	bf24      	itt	cs
 8000fde:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 8000fe2:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000fe6:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 8000fea:	bf24      	itt	cs
 8000fec:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 8000ff0:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000ff4:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 8000ff8:	bf24      	itt	cs
 8000ffa:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 8000ffe:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8001002:	011b      	lsls	r3, r3, #4
 8001004:	bf18      	it	ne
 8001006:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 800100a:	d1e0      	bne.n	8000fce <__aeabi_fdiv+0x46>
 800100c:	2afd      	cmp	r2, #253	; 0xfd
 800100e:	f63f af50 	bhi.w	8000eb2 <__aeabi_fmul+0x92>
 8001012:	428b      	cmp	r3, r1
 8001014:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8001018:	bf08      	it	eq
 800101a:	f020 0001 	biceq.w	r0, r0, #1
 800101e:	4770      	bx	lr
 8001020:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8001024:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8001028:	327f      	adds	r2, #127	; 0x7f
 800102a:	bfc2      	ittt	gt
 800102c:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8001030:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8001034:	4770      	bxgt	lr
 8001036:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 800103a:	f04f 0300 	mov.w	r3, #0
 800103e:	3a01      	subs	r2, #1
 8001040:	e737      	b.n	8000eb2 <__aeabi_fmul+0x92>
 8001042:	f092 0f00 	teq	r2, #0
 8001046:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 800104a:	bf02      	ittt	eq
 800104c:	0040      	lsleq	r0, r0, #1
 800104e:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8001052:	3a01      	subeq	r2, #1
 8001054:	d0f9      	beq.n	800104a <__aeabi_fdiv+0xc2>
 8001056:	ea40 000c 	orr.w	r0, r0, ip
 800105a:	f093 0f00 	teq	r3, #0
 800105e:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8001062:	bf02      	ittt	eq
 8001064:	0049      	lsleq	r1, r1, #1
 8001066:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 800106a:	3b01      	subeq	r3, #1
 800106c:	d0f9      	beq.n	8001062 <__aeabi_fdiv+0xda>
 800106e:	ea41 010c 	orr.w	r1, r1, ip
 8001072:	e795      	b.n	8000fa0 <__aeabi_fdiv+0x18>
 8001074:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8001078:	ea92 0f0c 	teq	r2, ip
 800107c:	d108      	bne.n	8001090 <__aeabi_fdiv+0x108>
 800107e:	0242      	lsls	r2, r0, #9
 8001080:	f47f af7d 	bne.w	8000f7e <__aeabi_fmul+0x15e>
 8001084:	ea93 0f0c 	teq	r3, ip
 8001088:	f47f af70 	bne.w	8000f6c <__aeabi_fmul+0x14c>
 800108c:	4608      	mov	r0, r1
 800108e:	e776      	b.n	8000f7e <__aeabi_fmul+0x15e>
 8001090:	ea93 0f0c 	teq	r3, ip
 8001094:	d104      	bne.n	80010a0 <__aeabi_fdiv+0x118>
 8001096:	024b      	lsls	r3, r1, #9
 8001098:	f43f af4c 	beq.w	8000f34 <__aeabi_fmul+0x114>
 800109c:	4608      	mov	r0, r1
 800109e:	e76e      	b.n	8000f7e <__aeabi_fmul+0x15e>
 80010a0:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80010a4:	bf18      	it	ne
 80010a6:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80010aa:	d1ca      	bne.n	8001042 <__aeabi_fdiv+0xba>
 80010ac:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 80010b0:	f47f af5c 	bne.w	8000f6c <__aeabi_fmul+0x14c>
 80010b4:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 80010b8:	f47f af3c 	bne.w	8000f34 <__aeabi_fmul+0x114>
 80010bc:	e75f      	b.n	8000f7e <__aeabi_fmul+0x15e>
 80010be:	bf00      	nop

080010c0 <__gesf2>:
 80010c0:	f04f 3cff 	mov.w	ip, #4294967295
 80010c4:	e006      	b.n	80010d4 <__cmpsf2+0x4>
 80010c6:	bf00      	nop

080010c8 <__lesf2>:
 80010c8:	f04f 0c01 	mov.w	ip, #1
 80010cc:	e002      	b.n	80010d4 <__cmpsf2+0x4>
 80010ce:	bf00      	nop

080010d0 <__cmpsf2>:
 80010d0:	f04f 0c01 	mov.w	ip, #1
 80010d4:	f84d cd04 	str.w	ip, [sp, #-4]!
 80010d8:	ea4f 0240 	mov.w	r2, r0, lsl #1
 80010dc:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80010e0:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80010e4:	bf18      	it	ne
 80010e6:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80010ea:	d011      	beq.n	8001110 <__cmpsf2+0x40>
 80010ec:	b001      	add	sp, #4
 80010ee:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 80010f2:	bf18      	it	ne
 80010f4:	ea90 0f01 	teqne	r0, r1
 80010f8:	bf58      	it	pl
 80010fa:	ebb2 0003 	subspl.w	r0, r2, r3
 80010fe:	bf88      	it	hi
 8001100:	17c8      	asrhi	r0, r1, #31
 8001102:	bf38      	it	cc
 8001104:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 8001108:	bf18      	it	ne
 800110a:	f040 0001 	orrne.w	r0, r0, #1
 800110e:	4770      	bx	lr
 8001110:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8001114:	d102      	bne.n	800111c <__cmpsf2+0x4c>
 8001116:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 800111a:	d105      	bne.n	8001128 <__cmpsf2+0x58>
 800111c:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 8001120:	d1e4      	bne.n	80010ec <__cmpsf2+0x1c>
 8001122:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 8001126:	d0e1      	beq.n	80010ec <__cmpsf2+0x1c>
 8001128:	f85d 0b04 	ldr.w	r0, [sp], #4
 800112c:	4770      	bx	lr
 800112e:	bf00      	nop

08001130 <__aeabi_cfrcmple>:
 8001130:	4684      	mov	ip, r0
 8001132:	4608      	mov	r0, r1
 8001134:	4661      	mov	r1, ip
 8001136:	e7ff      	b.n	8001138 <__aeabi_cfcmpeq>

08001138 <__aeabi_cfcmpeq>:
 8001138:	b50f      	push	{r0, r1, r2, r3, lr}
 800113a:	f7ff ffc9 	bl	80010d0 <__cmpsf2>
 800113e:	2800      	cmp	r0, #0
 8001140:	bf48      	it	mi
 8001142:	f110 0f00 	cmnmi.w	r0, #0
 8001146:	bd0f      	pop	{r0, r1, r2, r3, pc}

08001148 <__aeabi_fcmpeq>:
 8001148:	f84d ed08 	str.w	lr, [sp, #-8]!
 800114c:	f7ff fff4 	bl	8001138 <__aeabi_cfcmpeq>
 8001150:	bf0c      	ite	eq
 8001152:	2001      	moveq	r0, #1
 8001154:	2000      	movne	r0, #0
 8001156:	f85d fb08 	ldr.w	pc, [sp], #8
 800115a:	bf00      	nop

0800115c <__aeabi_fcmplt>:
 800115c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8001160:	f7ff ffea 	bl	8001138 <__aeabi_cfcmpeq>
 8001164:	bf34      	ite	cc
 8001166:	2001      	movcc	r0, #1
 8001168:	2000      	movcs	r0, #0
 800116a:	f85d fb08 	ldr.w	pc, [sp], #8
 800116e:	bf00      	nop

08001170 <__aeabi_fcmple>:
 8001170:	f84d ed08 	str.w	lr, [sp, #-8]!
 8001174:	f7ff ffe0 	bl	8001138 <__aeabi_cfcmpeq>
 8001178:	bf94      	ite	ls
 800117a:	2001      	movls	r0, #1
 800117c:	2000      	movhi	r0, #0
 800117e:	f85d fb08 	ldr.w	pc, [sp], #8
 8001182:	bf00      	nop

08001184 <__aeabi_fcmpge>:
 8001184:	f84d ed08 	str.w	lr, [sp, #-8]!
 8001188:	f7ff ffd2 	bl	8001130 <__aeabi_cfrcmple>
 800118c:	bf94      	ite	ls
 800118e:	2001      	movls	r0, #1
 8001190:	2000      	movhi	r0, #0
 8001192:	f85d fb08 	ldr.w	pc, [sp], #8
 8001196:	bf00      	nop

08001198 <__aeabi_fcmpgt>:
 8001198:	f84d ed08 	str.w	lr, [sp, #-8]!
 800119c:	f7ff ffc8 	bl	8001130 <__aeabi_cfrcmple>
 80011a0:	bf34      	ite	cc
 80011a2:	2001      	movcc	r0, #1
 80011a4:	2000      	movcs	r0, #0
 80011a6:	f85d fb08 	ldr.w	pc, [sp], #8
 80011aa:	bf00      	nop
 80011ac:	0000      	movs	r0, r0
	...

080011b0 <__aeabi_f2iz>:
 80011b0:	ea4f 0240 	mov.w	r2, r0, lsl #1
 80011b4:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 80011b8:	d30f      	bcc.n	80011da <__aeabi_f2iz+0x2a>
 80011ba:	f04f 039e 	mov.w	r3, #158	; 0x9e
 80011be:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 80011c2:	d90d      	bls.n	80011e0 <__aeabi_f2iz+0x30>
 80011c4:	ea4f 2300 	mov.w	r3, r0, lsl #8
 80011c8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80011cc:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 80011d0:	fa23 f002 	lsr.w	r0, r3, r2
 80011d4:	bf18      	it	ne
 80011d6:	4240      	negne	r0, r0
 80011d8:	4770      	bx	lr
 80011da:	f04f 0000 	mov.w	r0, #0
 80011de:	4770      	bx	lr
 80011e0:	f112 0f61 	cmn.w	r2, #97	; 0x61
 80011e4:	d101      	bne.n	80011ea <__aeabi_f2iz+0x3a>
 80011e6:	0242      	lsls	r2, r0, #9
 80011e8:	d105      	bne.n	80011f6 <__aeabi_f2iz+0x46>
 80011ea:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
 80011ee:	bf08      	it	eq
 80011f0:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80011f4:	4770      	bx	lr
 80011f6:	f04f 0000 	mov.w	r0, #0
 80011fa:	4770      	bx	lr
 80011fc:	0000      	movs	r0, r0
	...

08001200 <__aeabi_f2uiz>:
 8001200:	0042      	lsls	r2, r0, #1
 8001202:	d20e      	bcs.n	8001222 <__aeabi_f2uiz+0x22>
 8001204:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 8001208:	d30b      	bcc.n	8001222 <__aeabi_f2uiz+0x22>
 800120a:	f04f 039e 	mov.w	r3, #158	; 0x9e
 800120e:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 8001212:	d409      	bmi.n	8001228 <__aeabi_f2uiz+0x28>
 8001214:	ea4f 2300 	mov.w	r3, r0, lsl #8
 8001218:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800121c:	fa23 f002 	lsr.w	r0, r3, r2
 8001220:	4770      	bx	lr
 8001222:	f04f 0000 	mov.w	r0, #0
 8001226:	4770      	bx	lr
 8001228:	f112 0f61 	cmn.w	r2, #97	; 0x61
 800122c:	d101      	bne.n	8001232 <__aeabi_f2uiz+0x32>
 800122e:	0242      	lsls	r2, r0, #9
 8001230:	d102      	bne.n	8001238 <__aeabi_f2uiz+0x38>
 8001232:	f04f 30ff 	mov.w	r0, #4294967295
 8001236:	4770      	bx	lr
 8001238:	f04f 0000 	mov.w	r0, #0
 800123c:	4770      	bx	lr
 800123e:	bf00      	nop

08001240 <memcpy>:
 8001240:	4684      	mov	ip, r0
 8001242:	ea41 0300 	orr.w	r3, r1, r0
 8001246:	f013 0303 	ands.w	r3, r3, #3
 800124a:	d149      	bne.n	80012e0 <memcpy+0xa0>
 800124c:	3a40      	subs	r2, #64	; 0x40
 800124e:	d323      	bcc.n	8001298 <memcpy+0x58>
 8001250:	680b      	ldr	r3, [r1, #0]
 8001252:	6003      	str	r3, [r0, #0]
 8001254:	684b      	ldr	r3, [r1, #4]
 8001256:	6043      	str	r3, [r0, #4]
 8001258:	688b      	ldr	r3, [r1, #8]
 800125a:	6083      	str	r3, [r0, #8]
 800125c:	68cb      	ldr	r3, [r1, #12]
 800125e:	60c3      	str	r3, [r0, #12]
 8001260:	690b      	ldr	r3, [r1, #16]
 8001262:	6103      	str	r3, [r0, #16]
 8001264:	694b      	ldr	r3, [r1, #20]
 8001266:	6143      	str	r3, [r0, #20]
 8001268:	698b      	ldr	r3, [r1, #24]
 800126a:	6183      	str	r3, [r0, #24]
 800126c:	69cb      	ldr	r3, [r1, #28]
 800126e:	61c3      	str	r3, [r0, #28]
 8001270:	6a0b      	ldr	r3, [r1, #32]
 8001272:	6203      	str	r3, [r0, #32]
 8001274:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8001276:	6243      	str	r3, [r0, #36]	; 0x24
 8001278:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 800127a:	6283      	str	r3, [r0, #40]	; 0x28
 800127c:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 800127e:	62c3      	str	r3, [r0, #44]	; 0x2c
 8001280:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 8001282:	6303      	str	r3, [r0, #48]	; 0x30
 8001284:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 8001286:	6343      	str	r3, [r0, #52]	; 0x34
 8001288:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 800128a:	6383      	str	r3, [r0, #56]	; 0x38
 800128c:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 800128e:	63c3      	str	r3, [r0, #60]	; 0x3c
 8001290:	3040      	adds	r0, #64	; 0x40
 8001292:	3140      	adds	r1, #64	; 0x40
 8001294:	3a40      	subs	r2, #64	; 0x40
 8001296:	d2db      	bcs.n	8001250 <memcpy+0x10>
 8001298:	3230      	adds	r2, #48	; 0x30
 800129a:	d30b      	bcc.n	80012b4 <memcpy+0x74>
 800129c:	680b      	ldr	r3, [r1, #0]
 800129e:	6003      	str	r3, [r0, #0]
 80012a0:	684b      	ldr	r3, [r1, #4]
 80012a2:	6043      	str	r3, [r0, #4]
 80012a4:	688b      	ldr	r3, [r1, #8]
 80012a6:	6083      	str	r3, [r0, #8]
 80012a8:	68cb      	ldr	r3, [r1, #12]
 80012aa:	60c3      	str	r3, [r0, #12]
 80012ac:	3010      	adds	r0, #16
 80012ae:	3110      	adds	r1, #16
 80012b0:	3a10      	subs	r2, #16
 80012b2:	d2f3      	bcs.n	800129c <memcpy+0x5c>
 80012b4:	320c      	adds	r2, #12
 80012b6:	d305      	bcc.n	80012c4 <memcpy+0x84>
 80012b8:	f851 3b04 	ldr.w	r3, [r1], #4
 80012bc:	f840 3b04 	str.w	r3, [r0], #4
 80012c0:	3a04      	subs	r2, #4
 80012c2:	d2f9      	bcs.n	80012b8 <memcpy+0x78>
 80012c4:	3204      	adds	r2, #4
 80012c6:	d008      	beq.n	80012da <memcpy+0x9a>
 80012c8:	07d2      	lsls	r2, r2, #31
 80012ca:	bf1c      	itt	ne
 80012cc:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80012d0:	f800 3b01 	strbne.w	r3, [r0], #1
 80012d4:	d301      	bcc.n	80012da <memcpy+0x9a>
 80012d6:	880b      	ldrh	r3, [r1, #0]
 80012d8:	8003      	strh	r3, [r0, #0]
 80012da:	4660      	mov	r0, ip
 80012dc:	4770      	bx	lr
 80012de:	bf00      	nop
 80012e0:	2a08      	cmp	r2, #8
 80012e2:	d313      	bcc.n	800130c <memcpy+0xcc>
 80012e4:	078b      	lsls	r3, r1, #30
 80012e6:	d0b1      	beq.n	800124c <memcpy+0xc>
 80012e8:	f010 0303 	ands.w	r3, r0, #3
 80012ec:	d0ae      	beq.n	800124c <memcpy+0xc>
 80012ee:	f1c3 0304 	rsb	r3, r3, #4
 80012f2:	1ad2      	subs	r2, r2, r3
 80012f4:	07db      	lsls	r3, r3, #31
 80012f6:	bf1c      	itt	ne
 80012f8:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80012fc:	f800 3b01 	strbne.w	r3, [r0], #1
 8001300:	d3a4      	bcc.n	800124c <memcpy+0xc>
 8001302:	f831 3b02 	ldrh.w	r3, [r1], #2
 8001306:	f820 3b02 	strh.w	r3, [r0], #2
 800130a:	e79f      	b.n	800124c <memcpy+0xc>
 800130c:	3a04      	subs	r2, #4
 800130e:	d3d9      	bcc.n	80012c4 <memcpy+0x84>
 8001310:	3a01      	subs	r2, #1
 8001312:	f811 3b01 	ldrb.w	r3, [r1], #1
 8001316:	f800 3b01 	strb.w	r3, [r0], #1
 800131a:	d2f9      	bcs.n	8001310 <memcpy+0xd0>
 800131c:	780b      	ldrb	r3, [r1, #0]
 800131e:	7003      	strb	r3, [r0, #0]
 8001320:	784b      	ldrb	r3, [r1, #1]
 8001322:	7043      	strb	r3, [r0, #1]
 8001324:	788b      	ldrb	r3, [r1, #2]
 8001326:	7083      	strb	r3, [r0, #2]
 8001328:	4660      	mov	r0, ip
 800132a:	4770      	bx	lr
 800132c:	0000      	movs	r0, r0
	...

08001330 <strcmp>:
 8001330:	ea80 0c01 	eor.w	ip, r0, r1
 8001334:	f01c 0f03 	tst.w	ip, #3
 8001338:	d137      	bne.n	80013aa <strcmp+0x7a>
 800133a:	f010 0c03 	ands.w	ip, r0, #3
 800133e:	f020 0003 	bic.w	r0, r0, #3
 8001342:	f021 0103 	bic.w	r1, r1, #3
 8001346:	f850 2b04 	ldr.w	r2, [r0], #4
 800134a:	bf08      	it	eq
 800134c:	f851 3b04 	ldreq.w	r3, [r1], #4
 8001350:	d00e      	beq.n	8001370 <strcmp+0x40>
 8001352:	f08c 0c03 	eor.w	ip, ip, #3
 8001356:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 800135a:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 800135e:	fa23 fc0c 	lsr.w	ip, r3, ip
 8001362:	f851 3b04 	ldr.w	r3, [r1], #4
 8001366:	ea42 020c 	orr.w	r2, r2, ip
 800136a:	ea43 030c 	orr.w	r3, r3, ip
 800136e:	bf00      	nop
 8001370:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 8001374:	429a      	cmp	r2, r3
 8001376:	bf01      	itttt	eq
 8001378:	ea2c 0c02 	biceq.w	ip, ip, r2
 800137c:	f01c 3f80 	tsteq.w	ip, #2155905152	; 0x80808080
 8001380:	f850 2b04 	ldreq.w	r2, [r0], #4
 8001384:	f851 3b04 	ldreq.w	r3, [r1], #4
 8001388:	d0f2      	beq.n	8001370 <strcmp+0x40>
 800138a:	ea4f 6002 	mov.w	r0, r2, lsl #24
 800138e:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8001392:	2801      	cmp	r0, #1
 8001394:	bf28      	it	cs
 8001396:	ebb0 6f03 	cmpcs.w	r0, r3, lsl #24
 800139a:	bf08      	it	eq
 800139c:	0a1b      	lsreq	r3, r3, #8
 800139e:	d0f4      	beq.n	800138a <strcmp+0x5a>
 80013a0:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 80013a4:	0e00      	lsrs	r0, r0, #24
 80013a6:	1ac0      	subs	r0, r0, r3
 80013a8:	4770      	bx	lr
 80013aa:	f010 0f03 	tst.w	r0, #3
 80013ae:	d00a      	beq.n	80013c6 <strcmp+0x96>
 80013b0:	f810 2b01 	ldrb.w	r2, [r0], #1
 80013b4:	f811 3b01 	ldrb.w	r3, [r1], #1
 80013b8:	2a01      	cmp	r2, #1
 80013ba:	bf28      	it	cs
 80013bc:	429a      	cmpcs	r2, r3
 80013be:	d0f4      	beq.n	80013aa <strcmp+0x7a>
 80013c0:	eba2 0003 	sub.w	r0, r2, r3
 80013c4:	4770      	bx	lr
 80013c6:	f84d 5d04 	str.w	r5, [sp, #-4]!
 80013ca:	f850 2b04 	ldr.w	r2, [r0], #4
 80013ce:	f001 0503 	and.w	r5, r1, #3
 80013d2:	f021 0103 	bic.w	r1, r1, #3
 80013d6:	f851 3b04 	ldr.w	r3, [r1], #4
 80013da:	2d02      	cmp	r5, #2
 80013dc:	d026      	beq.n	800142c <strcmp+0xfc>
 80013de:	d84d      	bhi.n	800147c <strcmp+0x14c>
 80013e0:	f022 457f 	bic.w	r5, r2, #4278190080	; 0xff000000
 80013e4:	ebb5 2f13 	cmp.w	r5, r3, lsr #8
 80013e8:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 80013ec:	ea2c 0c02 	bic.w	ip, ip, r2
 80013f0:	d10d      	bne.n	800140e <strcmp+0xde>
 80013f2:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
 80013f6:	bf08      	it	eq
 80013f8:	f851 3b04 	ldreq.w	r3, [r1], #4
 80013fc:	d10a      	bne.n	8001414 <strcmp+0xe4>
 80013fe:	ea85 0502 	eor.w	r5, r5, r2
 8001402:	ebb5 6f03 	cmp.w	r5, r3, lsl #24
 8001406:	d10c      	bne.n	8001422 <strcmp+0xf2>
 8001408:	f850 2b04 	ldr.w	r2, [r0], #4
 800140c:	e7e8      	b.n	80013e0 <strcmp+0xb0>
 800140e:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8001412:	e05b      	b.n	80014cc <strcmp+0x19c>
 8001414:	f03c 4c7f 	bics.w	ip, ip, #4278190080	; 0xff000000
 8001418:	d154      	bne.n	80014c4 <strcmp+0x194>
 800141a:	780b      	ldrb	r3, [r1, #0]
 800141c:	ea4f 6512 	mov.w	r5, r2, lsr #24
 8001420:	e054      	b.n	80014cc <strcmp+0x19c>
 8001422:	ea4f 6512 	mov.w	r5, r2, lsr #24
 8001426:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 800142a:	e04f      	b.n	80014cc <strcmp+0x19c>
 800142c:	ea4f 4502 	mov.w	r5, r2, lsl #16
 8001430:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 8001434:	ea4f 4515 	mov.w	r5, r5, lsr #16
 8001438:	ea2c 0c02 	bic.w	ip, ip, r2
 800143c:	ebb5 4f13 	cmp.w	r5, r3, lsr #16
 8001440:	d118      	bne.n	8001474 <strcmp+0x144>
 8001442:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
 8001446:	bf08      	it	eq
 8001448:	f851 3b04 	ldreq.w	r3, [r1], #4
 800144c:	d107      	bne.n	800145e <strcmp+0x12e>
 800144e:	ea85 0502 	eor.w	r5, r5, r2
 8001452:	ebb5 4f03 	cmp.w	r5, r3, lsl #16
 8001456:	d109      	bne.n	800146c <strcmp+0x13c>
 8001458:	f850 2b04 	ldr.w	r2, [r0], #4
 800145c:	e7e6      	b.n	800142c <strcmp+0xfc>
 800145e:	ea5f 4c0c 	movs.w	ip, ip, lsl #16
 8001462:	d12f      	bne.n	80014c4 <strcmp+0x194>
 8001464:	880b      	ldrh	r3, [r1, #0]
 8001466:	ea4f 4512 	mov.w	r5, r2, lsr #16
 800146a:	e02f      	b.n	80014cc <strcmp+0x19c>
 800146c:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8001470:	ea4f 4512 	mov.w	r5, r2, lsr #16
 8001474:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8001478:	e028      	b.n	80014cc <strcmp+0x19c>
 800147a:	bf00      	nop
 800147c:	f002 05ff 	and.w	r5, r2, #255	; 0xff
 8001480:	ebb5 6f13 	cmp.w	r5, r3, lsr #24
 8001484:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 8001488:	ea2c 0c02 	bic.w	ip, ip, r2
 800148c:	d10d      	bne.n	80014aa <strcmp+0x17a>
 800148e:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
 8001492:	bf08      	it	eq
 8001494:	f851 3b04 	ldreq.w	r3, [r1], #4
 8001498:	d10a      	bne.n	80014b0 <strcmp+0x180>
 800149a:	ea85 0502 	eor.w	r5, r5, r2
 800149e:	ebb5 2f03 	cmp.w	r5, r3, lsl #8
 80014a2:	d10a      	bne.n	80014ba <strcmp+0x18a>
 80014a4:	f850 2b04 	ldr.w	r2, [r0], #4
 80014a8:	e7e8      	b.n	800147c <strcmp+0x14c>
 80014aa:	ea4f 6313 	mov.w	r3, r3, lsr #24
 80014ae:	e00d      	b.n	80014cc <strcmp+0x19c>
 80014b0:	f012 0fff 	tst.w	r2, #255	; 0xff
 80014b4:	d006      	beq.n	80014c4 <strcmp+0x194>
 80014b6:	f851 3b04 	ldr.w	r3, [r1], #4
 80014ba:	ea4f 2512 	mov.w	r5, r2, lsr #8
 80014be:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80014c2:	e003      	b.n	80014cc <strcmp+0x19c>
 80014c4:	f04f 0000 	mov.w	r0, #0
 80014c8:	bc20      	pop	{r5}
 80014ca:	4770      	bx	lr
 80014cc:	f005 02ff 	and.w	r2, r5, #255	; 0xff
 80014d0:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 80014d4:	2801      	cmp	r0, #1
 80014d6:	bf28      	it	cs
 80014d8:	4290      	cmpcs	r0, r2
 80014da:	bf04      	itt	eq
 80014dc:	0a2d      	lsreq	r5, r5, #8
 80014de:	0a1b      	lsreq	r3, r3, #8
 80014e0:	d0f4      	beq.n	80014cc <strcmp+0x19c>
 80014e2:	eba2 0000 	sub.w	r0, r2, r0
 80014e6:	bc20      	pop	{r5}
 80014e8:	4770      	bx	lr
 80014ea:	bf00      	nop
 80014ec:	0000      	movs	r0, r0
	...

080014f0 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 80014f0:	4770      	bx	lr
 80014f2:	bf00      	nop
	...

08001500 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8001500:	4770      	bx	lr
 8001502:	bf00      	nop
	...

08001510 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
  }
 8001510:	e7fe      	b.n	8001510 <__default_exit>
 8001512:	bf00      	nop
	...

08001520 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8001520:	b4f0      	push	{r4, r5, r6, r7}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8001522:	4e11      	ldr	r6, [pc, #68]	; (8001568 <__init_ram_areas+0x48>)
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8001524:	2500      	movs	r5, #0
 8001526:	f106 0780 	add.w	r7, r6, #128	; 0x80
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 800152a:	e896 001a 	ldmia.w	r6, {r1, r3, r4}
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800152e:	42a3      	cmp	r3, r4
 8001530:	d20d      	bcs.n	800154e <__init_ram_areas+0x2e>
 8001532:	461a      	mov	r2, r3
 8001534:	3904      	subs	r1, #4
      *p = *tp;
 8001536:	f851 0f04 	ldr.w	r0, [r1, #4]!
 800153a:	f842 0b04 	str.w	r0, [r2], #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800153e:	42a2      	cmp	r2, r4
 8001540:	d3f9      	bcc.n	8001536 <__init_ram_areas+0x16>
 8001542:	43da      	mvns	r2, r3
 8001544:	4414      	add	r4, r2
 8001546:	f024 0403 	bic.w	r4, r4, #3
 800154a:	3404      	adds	r4, #4
 800154c:	4423      	add	r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800154e:	68f2      	ldr	r2, [r6, #12]
 8001550:	4293      	cmp	r3, r2
 8001552:	d203      	bcs.n	800155c <__init_ram_areas+0x3c>
      *p = 0;
 8001554:	f843 5b04 	str.w	r5, [r3], #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8001558:	4293      	cmp	r3, r2
 800155a:	d3fb      	bcc.n	8001554 <__init_ram_areas+0x34>
      *p = 0;
      p++;
    }
    rap++;
 800155c:	3610      	adds	r6, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800155e:	42be      	cmp	r6, r7
 8001560:	d3e3      	bcc.n	800152a <__init_ram_areas+0xa>
#endif
}
 8001562:	bcf0      	pop	{r4, r5, r6, r7}
 8001564:	4770      	bx	lr
 8001566:	bf00      	nop
 8001568:	0800d4e0 	.word	0x0800d4e0
 800156c:	00000000 	.word	0x00000000

08001570 <_unhandled_exception>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
/*lint -restore*/

  while (true) {
  }
 8001570:	e7fe      	b.n	8001570 <_unhandled_exception>
 8001572:	bf00      	nop
	...

08001580 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8001580:	e7fe      	b.n	8001580 <_idle_thread>
 8001582:	bf00      	nop
	...

08001590 <chSysInit>:
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 8001590:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8001594:	4b1b      	ldr	r3, [pc, #108]	; (8001604 <chSysInit+0x74>)
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8001596:	b570      	push	{r4, r5, r6, lr}
 8001598:	2500      	movs	r5, #0
 800159a:	609d      	str	r5, [r3, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800159c:	68d8      	ldr	r0, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 800159e:	4a1a      	ldr	r2, [pc, #104]	; (8001608 <chSysInit+0x78>)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 80015a0:	4001      	ands	r1, r0
  reg_value  =  (reg_value                                   |
 80015a2:	430a      	orrs	r2, r1

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80015a4:	4819      	ldr	r0, [pc, #100]	; (800160c <chSysInit+0x7c>)
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 80015a6:	60da      	str	r2, [r3, #12]
 80015a8:	68c2      	ldr	r2, [r0, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80015aa:	4919      	ldr	r1, [pc, #100]	; (8001610 <chSysInit+0x80>)

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80015ac:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80015b0:	60c2      	str	r2, [r0, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80015b2:	680a      	ldr	r2, [r1, #0]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80015b4:	2020      	movs	r0, #32
 80015b6:	f042 0201 	orr.w	r2, r2, #1
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80015ba:	4c16      	ldr	r4, [pc, #88]	; (8001614 <chSysInit+0x84>)
 80015bc:	2610      	movs	r6, #16
 80015be:	600a      	str	r2, [r1, #0]
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 80015c0:	b082      	sub	sp, #8
 80015c2:	77de      	strb	r6, [r3, #31]
 80015c4:	f883 0022 	strb.w	r0, [r3, #34]	; 0x22
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
  _scheduler_init();
 80015c8:	f000 f93a 	bl	8001840 <_scheduler_init>
  _vt_init();
 80015cc:	f000 f8b8 	bl	8001740 <_vt_init>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 80015d0:	f000 fbee 	bl	8001db0 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 80015d4:	f001 fbe4 	bl	8002da0 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 80015d8:	f001 fc2a 	bl	8002e30 <_heap_init>
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80015dc:	4620      	mov	r0, r4
 80015de:	2140      	movs	r1, #64	; 0x40
 80015e0:	f000 fa26 	bl	8001a30 <_thread_init>
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 80015e4:	2201      	movs	r2, #1
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80015e6:	f844 0c14 	str.w	r0, [r4, #-20]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 80015ea:	7402      	strb	r2, [r0, #16]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80015ec:	f385 8811 	msr	BASEPRI, r5
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80015f0:	b662      	cpsie	i
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 80015f2:	21d0      	movs	r1, #208	; 0xd0
 80015f4:	9500      	str	r5, [sp, #0]
 80015f6:	f104 003c 	add.w	r0, r4, #60	; 0x3c
 80015fa:	4b07      	ldr	r3, [pc, #28]	; (8001618 <chSysInit+0x88>)
 80015fc:	f000 fa58 	bl	8001ab0 <chThdCreateStatic>
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
  }
#endif
}
 8001600:	b002      	add	sp, #8
 8001602:	bd70      	pop	{r4, r5, r6, pc}
 8001604:	e000ed00 	.word	0xe000ed00
 8001608:	05fa0300 	.word	0x05fa0300
 800160c:	e000edf0 	.word	0xe000edf0
 8001610:	e0001000 	.word	0xe0001000
 8001614:	20001184 	.word	0x20001184
 8001618:	08001581 	.word	0x08001581
 800161c:	00000000 	.word	0x00000000

08001620 <chSysHalt>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001620:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8001622:	4b01      	ldr	r3, [pc, #4]	; (8001628 <chSysHalt+0x8>)
 8001624:	6218      	str	r0, [r3, #32]

  /* Harmless infinite loop.*/
  while (true) {
  }
 8001626:	e7fe      	b.n	8001626 <chSysHalt+0x6>
 8001628:	20001160 	.word	0x20001160
 800162c:	00000000 	.word	0x00000000

08001630 <chSysIntegrityCheckI>:
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8001630:	07c3      	lsls	r3, r0, #31
 * @retval false        The test succeeded.
 * @retval true         Test failed.
 *
 * @iclass
 */
bool chSysIntegrityCheckI(unsigned testmask) {
 8001632:	b410      	push	{r4}
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8001634:	d510      	bpl.n	8001658 <chSysIntegrityCheckI+0x28>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
 8001636:	4c1d      	ldr	r4, [pc, #116]	; (80016ac <chSysIntegrityCheckI+0x7c>)
 8001638:	6822      	ldr	r2, [r4, #0]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 800163a:	42a2      	cmp	r2, r4
 800163c:	d02b      	beq.n	8001696 <chSysIntegrityCheckI+0x66>
 800163e:	2300      	movs	r3, #0
      n++;
      tp = tp->p_next;
 8001640:	6812      	ldr	r2, [r2, #0]

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
      n++;
 8001642:	3301      	adds	r3, #1
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8001644:	42a2      	cmp	r2, r4
 8001646:	d1fb      	bne.n	8001640 <chSysIntegrityCheckI+0x10>
      n++;
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
 8001648:	6851      	ldr	r1, [r2, #4]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 800164a:	4291      	cmp	r1, r2
 800164c:	d01f      	beq.n	800168e <chSysIntegrityCheckI+0x5e>
      n--;
      tp = tp->p_prev;
 800164e:	6849      	ldr	r1, [r1, #4]
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
      n--;
 8001650:	3b01      	subs	r3, #1
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8001652:	42a1      	cmp	r1, r4
 8001654:	d1fb      	bne.n	800164e <chSysIntegrityCheckI+0x1e>
      n--;
      tp = tp->p_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 8001656:	b9d3      	cbnz	r3, 800168e <chSysIntegrityCheckI+0x5e>
      return true;
    }
  }

  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 8001658:	f010 0002 	ands.w	r0, r0, #2
 800165c:	d014      	beq.n	8001688 <chSysIntegrityCheckI+0x58>
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
 800165e:	4c13      	ldr	r4, [pc, #76]	; (80016ac <chSysIntegrityCheckI+0x7c>)
 8001660:	4621      	mov	r1, r4
 8001662:	f851 3f14 	ldr.w	r3, [r1, #20]!
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001666:	428b      	cmp	r3, r1
 8001668:	d01b      	beq.n	80016a2 <chSysIntegrityCheckI+0x72>
 800166a:	2000      	movs	r0, #0
      n++;
      vtp = vtp->vt_next;
 800166c:	681b      	ldr	r3, [r3, #0]

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
      n++;
 800166e:	3001      	adds	r0, #1
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001670:	428b      	cmp	r3, r1
 8001672:	d1fb      	bne.n	800166c <chSysIntegrityCheckI+0x3c>
      n++;
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
 8001674:	69a2      	ldr	r2, [r4, #24]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001676:	429a      	cmp	r2, r3
 8001678:	d009      	beq.n	800168e <chSysIntegrityCheckI+0x5e>
      n--;
      vtp = vtp->vt_prev;
 800167a:	6852      	ldr	r2, [r2, #4]
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
      n--;
 800167c:	3801      	subs	r0, #1
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800167e:	428a      	cmp	r2, r1
 8001680:	d1fb      	bne.n	800167a <chSysIntegrityCheckI+0x4a>
      n--;
      vtp = vtp->vt_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 8001682:	3000      	adds	r0, #0
 8001684:	bf18      	it	ne
 8001686:	2001      	movne	r0, #1
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
}
 8001688:	f85d 4b04 	ldr.w	r4, [sp], #4
 800168c:	4770      	bx	lr
      tp = tp->p_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
      return true;
 800168e:	2001      	movs	r0, #1
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
}
 8001690:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001694:	4770      	bx	lr
      n++;
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
 8001696:	6861      	ldr	r1, [r4, #4]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8001698:	42a1      	cmp	r1, r4
  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 800169a:	bf18      	it	ne
 800169c:	2300      	movne	r3, #0
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 800169e:	d1d6      	bne.n	800164e <chSysIntegrityCheckI+0x1e>
 80016a0:	e7da      	b.n	8001658 <chSysIntegrityCheckI+0x28>
      n++;
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
 80016a2:	69a2      	ldr	r2, [r4, #24]
  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
 80016a4:	2000      	movs	r0, #0
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80016a6:	429a      	cmp	r2, r3
 80016a8:	d1e7      	bne.n	800167a <chSysIntegrityCheckI+0x4a>
 80016aa:	e7ed      	b.n	8001688 <chSysIntegrityCheckI+0x58>
 80016ac:	20001160 	.word	0x20001160

080016b0 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 80016b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 80016b2:	4d10      	ldr	r5, [pc, #64]	; (80016f4 <chSysTimerHandlerI+0x44>)
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80016b4:	462e      	mov	r6, r5
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 80016b6:	8bea      	ldrh	r2, [r5, #30]
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80016b8:	f856 3f14 	ldr.w	r3, [r6, #20]!
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 80016bc:	3201      	adds	r2, #1
 80016be:	b292      	uxth	r2, r2
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80016c0:	42b3      	cmp	r3, r6
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 80016c2:	83ea      	strh	r2, [r5, #30]
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80016c4:	d014      	beq.n	80016f0 <chSysTimerHandlerI+0x40>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
 80016c6:	891c      	ldrh	r4, [r3, #8]
 80016c8:	3c01      	subs	r4, #1
 80016ca:	b2a4      	uxth	r4, r4
 80016cc:	811c      	strh	r4, [r3, #8]
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 80016ce:	b97c      	cbnz	r4, 80016f0 <chSysTimerHandlerI+0x40>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80016d0:	2720      	movs	r7, #32
      vtfunc_t fn;

      vtp = ch.vtlist.vt_next;
      fn = vtp->vt_func;
      vtp->vt_func = NULL;
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80016d2:	681a      	ldr	r2, [r3, #0]
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
      virtual_timer_t *vtp;
      vtfunc_t fn;

      vtp = ch.vtlist.vt_next;
      fn = vtp->vt_func;
 80016d4:	68d9      	ldr	r1, [r3, #12]
      vtp->vt_func = NULL;
 80016d6:	60dc      	str	r4, [r3, #12]
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80016d8:	6056      	str	r6, [r2, #4]
      ch.vtlist.vt_next = vtp->vt_next;
 80016da:	616a      	str	r2, [r5, #20]
 80016dc:	f384 8811 	msr	BASEPRI, r4
      chSysUnlockFromISR();
      fn(vtp->vt_par);
 80016e0:	6918      	ldr	r0, [r3, #16]
 80016e2:	4788      	blx	r1
 80016e4:	f387 8811 	msr	BASEPRI, r7
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 80016e8:	696b      	ldr	r3, [r5, #20]
 80016ea:	891a      	ldrh	r2, [r3, #8]
 80016ec:	2a00      	cmp	r2, #0
 80016ee:	d0f0      	beq.n	80016d2 <chSysTimerHandlerI+0x22>
 80016f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80016f2:	bf00      	nop
 80016f4:	20001160 	.word	0x20001160
	...

08001700 <chSysGetStatusAndLockX>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8001700:	f3ef 8011 	mrs	r0, BASEPRI
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
 8001704:	b920      	cbnz	r0, 8001710 <chSysGetStatusAndLockX+0x10>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8001706:	f3ef 8305 	mrs	r3, IPSR

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800170a:	2320      	movs	r3, #32
 800170c:	f383 8811 	msr	BASEPRI, r3
    else {
      chSysLock();
    }
  }
  return sts;
}
 8001710:	4770      	bx	lr
 8001712:	bf00      	nop
	...

08001720 <chSysRestoreStatusX>:
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
 8001720:	b968      	cbnz	r0, 800173e <chSysRestoreStatusX+0x1e>
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 8001722:	b510      	push	{r4, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8001724:	f3ef 8405 	mrs	r4, IPSR
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {

  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 8001728:	f3c4 0408 	ubfx	r4, r4, #0, #9

  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
 800172c:	b114      	cbz	r4, 8001734 <chSysRestoreStatusX+0x14>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800172e:	f380 8811 	msr	BASEPRI, r0
 8001732:	bd10      	pop	{r4, pc}
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
 8001734:	f000 f964 	bl	8001a00 <chSchRescheduleS>
 8001738:	f384 8811 	msr	BASEPRI, r4
 800173c:	bd10      	pop	{r4, pc}
 800173e:	4770      	bx	lr

08001740 <_vt_init>:
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 8001740:	f64f 70ff 	movw	r0, #65535	; 0xffff
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8001744:	4b04      	ldr	r3, [pc, #16]	; (8001758 <_vt_init+0x18>)
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
 8001746:	2100      	movs	r1, #0
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8001748:	f103 0214 	add.w	r2, r3, #20
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 800174c:	8398      	strh	r0, [r3, #28]
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
 800174e:	83d9      	strh	r1, [r3, #30]
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8001750:	615a      	str	r2, [r3, #20]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001752:	619a      	str	r2, [r3, #24]
 8001754:	4770      	bx	lr
 8001756:	bf00      	nop
 8001758:	20001160 	.word	0x20001160
 800175c:	00000000 	.word	0x00000000

08001760 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8001760:	b430      	push	{r4, r5}
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 8001762:	4c0d      	ldr	r4, [pc, #52]	; (8001798 <chVTDoSetI+0x38>)
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 8001764:	6103      	str	r3, [r0, #16]
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 8001766:	6963      	ldr	r3, [r4, #20]

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 8001768:	60c2      	str	r2, [r0, #12]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 800176a:	891a      	ldrh	r2, [r3, #8]
 800176c:	4291      	cmp	r1, r2
 800176e:	d905      	bls.n	800177c <chVTDoSetI+0x1c>
    delta -= p->vt_delta;
    p = p->vt_next;
 8001770:	681b      	ldr	r3, [r3, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 8001772:	1a89      	subs	r1, r1, r2
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8001774:	891a      	ldrh	r2, [r3, #8]
    delta -= p->vt_delta;
 8001776:	b289      	uxth	r1, r1
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8001778:	428a      	cmp	r2, r1
 800177a:	d3f9      	bcc.n	8001770 <chVTDoSetI+0x10>
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
  ch.vtlist.vt_delta = (systime_t)-1;
 800177c:	f64f 75ff 	movw	r5, #65535	; 0xffff
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 8001780:	685a      	ldr	r2, [r3, #4]
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 8001782:	6003      	str	r3, [r0, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 8001784:	6042      	str	r2, [r0, #4]
  vtp->vt_prev->vt_next = vtp;
 8001786:	6010      	str	r0, [r2, #0]
  p->vt_prev = vtp;
 8001788:	6058      	str	r0, [r3, #4]
  vtp->vt_delta = delta
 800178a:	8101      	strh	r1, [r0, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 800178c:	891a      	ldrh	r2, [r3, #8]
 800178e:	1a51      	subs	r1, r2, r1
 8001790:	8119      	strh	r1, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8001792:	83a5      	strh	r5, [r4, #28]
}
 8001794:	bc30      	pop	{r4, r5}
 8001796:	4770      	bx	lr
 8001798:	20001160 	.word	0x20001160
 800179c:	00000000 	.word	0x00000000

080017a0 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 80017a0:	b430      	push	{r4, r5}
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = NULL;

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 80017a2:	f64f 74ff 	movw	r4, #65535	; 0xffff
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 80017a6:	6803      	ldr	r3, [r0, #0]
 80017a8:	8905      	ldrh	r5, [r0, #8]
 80017aa:	891a      	ldrh	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
 80017ac:	6841      	ldr	r1, [r0, #4]
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 80017ae:	442a      	add	r2, r5
 80017b0:	811a      	strh	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
 80017b2:	600b      	str	r3, [r1, #0]
  vtp->vt_next->vt_prev = vtp->vt_prev;
 80017b4:	6805      	ldr	r5, [r0, #0]
  vtp->vt_func = NULL;

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 80017b6:	4b03      	ldr	r3, [pc, #12]	; (80017c4 <chVTDoResetI+0x24>)
  vtp->vt_next->vt_delta += vtp->vt_delta;

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = NULL;
 80017b8:	2200      	movs	r2, #0
  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
 80017ba:	6069      	str	r1, [r5, #4]
  vtp->vt_func = NULL;
 80017bc:	60c2      	str	r2, [r0, #12]

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 80017be:	839c      	strh	r4, [r3, #28]
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80017c0:	bc30      	pop	{r4, r5}
 80017c2:	4770      	bx	lr
 80017c4:	20001160 	.word	0x20001160
	...

080017d0 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 80017d0:	b410      	push	{r4}
 80017d2:	2320      	movs	r3, #32
 80017d4:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 80017d8:	7c03      	ldrb	r3, [r0, #16]
 80017da:	2b07      	cmp	r3, #7
 80017dc:	d80e      	bhi.n	80017fc <wakeup+0x2c>
 80017de:	e8df f003 	tbb	[pc, r3]
 80017e2:	0d27      	.short	0x0d27
 80017e4:	0408230d 	.word	0x0408230d
 80017e8:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 80017ea:	6942      	ldr	r2, [r0, #20]
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
 80017ec:	6893      	ldr	r3, [r2, #8]
 80017ee:	3301      	adds	r3, #1
 80017f0:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 80017f2:	e890 000c 	ldmia.w	r0, {r2, r3}
 80017f6:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 80017f8:	6802      	ldr	r2, [r0, #0]
 80017fa:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 80017fc:	f04f 34ff 	mov.w	r4, #4294967295
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001800:	2200      	movs	r2, #0
 8001802:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8001804:	4b0d      	ldr	r3, [pc, #52]	; (800183c <wakeup+0x6c>)
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8001806:	6144      	str	r4, [r0, #20]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001808:	7402      	strb	r2, [r0, #16]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800180a:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800180c:	689a      	ldr	r2, [r3, #8]
 800180e:	428a      	cmp	r2, r1
 8001810:	d2fb      	bcs.n	800180a <wakeup+0x3a>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001812:	685a      	ldr	r2, [r3, #4]
 8001814:	2100      	movs	r1, #0
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001816:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
 8001818:	6042      	str	r2, [r0, #4]
  tp->p_prev->p_next = tp;
 800181a:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 800181c:	6058      	str	r0, [r3, #4]
 800181e:	f381 8811 	msr	BASEPRI, r1
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8001822:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001826:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8001828:	6943      	ldr	r3, [r0, #20]
 800182a:	2200      	movs	r2, #0
 800182c:	601a      	str	r2, [r3, #0]
    break;
 800182e:	e7e5      	b.n	80017fc <wakeup+0x2c>
 8001830:	2300      	movs	r3, #0
 8001832:	f383 8811 	msr	BASEPRI, r3
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8001836:	f85d 4b04 	ldr.w	r4, [sp], #4
 800183a:	4770      	bx	lr
 800183c:	20001160 	.word	0x20001160

08001840 <_scheduler_init>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001840:	4b02      	ldr	r3, [pc, #8]	; (800184c <_scheduler_init+0xc>)
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 8001842:	2200      	movs	r2, #0
 8001844:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8001846:	605b      	str	r3, [r3, #4]
 8001848:	609a      	str	r2, [r3, #8]
 800184a:	4770      	bx	lr
 800184c:	20001160 	.word	0x20001160

08001850 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8001850:	b410      	push	{r4}
 8001852:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001854:	2200      	movs	r2, #0
 8001856:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8001858:	4b07      	ldr	r3, [pc, #28]	; (8001878 <chSchReadyI+0x28>)
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800185a:	7402      	strb	r2, [r0, #16]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800185c:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800185e:	689a      	ldr	r2, [r3, #8]
 8001860:	428a      	cmp	r2, r1
 8001862:	d2fb      	bcs.n	800185c <chSchReadyI+0xc>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001864:	685a      	ldr	r2, [r3, #4]
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;

  return tp;
}
 8001866:	4620      	mov	r0, r4
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001868:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 800186a:	6062      	str	r2, [r4, #4]
  tp->p_prev->p_next = tp;
 800186c:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 800186e:	605c      	str	r4, [r3, #4]

  return tp;
}
 8001870:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001874:	4770      	bx	lr
 8001876:	bf00      	nop
 8001878:	20001160 	.word	0x20001160
 800187c:	00000000 	.word	0x00000000

08001880 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8001880:	4b07      	ldr	r3, [pc, #28]	; (80018a0 <chSchGoSleepS+0x20>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8001882:	b430      	push	{r4, r5}
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8001884:	681a      	ldr	r2, [r3, #0]
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8001886:	6919      	ldr	r1, [r3, #16]

  tqp->p_next = tp->p_next;
 8001888:	6814      	ldr	r4, [r2, #0]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800188a:	2501      	movs	r5, #1
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
  otp->p_state = newstate;
 800188c:	7408      	strb	r0, [r1, #16]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800188e:	6063      	str	r3, [r4, #4]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8001890:	611a      	str	r2, [r3, #16]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8001892:	7415      	strb	r5, [r2, #16]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8001894:	601c      	str	r4, [r3, #0]
  chSysSwitch(currp, otp);
 8001896:	4610      	mov	r0, r2
}
 8001898:	bc30      	pop	{r4, r5}
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 800189a:	f7fe bcc9 	b.w	8000230 <_port_switch>
 800189e:	bf00      	nop
 80018a0:	20001160 	.word	0x20001160
	...

080018b0 <chSchGoSleepTimeoutS>:
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80018b0:	f64f 73ff 	movw	r3, #65535	; 0xffff
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80018b4:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80018b6:	4299      	cmp	r1, r3
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80018b8:	b087      	sub	sp, #28

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80018ba:	d012      	beq.n	80018e2 <chSchGoSleepTimeoutS+0x32>
 80018bc:	4605      	mov	r5, r0
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 80018be:	4c0c      	ldr	r4, [pc, #48]	; (80018f0 <chSchGoSleepTimeoutS+0x40>)
 80018c0:	a801      	add	r0, sp, #4
 80018c2:	6923      	ldr	r3, [r4, #16]
 80018c4:	4a0b      	ldr	r2, [pc, #44]	; (80018f4 <chSchGoSleepTimeoutS+0x44>)
 80018c6:	f7ff ff4b 	bl	8001760 <chVTDoSetI>
    chSchGoSleepS(newstate);
 80018ca:	4628      	mov	r0, r5
 80018cc:	f7ff ffd8 	bl	8001880 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 80018d0:	9b04      	ldr	r3, [sp, #16]
 80018d2:	b113      	cbz	r3, 80018da <chSchGoSleepTimeoutS+0x2a>
      chVTDoResetI(&vt);
 80018d4:	a801      	add	r0, sp, #4
 80018d6:	f7ff ff63 	bl	80017a0 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 80018da:	6923      	ldr	r3, [r4, #16]
}
 80018dc:	6958      	ldr	r0, [r3, #20]
 80018de:	b007      	add	sp, #28
 80018e0:	bd30      	pop	{r4, r5, pc}
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 80018e2:	f7ff ffcd 	bl	8001880 <chSchGoSleepS>
 80018e6:	4c02      	ldr	r4, [pc, #8]	; (80018f0 <chSchGoSleepTimeoutS+0x40>)
  }

  return currp->p_u.rdymsg;
 80018e8:	6923      	ldr	r3, [r4, #16]
}
 80018ea:	6958      	ldr	r0, [r3, #20]
 80018ec:	b007      	add	sp, #28
 80018ee:	bd30      	pop	{r4, r5, pc}
 80018f0:	20001160 	.word	0x20001160
 80018f4:	080017d1 	.word	0x080017d1
	...

08001900 <chSchWakeupS>:

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8001900:	4b14      	ldr	r3, [pc, #80]	; (8001954 <chSchWakeupS+0x54>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8001902:	b470      	push	{r4, r5, r6}

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8001904:	691e      	ldr	r6, [r3, #16]
 8001906:	6884      	ldr	r4, [r0, #8]
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8001908:	4605      	mov	r5, r0
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 800190a:	6141      	str	r1, [r0, #20]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800190c:	68b0      	ldr	r0, [r6, #8]
 800190e:	4284      	cmp	r4, r0
 8001910:	d80c      	bhi.n	800192c <chSchWakeupS+0x2c>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001912:	2200      	movs	r2, #0
 8001914:	742a      	strb	r2, [r5, #16]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 8001916:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8001918:	689a      	ldr	r2, [r3, #8]
 800191a:	4294      	cmp	r4, r2
 800191c:	d9fb      	bls.n	8001916 <chSchWakeupS+0x16>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800191e:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001920:	602b      	str	r3, [r5, #0]
  tp->p_prev = cp->p_prev;
 8001922:	606a      	str	r2, [r5, #4]
  tp->p_prev->p_next = tp;
 8001924:	6015      	str	r5, [r2, #0]
  cp->p_prev = tp;
 8001926:	605d      	str	r5, [r3, #4]
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 8001928:	bc70      	pop	{r4, r5, r6}
 800192a:	4770      	bx	lr
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
  cp = (thread_t *)&ch.rlist.r_queue;
 800192c:	461a      	mov	r2, r3
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800192e:	2100      	movs	r1, #0
 8001930:	7431      	strb	r1, [r6, #16]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 8001932:	6812      	ldr	r2, [r2, #0]
  } while (cp->p_prio >= tp->p_prio);
 8001934:	6891      	ldr	r1, [r2, #8]
 8001936:	4288      	cmp	r0, r1
 8001938:	d9fb      	bls.n	8001932 <chSchWakeupS+0x32>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800193a:	6850      	ldr	r0, [r2, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 800193c:	2401      	movs	r4, #1
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800193e:	6070      	str	r0, [r6, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001940:	6032      	str	r2, [r6, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8001942:	6006      	str	r6, [r0, #0]
  cp->p_prev = tp;
 8001944:	6056      	str	r6, [r2, #4]
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 8001946:	611d      	str	r5, [r3, #16]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8001948:	742c      	strb	r4, [r5, #16]
    chSysSwitch(ntp, otp);
 800194a:	4631      	mov	r1, r6
 800194c:	4628      	mov	r0, r5
  }
}
 800194e:	bc70      	pop	{r4, r5, r6}
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 8001950:	f7fe bc6e 	b.w	8000230 <_port_switch>
 8001954:	20001160 	.word	0x20001160
	...

08001960 <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8001960:	4b04      	ldr	r3, [pc, #16]	; (8001974 <chSchIsPreemptionRequired+0x14>)
 8001962:	681a      	ldr	r2, [r3, #0]
  tprio_t p2 = currp->p_prio;
 8001964:	691b      	ldr	r3, [r3, #16]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8001966:	6890      	ldr	r0, [r2, #8]
 8001968:	689b      	ldr	r3, [r3, #8]
#endif
}
 800196a:	4298      	cmp	r0, r3
 800196c:	bf94      	ite	ls
 800196e:	2000      	movls	r0, #0
 8001970:	2001      	movhi	r0, #1
 8001972:	4770      	bx	lr
 8001974:	20001160 	.word	0x20001160
	...

08001980 <chSchDoRescheduleBehind>:
 * @special
 */
void chSchDoRescheduleBehind(void) {
  thread_t *otp;

  otp = currp;
 8001980:	4a0d      	ldr	r2, [pc, #52]	; (80019b8 <chSchDoRescheduleBehind+0x38>)
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleBehind(void) {
 8001982:	b4f0      	push	{r4, r5, r6, r7}
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8001984:	6810      	ldr	r0, [r2, #0]
  thread_t *otp;

  otp = currp;
 8001986:	6914      	ldr	r4, [r2, #16]

  tqp->p_next = tp->p_next;
 8001988:	6805      	ldr	r5, [r0, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800198a:	2701      	movs	r7, #1
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800198c:	2600      	movs	r6, #0
 800198e:	68a1      	ldr	r1, [r4, #8]
 8001990:	462b      	mov	r3, r5
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001992:	606a      	str	r2, [r5, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8001994:	6015      	str	r5, [r2, #0]
void chSchDoRescheduleBehind(void) {
  thread_t *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8001996:	6110      	str	r0, [r2, #16]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8001998:	7407      	strb	r7, [r0, #16]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800199a:	7426      	strb	r6, [r4, #16]
 800199c:	e000      	b.n	80019a0 <chSchDoRescheduleBehind+0x20>
 800199e:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
 80019a0:	689a      	ldr	r2, [r3, #8]
 80019a2:	428a      	cmp	r2, r1
 80019a4:	d2fb      	bcs.n	800199e <chSchDoRescheduleBehind+0x1e>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80019a6:	685a      	ldr	r2, [r3, #4]
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
  chSysSwitch(currp, otp);
 80019a8:	4621      	mov	r1, r4
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80019aa:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 80019ac:	6062      	str	r2, [r4, #4]
  tp->p_prev->p_next = tp;
 80019ae:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 80019b0:	605c      	str	r4, [r3, #4]
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
  chSysSwitch(currp, otp);
}
 80019b2:	bcf0      	pop	{r4, r5, r6, r7}
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
  chSysSwitch(currp, otp);
 80019b4:	f7fe bc3c 	b.w	8000230 <_port_switch>
 80019b8:	20001160 	.word	0x20001160
 80019bc:	00000000 	.word	0x00000000

080019c0 <chSchDoRescheduleAhead>:
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 80019c0:	4a0d      	ldr	r2, [pc, #52]	; (80019f8 <chSchDoRescheduleAhead+0x38>)
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 80019c2:	b4f0      	push	{r4, r5, r6, r7}
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80019c4:	6810      	ldr	r0, [r2, #0]
  thread_t *otp, *cp;

  otp = currp;
 80019c6:	6914      	ldr	r4, [r2, #16]

  tqp->p_next = tp->p_next;
 80019c8:	6805      	ldr	r5, [r0, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80019ca:	2701      	movs	r7, #1

  otp->p_state = CH_STATE_READY;
 80019cc:	2600      	movs	r6, #0
 80019ce:	68a1      	ldr	r1, [r4, #8]
 80019d0:	462b      	mov	r3, r5
  tqp->p_next->p_prev = (thread_t *)tqp;
 80019d2:	606a      	str	r2, [r5, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80019d4:	6015      	str	r5, [r2, #0]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80019d6:	6110      	str	r0, [r2, #16]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80019d8:	7407      	strb	r7, [r0, #16]

  otp->p_state = CH_STATE_READY;
 80019da:	7426      	strb	r6, [r4, #16]
 80019dc:	e000      	b.n	80019e0 <chSchDoRescheduleAhead+0x20>
 80019de:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 80019e0:	689a      	ldr	r2, [r3, #8]
 80019e2:	428a      	cmp	r2, r1
 80019e4:	d8fb      	bhi.n	80019de <chSchDoRescheduleAhead+0x1e>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 80019e6:	685a      	ldr	r2, [r3, #4]
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 80019e8:	4621      	mov	r1, r4
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 80019ea:	6023      	str	r3, [r4, #0]
  otp->p_prev = cp->p_prev;
 80019ec:	6062      	str	r2, [r4, #4]
  otp->p_prev->p_next = otp;
 80019ee:	6014      	str	r4, [r2, #0]
  cp->p_prev = otp;
 80019f0:	605c      	str	r4, [r3, #4]

  chSysSwitch(currp, otp);
}
 80019f2:	bcf0      	pop	{r4, r5, r6, r7}
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 80019f4:	f7fe bc1c 	b.w	8000230 <_port_switch>
 80019f8:	20001160 	.word	0x20001160
 80019fc:	00000000 	.word	0x00000000

08001a00 <chSchRescheduleS>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 8001a00:	4b04      	ldr	r3, [pc, #16]	; (8001a14 <chSchRescheduleS+0x14>)
 8001a02:	681a      	ldr	r2, [r3, #0]
 8001a04:	691b      	ldr	r3, [r3, #16]
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8001a06:	6892      	ldr	r2, [r2, #8]
 8001a08:	689b      	ldr	r3, [r3, #8]
 8001a0a:	429a      	cmp	r2, r3
 8001a0c:	d800      	bhi.n	8001a10 <chSchRescheduleS+0x10>
 8001a0e:	4770      	bx	lr
    chSchDoRescheduleAhead();
 8001a10:	f7ff bfd6 	b.w	80019c0 <chSchDoRescheduleAhead>
 8001a14:	20001160 	.word	0x20001160
	...

08001a20 <chSchDoReschedule>:
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8001a20:	f7ff bfce 	b.w	80019c0 <chSchDoRescheduleAhead>
	...

08001a30 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 8001a30:	b4f0      	push	{r4, r5, r6, r7}
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8001a32:	f100 041c 	add.w	r4, r0, #28
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001a36:	2200      	movs	r2, #0
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8001a38:	2702      	movs	r7, #2
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001a3a:	2601      	movs	r6, #1
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8001a3c:	f100 0518 	add.w	r5, r0, #24
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8001a40:	7407      	strb	r7, [r0, #16]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001a42:	7486      	strb	r6, [r0, #18]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8001a44:	6185      	str	r5, [r0, #24]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001a46:	61c4      	str	r4, [r0, #28]
  tqp->p_prev = (thread_t *)tqp;
 8001a48:	6204      	str	r4, [r0, #32]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8001a4a:	6081      	str	r1, [r0, #8]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8001a4c:	6301      	str	r1, [r0, #48]	; 0x30
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001a4e:	7442      	strb	r2, [r0, #17]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8001a50:	62c2      	str	r2, [r0, #44]	; 0x2c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8001a52:	6282      	str	r2, [r0, #40]	; 0x28
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
}
 8001a54:	bcf0      	pop	{r4, r5, r6, r7}
 8001a56:	4770      	bx	lr
	...

08001a60 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 8001a60:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001a64:	3924      	subs	r1, #36	; 0x24
 8001a66:	1846      	adds	r6, r0, r1
 8001a68:	60c6      	str	r6, [r0, #12]
 8001a6a:	f8df 903c 	ldr.w	r9, [pc, #60]	; 8001aa8 <chThdCreateI+0x48>
 8001a6e:	5043      	str	r3, [r0, r1]
 8001a70:	9b07      	ldr	r3, [sp, #28]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001a72:	2500      	movs	r5, #0
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8001a74:	f100 071c 	add.w	r7, r0, #28
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8001a78:	f04f 0802 	mov.w	r8, #2
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001a7c:	f04f 0c01 	mov.w	ip, #1
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8001a80:	f100 0e18 	add.w	lr, r0, #24

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001a84:	6073      	str	r3, [r6, #4]
 8001a86:	f8c6 9020 	str.w	r9, [r6, #32]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8001a8a:	6082      	str	r2, [r0, #8]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8001a8c:	6302      	str	r2, [r0, #48]	; 0x30
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8001a8e:	f880 8010 	strb.w	r8, [r0, #16]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001a92:	f880 c012 	strb.w	ip, [r0, #18]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8001a96:	f8c0 e018 	str.w	lr, [r0, #24]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001a9a:	61c7      	str	r7, [r0, #28]
  tqp->p_prev = (thread_t *)tqp;
 8001a9c:	6207      	str	r7, [r0, #32]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001a9e:	7445      	strb	r5, [r0, #17]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8001aa0:	62c5      	str	r5, [r0, #44]	; 0x2c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8001aa2:	6285      	str	r5, [r0, #40]	; 0x28
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);

  return _thread_init(tp, prio);
}
 8001aa4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8001aa8:	08000241 	.word	0x08000241
 8001aac:	00000000 	.word	0x00000000

08001ab0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8001ab0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001ab4:	469a      	mov	sl, r3
 8001ab6:	4604      	mov	r4, r0
 8001ab8:	2320      	movs	r3, #32
 8001aba:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001abe:	f8df 9050 	ldr.w	r9, [pc, #80]	; 8001b10 <chThdCreateStatic+0x60>
 8001ac2:	3924      	subs	r1, #36	; 0x24
 8001ac4:	9f08      	ldr	r7, [sp, #32]
 8001ac6:	1846      	adds	r6, r0, r1
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001ac8:	2500      	movs	r5, #0
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8001aca:	f100 031c 	add.w	r3, r0, #28
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001ace:	f04f 0c01 	mov.w	ip, #1
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8001ad2:	f100 0e18 	add.w	lr, r0, #24
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8001ad6:	f04f 0802 	mov.w	r8, #2

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001ada:	60c6      	str	r6, [r0, #12]
 8001adc:	f840 a001 	str.w	sl, [r0, r1]
 8001ae0:	6077      	str	r7, [r6, #4]
 8001ae2:	f8c6 9020 	str.w	r9, [r6, #32]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 8001ae6:	4629      	mov	r1, r5
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8001ae8:	6082      	str	r2, [r0, #8]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8001aea:	6302      	str	r2, [r0, #48]	; 0x30
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8001aec:	f880 8010 	strb.w	r8, [r0, #16]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001af0:	f880 c012 	strb.w	ip, [r0, #18]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8001af4:	f8c0 e018 	str.w	lr, [r0, #24]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001af8:	7445      	strb	r5, [r0, #17]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8001afa:	62c5      	str	r5, [r0, #44]	; 0x2c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8001afc:	6285      	str	r5, [r0, #40]	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001afe:	61c3      	str	r3, [r0, #28]
  tqp->p_prev = (thread_t *)tqp;
 8001b00:	6203      	str	r3, [r0, #32]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 8001b02:	f7ff fefd 	bl	8001900 <chSchWakeupS>
 8001b06:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();

  return tp;
}
 8001b0a:	4620      	mov	r0, r4
 8001b0c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001b10:	08000241 	.word	0x08000241
	...

08001b20 <chThdStart>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdStart(thread_t *tp) {
 8001b20:	b508      	push	{r3, lr}
 8001b22:	2320      	movs	r3, #32
 8001b24:	f383 8811 	msr	BASEPRI, r3
 */
static inline thread_t *chThdStartI(thread_t *tp) {

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");

  return chSchReadyI(tp);
 8001b28:	f7ff fe92 	bl	8001850 <chSchReadyI>
 8001b2c:	2300      	movs	r3, #0
 8001b2e:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  tp = chThdStartI(tp);
  chSysUnlock();

  return tp;
}
 8001b32:	bd08      	pop	{r3, pc}
	...

08001b40 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 8001b40:	b510      	push	{r4, lr}
 8001b42:	2320      	movs	r3, #32
 8001b44:	f383 8811 	msr	BASEPRI, r3

  chDbgCheck(newprio <= HIGHPRIO);

  chSysLock();
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->p_realprio;
 8001b48:	4b08      	ldr	r3, [pc, #32]	; (8001b6c <chThdSetPriority+0x2c>)
 8001b4a:	691b      	ldr	r3, [r3, #16]
 8001b4c:	6b1c      	ldr	r4, [r3, #48]	; 0x30
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio)) {
 8001b4e:	6899      	ldr	r1, [r3, #8]
 8001b50:	428c      	cmp	r4, r1
 8001b52:	d001      	beq.n	8001b58 <chThdSetPriority+0x18>
 8001b54:	4281      	cmp	r1, r0
 8001b56:	d200      	bcs.n	8001b5a <chThdSetPriority+0x1a>
    currp->p_prio = newprio;
 8001b58:	6098      	str	r0, [r3, #8]
  }
  currp->p_realprio = newprio;
 8001b5a:	6318      	str	r0, [r3, #48]	; 0x30
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
 8001b5c:	f7ff ff50 	bl	8001a00 <chSchRescheduleS>
 8001b60:	2300      	movs	r3, #0
 8001b62:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return oldprio;
}
 8001b66:	4620      	mov	r0, r4
 8001b68:	bd10      	pop	{r4, pc}
 8001b6a:	bf00      	nop
 8001b6c:	20001160 	.word	0x20001160

08001b70 <chThdTerminate>:
 8001b70:	2320      	movs	r3, #32
 8001b72:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chThdTerminate(thread_t *tp) {

  chSysLock();
  tp->p_flags |= CH_FLAG_TERMINATE;
 8001b76:	7c43      	ldrb	r3, [r0, #17]
 8001b78:	2200      	movs	r2, #0
 8001b7a:	f043 0304 	orr.w	r3, r3, #4
 8001b7e:	7443      	strb	r3, [r0, #17]
 8001b80:	f382 8811 	msr	BASEPRI, r2
 8001b84:	4770      	bx	lr
 8001b86:	bf00      	nop
	...

08001b90 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8001b90:	b508      	push	{r3, lr}
 8001b92:	4601      	mov	r1, r0
 8001b94:	2320      	movs	r3, #32
 8001b96:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8001b9a:	2008      	movs	r0, #8
 8001b9c:	f7ff fe88 	bl	80018b0 <chSchGoSleepTimeoutS>
 8001ba0:	2300      	movs	r3, #0
 8001ba2:	f383 8811 	msr	BASEPRI, r3
 8001ba6:	bd08      	pop	{r3, pc}
	...

08001bb0 <chThdSleepUntil>:
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
 8001bb0:	b508      	push	{r3, lr}
 8001bb2:	2320      	movs	r3, #32
 8001bb4:	f383 8811 	msr	BASEPRI, r3
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 8001bb8:	4b05      	ldr	r3, [pc, #20]	; (8001bd0 <chThdSleepUntil+0x20>)
 8001bba:	8bd9      	ldrh	r1, [r3, #30]

  chSysLock();
  time -= chVTGetSystemTimeX();
 8001bbc:	1a41      	subs	r1, r0, r1
 8001bbe:	b289      	uxth	r1, r1
  if (time > (systime_t)0) {
 8001bc0:	b111      	cbz	r1, 8001bc8 <chThdSleepUntil+0x18>
 8001bc2:	2008      	movs	r0, #8
 8001bc4:	f7ff fe74 	bl	80018b0 <chSchGoSleepTimeoutS>
 8001bc8:	2300      	movs	r3, #0
 8001bca:	f383 8811 	msr	BASEPRI, r3
 8001bce:	bd08      	pop	{r3, pc}
 8001bd0:	20001160 	.word	0x20001160
	...

08001be0 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 8001be0:	b508      	push	{r3, lr}
 8001be2:	2320      	movs	r3, #32
 8001be4:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.r_queue) >= currp->p_prio;
 8001be8:	4b06      	ldr	r3, [pc, #24]	; (8001c04 <chThdYield+0x24>)
 8001bea:	681a      	ldr	r2, [r3, #0]
 8001bec:	691b      	ldr	r3, [r3, #16]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 8001bee:	6892      	ldr	r2, [r2, #8]
 8001bf0:	689b      	ldr	r3, [r3, #8]
 8001bf2:	429a      	cmp	r2, r3
 8001bf4:	d301      	bcc.n	8001bfa <chThdYield+0x1a>
    chSchDoRescheduleBehind();
 8001bf6:	f7ff fec3 	bl	8001980 <chSchDoRescheduleBehind>
 8001bfa:	2300      	movs	r3, #0
 8001bfc:	f383 8811 	msr	BASEPRI, r3
 8001c00:	bd08      	pop	{r3, pc}
 8001c02:	bf00      	nop
 8001c04:	20001160 	.word	0x20001160
	...

08001c10 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8001c10:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp = currp;
 8001c12:	4b0a      	ldr	r3, [pc, #40]	; (8001c3c <chThdExitS+0x2c>)
 8001c14:	691c      	ldr	r4, [r3, #16]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8001c16:	69a3      	ldr	r3, [r4, #24]
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8001c18:	f104 0518 	add.w	r5, r4, #24
 8001c1c:	429d      	cmp	r5, r3
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;

  tp->p_u.exitcode = msg;
 8001c1e:	6160      	str	r0, [r4, #20]
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8001c20:	d007      	beq.n	8001c32 <chThdExitS+0x22>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 8001c22:	681a      	ldr	r2, [r3, #0]
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 8001c24:	4618      	mov	r0, r3
 8001c26:	61a2      	str	r2, [r4, #24]
 8001c28:	f7ff fe12 	bl	8001850 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8001c2c:	69a3      	ldr	r3, [r4, #24]
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8001c2e:	42ab      	cmp	r3, r5
 8001c30:	d1f7      	bne.n	8001c22 <chThdExitS+0x12>
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    REG_REMOVE(tp);
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8001c32:	200f      	movs	r0, #15

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 8001c34:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    REG_REMOVE(tp);
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8001c38:	f7ff be22 	b.w	8001880 <chSchGoSleepS>
 8001c3c:	20001160 	.word	0x20001160

08001c40 <chThdExit>:
 8001c40:	2320      	movs	r3, #32
 8001c42:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
 8001c46:	f7ff bfe3 	b.w	8001c10 <chThdExitS>
 8001c4a:	bf00      	nop
 8001c4c:	0000      	movs	r0, r0
	...

08001c50 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 8001c50:	b538      	push	{r3, r4, r5, lr}
 8001c52:	4604      	mov	r4, r0
 8001c54:	2320      	movs	r3, #32
 8001c56:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chDbgAssert(tp != currp, "waiting self");
#if CH_CFG_USE_DYNAMIC == TRUE
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
#endif
  if (tp->p_state != CH_STATE_FINAL) {
 8001c5a:	7c03      	ldrb	r3, [r0, #16]
 8001c5c:	2b0f      	cmp	r3, #15
 8001c5e:	d007      	beq.n	8001c70 <chThdWait+0x20>
    list_insert(currp, &tp->p_waiting);
 8001c60:	4b08      	ldr	r3, [pc, #32]	; (8001c84 <chThdWait+0x34>)
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {

  tp->p_next = tlp->p_next;
 8001c62:	6982      	ldr	r2, [r0, #24]
 8001c64:	691b      	ldr	r3, [r3, #16]
    chSchGoSleepS(CH_STATE_WTEXIT);
 8001c66:	2009      	movs	r0, #9
 8001c68:	601a      	str	r2, [r3, #0]
  tlp->p_next = tp;
 8001c6a:	61a3      	str	r3, [r4, #24]
 8001c6c:	f7ff fe08 	bl	8001880 <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
 8001c70:	6965      	ldr	r5, [r4, #20]
 8001c72:	2300      	movs	r3, #0
 8001c74:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
  /* Releasing a lock if it is a dynamic thread.*/
  chThdRelease(tp);
 8001c78:	4620      	mov	r0, r4
 8001c7a:	f000 f8b9 	bl	8001df0 <chThdRelease>
#endif

  return msg;
}
 8001c7e:	4628      	mov	r0, r5
 8001c80:	bd38      	pop	{r3, r4, r5, pc}
 8001c82:	bf00      	nop
 8001c84:	20001160 	.word	0x20001160
	...

08001c90 <chThdSuspendTimeoutS>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001c90:	4b05      	ldr	r3, [pc, #20]	; (8001ca8 <chThdSuspendTimeoutS+0x18>)
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
 8001c92:	4602      	mov	r2, r0
 8001c94:	691b      	ldr	r3, [r3, #16]
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  if (TIME_IMMEDIATE == timeout) {
 8001c96:	b121      	cbz	r1, 8001ca2 <chThdSuspendTimeoutS+0x12>
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8001c98:	6003      	str	r3, [r0, #0]
  tp->p_u.wttrp = trp;

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8001c9a:	2003      	movs	r0, #3
  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
  tp->p_u.wttrp = trp;
 8001c9c:	615a      	str	r2, [r3, #20]

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8001c9e:	f7ff be07 	b.w	80018b0 <chSchGoSleepTimeoutS>
}
 8001ca2:	f04f 30ff 	mov.w	r0, #4294967295
 8001ca6:	4770      	bx	lr
 8001ca8:	20001160 	.word	0x20001160
 8001cac:	00000000 	.word	0x00000000

08001cb0 <chThdResumeI>:
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8001cb0:	6803      	ldr	r3, [r0, #0]
 8001cb2:	b12b      	cbz	r3, 8001cc0 <chThdResumeI+0x10>
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8001cb4:	2200      	movs	r2, #0
 8001cb6:	6002      	str	r2, [r0, #0]
    tp->p_u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8001cb8:	4618      	mov	r0, r3

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 8001cba:	6159      	str	r1, [r3, #20]
    (void) chSchReadyI(tp);
 8001cbc:	f7ff bdc8 	b.w	8001850 <chSchReadyI>
 8001cc0:	4770      	bx	lr
 8001cc2:	bf00      	nop
	...

08001cd0 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 8001cd0:	b169      	cbz	r1, 8001cee <chThdEnqueueTimeoutS+0x1e>
 8001cd2:	4602      	mov	r2, r0
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8001cd4:	4b07      	ldr	r3, [pc, #28]	; (8001cf4 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8001cd6:	b410      	push	{r4}

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8001cd8:	691b      	ldr	r3, [r3, #16]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8001cda:	6844      	ldr	r4, [r0, #4]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001cdc:	2004      	movs	r0, #4
 8001cde:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->p_prev->p_next = tp;
 8001ce2:	6023      	str	r3, [r4, #0]
  tqp->p_prev = tp;
 8001ce4:	6053      	str	r3, [r2, #4]
}
 8001ce6:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001cea:	f7ff bde1 	b.w	80018b0 <chSchGoSleepTimeoutS>
}
 8001cee:	f04f 30ff 	mov.w	r0, #4294967295
 8001cf2:	4770      	bx	lr
 8001cf4:	20001160 	.word	0x20001160
	...

08001d00 <chThdDequeueNextI>:
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8001d00:	6802      	ldr	r2, [r0, #0]
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8001d02:	4603      	mov	r3, r0

  if (queue_notempty(tqp)) {
 8001d04:	4290      	cmp	r0, r2
 8001d06:	d009      	beq.n	8001d1c <chThdDequeueNextI+0x1c>
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8001d08:	b410      	push	{r4}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8001d0a:	6814      	ldr	r4, [r2, #0]
  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
  (void) chSchReadyI(tp);
 8001d0c:	4610      	mov	r0, r2
 8001d0e:	601c      	str	r4, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001d10:	6063      	str	r3, [r4, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8001d12:	6151      	str	r1, [r2, #20]

  if (queue_notempty(tqp)) {
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8001d14:	f85d 4b04 	ldr.w	r4, [sp], #4
  (void) chSchReadyI(tp);
 8001d18:	f7ff bd9a 	b.w	8001850 <chSchReadyI>
 8001d1c:	4770      	bx	lr
 8001d1e:	bf00      	nop

08001d20 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8001d20:	b538      	push	{r3, r4, r5, lr}
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8001d22:	6803      	ldr	r3, [r0, #0]
 8001d24:	4604      	mov	r4, r0

  while (queue_notempty(tqp)) {
 8001d26:	4298      	cmp	r0, r3
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8001d28:	460d      	mov	r5, r1

  while (queue_notempty(tqp)) {
 8001d2a:	d009      	beq.n	8001d40 <chThdDequeueAllI+0x20>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8001d2c:	681a      	ldr	r2, [r3, #0]
 8001d2e:	4618      	mov	r0, r3
 8001d30:	6022      	str	r2, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001d32:	6054      	str	r4, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8001d34:	615d      	str	r5, [r3, #20]
  (void) chSchReadyI(tp);
 8001d36:	f7ff fd8b 	bl	8001850 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8001d3a:	6823      	ldr	r3, [r4, #0]
 8001d3c:	429c      	cmp	r4, r3
 8001d3e:	d1f5      	bne.n	8001d2c <chThdDequeueAllI+0xc>
 8001d40:	bd38      	pop	{r3, r4, r5, pc}
 8001d42:	bf00      	nop
	...

08001d50 <chTMStartMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8001d50:	4b01      	ldr	r3, [pc, #4]	; (8001d58 <chTMStartMeasurementX+0x8>)
 8001d52:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8001d54:	6083      	str	r3, [r0, #8]
 8001d56:	4770      	bx	lr
 8001d58:	e0001000 	.word	0xe0001000
 8001d5c:	00000000 	.word	0x00000000

08001d60 <chTMStopMeasurementX>:
 8001d60:	4b0e      	ldr	r3, [pc, #56]	; (8001d9c <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8001d62:	490f      	ldr	r1, [pc, #60]	; (8001da0 <chTMStopMeasurementX+0x40>)
 8001d64:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8001d66:	6883      	ldr	r3, [r0, #8]
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8001d68:	6dc9      	ldr	r1, [r1, #92]	; 0x5c
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8001d6a:	1ad3      	subs	r3, r2, r3

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8001d6c:	68c2      	ldr	r2, [r0, #12]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8001d6e:	b430      	push	{r4, r5}
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8001d70:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8001d74:	1a5b      	subs	r3, r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8001d76:	3201      	adds	r2, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 8001d78:	6841      	ldr	r1, [r0, #4]
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8001d7a:	18e4      	adds	r4, r4, r3

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8001d7c:	60c2      	str	r2, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
 8001d7e:	6802      	ldr	r2, [r0, #0]
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8001d80:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 8001d84:	428b      	cmp	r3, r1
    tmp->worst = tmp->last;
 8001d86:	bf88      	it	hi
 8001d88:	6043      	strhi	r3, [r0, #4]
  }
  if (tmp->last < tmp->best) {
 8001d8a:	4293      	cmp	r3, r2
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8001d8c:	e9c0 4504 	strd	r4, r5, [r0, #16]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 8001d90:	bc30      	pop	{r4, r5}
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8001d92:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
    tmp->best = tmp->last;
 8001d94:	bf38      	it	cc
 8001d96:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 8001d98:	4770      	bx	lr
 8001d9a:	bf00      	nop
 8001d9c:	e0001000 	.word	0xe0001000
 8001da0:	20001160 	.word	0x20001160
	...

08001db0 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8001db0:	b5d0      	push	{r4, r6, r7, lr}
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8001db2:	4c0c      	ldr	r4, [pc, #48]	; (8001de4 <_tm_init+0x34>)
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8001db4:	b086      	sub	sp, #24
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8001db6:	2300      	movs	r3, #0
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8001db8:	f04f 32ff 	mov.w	r2, #4294967295
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8001dbc:	4668      	mov	r0, sp

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8001dbe:	2600      	movs	r6, #0
 8001dc0:	2700      	movs	r7, #0
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8001dc2:	65e3      	str	r3, [r4, #92]	; 0x5c
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 8001dc4:	9301      	str	r3, [sp, #4]
  tmp->last       = (rtcnt_t)0;
 8001dc6:	9302      	str	r3, [sp, #8]
  tmp->n          = (ucnt_t)0;
 8001dc8:	9303      	str	r3, [sp, #12]
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8001dca:	9200      	str	r2, [sp, #0]
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8001dcc:	e9cd 6704 	strd	r6, r7, [sp, #16]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8001dd0:	f7ff ffbe 	bl	8001d50 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 8001dd4:	4668      	mov	r0, sp
 8001dd6:	f7ff ffc3 	bl	8001d60 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 8001dda:	9b02      	ldr	r3, [sp, #8]
 8001ddc:	65e3      	str	r3, [r4, #92]	; 0x5c
}
 8001dde:	b006      	add	sp, #24
 8001de0:	bdd0      	pop	{r4, r6, r7, pc}
 8001de2:	bf00      	nop
 8001de4:	20001160 	.word	0x20001160
	...

08001df0 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8001df0:	4601      	mov	r1, r0
 8001df2:	2320      	movs	r3, #32
 8001df4:	f383 8811 	msr	BASEPRI, r3
  trefs_t refs;

  chSysLock();
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
  tp->p_refs--;
 8001df8:	7c83      	ldrb	r3, [r0, #18]
 8001dfa:	3b01      	subs	r3, #1
 8001dfc:	b2db      	uxtb	r3, r3
 8001dfe:	7483      	strb	r3, [r0, #18]
  refs = tp->p_refs;

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
 8001e00:	b913      	cbnz	r3, 8001e08 <chThdRelease+0x18>
 8001e02:	7c02      	ldrb	r2, [r0, #16]
 8001e04:	2a0f      	cmp	r2, #15
 8001e06:	d003      	beq.n	8001e10 <chThdRelease+0x20>
 8001e08:	2300      	movs	r3, #0
 8001e0a:	f383 8811 	msr	BASEPRI, r3
 8001e0e:	4770      	bx	lr
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
 8001e10:	7c42      	ldrb	r2, [r0, #17]
 8001e12:	f002 0203 	and.w	r2, r2, #3
 8001e16:	2a01      	cmp	r2, #1
 8001e18:	d006      	beq.n	8001e28 <chThdRelease+0x38>
 8001e1a:	2a02      	cmp	r2, #2
 8001e1c:	d1f4      	bne.n	8001e08 <chThdRelease+0x18>
 8001e1e:	f383 8811 	msr	BASEPRI, r3
    case CH_FLAG_MODE_MPOOL:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
#endif
      chSysUnlock();
      chPoolFree(tp->p_mpool, tp);
 8001e22:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8001e24:	f001 b914 	b.w	8003050 <chPoolFree>
 8001e28:	f383 8811 	msr	BASEPRI, r3
    case CH_FLAG_MODE_HEAP:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
#endif
      chSysUnlock();
      chHeapFree(tp);
 8001e2c:	f001 b868 	b.w	8002f00 <chHeapFree>

08001e30 <chThdCreateFromHeap>:
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
                              tprio_t prio, tfunc_t pf, void *arg) {
 8001e30:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001e32:	b083      	sub	sp, #12
 8001e34:	4616      	mov	r6, r2
 8001e36:	461d      	mov	r5, r3
 8001e38:	460f      	mov	r7, r1
  void *wsp;
  thread_t *tp;

  wsp = chHeapAlloc(heapp, size);
 8001e3a:	f001 f819 	bl	8002e70 <chHeapAlloc>
  if (wsp == NULL) {
 8001e3e:	b198      	cbz	r0, 8001e68 <chThdCreateFromHeap+0x38>
 8001e40:	2320      	movs	r3, #32
 8001e42:	f383 8811 	msr	BASEPRI, r3
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8001e46:	9b08      	ldr	r3, [sp, #32]
 8001e48:	4639      	mov	r1, r7
 8001e4a:	9300      	str	r3, [sp, #0]
 8001e4c:	4632      	mov	r2, r6
 8001e4e:	462b      	mov	r3, r5
 8001e50:	f7ff fe06 	bl	8001a60 <chThdCreateI>
  tp->p_flags = CH_FLAG_MODE_HEAP;
 8001e54:	2301      	movs	r3, #1
 8001e56:	7443      	strb	r3, [r0, #17]
  chSchWakeupS(tp, MSG_OK);
 8001e58:	2100      	movs	r1, #0
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8001e5a:	4604      	mov	r4, r0
  tp->p_flags = CH_FLAG_MODE_HEAP;
  chSchWakeupS(tp, MSG_OK);
 8001e5c:	f7ff fd50 	bl	8001900 <chSchWakeupS>
 8001e60:	2300      	movs	r3, #0
 8001e62:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
 8001e66:	4620      	mov	r0, r4
}
 8001e68:	b003      	add	sp, #12
 8001e6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001e6c:	0000      	movs	r0, r0
	...

08001e70 <chThdCreateFromMemoryPool>:
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
                                    tfunc_t pf, void *arg) {
 8001e70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001e74:	b082      	sub	sp, #8
 8001e76:	460f      	mov	r7, r1
 8001e78:	4616      	mov	r6, r2
 8001e7a:	4698      	mov	r8, r3
 8001e7c:	4605      	mov	r5, r0
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 8001e7e:	f001 f8cf 	bl	8003020 <chPoolAlloc>
  if (wsp == NULL) {
 8001e82:	b1a0      	cbz	r0, 8001eae <chThdCreateFromMemoryPool+0x3e>
 8001e84:	2320      	movs	r3, #32
 8001e86:	f383 8811 	msr	BASEPRI, r3
                  (uint8_t *)wsp + mp->mp_object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
 8001e8a:	6869      	ldr	r1, [r5, #4]
 8001e8c:	463a      	mov	r2, r7
 8001e8e:	4633      	mov	r3, r6
 8001e90:	f8cd 8000 	str.w	r8, [sp]
 8001e94:	f7ff fde4 	bl	8001a60 <chThdCreateI>
  tp->p_flags = CH_FLAG_MODE_MPOOL;
 8001e98:	2302      	movs	r3, #2
 8001e9a:	7443      	strb	r3, [r0, #17]
  tp->p_mpool = mp;
 8001e9c:	6345      	str	r5, [r0, #52]	; 0x34
  chSchWakeupS(tp, MSG_OK);
 8001e9e:	2100      	movs	r1, #0
                  (uint8_t *)wsp + mp->mp_object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
 8001ea0:	4604      	mov	r4, r0
  tp->p_flags = CH_FLAG_MODE_MPOOL;
  tp->p_mpool = mp;
  chSchWakeupS(tp, MSG_OK);
 8001ea2:	f7ff fd2d 	bl	8001900 <chSchWakeupS>
 8001ea6:	2300      	movs	r3, #0
 8001ea8:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
 8001eac:	4620      	mov	r0, r4
}
 8001eae:	b002      	add	sp, #8
 8001eb0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08001ec0 <chSemObjectInit>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001ec0:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 8001ec2:	6040      	str	r0, [r0, #4]
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->s_queue);
  sp->s_cnt = n;
 8001ec4:	6081      	str	r1, [r0, #8]
 8001ec6:	4770      	bx	lr
	...

08001ed0 <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 8001ed0:	b570      	push	{r4, r5, r6, lr}
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
 8001ed2:	6885      	ldr	r5, [r0, #8]
  sp->s_cnt = n;
 8001ed4:	6081      	str	r1, [r0, #8]
  while (++cnt <= (cnt_t)0) {
 8001ed6:	3501      	adds	r5, #1
 8001ed8:	2d00      	cmp	r5, #0
 8001eda:	dc0c      	bgt.n	8001ef6 <chSemResetI+0x26>
 8001edc:	4604      	mov	r4, r0
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 8001ede:	f06f 0601 	mvn.w	r6, #1

  return tp;
}

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_prev;
 8001ee2:	6860      	ldr	r0, [r4, #4]
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 8001ee4:	3501      	adds	r5, #1

  tqp->p_prev = tp->p_prev;
 8001ee6:	6843      	ldr	r3, [r0, #4]
 8001ee8:	6063      	str	r3, [r4, #4]
  tqp->p_prev->p_next = (thread_t *)tqp;
 8001eea:	601c      	str	r4, [r3, #0]
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 8001eec:	f7ff fcb0 	bl	8001850 <chSchReadyI>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 8001ef0:	2d01      	cmp	r5, #1
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 8001ef2:	6146      	str	r6, [r0, #20]
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 8001ef4:	d1f5      	bne.n	8001ee2 <chSemResetI+0x12>
 8001ef6:	bd70      	pop	{r4, r5, r6, pc}
	...

08001f00 <chSemReset>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {
 8001f00:	b508      	push	{r3, lr}
 8001f02:	2320      	movs	r3, #32
 8001f04:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chSemResetI(sp, n);
 8001f08:	f7ff ffe2 	bl	8001ed0 <chSemResetI>
  chSchRescheduleS();
 8001f0c:	f7ff fd78 	bl	8001a00 <chSchRescheduleS>
 8001f10:	2300      	movs	r3, #0
 8001f12:	f383 8811 	msr	BASEPRI, r3
 8001f16:	bd08      	pop	{r3, pc}
	...

08001f20 <chSemWait>:
 8001f20:	2320      	movs	r3, #32
 8001f22:	f383 8811 	msr	BASEPRI, r3
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 8001f26:	6883      	ldr	r3, [r0, #8]
 8001f28:	3b01      	subs	r3, #1
 8001f2a:	2b00      	cmp	r3, #0
 8001f2c:	6083      	str	r3, [r0, #8]
 8001f2e:	db04      	blt.n	8001f3a <chSemWait+0x1a>
    chSchGoSleepS(CH_STATE_WTSEM);

    return currp->p_u.rdymsg;
  }

  return MSG_OK;
 8001f30:	2000      	movs	r0, #0
 8001f32:	2300      	movs	r3, #0
 8001f34:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  msg = chSemWaitS(sp);
  chSysUnlock();

  return msg;
}
 8001f38:	4770      	bx	lr
 8001f3a:	4603      	mov	r3, r0
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(semaphore_t *sp) {
 8001f3c:	b510      	push	{r4, lr}
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    currp->p_u.wtsemp = sp;
 8001f3e:	4c08      	ldr	r4, [pc, #32]	; (8001f60 <chSemWait+0x40>)
    sem_insert(currp, &sp->s_queue);
    chSchGoSleepS(CH_STATE_WTSEM);
 8001f40:	2005      	movs	r0, #5
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    currp->p_u.wtsemp = sp;
 8001f42:	6922      	ldr	r2, [r4, #16]
 8001f44:	6153      	str	r3, [r2, #20]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8001f46:	6859      	ldr	r1, [r3, #4]
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 8001f48:	6013      	str	r3, [r2, #0]
  tp->p_prev = tqp->p_prev;
 8001f4a:	6051      	str	r1, [r2, #4]
  tp->p_prev->p_next = tp;
 8001f4c:	600a      	str	r2, [r1, #0]
  tqp->p_prev = tp;
 8001f4e:	605a      	str	r2, [r3, #4]
    sem_insert(currp, &sp->s_queue);
    chSchGoSleepS(CH_STATE_WTSEM);
 8001f50:	f7ff fc96 	bl	8001880 <chSchGoSleepS>

    return currp->p_u.rdymsg;
 8001f54:	6923      	ldr	r3, [r4, #16]
 8001f56:	6958      	ldr	r0, [r3, #20]
 8001f58:	2300      	movs	r3, #0
 8001f5a:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  msg = chSemWaitS(sp);
  chSysUnlock();

  return msg;
}
 8001f5e:	bd10      	pop	{r4, pc}
 8001f60:	20001160 	.word	0x20001160
	...

08001f70 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8001f70:	4603      	mov	r3, r0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 8001f72:	6880      	ldr	r0, [r0, #8]
 8001f74:	1e42      	subs	r2, r0, #1
 8001f76:	2a00      	cmp	r2, #0
 8001f78:	609a      	str	r2, [r3, #8]
 8001f7a:	db01      	blt.n	8001f80 <chSemWaitTimeoutS+0x10>
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
 8001f7c:	2000      	movs	r0, #0
 8001f7e:	4770      	bx	lr
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8001f80:	b410      	push	{r4}
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
 8001f82:	b161      	cbz	r1, 8001f9e <chSemWaitTimeoutS+0x2e>
      sp->s_cnt++;

      return MSG_TIMEOUT;
    }
    currp->p_u.wtsemp = sp;
 8001f84:	4a09      	ldr	r2, [pc, #36]	; (8001fac <chSemWaitTimeoutS+0x3c>)
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 8001f86:	2005      	movs	r0, #5
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;

      return MSG_TIMEOUT;
    }
    currp->p_u.wtsemp = sp;
 8001f88:	6912      	ldr	r2, [r2, #16]
 8001f8a:	6153      	str	r3, [r2, #20]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8001f8c:	685c      	ldr	r4, [r3, #4]
 8001f8e:	e882 0018 	stmia.w	r2, {r3, r4}
  tp->p_prev->p_next = tp;
 8001f92:	6022      	str	r2, [r4, #0]
  tqp->p_prev = tp;
 8001f94:	605a      	str	r2, [r3, #4]

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
}
 8001f96:	f85d 4b04 	ldr.w	r4, [sp], #4
      return MSG_TIMEOUT;
    }
    currp->p_u.wtsemp = sp;
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 8001f9a:	f7ff bc89 	b.w	80018b0 <chSchGoSleepTimeoutS>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;
 8001f9e:	6098      	str	r0, [r3, #8]

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
}
 8001fa0:	f85d 4b04 	ldr.w	r4, [sp], #4

  if (--sp->s_cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;

      return MSG_TIMEOUT;
 8001fa4:	f04f 30ff 	mov.w	r0, #4294967295

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
}
 8001fa8:	4770      	bx	lr
 8001faa:	bf00      	nop
 8001fac:	20001160 	.word	0x20001160

08001fb0 <chSemWaitTimeout>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t time) {
 8001fb0:	b508      	push	{r3, lr}
 8001fb2:	2320      	movs	r3, #32
 8001fb4:	f383 8811 	msr	BASEPRI, r3
  msg_t msg;

  chSysLock();
  msg = chSemWaitTimeoutS(sp, time);
 8001fb8:	f7ff ffda 	bl	8001f70 <chSemWaitTimeoutS>
 8001fbc:	2300      	movs	r3, #0
 8001fbe:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return msg;
}
 8001fc2:	bd08      	pop	{r3, pc}
	...

08001fd0 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
 8001fd0:	b508      	push	{r3, lr}
 8001fd2:	2320      	movs	r3, #32
 8001fd4:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sp->s_cnt <= (cnt_t)0) {
 8001fd8:	6883      	ldr	r3, [r0, #8]
 8001fda:	3301      	adds	r3, #1
 8001fdc:	2b00      	cmp	r3, #0
 8001fde:	6083      	str	r3, [r0, #8]
 8001fe0:	dd03      	ble.n	8001fea <chSemSignal+0x1a>
 8001fe2:	2300      	movs	r3, #0
 8001fe4:	f383 8811 	msr	BASEPRI, r3
 8001fe8:	bd08      	pop	{r3, pc}
 8001fea:	4603      	mov	r3, r0
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8001fec:	6800      	ldr	r0, [r0, #0]
    chSchWakeupS(queue_fifo_remove(&sp->s_queue), MSG_OK);
 8001fee:	2100      	movs	r1, #0

  tqp->p_next = tp->p_next;
 8001ff0:	6802      	ldr	r2, [r0, #0]
 8001ff2:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001ff4:	6053      	str	r3, [r2, #4]
 8001ff6:	f7ff fc83 	bl	8001900 <chSchWakeupS>
 8001ffa:	2300      	movs	r3, #0
 8001ffc:	f383 8811 	msr	BASEPRI, r3
 8002000:	bd08      	pop	{r3, pc}
 8002002:	bf00      	nop
	...

08002010 <chSemSignalI>:
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= (cnt_t)0) {
 8002010:	6883      	ldr	r3, [r0, #8]
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
 8002012:	4602      	mov	r2, r0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= (cnt_t)0) {
 8002014:	3301      	adds	r3, #1
 8002016:	2b00      	cmp	r3, #0
 8002018:	6083      	str	r3, [r0, #8]
 800201a:	dd00      	ble.n	800201e <chSemSignalI+0xe>
 800201c:	4770      	bx	lr
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 800201e:	6803      	ldr	r3, [r0, #0]
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
 8002020:	b410      	push	{r4}

  tqp->p_next = tp->p_next;
 8002022:	6819      	ldr	r1, [r3, #0]

  if (++sp->s_cnt <= (cnt_t)0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = MSG_OK;
 8002024:	2400      	movs	r4, #0
 8002026:	6011      	str	r1, [r2, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8002028:	604a      	str	r2, [r1, #4]
 800202a:	615c      	str	r4, [r3, #20]
    (void) chSchReadyI(tp);
 800202c:	4618      	mov	r0, r3
  }
}
 800202e:	f85d 4b04 	ldr.w	r4, [sp], #4
  if (++sp->s_cnt <= (cnt_t)0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
 8002032:	f7ff bc0d 	b.w	8001850 <chSchReadyI>
 8002036:	bf00      	nop
	...

08002040 <chSemAddCounterI>:
 * @param[in] n         value to be added to the semaphore counter. The value
 *                      must be positive.
 *
 * @iclass
 */
void chSemAddCounterI(semaphore_t *sp, cnt_t n) {
 8002040:	b570      	push	{r4, r5, r6, lr}
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8002042:	1e0c      	subs	r4, r1, #0
 8002044:	dd12      	ble.n	800206c <chSemAddCounterI+0x2c>
 8002046:	4605      	mov	r5, r0
    if (++sp->s_cnt <= (cnt_t)0) {
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 8002048:	2600      	movs	r6, #0
 800204a:	e001      	b.n	8002050 <chSemAddCounterI+0x10>
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 800204c:	3c01      	subs	r4, #1
 800204e:	d00d      	beq.n	800206c <chSemAddCounterI+0x2c>
    if (++sp->s_cnt <= (cnt_t)0) {
 8002050:	68ab      	ldr	r3, [r5, #8]
 8002052:	3301      	adds	r3, #1
 8002054:	2b00      	cmp	r3, #0
 8002056:	60ab      	str	r3, [r5, #8]
 8002058:	dcf8      	bgt.n	800204c <chSemAddCounterI+0xc>
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 800205a:	6828      	ldr	r0, [r5, #0]

  tqp->p_next = tp->p_next;
 800205c:	6803      	ldr	r3, [r0, #0]
 800205e:	602b      	str	r3, [r5, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8002060:	605d      	str	r5, [r3, #4]
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 8002062:	f7ff fbf5 	bl	8001850 <chSchReadyI>
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8002066:	3c01      	subs	r4, #1
    if (++sp->s_cnt <= (cnt_t)0) {
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 8002068:	6146      	str	r6, [r0, #20]
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 800206a:	d1f1      	bne.n	8002050 <chSemAddCounterI+0x10>
 800206c:	bd70      	pop	{r4, r5, r6, pc}
 800206e:	bf00      	nop

08002070 <chSemSignalWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 8002070:	b510      	push	{r4, lr}
 8002072:	4602      	mov	r2, r0
 8002074:	b082      	sub	sp, #8
 8002076:	2320      	movs	r3, #32
 8002078:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(((spw->s_cnt >= (cnt_t)0) && queue_isempty(&spw->s_queue)) ||
              ((spw->s_cnt < (cnt_t)0) && queue_notempty(&spw->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sps->s_cnt <= (cnt_t)0) {
 800207c:	6883      	ldr	r3, [r0, #8]
 800207e:	3301      	adds	r3, #1
 8002080:	2b00      	cmp	r3, #0
 8002082:	6083      	str	r3, [r0, #8]
 8002084:	dd1d      	ble.n	80020c2 <chSemSignalWait+0x52>
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
  }
  if (--spw->s_cnt < (cnt_t)0) {
 8002086:	688b      	ldr	r3, [r1, #8]
 8002088:	3b01      	subs	r3, #1
 800208a:	2b00      	cmp	r3, #0
 800208c:	608b      	str	r3, [r1, #8]
 800208e:	db07      	blt.n	80020a0 <chSemSignalWait+0x30>
    ctp->p_u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
    msg = ctp->p_u.rdymsg;
  }
  else {
    chSchRescheduleS();
 8002090:	f7ff fcb6 	bl	8001a00 <chSchRescheduleS>
    msg = MSG_OK;
 8002094:	2000      	movs	r0, #0
 8002096:	2300      	movs	r3, #0
 8002098:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return msg;
}
 800209c:	b002      	add	sp, #8
 800209e:	bd10      	pop	{r4, pc}
  chSysLock();
  if (++sps->s_cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
  }
  if (--spw->s_cnt < (cnt_t)0) {
    thread_t *ctp = currp;
 80020a0:	4a0d      	ldr	r2, [pc, #52]	; (80020d8 <chSemSignalWait+0x68>)
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 80020a2:	684b      	ldr	r3, [r1, #4]
 80020a4:	6914      	ldr	r4, [r2, #16]
    sem_insert(ctp, &spw->s_queue);
    ctp->p_u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
 80020a6:	2005      	movs	r0, #5
 80020a8:	e884 000a 	stmia.w	r4, {r1, r3}
  tp->p_prev->p_next = tp;
 80020ac:	601c      	str	r4, [r3, #0]
  tqp->p_prev = tp;
 80020ae:	604c      	str	r4, [r1, #4]
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
  }
  if (--spw->s_cnt < (cnt_t)0) {
    thread_t *ctp = currp;
    sem_insert(ctp, &spw->s_queue);
    ctp->p_u.wtsemp = spw;
 80020b0:	6161      	str	r1, [r4, #20]
    chSchGoSleepS(CH_STATE_WTSEM);
 80020b2:	f7ff fbe5 	bl	8001880 <chSchGoSleepS>
    msg = ctp->p_u.rdymsg;
 80020b6:	6960      	ldr	r0, [r4, #20]
 80020b8:	2300      	movs	r3, #0
 80020ba:	f383 8811 	msr	BASEPRI, r3
    msg = MSG_OK;
  }
  chSysUnlock();

  return msg;
}
 80020be:	b002      	add	sp, #8
 80020c0:	bd10      	pop	{r4, pc}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80020c2:	6800      	ldr	r0, [r0, #0]
 80020c4:	9101      	str	r1, [sp, #4]

  tqp->p_next = tp->p_next;
 80020c6:	6803      	ldr	r3, [r0, #0]
 80020c8:	6013      	str	r3, [r2, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80020ca:	605a      	str	r2, [r3, #4]
              ((spw->s_cnt < (cnt_t)0) && queue_notempty(&spw->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sps->s_cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
 80020cc:	f7ff fbc0 	bl	8001850 <chSchReadyI>
 80020d0:	2300      	movs	r3, #0
 80020d2:	6143      	str	r3, [r0, #20]
 80020d4:	9901      	ldr	r1, [sp, #4]
 80020d6:	e7d6      	b.n	8002086 <chSemSignalWait+0x16>
 80020d8:	20001160 	.word	0x20001160
 80020dc:	00000000 	.word	0x00000000

080020e0 <chMtxObjectInit>:
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 80020e0:	2300      	movs	r3, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80020e2:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 80020e4:	6040      	str	r0, [r0, #4]
 80020e6:	6083      	str	r3, [r0, #8]
 80020e8:	4770      	bx	lr
 80020ea:	bf00      	nop
 80020ec:	0000      	movs	r0, r0
	...

080020f0 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 80020f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 80020f2:	6882      	ldr	r2, [r0, #8]
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 80020f4:	4b2f      	ldr	r3, [pc, #188]	; (80021b4 <chMtxLockS+0xc4>)
 80020f6:	691c      	ldr	r4, [r3, #16]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 80020f8:	2a00      	cmp	r2, #0
 80020fa:	d055      	beq.n	80021a8 <chMtxLockS+0xb8>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 80020fc:	68a1      	ldr	r1, [r4, #8]
 80020fe:	6893      	ldr	r3, [r2, #8]
 8002100:	4605      	mov	r5, r0
 8002102:	4299      	cmp	r1, r3
 8002104:	d906      	bls.n	8002114 <chMtxLockS+0x24>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8002106:	7c13      	ldrb	r3, [r2, #16]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 8002108:	6091      	str	r1, [r2, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 800210a:	2b06      	cmp	r3, #6
 800210c:	d033      	beq.n	8002176 <chMtxLockS+0x86>
 800210e:	2b07      	cmp	r3, #7
 8002110:	d01d      	beq.n	800214e <chMtxLockS+0x5e>
 8002112:	b19b      	cbz	r3, 800213c <chMtxLockS+0x4c>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8002114:	462b      	mov	r3, r5
 8002116:	e003      	b.n	8002120 <chMtxLockS+0x30>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8002118:	6899      	ldr	r1, [r3, #8]
 800211a:	68a2      	ldr	r2, [r4, #8]
 800211c:	4291      	cmp	r1, r2
 800211e:	d302      	bcc.n	8002126 <chMtxLockS+0x36>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8002120:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8002122:	429d      	cmp	r5, r3
 8002124:	d1f8      	bne.n	8002118 <chMtxLockS+0x28>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8002126:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8002128:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 800212a:	6062      	str	r2, [r4, #4]
  tp->p_prev->p_next = tp;
 800212c:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 800212e:	605c      	str	r4, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
 8002130:	6165      	str	r5, [r4, #20]
      chSchGoSleepS(CH_STATE_WTMTX);
 8002132:	2006      	movs	r0, #6
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
  }
}
 8002134:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8002138:	f7ff bba2 	b.w	8001880 <chSchGoSleepS>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 800213c:	e892 000a 	ldmia.w	r2, {r1, r3}
 8002140:	6019      	str	r1, [r3, #0]
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8002142:	4610      	mov	r0, r2
  tp->p_next->p_prev = tp->p_prev;
 8002144:	6812      	ldr	r2, [r2, #0]
 8002146:	6053      	str	r3, [r2, #4]
 8002148:	f7ff fb82 	bl	8001850 <chSchReadyI>
          break;
 800214c:	e7e2      	b.n	8002114 <chMtxLockS+0x24>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 800214e:	6817      	ldr	r7, [r2, #0]
 8002150:	6850      	ldr	r0, [r2, #4]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8002152:	6956      	ldr	r6, [r2, #20]
 8002154:	6007      	str	r7, [r0, #0]
  tp->p_next->p_prev = tp->p_prev;
 8002156:	6817      	ldr	r7, [r2, #0]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8002158:	4633      	mov	r3, r6
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
  tp->p_next->p_prev = tp->p_prev;
 800215a:	6078      	str	r0, [r7, #4]
 800215c:	e002      	b.n	8002164 <chMtxLockS+0x74>
static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800215e:	6898      	ldr	r0, [r3, #8]
 8002160:	4288      	cmp	r0, r1
 8002162:	d302      	bcc.n	800216a <chMtxLockS+0x7a>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8002164:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8002166:	429e      	cmp	r6, r3
 8002168:	d1f9      	bne.n	800215e <chMtxLockS+0x6e>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800216a:	6859      	ldr	r1, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 800216c:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
 800216e:	6051      	str	r1, [r2, #4]
  tp->p_prev->p_next = tp;
 8002170:	600a      	str	r2, [r1, #0]
  cp->p_prev = tp;
 8002172:	605a      	str	r2, [r3, #4]
 8002174:	e7ce      	b.n	8002114 <chMtxLockS+0x24>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8002176:	6817      	ldr	r7, [r2, #0]
 8002178:	6850      	ldr	r0, [r2, #4]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 800217a:	6956      	ldr	r6, [r2, #20]
 800217c:	6007      	str	r7, [r0, #0]
  tp->p_next->p_prev = tp->p_prev;
 800217e:	6817      	ldr	r7, [r2, #0]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8002180:	4633      	mov	r3, r6
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
  tp->p_next->p_prev = tp->p_prev;
 8002182:	6078      	str	r0, [r7, #4]
 8002184:	e002      	b.n	800218c <chMtxLockS+0x9c>
static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8002186:	6898      	ldr	r0, [r3, #8]
 8002188:	4288      	cmp	r0, r1
 800218a:	d302      	bcc.n	8002192 <chMtxLockS+0xa2>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 800218c:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800218e:	429e      	cmp	r6, r3
 8002190:	d1f9      	bne.n	8002186 <chMtxLockS+0x96>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8002192:	6859      	ldr	r1, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8002194:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
 8002196:	6051      	str	r1, [r2, #4]
  tp->p_prev->p_next = tp;
 8002198:	600a      	str	r2, [r1, #0]
  cp->p_prev = tp;
 800219a:	605a      	str	r2, [r3, #4]
          tp = tp->p_u.wtmtxp->m_owner;
 800219c:	68b2      	ldr	r2, [r6, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 800219e:	68a1      	ldr	r1, [r4, #8]
 80021a0:	6893      	ldr	r3, [r2, #8]
 80021a2:	428b      	cmp	r3, r1
 80021a4:	d3af      	bcc.n	8002106 <chMtxLockS+0x16>
 80021a6:	e7b5      	b.n	8002114 <chMtxLockS+0x24>

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
 80021a8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 80021aa:	6084      	str	r4, [r0, #8]
    mp->m_next = ctp->p_mtxlist;
 80021ac:	60c3      	str	r3, [r0, #12]
    ctp->p_mtxlist = mp;
 80021ae:	62e0      	str	r0, [r4, #44]	; 0x2c
 80021b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80021b2:	bf00      	nop
 80021b4:	20001160 	.word	0x20001160
	...

080021c0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 80021c0:	b508      	push	{r3, lr}
 80021c2:	2320      	movs	r3, #32
 80021c4:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chMtxLockS(mp);
 80021c8:	f7ff ff92 	bl	80020f0 <chMtxLockS>
 80021cc:	2300      	movs	r3, #0
 80021ce:	f383 8811 	msr	BASEPRI, r3
 80021d2:	bd08      	pop	{r3, pc}
	...

080021e0 <chMtxTryLock>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @api
 */
bool chMtxTryLock(mutex_t *mp) {
 80021e0:	4603      	mov	r3, r0
 80021e2:	2220      	movs	r2, #32
 80021e4:	f382 8811 	msr	BASEPRI, r2
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->m_owner != NULL) {
 80021e8:	6882      	ldr	r2, [r0, #8]
    if (mp->m_owner == currp) {
      mp->m_cnt++;
      return true;
    }
#endif
    return false;
 80021ea:	2000      	movs	r0, #0
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->m_owner != NULL) {
 80021ec:	b11a      	cbz	r2, 80021f6 <chMtxTryLock+0x16>
 80021ee:	2300      	movs	r3, #0
 80021f0:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  b = chMtxTryLockS(mp);
  chSysUnlock();

  return b;
}
 80021f4:	4770      	bx	lr

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 80021f6:	4a05      	ldr	r2, [pc, #20]	; (800220c <chMtxTryLock+0x2c>)
  mp->m_next = currp->p_mtxlist;
  currp->p_mtxlist = mp;
 80021f8:	2001      	movs	r0, #1

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 80021fa:	6912      	ldr	r2, [r2, #16]
  mp->m_next = currp->p_mtxlist;
 80021fc:	6ad1      	ldr	r1, [r2, #44]	; 0x2c

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 80021fe:	609a      	str	r2, [r3, #8]
  mp->m_next = currp->p_mtxlist;
 8002200:	60d9      	str	r1, [r3, #12]
  currp->p_mtxlist = mp;
 8002202:	62d3      	str	r3, [r2, #44]	; 0x2c
 8002204:	2300      	movs	r3, #0
 8002206:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  b = chMtxTryLockS(mp);
  chSysUnlock();

  return b;
}
 800220a:	4770      	bx	lr
 800220c:	20001160 	.word	0x20001160

08002210 <chMtxUnlock>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 8002210:	4b17      	ldr	r3, [pc, #92]	; (8002270 <chMtxUnlock+0x60>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8002212:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8002214:	691d      	ldr	r5, [r3, #16]
 8002216:	2320      	movs	r3, #32
 8002218:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800221c:	6804      	ldr	r4, [r0, #0]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 800221e:	68c3      	ldr	r3, [r0, #12]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8002220:	42a0      	cmp	r0, r4
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 8002222:	62eb      	str	r3, [r5, #44]	; 0x2c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8002224:	d01d      	beq.n	8002262 <chMtxUnlock+0x52>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8002226:	6b29      	ldr	r1, [r5, #48]	; 0x30
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8002228:	b14b      	cbz	r3, 800223e <chMtxUnlock+0x2e>
 800222a:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800222c:	4293      	cmp	r3, r2
 800222e:	d003      	beq.n	8002238 <chMtxUnlock+0x28>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 8002230:	6892      	ldr	r2, [r2, #8]
 8002232:	4291      	cmp	r1, r2
 8002234:	bf38      	it	cc
 8002236:	4611      	movcc	r1, r2
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 8002238:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 800223a:	2b00      	cmp	r3, #0
 800223c:	d1f5      	bne.n	800222a <chMtxUnlock+0x1a>
 800223e:	4603      	mov	r3, r0
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8002240:	6822      	ldr	r2, [r4, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 8002242:	6ae6      	ldr	r6, [r4, #44]	; 0x2c

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8002244:	4620      	mov	r0, r4
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 8002246:	60a9      	str	r1, [r5, #8]
 8002248:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800224a:	6053      	str	r3, [r2, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 800224c:	609c      	str	r4, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 800224e:	60de      	str	r6, [r3, #12]
      tp->p_mtxlist = mp;
 8002250:	62e3      	str	r3, [r4, #44]	; 0x2c

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8002252:	f7ff fafd 	bl	8001850 <chSchReadyI>
      chSchRescheduleS();
 8002256:	f7ff fbd3 	bl	8001a00 <chSchRescheduleS>
 800225a:	2300      	movs	r3, #0
 800225c:	f383 8811 	msr	BASEPRI, r3
 8002260:	bd70      	pop	{r4, r5, r6, pc}
    }
    else {
      mp->m_owner = NULL;
 8002262:	2300      	movs	r3, #0
 8002264:	6083      	str	r3, [r0, #8]
 8002266:	2300      	movs	r3, #0
 8002268:	f383 8811 	msr	BASEPRI, r3
 800226c:	bd70      	pop	{r4, r5, r6, pc}
 800226e:	bf00      	nop
 8002270:	20001160 	.word	0x20001160
	...

08002280 <chMtxUnlockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 8002280:	b430      	push	{r4, r5}
 8002282:	4604      	mov	r4, r0
  thread_t *ctp = currp;
 8002284:	4a11      	ldr	r2, [pc, #68]	; (80022cc <chMtxUnlockS+0x4c>)
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002286:	6825      	ldr	r5, [r4, #0]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 8002288:	68c3      	ldr	r3, [r0, #12]
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
  thread_t *ctp = currp;
 800228a:	6910      	ldr	r0, [r2, #16]
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800228c:	42ac      	cmp	r4, r5
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 800228e:	62c3      	str	r3, [r0, #44]	; 0x2c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8002290:	d017      	beq.n	80022c2 <chMtxUnlockS+0x42>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8002292:	6b01      	ldr	r1, [r0, #48]	; 0x30
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8002294:	b14b      	cbz	r3, 80022aa <chMtxUnlockS+0x2a>
 8002296:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8002298:	4293      	cmp	r3, r2
 800229a:	d003      	beq.n	80022a4 <chMtxUnlockS+0x24>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 800229c:	6892      	ldr	r2, [r2, #8]
 800229e:	4291      	cmp	r1, r2
 80022a0:	bf38      	it	cc
 80022a2:	4611      	movcc	r1, r2
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 80022a4:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 80022a6:	2b00      	cmp	r3, #0
 80022a8:	d1f5      	bne.n	8002296 <chMtxUnlockS+0x16>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 80022aa:	6aea      	ldr	r2, [r5, #44]	; 0x2c
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80022ac:	682b      	ldr	r3, [r5, #0]
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 80022ae:	6081      	str	r1, [r0, #8]
 80022b0:	6023      	str	r3, [r4, #0]
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
      (void) chSchReadyI(tp);
 80022b2:	4628      	mov	r0, r5
  tqp->p_next->p_prev = (thread_t *)tqp;
 80022b4:	605c      	str	r4, [r3, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 80022b6:	60a5      	str	r5, [r4, #8]
      mp->m_next = tp->p_mtxlist;
 80022b8:	60e2      	str	r2, [r4, #12]
      tp->p_mtxlist = mp;
 80022ba:	62ec      	str	r4, [r5, #44]	; 0x2c
      mp->m_owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 80022bc:	bc30      	pop	{r4, r5}
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
      (void) chSchReadyI(tp);
 80022be:	f7ff bac7 	b.w	8001850 <chSchReadyI>
    }
    else {
      mp->m_owner = NULL;
 80022c2:	2300      	movs	r3, #0
 80022c4:	60a3      	str	r3, [r4, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 80022c6:	bc30      	pop	{r4, r5}
 80022c8:	4770      	bx	lr
 80022ca:	bf00      	nop
 80022cc:	20001160 	.word	0x20001160

080022d0 <chMtxUnlockAll>:
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
  thread_t *ctp = currp;
 80022d0:	4a13      	ldr	r2, [pc, #76]	; (8002320 <chMtxUnlockAll+0x50>)
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
 80022d2:	b570      	push	{r4, r5, r6, lr}
 80022d4:	2320      	movs	r3, #32
  thread_t *ctp = currp;
 80022d6:	6914      	ldr	r4, [r2, #16]
 80022d8:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
 80022dc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80022de:	b1d3      	cbz	r3, 8002316 <chMtxUnlockAll+0x46>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
 80022e0:	2600      	movs	r6, #0
 80022e2:	e00b      	b.n	80022fc <chMtxUnlockAll+0x2c>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
        mp->m_owner = tp;
        mp->m_next = tp->p_mtxlist;
 80022e4:	6ad5      	ldr	r5, [r2, #44]	; 0x2c
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80022e6:	6811      	ldr	r1, [r2, #0]
        tp->p_mtxlist = mp;
        (void) chSchReadyI(tp);
 80022e8:	4610      	mov	r0, r2
 80022ea:	6019      	str	r1, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80022ec:	604b      	str	r3, [r1, #4]
      if (chMtxQueueNotEmptyS(mp)) {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
        mp->m_owner = tp;
 80022ee:	609a      	str	r2, [r3, #8]
        mp->m_next = tp->p_mtxlist;
 80022f0:	60dd      	str	r5, [r3, #12]
        tp->p_mtxlist = mp;
 80022f2:	62d3      	str	r3, [r2, #44]	; 0x2c
        (void) chSchReadyI(tp);
 80022f4:	f7ff faac 	bl	8001850 <chSchReadyI>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
      }
    } while (ctp->p_mtxlist != NULL);
 80022f8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80022fa:	b143      	cbz	r3, 800230e <chMtxUnlockAll+0x3e>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80022fc:	681a      	ldr	r2, [r3, #0]

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
    do {
      mutex_t *mp = ctp->p_mtxlist;
      ctp->p_mtxlist = mp->m_next;
 80022fe:	68d9      	ldr	r1, [r3, #12]
      if (chMtxQueueNotEmptyS(mp)) {
 8002300:	4293      	cmp	r3, r2

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
    do {
      mutex_t *mp = ctp->p_mtxlist;
      ctp->p_mtxlist = mp->m_next;
 8002302:	62e1      	str	r1, [r4, #44]	; 0x2c
      if (chMtxQueueNotEmptyS(mp)) {
 8002304:	d1ee      	bne.n	80022e4 <chMtxUnlockAll+0x14>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
 8002306:	609e      	str	r6, [r3, #8]
      }
    } while (ctp->p_mtxlist != NULL);
 8002308:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800230a:	2b00      	cmp	r3, #0
 800230c:	d1f6      	bne.n	80022fc <chMtxUnlockAll+0x2c>
    ctp->p_prio = ctp->p_realprio;
 800230e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002310:	60a3      	str	r3, [r4, #8]
    chSchRescheduleS();
 8002312:	f7ff fb75 	bl	8001a00 <chSchRescheduleS>
 8002316:	2300      	movs	r3, #0
 8002318:	f383 8811 	msr	BASEPRI, r3
 800231c:	bd70      	pop	{r4, r5, r6, pc}
 800231e:	bf00      	nop
 8002320:	20001160 	.word	0x20001160
	...

08002330 <chCondObjectInit>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002330:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 8002332:	6040      	str	r0, [r0, #4]
 8002334:	4770      	bx	lr
 8002336:	bf00      	nop
	...

08002340 <chCondSignal>:
 8002340:	2320      	movs	r3, #32
 8002342:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002346:	6802      	ldr	r2, [r0, #0]
void chCondSignal(condition_variable_t *cp) {

  chDbgCheck(cp != NULL);

  chSysLock();
  if (queue_notempty(&cp->c_queue)) {
 8002348:	4282      	cmp	r2, r0
 800234a:	d00c      	beq.n	8002366 <chCondSignal+0x26>
 800234c:	4603      	mov	r3, r0
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
 800234e:	b510      	push	{r4, lr}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8002350:	6814      	ldr	r4, [r2, #0]

  chDbgCheck(cp != NULL);

  chSysLock();
  if (queue_notempty(&cp->c_queue)) {
    chSchWakeupS(queue_fifo_remove(&cp->c_queue), MSG_OK);
 8002352:	4610      	mov	r0, r2
 8002354:	601c      	str	r4, [r3, #0]
 8002356:	2100      	movs	r1, #0
  tqp->p_next->p_prev = (thread_t *)tqp;
 8002358:	6063      	str	r3, [r4, #4]
 800235a:	f7ff fad1 	bl	8001900 <chSchWakeupS>
 800235e:	2300      	movs	r3, #0
 8002360:	f383 8811 	msr	BASEPRI, r3
 8002364:	bd10      	pop	{r4, pc}
 8002366:	2300      	movs	r3, #0
 8002368:	f383 8811 	msr	BASEPRI, r3
 800236c:	4770      	bx	lr
 800236e:	bf00      	nop

08002370 <chCondSignalI>:
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002370:	6802      	ldr	r2, [r0, #0]
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
 8002372:	4603      	mov	r3, r0

  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->c_queue)) {
 8002374:	4290      	cmp	r0, r2
 8002376:	d00a      	beq.n	800238e <chCondSignalI+0x1e>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8002378:	6811      	ldr	r1, [r2, #0]
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
 800237a:	b410      	push	{r4}
  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->c_queue)) {
    thread_t *tp = queue_fifo_remove(&cp->c_queue);
    tp->p_u.rdymsg = MSG_OK;
 800237c:	2400      	movs	r4, #0
 800237e:	6001      	str	r1, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8002380:	604b      	str	r3, [r1, #4]
 8002382:	6154      	str	r4, [r2, #20]
    (void) chSchReadyI(tp);
 8002384:	4610      	mov	r0, r2
  }
}
 8002386:	f85d 4b04 	ldr.w	r4, [sp], #4
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->c_queue)) {
    thread_t *tp = queue_fifo_remove(&cp->c_queue);
    tp->p_u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
 800238a:	f7ff ba61 	b.w	8001850 <chSchReadyI>
 800238e:	4770      	bx	lr

08002390 <chCondBroadcastI>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondBroadcastI(condition_variable_t *cp) {
 8002390:	b538      	push	{r3, r4, r5, lr}
 8002392:	4604      	mov	r4, r0
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002394:	6800      	ldr	r0, [r0, #0]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 8002396:	4284      	cmp	r4, r0
 8002398:	d00a      	beq.n	80023b0 <chCondBroadcastI+0x20>
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
 800239a:	f06f 0501 	mvn.w	r5, #1
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800239e:	6803      	ldr	r3, [r0, #0]
 80023a0:	6023      	str	r3, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80023a2:	605c      	str	r4, [r3, #4]
 80023a4:	f7ff fa54 	bl	8001850 <chSchReadyI>
 80023a8:	6145      	str	r5, [r0, #20]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80023aa:	6820      	ldr	r0, [r4, #0]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 80023ac:	42a0      	cmp	r0, r4
 80023ae:	d1f6      	bne.n	800239e <chCondBroadcastI+0xe>
 80023b0:	bd38      	pop	{r3, r4, r5, pc}
 80023b2:	bf00      	nop
	...

080023c0 <chCondBroadcast>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondBroadcast(condition_variable_t *cp) {
 80023c0:	b508      	push	{r3, lr}
 80023c2:	2320      	movs	r3, #32
 80023c4:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chCondBroadcastI(cp);
 80023c8:	f7ff ffe2 	bl	8002390 <chCondBroadcastI>
  chSchRescheduleS();
 80023cc:	f7ff fb18 	bl	8001a00 <chSchRescheduleS>
 80023d0:	2300      	movs	r3, #0
 80023d2:	f383 8811 	msr	BASEPRI, r3
 80023d6:	bd08      	pop	{r3, pc}
	...

080023e0 <chCondWaitS>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
 80023e0:	b570      	push	{r4, r5, r6, lr}
 80023e2:	4605      	mov	r5, r0
  thread_t *ctp = currp;
 80023e4:	4b0e      	ldr	r3, [pc, #56]	; (8002420 <chCondWaitS+0x40>)
 80023e6:	691c      	ldr	r4, [r3, #16]
 *
 * @sclass
 */
static inline mutex_t *chMtxGetNextMutexS(void) {

  return chThdGetSelfX()->p_mtxlist;
 80023e8:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  chDbgCheck(cp != NULL);
  chDbgAssert(ctp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 80023ea:	4630      	mov	r0, r6
 80023ec:	f7ff ff48 	bl	8002280 <chMtxUnlockS>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 80023f0:	462b      	mov	r3, r5

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->p_u.wtobjp = cp;
 80023f2:	6165      	str	r5, [r4, #20]
 80023f4:	e003      	b.n	80023fe <chCondWaitS+0x1e>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 80023f6:	6899      	ldr	r1, [r3, #8]
 80023f8:	68a2      	ldr	r2, [r4, #8]
 80023fa:	4291      	cmp	r1, r2
 80023fc:	d302      	bcc.n	8002404 <chCondWaitS+0x24>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 80023fe:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8002400:	429d      	cmp	r5, r3
 8002402:	d1f8      	bne.n	80023f6 <chCondWaitS+0x16>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8002404:	685a      	ldr	r2, [r3, #4]
  queue_prio_insert(ctp, &cp->c_queue);
  chSchGoSleepS(CH_STATE_WTCOND);
 8002406:	2007      	movs	r0, #7

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8002408:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 800240a:	6062      	str	r2, [r4, #4]
  tp->p_prev->p_next = tp;
 800240c:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 800240e:	605c      	str	r4, [r3, #4]
 8002410:	f7ff fa36 	bl	8001880 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 8002414:	6964      	ldr	r4, [r4, #20]
  chMtxLockS(mp);
 8002416:	4630      	mov	r0, r6
 8002418:	f7ff fe6a 	bl	80020f0 <chMtxLockS>

  return msg;
}
 800241c:	4620      	mov	r0, r4
 800241e:	bd70      	pop	{r4, r5, r6, pc}
 8002420:	20001160 	.word	0x20001160
	...

08002430 <chCondWait>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @api
 */
msg_t chCondWait(condition_variable_t *cp) {
 8002430:	b508      	push	{r3, lr}
 8002432:	2320      	movs	r3, #32
 8002434:	f383 8811 	msr	BASEPRI, r3
  msg_t msg;

  chSysLock();
  msg = chCondWaitS(cp);
 8002438:	f7ff ffd2 	bl	80023e0 <chCondWaitS>
 800243c:	2300      	movs	r3, #0
 800243e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  return msg;
}
 8002442:	bd08      	pop	{r3, pc}
	...

08002450 <chCondWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chCondWaitTimeoutS(condition_variable_t *cp, systime_t time) {
 8002450:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002452:	4605      	mov	r5, r0
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002454:	4c11      	ldr	r4, [pc, #68]	; (800249c <chCondWaitTimeoutS+0x4c>)
 8002456:	460f      	mov	r7, r1
 8002458:	6923      	ldr	r3, [r4, #16]
 800245a:	6ade      	ldr	r6, [r3, #44]	; 0x2c
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
  chDbgAssert(currp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 800245c:	4630      	mov	r0, r6
 800245e:	f7ff ff0f 	bl	8002280 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->p_u.wtobjp = cp;
 8002462:	6924      	ldr	r4, [r4, #16]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8002464:	462b      	mov	r3, r5
 8002466:	6165      	str	r5, [r4, #20]
 8002468:	e003      	b.n	8002472 <chCondWaitTimeoutS+0x22>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800246a:	6898      	ldr	r0, [r3, #8]
 800246c:	68a2      	ldr	r2, [r4, #8]
 800246e:	4290      	cmp	r0, r2
 8002470:	d302      	bcc.n	8002478 <chCondWaitTimeoutS+0x28>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8002472:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8002474:	429d      	cmp	r5, r3
 8002476:	d1f8      	bne.n	800246a <chCondWaitTimeoutS+0x1a>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8002478:	685a      	ldr	r2, [r3, #4]
  queue_prio_insert(currp, &cp->c_queue);
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
 800247a:	4639      	mov	r1, r7

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 800247c:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 800247e:	6062      	str	r2, [r4, #4]
 8002480:	2007      	movs	r0, #7
  tp->p_prev->p_next = tp;
 8002482:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 8002484:	605c      	str	r4, [r3, #4]
 8002486:	f7ff fa13 	bl	80018b0 <chSchGoSleepTimeoutS>
  if (msg != MSG_TIMEOUT) {
 800248a:	1c43      	adds	r3, r0, #1

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->p_u.wtobjp = cp;
  queue_prio_insert(currp, &cp->c_queue);
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
 800248c:	4604      	mov	r4, r0
  if (msg != MSG_TIMEOUT) {
 800248e:	d002      	beq.n	8002496 <chCondWaitTimeoutS+0x46>
    chMtxLockS(mp);
 8002490:	4630      	mov	r0, r6
 8002492:	f7ff fe2d 	bl	80020f0 <chMtxLockS>
  }

  return msg;
}
 8002496:	4620      	mov	r0, r4
 8002498:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800249a:	bf00      	nop
 800249c:	20001160 	.word	0x20001160

080024a0 <chCondWaitTimeout>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chCondWaitTimeout(condition_variable_t *cp, systime_t time) {
 80024a0:	b508      	push	{r3, lr}
 80024a2:	2320      	movs	r3, #32
 80024a4:	f383 8811 	msr	BASEPRI, r3
  msg_t msg;

  chSysLock();
  msg = chCondWaitTimeoutS(cp, time);
 80024a8:	f7ff ffd2 	bl	8002450 <chCondWaitTimeoutS>
 80024ac:	2300      	movs	r3, #0
 80024ae:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return msg;
}
 80024b2:	bd08      	pop	{r3, pc}
	...

080024c0 <chEvtRegisterMaskWithFlags>:
 * @api
 */
void chEvtRegisterMaskWithFlags(event_source_t *esp,
                                event_listener_t *elp,
                                eventmask_t events,
                                eventflags_t wflags) {
 80024c0:	b470      	push	{r4, r5, r6}
 80024c2:	2420      	movs	r4, #32
 80024c4:	f384 8811 	msr	BASEPRI, r4
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
 80024c8:	4c06      	ldr	r4, [pc, #24]	; (80024e4 <chEvtRegisterMaskWithFlags+0x24>)
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 80024ca:	6806      	ldr	r6, [r0, #0]
  esp->es_next     = elp;
  elp->el_listener = currp;
 80024cc:	6925      	ldr	r5, [r4, #16]
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
 80024ce:	2400      	movs	r4, #0
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 80024d0:	600e      	str	r6, [r1, #0]
  esp->es_next     = elp;
 80024d2:	6001      	str	r1, [r0, #0]
  elp->el_listener = currp;
 80024d4:	604d      	str	r5, [r1, #4]
  elp->el_events   = events;
 80024d6:	608a      	str	r2, [r1, #8]
  elp->el_flags    = (eventflags_t)0;
  elp->el_wflags   = wflags;
 80024d8:	610b      	str	r3, [r1, #16]
  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
 80024da:	60cc      	str	r4, [r1, #12]
 80024dc:	f384 8811 	msr	BASEPRI, r4
  elp->el_wflags   = wflags;
  chSysUnlock();
}
 80024e0:	bc70      	pop	{r4, r5, r6}
 80024e2:	4770      	bx	lr
 80024e4:	20001160 	.word	0x20001160
	...

080024f0 <chEvtUnregister>:
 80024f0:	2320      	movs	r3, #32
 80024f2:	f383 8811 	msr	BASEPRI, r3
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));

  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
 80024f6:	4602      	mov	r2, r0
 80024f8:	e002      	b.n	8002500 <chEvtUnregister+0x10>
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
  /*lint -restore*/
    if (p->el_next == elp) {
 80024fa:	428b      	cmp	r3, r1
 80024fc:	d007      	beq.n	800250e <chEvtUnregister+0x1e>
 80024fe:	461a      	mov	r2, r3
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
 8002500:	6813      	ldr	r3, [r2, #0]
 8002502:	4283      	cmp	r3, r0
 8002504:	d1f9      	bne.n	80024fa <chEvtUnregister+0xa>
 8002506:	2300      	movs	r3, #0
 8002508:	f383 8811 	msr	BASEPRI, r3
 800250c:	4770      	bx	lr
  /*lint -restore*/
    if (p->el_next == elp) {
      p->el_next = elp->el_next;
 800250e:	680b      	ldr	r3, [r1, #0]
 8002510:	6013      	str	r3, [r2, #0]
 8002512:	2300      	movs	r3, #0
 8002514:	f383 8811 	msr	BASEPRI, r3
 8002518:	4770      	bx	lr
 800251a:	bf00      	nop
 800251c:	0000      	movs	r0, r0
	...

08002520 <chEvtGetAndClearEvents>:
 * @param[in] events    the events to be cleared
 * @return              The pending events that were cleared.
 *
 * @api
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
 8002520:	b410      	push	{r4}
 8002522:	2320      	movs	r3, #32
 8002524:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = currp->p_epending & events;
 8002528:	4b06      	ldr	r3, [pc, #24]	; (8002544 <chEvtGetAndClearEvents+0x24>)
 800252a:	2100      	movs	r1, #0
 800252c:	691a      	ldr	r2, [r3, #16]
 800252e:	6a93      	ldr	r3, [r2, #40]	; 0x28
  currp->p_epending &= ~events;
 8002530:	ea23 0400 	bic.w	r4, r3, r0
 8002534:	6294      	str	r4, [r2, #40]	; 0x28
 8002536:	f381 8811 	msr	BASEPRI, r1
  chSysUnlock();

  return m;
}
 800253a:	4018      	ands	r0, r3
 800253c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002540:	4770      	bx	lr
 8002542:	bf00      	nop
 8002544:	20001160 	.word	0x20001160
	...

08002550 <chEvtAddEvents>:
 8002550:	2320      	movs	r3, #32
 8002552:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t events) {

  chSysLock();
  currp->p_epending |= events;
 8002556:	4b04      	ldr	r3, [pc, #16]	; (8002568 <chEvtAddEvents+0x18>)
 8002558:	2100      	movs	r1, #0
 800255a:	691a      	ldr	r2, [r3, #16]
 800255c:	6a93      	ldr	r3, [r2, #40]	; 0x28
 800255e:	4318      	orrs	r0, r3
 8002560:	6290      	str	r0, [r2, #40]	; 0x28
 8002562:	f381 8811 	msr	BASEPRI, r1
  events = currp->p_epending;
  chSysUnlock();

  return events;
}
 8002566:	4770      	bx	lr
 8002568:	20001160 	.word	0x20001160
 800256c:	00000000 	.word	0x00000000

08002570 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8002570:	6a83      	ldr	r3, [r0, #40]	; 0x28
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8002572:	7c02      	ldrb	r2, [r0, #16]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8002574:	4319      	orrs	r1, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8002576:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8002578:	6281      	str	r1, [r0, #40]	; 0x28
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 800257a:	d00a      	beq.n	8002592 <chEvtSignalI+0x22>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800257c:	2a0b      	cmp	r2, #11
 800257e:	d000      	beq.n	8002582 <chEvtSignalI+0x12>
 8002580:	4770      	bx	lr
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8002582:	6943      	ldr	r3, [r0, #20]
 8002584:	4019      	ands	r1, r3

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8002586:	428b      	cmp	r3, r1
 8002588:	d1fa      	bne.n	8002580 <chEvtSignalI+0x10>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 800258a:	2300      	movs	r3, #0
 800258c:	6143      	str	r3, [r0, #20]
    (void) chSchReadyI(tp);
 800258e:	f7ff b95f 	b.w	8001850 <chSchReadyI>
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8002592:	6943      	ldr	r3, [r0, #20]
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8002594:	4219      	tst	r1, r3
 8002596:	d1f8      	bne.n	800258a <chEvtSignalI+0x1a>
 8002598:	4770      	bx	lr
 800259a:	bf00      	nop
 800259c:	0000      	movs	r0, r0
	...

080025a0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80025a0:	b570      	push	{r4, r5, r6, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 80025a2:	6804      	ldr	r4, [r0, #0]
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80025a4:	4606      	mov	r6, r0
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80025a6:	42a0      	cmp	r0, r4
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80025a8:	460d      	mov	r5, r1
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80025aa:	d00d      	beq.n	80025c8 <chEvtBroadcastFlagsI+0x28>
  /*lint -restore*/
    elp->el_flags |= flags;
 80025ac:	68e3      	ldr	r3, [r4, #12]
 80025ae:	432b      	orrs	r3, r5
 80025b0:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 80025b2:	b115      	cbz	r5, 80025ba <chEvtBroadcastFlagsI+0x1a>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 80025b4:	6922      	ldr	r2, [r4, #16]
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 80025b6:	4213      	tst	r3, r2
 80025b8:	d003      	beq.n	80025c2 <chEvtBroadcastFlagsI+0x22>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 80025ba:	6860      	ldr	r0, [r4, #4]
 80025bc:	68a1      	ldr	r1, [r4, #8]
 80025be:	f7ff ffd7 	bl	8002570 <chEvtSignalI>
    }
    elp = elp->el_next;
 80025c2:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80025c4:	42a6      	cmp	r6, r4
 80025c6:	d1f1      	bne.n	80025ac <chEvtBroadcastFlagsI+0xc>
 80025c8:	bd70      	pop	{r4, r5, r6, pc}
 80025ca:	bf00      	nop
 80025cc:	0000      	movs	r0, r0
	...

080025d0 <chEvtSignal>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t events) {
 80025d0:	b508      	push	{r3, lr}
 80025d2:	2320      	movs	r3, #32
 80025d4:	f383 8811 	msr	BASEPRI, r3

  chDbgCheck(tp != NULL);

  chSysLock();
  chEvtSignalI(tp, events);
 80025d8:	f7ff ffca 	bl	8002570 <chEvtSignalI>
  chSchRescheduleS();
 80025dc:	f7ff fa10 	bl	8001a00 <chSchRescheduleS>
 80025e0:	2300      	movs	r3, #0
 80025e2:	f383 8811 	msr	BASEPRI, r3
 80025e6:	bd08      	pop	{r3, pc}
	...

080025f0 <chEvtBroadcastFlags>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {
 80025f0:	b508      	push	{r3, lr}
 80025f2:	2320      	movs	r3, #32
 80025f4:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 80025f8:	f7ff ffd2 	bl	80025a0 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 80025fc:	f7ff fa00 	bl	8001a00 <chSchRescheduleS>
 8002600:	2300      	movs	r3, #0
 8002602:	f383 8811 	msr	BASEPRI, r3
 8002606:	bd08      	pop	{r3, pc}
	...

08002610 <chEvtDispatch>:
 * @param[in] handlers  an array of @p evhandler_t. The array must have size
 *                      equal to the number of bits in eventmask_t.
 *
 * @api
 */
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
 8002610:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 8002612:	460d      	mov	r5, r1
 8002614:	b1b9      	cbz	r1, 8002646 <chEvtDispatch+0x36>
 8002616:	4606      	mov	r6, r0
 8002618:	2400      	movs	r4, #0
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 800261a:	2701      	movs	r7, #1

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 800261c:	fa25 f304 	lsr.w	r3, r5, r4
 8002620:	07db      	lsls	r3, r3, #31
 8002622:	d404      	bmi.n	800262e <chEvtDispatch+0x1e>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
 8002624:	3401      	adds	r4, #1

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 8002626:	fa25 f304 	lsr.w	r3, r5, r4
 800262a:	07db      	lsls	r3, r3, #31
 800262c:	d5fa      	bpl.n	8002624 <chEvtDispatch+0x14>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 800262e:	fa07 f304 	lsl.w	r3, r7, r4
      handlers[eid](eid);
 8002632:	4620      	mov	r0, r4

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 8002634:	ea25 0503 	bic.w	r5, r5, r3
      handlers[eid](eid);
 8002638:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
 800263c:	4798      	blx	r3
    }
    eid++;
 800263e:	3401      	adds	r4, #1
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 8002640:	2d00      	cmp	r5, #0
 8002642:	d1eb      	bne.n	800261c <chEvtDispatch+0xc>
 8002644:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002646:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08002650 <chEvtWaitOne>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 8002650:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8002652:	4b0d      	ldr	r3, [pc, #52]	; (8002688 <chEvtWaitOne+0x38>)
 8002654:	691d      	ldr	r5, [r3, #16]
 8002656:	2320      	movs	r3, #32
 8002658:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 800265c:	6aab      	ldr	r3, [r5, #40]	; 0x28
  if (m == (eventmask_t)0) {
 800265e:	ea10 0203 	ands.w	r2, r0, r3
 8002662:	d107      	bne.n	8002674 <chEvtWaitOne+0x24>
 8002664:	4604      	mov	r4, r0
    ctp->p_u.ewmask = events;
 8002666:	6168      	str	r0, [r5, #20]
    chSchGoSleepS(CH_STATE_WTOREVT);
 8002668:	200a      	movs	r0, #10
 800266a:	f7ff f909 	bl	8001880 <chSchGoSleepS>
    m = ctp->p_epending & events;
 800266e:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8002670:	ea04 0203 	and.w	r2, r4, r3
  }
  m ^= m & (m - (eventmask_t)1);
 8002674:	4250      	negs	r0, r2
 8002676:	4010      	ands	r0, r2
  ctp->p_epending &= ~m;
 8002678:	ea23 0300 	bic.w	r3, r3, r0
 800267c:	62ab      	str	r3, [r5, #40]	; 0x28
 800267e:	2300      	movs	r3, #0
 8002680:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 8002684:	bd38      	pop	{r3, r4, r5, pc}
 8002686:	bf00      	nop
 8002688:	20001160 	.word	0x20001160
 800268c:	00000000 	.word	0x00000000

08002690 <chEvtWaitAny>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 8002690:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8002692:	4b0c      	ldr	r3, [pc, #48]	; (80026c4 <chEvtWaitAny+0x34>)
 8002694:	691d      	ldr	r5, [r3, #16]
 8002696:	2320      	movs	r3, #32
 8002698:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 800269c:	6aab      	ldr	r3, [r5, #40]	; 0x28
  if (m == (eventmask_t)0) {
 800269e:	ea10 0403 	ands.w	r4, r0, r3
 80026a2:	d106      	bne.n	80026b2 <chEvtWaitAny+0x22>
 80026a4:	4604      	mov	r4, r0
    ctp->p_u.ewmask = events;
 80026a6:	6168      	str	r0, [r5, #20]
    chSchGoSleepS(CH_STATE_WTOREVT);
 80026a8:	200a      	movs	r0, #10
 80026aa:	f7ff f8e9 	bl	8001880 <chSchGoSleepS>
    m = ctp->p_epending & events;
 80026ae:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80026b0:	401c      	ands	r4, r3
  }
  ctp->p_epending &= ~m;
 80026b2:	ea23 0304 	bic.w	r3, r3, r4
 80026b6:	62ab      	str	r3, [r5, #40]	; 0x28
 80026b8:	2300      	movs	r3, #0
 80026ba:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 80026be:	4620      	mov	r0, r4
 80026c0:	bd38      	pop	{r3, r4, r5, pc}
 80026c2:	bf00      	nop
 80026c4:	20001160 	.word	0x20001160
	...

080026d0 <chEvtWaitAll>:
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
 80026d0:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 80026d2:	4b0c      	ldr	r3, [pc, #48]	; (8002704 <chEvtWaitAll+0x34>)
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
 80026d4:	4604      	mov	r4, r0
  thread_t *ctp = currp;
 80026d6:	691d      	ldr	r5, [r3, #16]
 80026d8:	2320      	movs	r3, #32
 80026da:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if ((ctp->p_epending & events) != events) {
 80026de:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80026e0:	ea00 0203 	and.w	r2, r0, r3
 80026e4:	4282      	cmp	r2, r0
 80026e6:	d004      	beq.n	80026f2 <chEvtWaitAll+0x22>
    ctp->p_u.ewmask = events;
 80026e8:	6168      	str	r0, [r5, #20]
    chSchGoSleepS(CH_STATE_WTANDEVT);
 80026ea:	200b      	movs	r0, #11
 80026ec:	f7ff f8c8 	bl	8001880 <chSchGoSleepS>
 80026f0:	6aab      	ldr	r3, [r5, #40]	; 0x28
  }
  ctp->p_epending &= ~events;
 80026f2:	ea23 0304 	bic.w	r3, r3, r4
 80026f6:	62ab      	str	r3, [r5, #40]	; 0x28
 80026f8:	2300      	movs	r3, #0
 80026fa:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return events;
}
 80026fe:	4620      	mov	r0, r4
 8002700:	bd38      	pop	{r3, r4, r5, pc}
 8002702:	bf00      	nop
 8002704:	20001160 	.word	0x20001160
	...

08002710 <chEvtWaitOneTimeout>:
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8002710:	4b12      	ldr	r3, [pc, #72]	; (800275c <chEvtWaitOneTimeout+0x4c>)
 * @return              The mask of the lowest event id served and cleared.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
 8002712:	b570      	push	{r4, r5, r6, lr}
 8002714:	2220      	movs	r2, #32
  thread_t *ctp = currp;
 8002716:	691d      	ldr	r5, [r3, #16]
 8002718:	f382 8811 	msr	BASEPRI, r2
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 800271c:	6aaa      	ldr	r2, [r5, #40]	; 0x28
  if (m == (eventmask_t)0) {
 800271e:	ea10 0602 	ands.w	r6, r0, r2
 8002722:	d10e      	bne.n	8002742 <chEvtWaitOneTimeout+0x32>
    if (TIME_IMMEDIATE == time) {
 8002724:	b919      	cbnz	r1, 800272e <chEvtWaitOneTimeout+0x1e>
 8002726:	f381 8811 	msr	BASEPRI, r1
      chSysUnlock();
      return (eventmask_t)0;
 800272a:	4608      	mov	r0, r1
 800272c:	bd70      	pop	{r4, r5, r6, pc}
    }
    ctp->p_u.ewmask = events;
 800272e:	6168      	str	r0, [r5, #20]
 8002730:	4604      	mov	r4, r0
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8002732:	200a      	movs	r0, #10
 8002734:	f7ff f8bc 	bl	80018b0 <chSchGoSleepTimeoutS>
 8002738:	2800      	cmp	r0, #0
 800273a:	db0b      	blt.n	8002754 <chEvtWaitOneTimeout+0x44>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
 800273c:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 800273e:	ea04 0602 	and.w	r6, r4, r2
  }
  m ^= m & (m - (eventmask_t)1);
 8002742:	4270      	negs	r0, r6
 8002744:	4030      	ands	r0, r6
  ctp->p_epending &= ~m;
 8002746:	ea22 0200 	bic.w	r2, r2, r0
 800274a:	62aa      	str	r2, [r5, #40]	; 0x28
 800274c:	2300      	movs	r3, #0
 800274e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 8002752:	bd70      	pop	{r4, r5, r6, pc}
 8002754:	f386 8811 	msr	BASEPRI, r6
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
      chSysUnlock();
      return (eventmask_t)0;
 8002758:	4630      	mov	r0, r6
 800275a:	bd70      	pop	{r4, r5, r6, pc}
 800275c:	20001160 	.word	0x20001160

08002760 <chEvtWaitAnyTimeout>:
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8002760:	4b12      	ldr	r3, [pc, #72]	; (80027ac <chEvtWaitAnyTimeout+0x4c>)
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
 8002762:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8002764:	691e      	ldr	r6, [r3, #16]
 8002766:	2320      	movs	r3, #32
 8002768:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 800276c:	6ab3      	ldr	r3, [r6, #40]	; 0x28
  if (m == (eventmask_t)0) {
 800276e:	ea10 0403 	ands.w	r4, r0, r3
 8002772:	d10e      	bne.n	8002792 <chEvtWaitAnyTimeout+0x32>
    if (TIME_IMMEDIATE == time) {
 8002774:	b919      	cbnz	r1, 800277e <chEvtWaitAnyTimeout+0x1e>
 8002776:	f381 8811 	msr	BASEPRI, r1
      chSysUnlock();
      return (eventmask_t)0;
 800277a:	4608      	mov	r0, r1
 800277c:	bd70      	pop	{r4, r5, r6, pc}
    }
    ctp->p_u.ewmask = events;
 800277e:	6170      	str	r0, [r6, #20]
 8002780:	4605      	mov	r5, r0
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8002782:	200a      	movs	r0, #10
 8002784:	f7ff f894 	bl	80018b0 <chSchGoSleepTimeoutS>
 8002788:	2800      	cmp	r0, #0
 800278a:	db0a      	blt.n	80027a2 <chEvtWaitAnyTimeout+0x42>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
 800278c:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 800278e:	ea05 0403 	and.w	r4, r5, r3
  }
  ctp->p_epending &= ~m;
 8002792:	ea23 0304 	bic.w	r3, r3, r4
 8002796:	62b3      	str	r3, [r6, #40]	; 0x28
 8002798:	2300      	movs	r3, #0
 800279a:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
 800279e:	4620      	mov	r0, r4
}
 80027a0:	bd70      	pop	{r4, r5, r6, pc}
 80027a2:	f384 8811 	msr	BASEPRI, r4
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
      chSysUnlock();
      return (eventmask_t)0;
 80027a6:	4620      	mov	r0, r4
 80027a8:	bd70      	pop	{r4, r5, r6, pc}
 80027aa:	bf00      	nop
 80027ac:	20001160 	.word	0x20001160

080027b0 <chEvtWaitAllTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
 80027b0:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 80027b2:	4b10      	ldr	r3, [pc, #64]	; (80027f4 <chEvtWaitAllTimeout+0x44>)
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
 80027b4:	4604      	mov	r4, r0
  thread_t *ctp = currp;
 80027b6:	691d      	ldr	r5, [r3, #16]
 80027b8:	2320      	movs	r3, #32
 80027ba:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if ((ctp->p_epending & events) != events) {
 80027be:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80027c0:	ea00 0203 	and.w	r2, r0, r3
 80027c4:	4282      	cmp	r2, r0
 80027c6:	d00b      	beq.n	80027e0 <chEvtWaitAllTimeout+0x30>
 80027c8:	4608      	mov	r0, r1
    if (TIME_IMMEDIATE == time) {
 80027ca:	b911      	cbnz	r1, 80027d2 <chEvtWaitAllTimeout+0x22>
 80027cc:	f380 8811 	msr	BASEPRI, r0
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
      chSysUnlock();
      return (eventmask_t)0;
 80027d0:	bd38      	pop	{r3, r4, r5, pc}
  if ((ctp->p_epending & events) != events) {
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
 80027d2:	616c      	str	r4, [r5, #20]
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
 80027d4:	200b      	movs	r0, #11
 80027d6:	f7ff f86b 	bl	80018b0 <chSchGoSleepTimeoutS>
 80027da:	2800      	cmp	r0, #0
 80027dc:	db08      	blt.n	80027f0 <chEvtWaitAllTimeout+0x40>
 80027de:	6aab      	ldr	r3, [r5, #40]	; 0x28
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->p_epending &= ~events;
 80027e0:	ea23 0304 	bic.w	r3, r3, r4
 80027e4:	62ab      	str	r3, [r5, #40]	; 0x28
 80027e6:	2300      	movs	r3, #0
 80027e8:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return events;
 80027ec:	4620      	mov	r0, r4
}
 80027ee:	bd38      	pop	{r3, r4, r5, pc}
 80027f0:	2000      	movs	r0, #0
 80027f2:	e7eb      	b.n	80027cc <chEvtWaitAllTimeout+0x1c>
 80027f4:	20001160 	.word	0x20001160
	...

08002800 <chMsgSend>:
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
  thread_t *ctp = currp;
 8002800:	4b0e      	ldr	r3, [pc, #56]	; (800283c <chMsgSend+0x3c>)
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 8002802:	b570      	push	{r4, r5, r6, lr}
 8002804:	2220      	movs	r2, #32
  thread_t *ctp = currp;
 8002806:	691c      	ldr	r4, [r3, #16]
 8002808:	f382 8811 	msr	BASEPRI, r2

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->p_msg = msg;
  ctp->p_u.wtobjp = &tp->p_msgqueue;
 800280c:	f100 051c 	add.w	r5, r0, #28
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == CH_STATE_WTMSG) {
 8002810:	7c06      	ldrb	r6, [r0, #16]

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->p_msg = msg;
  ctp->p_u.wtobjp = &tp->p_msgqueue;
 8002812:	6165      	str	r5, [r4, #20]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8002814:	6a02      	ldr	r2, [r0, #32]
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == CH_STATE_WTMSG) {
 8002816:	2e0e      	cmp	r6, #14
  thread_t *ctp = currp;

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->p_msg = msg;
 8002818:	6261      	str	r1, [r4, #36]	; 0x24
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 800281a:	6025      	str	r5, [r4, #0]
  tp->p_prev = tqp->p_prev;
 800281c:	6062      	str	r2, [r4, #4]
  tp->p_prev->p_next = tp;
 800281e:	6014      	str	r4, [r2, #0]
  tqp->p_prev = tp;
 8002820:	6204      	str	r4, [r0, #32]
  ctp->p_u.wtobjp = &tp->p_msgqueue;
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == CH_STATE_WTMSG) {
 8002822:	d007      	beq.n	8002834 <chMsgSend+0x34>
    (void) chSchReadyI(tp);
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 8002824:	200c      	movs	r0, #12
 8002826:	f7ff f82b 	bl	8001880 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 800282a:	6960      	ldr	r0, [r4, #20]
 800282c:	2300      	movs	r3, #0
 800282e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return msg;
}
 8002832:	bd70      	pop	{r4, r5, r6, pc}
  chSysLock();
  ctp->p_msg = msg;
  ctp->p_u.wtobjp = &tp->p_msgqueue;
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == CH_STATE_WTMSG) {
    (void) chSchReadyI(tp);
 8002834:	f7ff f80c 	bl	8001850 <chSchReadyI>
 8002838:	e7f4      	b.n	8002824 <chMsgSend+0x24>
 800283a:	bf00      	nop
 800283c:	20001160 	.word	0x20001160

08002840 <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
thread_t *chMsgWait(void) {
 8002840:	b510      	push	{r4, lr}
 8002842:	2320      	movs	r3, #32
 8002844:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
 8002848:	4c0b      	ldr	r4, [pc, #44]	; (8002878 <chMsgWait+0x38>)
 800284a:	6922      	ldr	r2, [r4, #16]
 */
static inline bool chMsgIsPendingI(thread_t *tp) {

  chDbgCheckClassI();

  return (bool)(tp->p_msgqueue.p_next != (thread_t *)&tp->p_msgqueue);
 800284c:	4613      	mov	r3, r2
 800284e:	f853 0f1c 	ldr.w	r0, [r3, #28]!
 8002852:	4298      	cmp	r0, r3
 8002854:	d008      	beq.n	8002868 <chMsgWait+0x28>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8002856:	6801      	ldr	r1, [r0, #0]
    chSchGoSleepS(CH_STATE_WTMSG);
  }
  tp = queue_fifo_remove(&currp->p_msgqueue);
  tp->p_state = CH_STATE_SNDMSG;
 8002858:	240d      	movs	r4, #13
 800285a:	61d1      	str	r1, [r2, #28]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800285c:	604b      	str	r3, [r1, #4]
 800285e:	2200      	movs	r2, #0
 8002860:	7404      	strb	r4, [r0, #16]
 8002862:	f382 8811 	msr	BASEPRI, r2
  chSysUnlock();

  return tp;
}
 8002866:	bd10      	pop	{r4, pc}
thread_t *chMsgWait(void) {
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
    chSchGoSleepS(CH_STATE_WTMSG);
 8002868:	200e      	movs	r0, #14
 800286a:	f7ff f809 	bl	8001880 <chSchGoSleepS>
 800286e:	6922      	ldr	r2, [r4, #16]
 8002870:	69d0      	ldr	r0, [r2, #28]
 8002872:	f102 031c 	add.w	r3, r2, #28
 8002876:	e7ee      	b.n	8002856 <chMsgWait+0x16>
 8002878:	20001160 	.word	0x20001160
 800287c:	00000000 	.word	0x00000000

08002880 <chMsgRelease>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @api
 */
void chMsgRelease(thread_t *tp, msg_t msg) {
 8002880:	b508      	push	{r3, lr}
 8002882:	2320      	movs	r3, #32
 8002884:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
 8002888:	f7ff f83a 	bl	8001900 <chSchWakeupS>
 800288c:	2300      	movs	r3, #0
 800288e:	f383 8811 	msr	BASEPRI, r3
 8002892:	bd08      	pop	{r3, pc}
	...

080028a0 <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
 80028a0:	460b      	mov	r3, r1
 80028a2:	b510      	push	{r4, lr}
 80028a4:	4604      	mov	r4, r0
  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->mb_buffer = buf;
  mbp->mb_rdptr = buf;
  mbp->mb_wrptr = buf;
  mbp->mb_top = &buf[n];
 80028a6:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 80028aa:	6041      	str	r1, [r0, #4]
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->mb_buffer = buf;
 80028ac:	6003      	str	r3, [r0, #0]
  mbp->mb_rdptr = buf;
 80028ae:	60c3      	str	r3, [r0, #12]
  mbp->mb_wrptr = buf;
 80028b0:	6083      	str	r3, [r0, #8]
  mbp->mb_top = &buf[n];
  chSemObjectInit(&mbp->mb_emptysem, n);
 80028b2:	4611      	mov	r1, r2
 80028b4:	301c      	adds	r0, #28
 80028b6:	f7ff fb03 	bl	8001ec0 <chSemObjectInit>
  chSemObjectInit(&mbp->mb_fullsem, (cnt_t)0);
 80028ba:	f104 0010 	add.w	r0, r4, #16
 80028be:	2100      	movs	r1, #0
}
 80028c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  mbp->mb_buffer = buf;
  mbp->mb_rdptr = buf;
  mbp->mb_wrptr = buf;
  mbp->mb_top = &buf[n];
  chSemObjectInit(&mbp->mb_emptysem, n);
  chSemObjectInit(&mbp->mb_fullsem, (cnt_t)0);
 80028c4:	f7ff bafc 	b.w	8001ec0 <chSemObjectInit>
	...

080028d0 <chMBResetI>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBResetI(mailbox_t *mbp) {
 80028d0:	b510      	push	{r4, lr}
 80028d2:	4604      	mov	r4, r0

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
 80028d4:	6803      	ldr	r3, [r0, #0]
  mbp->mb_rdptr = mbp->mb_buffer;
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 80028d6:	6841      	ldr	r1, [r0, #4]
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
 80028d8:	6083      	str	r3, [r0, #8]
  mbp->mb_rdptr = mbp->mb_buffer;
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 80028da:	1ac9      	subs	r1, r1, r3

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
  mbp->mb_rdptr = mbp->mb_buffer;
 80028dc:	60c3      	str	r3, [r0, #12]
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 80028de:	1089      	asrs	r1, r1, #2
 80028e0:	301c      	adds	r0, #28
 80028e2:	f7ff faf5 	bl	8001ed0 <chSemResetI>
  chSemResetI(&mbp->mb_fullsem, (cnt_t)0);
 80028e6:	f104 0010 	add.w	r0, r4, #16
 80028ea:	2100      	movs	r1, #0
}
 80028ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
  mbp->mb_rdptr = mbp->mb_buffer;
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
  chSemResetI(&mbp->mb_fullsem, (cnt_t)0);
 80028f0:	f7ff baee 	b.w	8001ed0 <chSemResetI>
	...

08002900 <chMBReset>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBReset(mailbox_t *mbp) {
 8002900:	b508      	push	{r3, lr}
 8002902:	2320      	movs	r3, #32
 8002904:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chMBResetI(mbp);
 8002908:	f7ff ffe2 	bl	80028d0 <chMBResetI>
  chSchRescheduleS();
 800290c:	f7ff f878 	bl	8001a00 <chSchRescheduleS>
 8002910:	2300      	movs	r3, #0
 8002912:	f383 8811 	msr	BASEPRI, r3
 8002916:	bd08      	pop	{r3, pc}
	...

08002920 <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002920:	b570      	push	{r4, r5, r6, lr}
 8002922:	4604      	mov	r4, r0
 8002924:	460e      	mov	r6, r1
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 8002926:	301c      	adds	r0, #28
 8002928:	4611      	mov	r1, r2
 800292a:	f7ff fb21 	bl	8001f70 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
 800292e:	4605      	mov	r5, r0
 8002930:	b978      	cbnz	r0, 8002952 <chMBPostS+0x32>
    *mbp->mb_wrptr++ = msg;
 8002932:	68a2      	ldr	r2, [r4, #8]
    if (mbp->mb_wrptr >= mbp->mb_top) {
 8002934:	6861      	ldr	r1, [r4, #4]
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 8002936:	1d13      	adds	r3, r2, #4
    if (mbp->mb_wrptr >= mbp->mb_top) {
 8002938:	428b      	cmp	r3, r1
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 800293a:	60a3      	str	r3, [r4, #8]
    if (mbp->mb_wrptr >= mbp->mb_top) {
      mbp->mb_wrptr = mbp->mb_buffer;
 800293c:	bf28      	it	cs
 800293e:	6823      	ldrcs	r3, [r4, #0]
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 8002940:	6016      	str	r6, [r2, #0]
    if (mbp->mb_wrptr >= mbp->mb_top) {
      mbp->mb_wrptr = mbp->mb_buffer;
    }
    chSemSignalI(&mbp->mb_fullsem);
 8002942:	f104 0010 	add.w	r0, r4, #16

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
    if (mbp->mb_wrptr >= mbp->mb_top) {
      mbp->mb_wrptr = mbp->mb_buffer;
 8002946:	bf28      	it	cs
 8002948:	60a3      	strcs	r3, [r4, #8]
    }
    chSemSignalI(&mbp->mb_fullsem);
 800294a:	f7ff fb61 	bl	8002010 <chSemSignalI>
    chSchRescheduleS();
 800294e:	f7ff f857 	bl	8001a00 <chSchRescheduleS>
  }

  return rdymsg;
}
 8002952:	4628      	mov	r0, r5
 8002954:	bd70      	pop	{r4, r5, r6, pc}
 8002956:	bf00      	nop
	...

08002960 <chMBPost>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002960:	b508      	push	{r3, lr}
 8002962:	2320      	movs	r3, #32
 8002964:	f383 8811 	msr	BASEPRI, r3
  msg_t rdymsg;

  chSysLock();
  rdymsg = chMBPostS(mbp, msg, timeout);
 8002968:	f7ff ffda 	bl	8002920 <chMBPostS>
 800296c:	2300      	movs	r3, #0
 800296e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return rdymsg;
}
 8002972:	bd08      	pop	{r3, pc}
	...

08002980 <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8002980:	b538      	push	{r3, r4, r5, lr}
 8002982:	6a43      	ldr	r3, [r0, #36]	; 0x24

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 8002984:	2b00      	cmp	r3, #0
 8002986:	dd12      	ble.n	80029ae <chMBPostI+0x2e>
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
 8002988:	6884      	ldr	r4, [r0, #8]
  if (mbp->mb_wrptr >= mbp->mb_top) {
 800298a:	6845      	ldr	r5, [r0, #4]
  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
 800298c:	1d22      	adds	r2, r4, #4
 */
static inline void chSemFastWaitI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt--;
 800298e:	3b01      	subs	r3, #1
  if (mbp->mb_wrptr >= mbp->mb_top) {
 8002990:	42aa      	cmp	r2, r5
 8002992:	6243      	str	r3, [r0, #36]	; 0x24
     mbp->mb_wrptr = mbp->mb_buffer;
 8002994:	bf28      	it	cs
 8002996:	6803      	ldrcs	r3, [r0, #0]
  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
 8002998:	6082      	str	r2, [r0, #8]
 800299a:	6021      	str	r1, [r4, #0]
  if (mbp->mb_wrptr >= mbp->mb_top) {
     mbp->mb_wrptr = mbp->mb_buffer;
  }
  chSemSignalI(&mbp->mb_fullsem);
 800299c:	f100 0010 	add.w	r0, r0, #16
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
  if (mbp->mb_wrptr >= mbp->mb_top) {
     mbp->mb_wrptr = mbp->mb_buffer;
 80029a0:	bf28      	it	cs
 80029a2:	f840 3c08 	strcs.w	r3, [r0, #-8]
  }
  chSemSignalI(&mbp->mb_fullsem);
 80029a6:	f7ff fb33 	bl	8002010 <chSemSignalI>

  return MSG_OK;
 80029aa:	2000      	movs	r0, #0
 80029ac:	bd38      	pop	{r3, r4, r5, pc}

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
 80029ae:	f04f 30ff 	mov.w	r0, #4294967295
     mbp->mb_wrptr = mbp->mb_buffer;
  }
  chSemSignalI(&mbp->mb_fullsem);

  return MSG_OK;
}
 80029b2:	bd38      	pop	{r3, r4, r5, pc}
	...

080029c0 <chMBPostAheadS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostAheadS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 80029c0:	b570      	push	{r4, r5, r6, lr}
 80029c2:	4604      	mov	r4, r0
 80029c4:	460e      	mov	r6, r1
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 80029c6:	301c      	adds	r0, #28
 80029c8:	4611      	mov	r1, r2
 80029ca:	f7ff fad1 	bl	8001f70 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
 80029ce:	4605      	mov	r5, r0
 80029d0:	b960      	cbnz	r0, 80029ec <chMBPostAheadS+0x2c>
    if (--mbp->mb_rdptr < mbp->mb_buffer) {
 80029d2:	68e3      	ldr	r3, [r4, #12]
 80029d4:	6822      	ldr	r2, [r4, #0]
 80029d6:	3b04      	subs	r3, #4
 80029d8:	4293      	cmp	r3, r2
 80029da:	60e3      	str	r3, [r4, #12]
 80029dc:	d308      	bcc.n	80029f0 <chMBPostAheadS+0x30>
      mbp->mb_rdptr = mbp->mb_top - 1;
    }
    *mbp->mb_rdptr = msg;
 80029de:	601e      	str	r6, [r3, #0]
    chSemSignalI(&mbp->mb_fullsem);
 80029e0:	f104 0010 	add.w	r0, r4, #16
 80029e4:	f7ff fb14 	bl	8002010 <chSemSignalI>
    chSchRescheduleS();
 80029e8:	f7ff f80a 	bl	8001a00 <chSchRescheduleS>
  }

  return rdymsg;
}
 80029ec:	4628      	mov	r0, r5
 80029ee:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    if (--mbp->mb_rdptr < mbp->mb_buffer) {
      mbp->mb_rdptr = mbp->mb_top - 1;
 80029f0:	6863      	ldr	r3, [r4, #4]
 80029f2:	3b04      	subs	r3, #4
 80029f4:	60e3      	str	r3, [r4, #12]
 80029f6:	e7f2      	b.n	80029de <chMBPostAheadS+0x1e>
	...

08002a00 <chMBPostAhead>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostAhead(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002a00:	b508      	push	{r3, lr}
 8002a02:	2320      	movs	r3, #32
 8002a04:	f383 8811 	msr	BASEPRI, r3
  msg_t rdymsg;

  chSysLock();
  rdymsg = chMBPostAheadS(mbp, msg, timeout);
 8002a08:	f7ff ffda 	bl	80029c0 <chMBPostAheadS>
 8002a0c:	2300      	movs	r3, #0
 8002a0e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return rdymsg;
}
 8002a12:	bd08      	pop	{r3, pc}
	...

08002a20 <chMBPostAheadI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 8002a20:	6a42      	ldr	r2, [r0, #36]	; 0x24

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 8002a22:	2a00      	cmp	r2, #0
 8002a24:	dd11      	ble.n	8002a4a <chMBPostAheadI+0x2a>
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_emptysem);
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
 8002a26:	68c3      	ldr	r3, [r0, #12]
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 8002a28:	b510      	push	{r4, lr}

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_emptysem);
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
 8002a2a:	6804      	ldr	r4, [r0, #0]
 8002a2c:	3b04      	subs	r3, #4
 8002a2e:	3a01      	subs	r2, #1
 8002a30:	42a3      	cmp	r3, r4
 8002a32:	6242      	str	r2, [r0, #36]	; 0x24
 8002a34:	60c3      	str	r3, [r0, #12]
 8002a36:	d202      	bcs.n	8002a3e <chMBPostAheadI+0x1e>
    mbp->mb_rdptr = mbp->mb_top - 1;
 8002a38:	6843      	ldr	r3, [r0, #4]
 8002a3a:	3b04      	subs	r3, #4
 8002a3c:	60c3      	str	r3, [r0, #12]
  }
  *mbp->mb_rdptr = msg;
 8002a3e:	6019      	str	r1, [r3, #0]
  chSemSignalI(&mbp->mb_fullsem);
 8002a40:	3010      	adds	r0, #16
 8002a42:	f7ff fae5 	bl	8002010 <chSemSignalI>

  return MSG_OK;
 8002a46:	2000      	movs	r0, #0
 8002a48:	bd10      	pop	{r4, pc}

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
 8002a4a:	f04f 30ff 	mov.w	r0, #4294967295
 8002a4e:	4770      	bx	lr

08002a50 <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8002a50:	b570      	push	{r4, r5, r6, lr}
 8002a52:	4604      	mov	r4, r0
 8002a54:	460e      	mov	r6, r1
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
 8002a56:	3010      	adds	r0, #16
 8002a58:	4611      	mov	r1, r2
 8002a5a:	f7ff fa89 	bl	8001f70 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
 8002a5e:	4605      	mov	r5, r0
 8002a60:	b980      	cbnz	r0, 8002a84 <chMBFetchS+0x34>
    *msgp = *mbp->mb_rdptr++;
 8002a62:	68e3      	ldr	r3, [r4, #12]
    if (mbp->mb_rdptr >= mbp->mb_top) {
 8002a64:	6862      	ldr	r2, [r4, #4]
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
 8002a66:	6819      	ldr	r1, [r3, #0]
 8002a68:	3304      	adds	r3, #4
    if (mbp->mb_rdptr >= mbp->mb_top) {
 8002a6a:	4293      	cmp	r3, r2
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
 8002a6c:	60e3      	str	r3, [r4, #12]
    if (mbp->mb_rdptr >= mbp->mb_top) {
      mbp->mb_rdptr = mbp->mb_buffer;
 8002a6e:	bf28      	it	cs
 8002a70:	6823      	ldrcs	r3, [r4, #0]
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
 8002a72:	6031      	str	r1, [r6, #0]
    if (mbp->mb_rdptr >= mbp->mb_top) {
      mbp->mb_rdptr = mbp->mb_buffer;
    }
    chSemSignalI(&mbp->mb_emptysem);
 8002a74:	f104 001c 	add.w	r0, r4, #28

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
    if (mbp->mb_rdptr >= mbp->mb_top) {
      mbp->mb_rdptr = mbp->mb_buffer;
 8002a78:	bf28      	it	cs
 8002a7a:	60e3      	strcs	r3, [r4, #12]
    }
    chSemSignalI(&mbp->mb_emptysem);
 8002a7c:	f7ff fac8 	bl	8002010 <chSemSignalI>
    chSchRescheduleS();
 8002a80:	f7fe ffbe 	bl	8001a00 <chSchRescheduleS>
  }

  return rdymsg;
}
 8002a84:	4628      	mov	r0, r5
 8002a86:	bd70      	pop	{r4, r5, r6, pc}
	...

08002a90 <chMBFetch>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8002a90:	b508      	push	{r3, lr}
 8002a92:	2320      	movs	r3, #32
 8002a94:	f383 8811 	msr	BASEPRI, r3
  msg_t rdymsg;

  chSysLock();
  rdymsg = chMBFetchS(mbp, msgp, timeout);
 8002a98:	f7ff ffda 	bl	8002a50 <chMBFetchS>
 8002a9c:	2300      	movs	r3, #0
 8002a9e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return rdymsg;
}
 8002aa2:	bd08      	pop	{r3, pc}
	...

08002ab0 <chMBFetchI>:
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 8002ab0:	6983      	ldr	r3, [r0, #24]

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
 8002ab2:	2b00      	cmp	r3, #0
 8002ab4:	dd14      	ble.n	8002ae0 <chMBFetchI+0x30>
 8002ab6:	1e5a      	subs	r2, r3, #1
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
 8002ab8:	68c3      	ldr	r3, [r0, #12]
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 8002aba:	b510      	push	{r4, lr}
 8002abc:	6182      	str	r2, [r0, #24]
  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
  if (mbp->mb_rdptr >= mbp->mb_top) {
 8002abe:	6842      	ldr	r2, [r0, #4]

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
 8002ac0:	681c      	ldr	r4, [r3, #0]
 8002ac2:	3304      	adds	r3, #4
  if (mbp->mb_rdptr >= mbp->mb_top) {
 8002ac4:	4293      	cmp	r3, r2

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
 8002ac6:	60c3      	str	r3, [r0, #12]
  if (mbp->mb_rdptr >= mbp->mb_top) {
    mbp->mb_rdptr = mbp->mb_buffer;
 8002ac8:	bf28      	it	cs
 8002aca:	6803      	ldrcs	r3, [r0, #0]

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
 8002acc:	600c      	str	r4, [r1, #0]
  if (mbp->mb_rdptr >= mbp->mb_top) {
    mbp->mb_rdptr = mbp->mb_buffer;
  }
  chSemSignalI(&mbp->mb_emptysem);
 8002ace:	f100 001c 	add.w	r0, r0, #28
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
  if (mbp->mb_rdptr >= mbp->mb_top) {
    mbp->mb_rdptr = mbp->mb_buffer;
 8002ad2:	bf28      	it	cs
 8002ad4:	f840 3c10 	strcs.w	r3, [r0, #-16]
  }
  chSemSignalI(&mbp->mb_emptysem);
 8002ad8:	f7ff fa9a 	bl	8002010 <chSemSignalI>

  return MSG_OK;
 8002adc:	2000      	movs	r0, #0
 8002ade:	bd10      	pop	{r4, pc}

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
 8002ae0:	f04f 30ff 	mov.w	r0, #4294967295
 8002ae4:	4770      	bx	lr
 8002ae6:	bf00      	nop
	...

08002af0 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 8002af0:	b430      	push	{r4, r5}
 8002af2:	9c02      	ldr	r4, [sp, #8]

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8002af4:	2500      	movs	r5, #0
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8002af6:	440a      	add	r2, r1
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8002af8:	6085      	str	r5, [r0, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 8002afa:	6204      	str	r4, [r0, #32]
  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8002afc:	6102      	str	r2, [r0, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002afe:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 8002b00:	6040      	str	r0, [r0, #4]
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8002b02:	60c1      	str	r1, [r0, #12]
  iqp->q_rdptr   = bp;
 8002b04:	6181      	str	r1, [r0, #24]
  iqp->q_wrptr   = bp;
 8002b06:	6141      	str	r1, [r0, #20]
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8002b08:	61c3      	str	r3, [r0, #28]
  iqp->q_link    = link;
}
 8002b0a:	bc30      	pop	{r4, r5}
 8002b0c:	4770      	bx	lr
 8002b0e:	bf00      	nop

08002b10 <chIQResetI>:
 */
void chIQResetI(input_queue_t *iqp) {

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
 8002b10:	68c2      	ldr	r2, [r0, #12]
  iqp->q_wrptr = iqp->q_buffer;
  iqp->q_counter = 0;
 8002b12:	2100      	movs	r1, #0
 8002b14:	6081      	str	r1, [r0, #8]
 */
void chIQResetI(input_queue_t *iqp) {

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
 8002b16:	6182      	str	r2, [r0, #24]
  iqp->q_wrptr = iqp->q_buffer;
 8002b18:	6142      	str	r2, [r0, #20]
  iqp->q_counter = 0;
  chThdDequeueAllI(&iqp->q_waiting, Q_RESET);
 8002b1a:	f06f 0101 	mvn.w	r1, #1
 8002b1e:	f7ff b8ff 	b.w	8001d20 <chThdDequeueAllI>
 8002b22:	bf00      	nop
	...

08002b30 <chIQPutI>:
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8002b30:	6943      	ldr	r3, [r0, #20]
 8002b32:	6982      	ldr	r2, [r0, #24]
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 8002b34:	b510      	push	{r4, lr}
 8002b36:	4293      	cmp	r3, r2
 8002b38:	d010      	beq.n	8002b5c <chIQPutI+0x2c>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 8002b3a:	6882      	ldr	r2, [r0, #8]
  *iqp->q_wrptr++ = b;
 8002b3c:	1c5c      	adds	r4, r3, #1

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 8002b3e:	3201      	adds	r2, #1
 8002b40:	6082      	str	r2, [r0, #8]
  *iqp->q_wrptr++ = b;
 8002b42:	6144      	str	r4, [r0, #20]
 8002b44:	7019      	strb	r1, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8002b46:	6942      	ldr	r2, [r0, #20]
 8002b48:	6903      	ldr	r3, [r0, #16]
 8002b4a:	429a      	cmp	r2, r3
 8002b4c:	d301      	bcc.n	8002b52 <chIQPutI+0x22>
    iqp->q_wrptr = iqp->q_buffer;
 8002b4e:	68c3      	ldr	r3, [r0, #12]
 8002b50:	6143      	str	r3, [r0, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 8002b52:	2100      	movs	r1, #0
 8002b54:	f7ff f8d4 	bl	8001d00 <chThdDequeueNextI>

  return Q_OK;
 8002b58:	2000      	movs	r0, #0
 8002b5a:	bd10      	pop	{r4, pc}
 8002b5c:	6882      	ldr	r2, [r0, #8]
 8002b5e:	2a00      	cmp	r2, #0
 8002b60:	d0eb      	beq.n	8002b3a <chIQPutI+0xa>
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {

  chDbgCheckClassI();

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
 8002b62:	f06f 0003 	mvn.w	r0, #3
 8002b66:	bd10      	pop	{r4, pc}
	...

08002b70 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8002b70:	b570      	push	{r4, r5, r6, lr}
 8002b72:	2320      	movs	r3, #32
 8002b74:	460e      	mov	r6, r1
 8002b76:	4604      	mov	r4, r0
 8002b78:	f383 8811 	msr	BASEPRI, r3
  uint8_t b;

  chSysLock();
  if (iqp->q_notify != NULL) {
 8002b7c:	69c3      	ldr	r3, [r0, #28]
 8002b7e:	b13b      	cbz	r3, 8002b90 <chIQGetTimeout+0x20>
    iqp->q_notify(iqp);
 8002b80:	4798      	blx	r3
 8002b82:	e005      	b.n	8002b90 <chIQGetTimeout+0x20>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8002b84:	4620      	mov	r0, r4
 8002b86:	4631      	mov	r1, r6
 8002b88:	f7ff f8a2 	bl	8001cd0 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8002b8c:	2800      	cmp	r0, #0
 8002b8e:	db13      	blt.n	8002bb8 <chIQGetTimeout+0x48>
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8002b90:	68a5      	ldr	r5, [r4, #8]
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 8002b92:	2d00      	cmp	r5, #0
 8002b94:	d0f6      	beq.n	8002b84 <chIQGetTimeout+0x14>
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8002b96:	69a1      	ldr	r1, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8002b98:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8002b9a:	6925      	ldr	r5, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8002b9c:	1c4a      	adds	r2, r1, #1
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8002b9e:	3b01      	subs	r3, #1
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8002ba0:	42aa      	cmp	r2, r5
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8002ba2:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8002ba4:	bf28      	it	cs
 8002ba6:	68e3      	ldrcs	r3, [r4, #12]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8002ba8:	61a2      	str	r2, [r4, #24]
 8002baa:	7808      	ldrb	r0, [r1, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8002bac:	bf28      	it	cs
 8002bae:	61a3      	strcs	r3, [r4, #24]
 8002bb0:	2300      	movs	r3, #0
 8002bb2:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return (msg_t)b;
}
 8002bb6:	bd70      	pop	{r4, r5, r6, pc}
 8002bb8:	f385 8811 	msr	BASEPRI, r5

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
    if (msg < Q_OK) {
      chSysUnlock();
      return msg;
 8002bbc:	bd70      	pop	{r4, r5, r6, pc}
 8002bbe:	bf00      	nop

08002bc0 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8002bc0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002bc4:	4604      	mov	r4, r0
 8002bc6:	b083      	sub	sp, #12
 8002bc8:	4689      	mov	r9, r1
 8002bca:	4693      	mov	fp, r2
 8002bcc:	461d      	mov	r5, r3
  qnotify_t nfy = iqp->q_notify;
 8002bce:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8002bd2:	2720      	movs	r7, #32
 8002bd4:	f387 8811 	msr	BASEPRI, r7
  size_t r = 0;
 8002bd8:	2600      	movs	r6, #0
 8002bda:	46b2      	mov	sl, r6
 8002bdc:	9701      	str	r7, [sp, #4]

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    if (nfy != NULL) {
 8002bde:	f1b8 0f00 	cmp.w	r8, #0
 8002be2:	d007      	beq.n	8002bf4 <chIQReadTimeout+0x34>
      nfy(iqp);
 8002be4:	4620      	mov	r0, r4
 8002be6:	47c0      	blx	r8
 8002be8:	e004      	b.n	8002bf4 <chIQReadTimeout+0x34>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 8002bea:	4620      	mov	r0, r4
 8002bec:	4629      	mov	r1, r5
 8002bee:	f7ff f86f 	bl	8001cd0 <chThdEnqueueTimeoutS>
 8002bf2:	b9d0      	cbnz	r0, 8002c2a <chIQReadTimeout+0x6a>
 8002bf4:	68a7      	ldr	r7, [r4, #8]
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 8002bf6:	2f00      	cmp	r7, #0
 8002bf8:	d0f7      	beq.n	8002bea <chIQReadTimeout+0x2a>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8002bfa:	69a2      	ldr	r2, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8002bfc:	68a3      	ldr	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8002bfe:	1c51      	adds	r1, r2, #1
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8002c00:	3b01      	subs	r3, #1
    *bp++ = *iqp->q_rdptr++;
 8002c02:	61a1      	str	r1, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8002c04:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8002c06:	7813      	ldrb	r3, [r2, #0]
 8002c08:	f809 3b01 	strb.w	r3, [r9], #1
    if (iqp->q_rdptr >= iqp->q_top) {
 8002c0c:	6923      	ldr	r3, [r4, #16]
 8002c0e:	69a2      	ldr	r2, [r4, #24]
 8002c10:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 8002c12:	bf24      	itt	cs
 8002c14:	68e3      	ldrcs	r3, [r4, #12]
 8002c16:	61a3      	strcs	r3, [r4, #24]
 8002c18:	f38a 8811 	msr	BASEPRI, sl
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
 8002c1c:	3601      	adds	r6, #1
    if (--n == 0U) {
 8002c1e:	45b3      	cmp	fp, r6
 8002c20:	d005      	beq.n	8002c2e <chIQReadTimeout+0x6e>
 8002c22:	9b01      	ldr	r3, [sp, #4]
 8002c24:	f383 8811 	msr	BASEPRI, r3
 8002c28:	e7d9      	b.n	8002bde <chIQReadTimeout+0x1e>
 8002c2a:	f387 8811 	msr	BASEPRI, r7
      return r;
    }

    chSysLock();
  }
}
 8002c2e:	4630      	mov	r0, r6
 8002c30:	b003      	add	sp, #12
 8002c32:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002c36:	bf00      	nop
	...

08002c40 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 8002c40:	b430      	push	{r4, r5}
 8002c42:	9c02      	ldr	r4, [sp, #8]
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8002c44:	188d      	adds	r5, r1, r2
 8002c46:	6105      	str	r5, [r0, #16]
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 8002c48:	6204      	str	r4, [r0, #32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002c4a:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 8002c4c:	6040      	str	r0, [r0, #4]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8002c4e:	6082      	str	r2, [r0, #8]
  oqp->q_buffer  = bp;
 8002c50:	60c1      	str	r1, [r0, #12]
  oqp->q_rdptr   = bp;
 8002c52:	6181      	str	r1, [r0, #24]
  oqp->q_wrptr   = bp;
 8002c54:	6141      	str	r1, [r0, #20]
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 8002c56:	61c3      	str	r3, [r0, #28]
  oqp->q_link    = link;
}
 8002c58:	bc30      	pop	{r4, r5}
 8002c5a:	4770      	bx	lr
 8002c5c:	0000      	movs	r0, r0
	...

08002c60 <chOQResetI>:
 */
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
 8002c60:	68c1      	ldr	r1, [r0, #12]
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
 8002c62:	6902      	ldr	r2, [r0, #16]
 */
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
 8002c64:	6181      	str	r1, [r0, #24]
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
 8002c66:	1a52      	subs	r2, r2, r1
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
  oqp->q_wrptr = oqp->q_buffer;
 8002c68:	6141      	str	r1, [r0, #20]
  oqp->q_counter = chQSizeX(oqp);
 8002c6a:	6082      	str	r2, [r0, #8]
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
 8002c6c:	f06f 0101 	mvn.w	r1, #1
 8002c70:	f7ff b856 	b.w	8001d20 <chThdDequeueAllI>
	...

08002c80 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8002c80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002c82:	4604      	mov	r4, r0
 8002c84:	460f      	mov	r7, r1
 8002c86:	4616      	mov	r6, r2
 8002c88:	2320      	movs	r3, #32
 8002c8a:	f383 8811 	msr	BASEPRI, r3
 8002c8e:	e005      	b.n	8002c9c <chOQPutTimeout+0x1c>

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8002c90:	4620      	mov	r0, r4
 8002c92:	4631      	mov	r1, r6
 8002c94:	f7ff f81c 	bl	8001cd0 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8002c98:	2800      	cmp	r0, #0
 8002c9a:	db17      	blt.n	8002ccc <chOQPutTimeout+0x4c>
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8002c9c:	68a5      	ldr	r5, [r4, #8]
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 8002c9e:	2d00      	cmp	r5, #0
 8002ca0:	d0f6      	beq.n	8002c90 <chOQPutTimeout+0x10>
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8002ca2:	6962      	ldr	r2, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8002ca4:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8002ca6:	1c51      	adds	r1, r2, #1
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8002ca8:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 8002caa:	6161      	str	r1, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8002cac:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8002cae:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8002cb0:	6923      	ldr	r3, [r4, #16]
 8002cb2:	6962      	ldr	r2, [r4, #20]
 8002cb4:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8002cb6:	bf24      	itt	cs
 8002cb8:	68e3      	ldrcs	r3, [r4, #12]
 8002cba:	6163      	strcs	r3, [r4, #20]
  }

  if (oqp->q_notify != NULL) {
 8002cbc:	69e3      	ldr	r3, [r4, #28]
 8002cbe:	b10b      	cbz	r3, 8002cc4 <chOQPutTimeout+0x44>
    oqp->q_notify(oqp);
 8002cc0:	4620      	mov	r0, r4
 8002cc2:	4798      	blx	r3
 8002cc4:	2000      	movs	r0, #0
 8002cc6:	f380 8811 	msr	BASEPRI, r0
  }
  chSysUnlock();

  return Q_OK;
}
 8002cca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002ccc:	f385 8811 	msr	BASEPRI, r5
  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < Q_OK) {
      chSysUnlock();
      return msg;
 8002cd0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002cd2:	bf00      	nop
	...

08002ce0 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 8002ce0:	b538      	push	{r3, r4, r5, lr}
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8002ce2:	6942      	ldr	r2, [r0, #20]
 8002ce4:	6983      	ldr	r3, [r0, #24]
 8002ce6:	429a      	cmp	r2, r3
 8002ce8:	d00f      	beq.n	8002d0a <chOQGetI+0x2a>

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8002cea:	6882      	ldr	r2, [r0, #8]
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 8002cec:	6905      	ldr	r5, [r0, #16]
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 8002cee:	1c59      	adds	r1, r3, #1

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8002cf0:	3201      	adds	r2, #1
 8002cf2:	6082      	str	r2, [r0, #8]
  b = *oqp->q_rdptr++;
 8002cf4:	6181      	str	r1, [r0, #24]
  if (oqp->q_rdptr >= oqp->q_top) {
 8002cf6:	42a9      	cmp	r1, r5
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 8002cf8:	781c      	ldrb	r4, [r3, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 8002cfa:	d301      	bcc.n	8002d00 <chOQGetI+0x20>
    oqp->q_rdptr = oqp->q_buffer;
 8002cfc:	68c3      	ldr	r3, [r0, #12]
 8002cfe:	6183      	str	r3, [r0, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 8002d00:	2100      	movs	r1, #0
 8002d02:	f7fe fffd 	bl	8001d00 <chThdDequeueNextI>

  return (msg_t)b;
 8002d06:	4620      	mov	r0, r4
 8002d08:	bd38      	pop	{r3, r4, r5, pc}
 8002d0a:	6882      	ldr	r2, [r0, #8]
 8002d0c:	2a00      	cmp	r2, #0
 8002d0e:	d0ec      	beq.n	8002cea <chOQGetI+0xa>
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
 8002d10:	f06f 0002 	mvn.w	r0, #2
 8002d14:	bd38      	pop	{r3, r4, r5, pc}
 8002d16:	bf00      	nop
	...

08002d20 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8002d20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002d24:	b083      	sub	sp, #12
 8002d26:	4604      	mov	r4, r0
 8002d28:	468b      	mov	fp, r1
 8002d2a:	4615      	mov	r5, r2
 8002d2c:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = oqp->q_notify;
 8002d2e:	69c7      	ldr	r7, [r0, #28]
 8002d30:	f04f 0820 	mov.w	r8, #32
 8002d34:	f388 8811 	msr	BASEPRI, r8
  size_t w = 0;
 8002d38:	2600      	movs	r6, #0
 8002d3a:	46b1      	mov	r9, r6
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8002d3c:	68a3      	ldr	r3, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8002d3e:	f10b 0a01 	add.w	sl, fp, #1

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8002d42:	b1fb      	cbz	r3, 8002d84 <chOQWriteTimeout+0x64>
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8002d44:	6962      	ldr	r2, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8002d46:	68a3      	ldr	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8002d48:	1c50      	adds	r0, r2, #1
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8002d4a:	3b01      	subs	r3, #1
    *oqp->q_wrptr++ = *bp++;
 8002d4c:	6160      	str	r0, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8002d4e:	60a3      	str	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8002d50:	f89b 3000 	ldrb.w	r3, [fp]
 8002d54:	7013      	strb	r3, [r2, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8002d56:	6923      	ldr	r3, [r4, #16]
 8002d58:	6962      	ldr	r2, [r4, #20]
 8002d5a:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
 8002d5c:	bf24      	itt	cs
 8002d5e:	68e3      	ldrcs	r3, [r4, #12]
 8002d60:	6163      	strcs	r3, [r4, #20]
    }

    if (nfy != NULL) {
 8002d62:	b10f      	cbz	r7, 8002d68 <chOQWriteTimeout+0x48>
      nfy(oqp);
 8002d64:	4620      	mov	r0, r4
 8002d66:	47b8      	blx	r7
 8002d68:	f389 8811 	msr	BASEPRI, r9
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
 8002d6c:	3d01      	subs	r5, #1
    if (nfy != NULL) {
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
 8002d6e:	f106 0601 	add.w	r6, r6, #1
    if (--n == 0U) {
 8002d72:	d011      	beq.n	8002d98 <chOQWriteTimeout+0x78>
 8002d74:	f388 8811 	msr	BASEPRI, r8
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8002d78:	46d3      	mov	fp, sl
 8002d7a:	68a3      	ldr	r3, [r4, #8]
 8002d7c:	f10b 0a01 	add.w	sl, fp, #1

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8002d80:	2b00      	cmp	r3, #0
 8002d82:	d1df      	bne.n	8002d44 <chOQWriteTimeout+0x24>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 8002d84:	4620      	mov	r0, r4
 8002d86:	9901      	ldr	r1, [sp, #4]
 8002d88:	9300      	str	r3, [sp, #0]
 8002d8a:	f7fe ffa1 	bl	8001cd0 <chThdEnqueueTimeoutS>
 8002d8e:	9b00      	ldr	r3, [sp, #0]
 8002d90:	2800      	cmp	r0, #0
 8002d92:	d0d3      	beq.n	8002d3c <chOQWriteTimeout+0x1c>
 8002d94:	f383 8811 	msr	BASEPRI, r3
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 8002d98:	4630      	mov	r0, r6
 8002d9a:	b003      	add	sp, #12
 8002d9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08002da0 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8002da0:	4a05      	ldr	r2, [pc, #20]	; (8002db8 <_core_init+0x18>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8002da2:	4b06      	ldr	r3, [pc, #24]	; (8002dbc <_core_init+0x1c>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8002da4:	4806      	ldr	r0, [pc, #24]	; (8002dc0 <_core_init+0x20>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8002da6:	4907      	ldr	r1, [pc, #28]	; (8002dc4 <_core_init+0x24>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8002da8:	f022 0207 	bic.w	r2, r2, #7
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8002dac:	f023 0307 	bic.w	r3, r3, #7
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8002db0:	6002      	str	r2, [r0, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8002db2:	600b      	str	r3, [r1, #0]
 8002db4:	4770      	bx	lr
 8002db6:	bf00      	nop
 8002db8:	200030d7 	.word	0x200030d7
 8002dbc:	2000c000 	.word	0x2000c000
 8002dc0:	20001294 	.word	0x20001294
 8002dc4:	20001290 	.word	0x20001290
	...

08002dd0 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8002dd0:	b410      	push	{r4}
 8002dd2:	2320      	movs	r3, #32
 8002dd4:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8002dd8:	4c09      	ldr	r4, [pc, #36]	; (8002e00 <chCoreAlloc+0x30>)
 8002dda:	4b0a      	ldr	r3, [pc, #40]	; (8002e04 <chCoreAlloc+0x34>)
 8002ddc:	6822      	ldr	r2, [r4, #0]
 8002dde:	6819      	ldr	r1, [r3, #0]
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8002de0:	1dc3      	adds	r3, r0, #7
 8002de2:	f023 0307 	bic.w	r3, r3, #7
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8002de6:	1a89      	subs	r1, r1, r2
 8002de8:	428b      	cmp	r3, r1
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 8002dea:	bf9d      	ittte	ls
 8002dec:	189b      	addls	r3, r3, r2
 8002dee:	6023      	strls	r3, [r4, #0]

  return p;
 8002df0:	4610      	movls	r0, r2

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
  /*lint -restore*/
    return NULL;
 8002df2:	2000      	movhi	r0, #0
 8002df4:	2300      	movs	r3, #0
 8002df6:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 8002dfa:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002dfe:	4770      	bx	lr
 8002e00:	20001294 	.word	0x20001294
 8002e04:	20001290 	.word	0x20001290
	...

08002e10 <chCoreGetStatusX>:
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(endmem - nextmem);
 8002e10:	4a02      	ldr	r2, [pc, #8]	; (8002e1c <chCoreGetStatusX+0xc>)
 8002e12:	4b03      	ldr	r3, [pc, #12]	; (8002e20 <chCoreGetStatusX+0x10>)
 8002e14:	6810      	ldr	r0, [r2, #0]
 8002e16:	681b      	ldr	r3, [r3, #0]
  /*lint -restore*/
}
 8002e18:	1ac0      	subs	r0, r0, r3
 8002e1a:	4770      	bx	lr
 8002e1c:	20001290 	.word	0x20001290
 8002e20:	20001294 	.word	0x20001294
	...

08002e30 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8002e30:	4b04      	ldr	r3, [pc, #16]	; (8002e44 <_heap_init+0x14>)
 8002e32:	4905      	ldr	r1, [pc, #20]	; (8002e48 <_heap_init+0x18>)
  default_heap.h_free.h.u.next = NULL;
 8002e34:	2200      	movs	r2, #0
  default_heap.h_free.h.size = 0;
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8002e36:	f103 0010 	add.w	r0, r3, #16
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8002e3a:	6019      	str	r1, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
 8002e3c:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 8002e3e:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8002e40:	f7ff b94e 	b.w	80020e0 <chMtxObjectInit>
 8002e44:	20001298 	.word	0x20001298
 8002e48:	08002dd1 	.word	0x08002dd1
 8002e4c:	00000000 	.word	0x00000000

08002e50 <chHeapObjectInit>:
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 8002e50:	2300      	movs	r3, #0
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 8002e52:	3a08      	subs	r2, #8
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
  heapp->h_free.h.u.next = hp;
 8002e54:	6081      	str	r1, [r0, #8]
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 8002e56:	6003      	str	r3, [r0, #0]
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
 8002e58:	60c3      	str	r3, [r0, #12]
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&heapp->h_mtx);
 8002e5a:	3010      	adds	r0, #16

  heapp->h_provider = NULL;
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 8002e5c:	604a      	str	r2, [r1, #4]
  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
 8002e5e:	600b      	str	r3, [r1, #0]
  hp->h.size = size - sizeof(union heap_header);
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&heapp->h_mtx);
 8002e60:	f7ff b93e 	b.w	80020e0 <chMtxObjectInit>
	...

08002e70 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 8002e70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL) {
    heapp = &default_heap;
 8002e72:	4e21      	ldr	r6, [pc, #132]	; (8002ef8 <chHeapAlloc+0x88>)
  }

  size = MEM_ALIGN_NEXT(size);
 8002e74:	3107      	adds	r1, #7
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL) {
    heapp = &default_heap;
 8002e76:	2800      	cmp	r0, #0
 8002e78:	bf18      	it	ne
 8002e7a:	4606      	movne	r6, r0
  }

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
 8002e7c:	f106 0710 	add.w	r7, r6, #16
 8002e80:	4638      	mov	r0, r7

  if (heapp == NULL) {
    heapp = &default_heap;
  }

  size = MEM_ALIGN_NEXT(size);
 8002e82:	f021 0507 	bic.w	r5, r1, #7
  qp = &heapp->h_free;
 8002e86:	f106 0408 	add.w	r4, r6, #8

  H_LOCK(heapp);
 8002e8a:	f7ff f999 	bl	80021c0 <chMtxLock>
  while (qp->h.u.next != NULL) {
 8002e8e:	e003      	b.n	8002e98 <chHeapAlloc+0x28>
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
 8002e90:	6843      	ldr	r3, [r0, #4]
 8002e92:	429d      	cmp	r5, r3
 8002e94:	d912      	bls.n	8002ebc <chHeapAlloc+0x4c>
 8002e96:	4604      	mov	r4, r0

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
 8002e98:	6820      	ldr	r0, [r4, #0]
 8002e9a:	2800      	cmp	r0, #0
 8002e9c:	d1f8      	bne.n	8002e90 <chHeapAlloc+0x20>
      return (void *)(hp + 1);
      /*lint -restore*/
    }
    qp = hp;
  }
  H_UNLOCK(heapp);
 8002e9e:	4638      	mov	r0, r7
 8002ea0:	f7ff f9b6 	bl	8002210 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider != NULL) {
 8002ea4:	6833      	ldr	r3, [r6, #0]
 8002ea6:	b323      	cbz	r3, 8002ef2 <chHeapAlloc+0x82>
    hp = heapp->h_provider(size + sizeof(union heap_header));
 8002ea8:	f105 0008 	add.w	r0, r5, #8
 8002eac:	4798      	blx	r3
    if (hp != NULL) {
 8002eae:	b300      	cbz	r0, 8002ef2 <chHeapAlloc+0x82>
      hp->h.u.heap = heapp;
 8002eb0:	6006      	str	r6, [r0, #0]
      hp->h.size = size;
 8002eb2:	6045      	str	r5, [r0, #4]
      hp++;
 8002eb4:	f100 0408 	add.w	r4, r0, #8
      /*lint -restore*/
    }
  }

  return NULL;
}
 8002eb8:	4620      	mov	r0, r4
 8002eba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
      if (hp->h.size < (size + sizeof(union heap_header))) {
 8002ebc:	f105 0108 	add.w	r1, r5, #8
 8002ec0:	4299      	cmp	r1, r3
 8002ec2:	d909      	bls.n	8002ed8 <chHeapAlloc+0x68>
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
 8002ec4:	6803      	ldr	r3, [r0, #0]
 8002ec6:	6023      	str	r3, [r4, #0]
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
        qp->h.u.next = fp;
        hp->h.size = size;
      }
      hp->h.u.heap = heapp;
 8002ec8:	4604      	mov	r4, r0
      H_UNLOCK(heapp);
 8002eca:	4638      	mov	r0, r7
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
        qp->h.u.next = fp;
        hp->h.size = size;
      }
      hp->h.u.heap = heapp;
 8002ecc:	f844 6b08 	str.w	r6, [r4], #8
      H_UNLOCK(heapp);
 8002ed0:	f7ff f99e 	bl	8002210 <chMtxUnlock>
      /*lint -restore*/
    }
  }

  return NULL;
}
 8002ed4:	4620      	mov	r0, r4
 8002ed6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002ed8:	f06f 0e07 	mvn.w	lr, #7
 8002edc:	ebc5 0e0e 	rsb	lr, r5, lr
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 8002ee0:	449e      	add	lr, r3
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
 8002ee2:	6803      	ldr	r3, [r0, #0]
        qp->h.u.next = hp->h.u.next;
      }
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
 8002ee4:	1842      	adds	r2, r0, r1
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
 8002ee6:	5043      	str	r3, [r0, r1]
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 8002ee8:	f8c2 e004 	str.w	lr, [r2, #4]
        qp->h.u.next = fp;
 8002eec:	6022      	str	r2, [r4, #0]
        hp->h.size = size;
 8002eee:	6045      	str	r5, [r0, #4]
 8002ef0:	e7ea      	b.n	8002ec8 <chHeapAlloc+0x58>
      return (void *)hp;
      /*lint -restore*/
    }
  }

  return NULL;
 8002ef2:	2400      	movs	r4, #0
 8002ef4:	e7e0      	b.n	8002eb8 <chHeapAlloc+0x48>
 8002ef6:	bf00      	nop
 8002ef8:	20001298 	.word	0x20001298
 8002efc:	00000000 	.word	0x00000000

08002f00 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8002f00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  chDbgCheck(p != NULL);

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
  /*lint -restore*/
  heapp = hp->h.u.heap;
 8002f02:	f850 5c08 	ldr.w	r5, [r0, #-8]
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8002f06:	4606      	mov	r6, r0
  hp = (union heap_header *)p - 1;
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;

  H_LOCK(heapp);
 8002f08:	f105 0710 	add.w	r7, r5, #16
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
 8002f0c:	f1a0 0408 	sub.w	r4, r0, #8
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 8002f10:	3508      	adds	r5, #8

  H_LOCK(heapp);
 8002f12:	4638      	mov	r0, r7
 8002f14:	f7ff f954 	bl	80021c0 <chMtxLock>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 8002f18:	462b      	mov	r3, r5

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 8002f1a:	42ab      	cmp	r3, r5
 8002f1c:	d004      	beq.n	8002f28 <chHeapFree+0x28>
 8002f1e:	42a3      	cmp	r3, r4
 8002f20:	d302      	bcc.n	8002f28 <chHeapFree+0x28>
 8002f22:	681b      	ldr	r3, [r3, #0]
 8002f24:	42ab      	cmp	r3, r5
 8002f26:	d1fa      	bne.n	8002f1e <chHeapFree+0x1e>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 8002f28:	681a      	ldr	r2, [r3, #0]

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 8002f2a:	b11a      	cbz	r2, 8002f34 <chHeapFree+0x34>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 8002f2c:	4294      	cmp	r4, r2
 8002f2e:	d301      	bcc.n	8002f34 <chHeapFree+0x34>
 8002f30:	4613      	mov	r3, r2
        qp->h.u.next = hp->h.u.next;
      }
      break;
    }
    qp = qp->h.u.next;
  }
 8002f32:	e7f2      	b.n	8002f1a <chHeapFree+0x1a>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 8002f34:	f856 1c04 	ldr.w	r1, [r6, #-4]
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
 8002f38:	f846 2c08 	str.w	r2, [r6, #-8]
      qp->h.u.next = hp;
 8002f3c:	601c      	str	r4, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 8002f3e:	f101 0208 	add.w	r2, r1, #8
 8002f42:	f856 5c08 	ldr.w	r5, [r6, #-8]
 8002f46:	18a0      	adds	r0, r4, r2
 8002f48:	42a8      	cmp	r0, r5
 8002f4a:	d00a      	beq.n	8002f62 <chHeapFree+0x62>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
 8002f4c:	6859      	ldr	r1, [r3, #4]
 8002f4e:	f101 0208 	add.w	r2, r1, #8
 8002f52:	441a      	add	r2, r3
 8002f54:	4294      	cmp	r4, r2
 8002f56:	d010      	beq.n	8002f7a <chHeapFree+0x7a>
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 8002f58:	4638      	mov	r0, r7

  return;
}
 8002f5a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 8002f5e:	f7ff b957 	b.w	8002210 <chMtxUnlock>
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 8002f62:	6845      	ldr	r5, [r0, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
 8002f64:	58a0      	ldr	r0, [r4, r2]
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 8002f66:	194a      	adds	r2, r1, r5
 8002f68:	3208      	adds	r2, #8
        hp->h.u.next = hp->h.u.next->h.u.next;
 8002f6a:	e906 0005 	stmdb	r6, {r0, r2}
      }
      if ((LIMIT(qp) == hp)) {
 8002f6e:	6859      	ldr	r1, [r3, #4]
 8002f70:	f101 0208 	add.w	r2, r1, #8
 8002f74:	441a      	add	r2, r3
 8002f76:	4294      	cmp	r4, r2
 8002f78:	d1ee      	bne.n	8002f58 <chHeapFree+0x58>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
        qp->h.u.next = hp->h.u.next;
 8002f7a:	e916 0005 	ldmdb	r6, {r0, r2}
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 8002f7e:	440a      	add	r2, r1
 8002f80:	3208      	adds	r2, #8
        qp->h.u.next = hp->h.u.next;
 8002f82:	e883 0005 	stmia.w	r3, {r0, r2}
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 8002f86:	4638      	mov	r0, r7

  return;
}
 8002f88:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 8002f8c:	f7ff b940 	b.w	8002210 <chMtxUnlock>

08002f90 <chHeapStatus>:
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
 8002f90:	b570      	push	{r4, r5, r6, lr}
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL) {
    heapp = &default_heap;
 8002f92:	4c0f      	ldr	r4, [pc, #60]	; (8002fd0 <chHeapStatus+0x40>)
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
 8002f94:	460e      	mov	r6, r1
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL) {
    heapp = &default_heap;
 8002f96:	2800      	cmp	r0, #0
 8002f98:	bf18      	it	ne
 8002f9a:	4604      	movne	r4, r0
  }

  H_LOCK(heapp);
 8002f9c:	f104 0510 	add.w	r5, r4, #16
 8002fa0:	4628      	mov	r0, r5
 8002fa2:	f7ff f90d 	bl	80021c0 <chMtxLock>
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8002fa6:	68a3      	ldr	r3, [r4, #8]
 8002fa8:	b173      	cbz	r3, 8002fc8 <chHeapStatus+0x38>
 8002faa:	2200      	movs	r2, #0
 8002fac:	4614      	mov	r4, r2
    sz += qp->h.u.next->h.size;
 8002fae:	6858      	ldr	r0, [r3, #4]

  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8002fb0:	681b      	ldr	r3, [r3, #0]
    sz += qp->h.u.next->h.size;
    n++;
 8002fb2:	3401      	adds	r4, #1
  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
    sz += qp->h.u.next->h.size;
 8002fb4:	4402      	add	r2, r0

  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8002fb6:	2b00      	cmp	r3, #0
 8002fb8:	d1f9      	bne.n	8002fae <chHeapStatus+0x1e>
    sz += qp->h.u.next->h.size;
    n++;
    qp = qp->h.u.next;
  }
  if (sizep != NULL) {
 8002fba:	b106      	cbz	r6, 8002fbe <chHeapStatus+0x2e>
    *sizep = sz;
 8002fbc:	6032      	str	r2, [r6, #0]
  }
  H_UNLOCK(heapp);
 8002fbe:	4628      	mov	r0, r5
 8002fc0:	f7ff f926 	bl	8002210 <chMtxUnlock>

  return n;
}
 8002fc4:	4620      	mov	r0, r4
 8002fc6:	bd70      	pop	{r4, r5, r6, pc}
  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  sz = 0;
 8002fc8:	461a      	mov	r2, r3
  n = 0;
 8002fca:	461c      	mov	r4, r3
 8002fcc:	e7f5      	b.n	8002fba <chHeapStatus+0x2a>
 8002fce:	bf00      	nop
 8002fd0:	20001298 	.word	0x20001298
	...

08002fe0 <chPoolObjectInit>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 8002fe0:	2300      	movs	r3, #0
  mp->mp_object_size = size;
 8002fe2:	6041      	str	r1, [r0, #4]
  mp->mp_provider = provider;
 8002fe4:	6082      	str	r2, [r0, #8]
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 8002fe6:	6003      	str	r3, [r0, #0]
 8002fe8:	4770      	bx	lr
 8002fea:	bf00      	nop
 8002fec:	0000      	movs	r0, r0
	...

08002ff0 <chPoolLoadArray>:
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8002ff0:	b172      	cbz	r2, 8003010 <chPoolLoadArray+0x20>
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {
 8002ff2:	b430      	push	{r4, r5}
 8002ff4:	2520      	movs	r5, #32
 8002ff6:	2400      	movs	r4, #0
 8002ff8:	f385 8811 	msr	BASEPRI, r5
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8002ffc:	6803      	ldr	r3, [r0, #0]
 8002ffe:	600b      	str	r3, [r1, #0]
  mp->mp_next = php;
 8003000:	6001      	str	r1, [r0, #0]
 8003002:	f384 8811 	msr	BASEPRI, r4
  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
 8003006:	6843      	ldr	r3, [r0, #4]
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8003008:	3a01      	subs	r2, #1
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
 800300a:	4419      	add	r1, r3
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 800300c:	d1f4      	bne.n	8002ff8 <chPoolLoadArray+0x8>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
    /*lint -restore*/
    n--;
  }
}
 800300e:	bc30      	pop	{r4, r5}
 8003010:	4770      	bx	lr
 8003012:	bf00      	nop
	...

08003020 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 8003020:	b508      	push	{r3, lr}
 8003022:	2220      	movs	r2, #32
 8003024:	4603      	mov	r3, r0
 8003026:	f382 8811 	msr	BASEPRI, r2
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  objp = mp->mp_next;
 800302a:	6800      	ldr	r0, [r0, #0]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 800302c:	b128      	cbz	r0, 800303a <chPoolAlloc+0x1a>
    mp->mp_next = mp->mp_next->ph_next;
 800302e:	6802      	ldr	r2, [r0, #0]
 8003030:	601a      	str	r2, [r3, #0]
 8003032:	2300      	movs	r3, #0
 8003034:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  objp = chPoolAllocI(mp);
  chSysUnlock();

  return objp;
}
 8003038:	bd08      	pop	{r3, pc}
  objp = mp->mp_next;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    mp->mp_next = mp->mp_next->ph_next;
  }
  else if (mp->mp_provider != NULL) {
 800303a:	689a      	ldr	r2, [r3, #8]
 800303c:	2a00      	cmp	r2, #0
 800303e:	d0f8      	beq.n	8003032 <chPoolAlloc+0x12>
    objp = mp->mp_provider(mp->mp_object_size);
 8003040:	6858      	ldr	r0, [r3, #4]
 8003042:	4790      	blx	r2
 8003044:	2300      	movs	r3, #0
 8003046:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  objp = chPoolAllocI(mp);
  chSysUnlock();

  return objp;
}
 800304a:	bd08      	pop	{r3, pc}
 800304c:	0000      	movs	r0, r0
	...

08003050 <chPoolFree>:
 8003050:	2320      	movs	r3, #32
 8003052:	f383 8811 	msr	BASEPRI, r3
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8003056:	6802      	ldr	r2, [r0, #0]
 8003058:	2300      	movs	r3, #0
 800305a:	600a      	str	r2, [r1, #0]
  mp->mp_next = php;
 800305c:	6001      	str	r1, [r0, #0]
 800305e:	f383 8811 	msr	BASEPRI, r3
 8003062:	4770      	bx	lr
	...

08003070 <SVC_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003070:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8003074:	3320      	adds	r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8003076:	f383 8809 	msr	PSP, r3

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800307a:	2300      	movs	r3, #0
 800307c:	f383 8811 	msr	BASEPRI, r3
 8003080:	4770      	bx	lr
 8003082:	bf00      	nop
	...

08003090 <_port_irq_epilogue>:
 8003090:	2320      	movs	r3, #32
 8003092:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8003096:	4b0f      	ldr	r3, [pc, #60]	; (80030d4 <_port_irq_epilogue+0x44>)
 8003098:	685b      	ldr	r3, [r3, #4]
 800309a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800309e:	d102      	bne.n	80030a6 <_port_irq_epilogue+0x16>
 80030a0:	f383 8811 	msr	BASEPRI, r3
 80030a4:	4770      	bx	lr
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 80030a6:	b510      	push	{r4, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80030a8:	f3ef 8409 	mrs	r4, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 80030ac:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80030b0:	f844 3c04 	str.w	r3, [r4, #-4]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 80030b4:	f1a4 0320 	sub.w	r3, r4, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80030b8:	f383 8809 	msr	PSP, r3
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80030bc:	f7fe fc50 	bl	8001960 <chSchIsPreemptionRequired>
 80030c0:	b118      	cbz	r0, 80030ca <_port_irq_epilogue+0x3a>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80030c2:	4b05      	ldr	r3, [pc, #20]	; (80030d8 <_port_irq_epilogue+0x48>)
 80030c4:	f844 3c08 	str.w	r3, [r4, #-8]
 80030c8:	bd10      	pop	{r4, pc}
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80030ca:	4b04      	ldr	r3, [pc, #16]	; (80030dc <_port_irq_epilogue+0x4c>)
 80030cc:	f844 3c08 	str.w	r3, [r4, #-8]
 80030d0:	bd10      	pop	{r4, pc}
 80030d2:	bf00      	nop
 80030d4:	e000ed00 	.word	0xe000ed00
 80030d8:	08000251 	.word	0x08000251
 80030dc:	08000254 	.word	0x08000254

080030e0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 80030e0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 80030e2:	f001 f945 	bl	8004370 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 80030e6:	480a      	ldr	r0, [pc, #40]	; (8003110 <halInit+0x30>)
 80030e8:	f001 fb9a 	bl	8004820 <_pal_lld_init>
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
 80030ec:	f000 fa88 	bl	8003600 <adcInit>
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
#endif
#if (HAL_USE_I2C == TRUE) || defined(__DOXYGEN__)
  i2cInit();
 80030f0:	f000 fa96 	bl	8003620 <i2cInit>
#endif
#if (HAL_USE_MAC == TRUE) || defined(__DOXYGEN__)
  macInit();
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
 80030f4:	f000 fafc 	bl	80036f0 <pwmInit>
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 80030f8:	f000 fb4a 	bl	8003790 <sdInit>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 80030fc:	f000 fd90 	bl	8003c20 <usbInit>
#endif
#if (HAL_USE_MMC_SPI == TRUE) || defined(__DOXYGEN__)
  mmcInit();
#endif
#if (HAL_USE_SERIAL_USB == TRUE) || defined(__DOXYGEN__)
  sduInit();
 8003100:	f000 fc76 	bl	80039f0 <sduInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8003104:	f002 fbcc 	bl	80058a0 <boardInit>
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
#endif
}
 8003108:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 800310c:	f000 b808 	b.w	8003120 <stInit>
 8003110:	0800d730 	.word	0x0800d730
	...

08003120 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
 8003120:	f001 bb36 	b.w	8004790 <st_lld_init>
	...

08003130 <ibqObjectInit>:
 *
 * @init
 */
void ibqObjectInit(input_buffers_queue_t *ibqp, uint8_t *bp,
                   size_t size, size_t n,
                   bqnotify_t infy, void *link) {
 8003130:	b4f0      	push	{r4, r5, r6, r7}

  osalThreadQueueObjectInit(&ibqp->waiting);
  ibqp->bcounter = 0;
  ibqp->brdptr   = bp;
  ibqp->bwrptr   = bp;
  ibqp->btop     = bp + ((size + sizeof (size_t)) * n);
 8003132:	3204      	adds	r2, #4
 8003134:	fb03 1702 	mla	r7, r3, r2, r1
 *
 * @init
 */
void ibqObjectInit(input_buffers_queue_t *ibqp, uint8_t *bp,
                   size_t size, size_t n,
                   bqnotify_t infy, void *link) {
 8003138:	9e04      	ldr	r6, [sp, #16]
 800313a:	9d05      	ldr	r5, [sp, #20]

  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&ibqp->waiting);
  ibqp->bcounter = 0;
 800313c:	2400      	movs	r4, #0
  ibqp->brdptr   = bp;
  ibqp->bwrptr   = bp;
  ibqp->btop     = bp + ((size + sizeof (size_t)) * n);
 800313e:	6147      	str	r7, [r0, #20]
  ibqp->bsize    = size + sizeof (size_t);
  ibqp->bn       = n;
  ibqp->buffers  = bp;
  ibqp->ptr      = NULL;
  ibqp->top      = NULL;
  ibqp->notify   = infy;
 8003140:	62c6      	str	r6, [r0, #44]	; 0x2c
  ibqp->link     = link;
 8003142:	6305      	str	r5, [r0, #48]	; 0x30
                   bqnotify_t infy, void *link) {

  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&ibqp->waiting);
  ibqp->bcounter = 0;
 8003144:	6084      	str	r4, [r0, #8]
  ibqp->bwrptr   = bp;
  ibqp->btop     = bp + ((size + sizeof (size_t)) * n);
  ibqp->bsize    = size + sizeof (size_t);
  ibqp->bn       = n;
  ibqp->buffers  = bp;
  ibqp->ptr      = NULL;
 8003146:	6244      	str	r4, [r0, #36]	; 0x24
  ibqp->top      = NULL;
 8003148:	6284      	str	r4, [r0, #40]	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800314a:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 800314c:	6040      	str	r0, [r0, #4]

  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&ibqp->waiting);
  ibqp->bcounter = 0;
  ibqp->brdptr   = bp;
 800314e:	6101      	str	r1, [r0, #16]
  ibqp->bwrptr   = bp;
 8003150:	60c1      	str	r1, [r0, #12]
  ibqp->btop     = bp + ((size + sizeof (size_t)) * n);
  ibqp->bsize    = size + sizeof (size_t);
 8003152:	6182      	str	r2, [r0, #24]
  ibqp->bn       = n;
 8003154:	61c3      	str	r3, [r0, #28]
  ibqp->buffers  = bp;
 8003156:	6201      	str	r1, [r0, #32]
  ibqp->ptr      = NULL;
  ibqp->top      = NULL;
  ibqp->notify   = infy;
  ibqp->link     = link;
}
 8003158:	bcf0      	pop	{r4, r5, r6, r7}
 800315a:	4770      	bx	lr
 800315c:	0000      	movs	r0, r0
	...

08003160 <ibqResetI>:
void ibqResetI(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassI();

  ibqp->bcounter = 0;
  ibqp->brdptr   = ibqp->buffers;
 8003160:	6a01      	ldr	r1, [r0, #32]
 */
void ibqResetI(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassI();

  ibqp->bcounter = 0;
 8003162:	2200      	movs	r2, #0
  ibqp->brdptr   = ibqp->buffers;
 8003164:	6101      	str	r1, [r0, #16]
  ibqp->bwrptr   = ibqp->buffers;
 8003166:	60c1      	str	r1, [r0, #12]
 */
void ibqResetI(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassI();

  ibqp->bcounter = 0;
 8003168:	6082      	str	r2, [r0, #8]
  ibqp->brdptr   = ibqp->buffers;
  ibqp->bwrptr   = ibqp->buffers;
  ibqp->ptr      = NULL;
 800316a:	6242      	str	r2, [r0, #36]	; 0x24
  ibqp->top      = NULL;
 800316c:	6282      	str	r2, [r0, #40]	; 0x28
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 800316e:	f06f 0101 	mvn.w	r1, #1
 8003172:	f7fe bdd5 	b.w	8001d20 <chThdDequeueAllI>
 8003176:	bf00      	nop
	...

08003180 <ibqGetEmptyBufferI>:
 */
uint8_t *ibqGetEmptyBufferI(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassI();

  if (ibqIsFullI(ibqp)) {
 8003180:	68c3      	ldr	r3, [r0, #12]
 8003182:	6902      	ldr	r2, [r0, #16]
 8003184:	4293      	cmp	r3, r2
 8003186:	d001      	beq.n	800318c <ibqGetEmptyBufferI+0xc>
    return NULL;
  }

  return ibqp->bwrptr + sizeof (size_t);
 8003188:	1d18      	adds	r0, r3, #4
}
 800318a:	4770      	bx	lr
 */
uint8_t *ibqGetEmptyBufferI(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassI();

  if (ibqIsFullI(ibqp)) {
 800318c:	6882      	ldr	r2, [r0, #8]
 800318e:	2a00      	cmp	r2, #0
 8003190:	d0fa      	beq.n	8003188 <ibqGetEmptyBufferI+0x8>
    return NULL;
 8003192:	2000      	movs	r0, #0
 8003194:	4770      	bx	lr
 8003196:	bf00      	nop
	...

080031a0 <ibqPostFullBufferI>:
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @iclass
 */
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {
 80031a0:	b430      	push	{r4, r5}

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;
 80031a2:	68c4      	ldr	r4, [r0, #12]

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
  ibqp->bwrptr += ibqp->bsize;
  if (ibqp->bwrptr >= ibqp->btop) {
 80031a4:	6945      	ldr	r5, [r0, #20]

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;
 80031a6:	6021      	str	r1, [r4, #0]

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
  ibqp->bwrptr += ibqp->bsize;
 80031a8:	6983      	ldr	r3, [r0, #24]

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
 80031aa:	6882      	ldr	r2, [r0, #8]
  ibqp->bwrptr += ibqp->bsize;
 80031ac:	4423      	add	r3, r4
  if (ibqp->bwrptr >= ibqp->btop) {
 80031ae:	42ab      	cmp	r3, r5
  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
  ibqp->bwrptr += ibqp->bsize;
 80031b0:	60c3      	str	r3, [r0, #12]
  if (ibqp->bwrptr >= ibqp->btop) {
    ibqp->bwrptr = ibqp->buffers;
 80031b2:	bf28      	it	cs
 80031b4:	6a03      	ldrcs	r3, [r0, #32]

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
 80031b6:	f102 0201 	add.w	r2, r2, #1
 80031ba:	6082      	str	r2, [r0, #8]
  ibqp->bwrptr += ibqp->bsize;
  if (ibqp->bwrptr >= ibqp->btop) {
    ibqp->bwrptr = ibqp->buffers;
 80031bc:	bf28      	it	cs
 80031be:	60c3      	strcs	r3, [r0, #12]
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueNextI(tqp, msg);
 80031c0:	2100      	movs	r1, #0
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&ibqp->waiting, MSG_OK);
}
 80031c2:	bc30      	pop	{r4, r5}
 80031c4:	f7fe bd9c 	b.w	8001d00 <chThdDequeueNextI>
	...

080031d0 <ibqGetFullBufferTimeoutS>:
   * @retval MSG_RESET    if the queue has been reset.
   *
   * @sclass
   */
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 systime_t timeout) {
 80031d0:	b538      	push	{r3, r4, r5, lr}
 80031d2:	4604      	mov	r4, r0
 80031d4:	460d      	mov	r5, r1

  osalDbgCheckClassS();

  while (ibqIsEmptyI(ibqp)) {
 80031d6:	e005      	b.n	80031e4 <ibqGetFullBufferTimeoutS+0x14>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chThdEnqueueTimeoutS(tqp, time);
 80031d8:	4620      	mov	r0, r4
 80031da:	4629      	mov	r1, r5
 80031dc:	f7fe fd78 	bl	8001cd0 <chThdEnqueueTimeoutS>
    msg_t msg = osalThreadEnqueueTimeoutS(&ibqp->waiting, timeout);
    if (msg < MSG_OK) {
 80031e0:	2800      	cmp	r0, #0
 80031e2:	db09      	blt.n	80031f8 <ibqGetFullBufferTimeoutS+0x28>
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 systime_t timeout) {

  osalDbgCheckClassS();

  while (ibqIsEmptyI(ibqp)) {
 80031e4:	68a3      	ldr	r3, [r4, #8]
 80031e6:	2b00      	cmp	r3, #0
 80031e8:	d0f6      	beq.n	80031d8 <ibqGetFullBufferTimeoutS+0x8>
  }

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");

  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 80031ea:	6923      	ldr	r3, [r4, #16]
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 80031ec:	2000      	movs	r0, #0
 80031ee:	681a      	ldr	r2, [r3, #0]
  }

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");

  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 80031f0:	3304      	adds	r3, #4
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 80031f2:	441a      	add	r2, r3
 80031f4:	62a2      	str	r2, [r4, #40]	; 0x28
  }

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");

  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 80031f6:	6263      	str	r3, [r4, #36]	; 0x24
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);

  return MSG_OK;
}
 80031f8:	bd38      	pop	{r3, r4, r5, pc}
 80031fa:	bf00      	nop
 80031fc:	0000      	movs	r0, r0
	...

08003200 <ibqReleaseEmptyBufferS>:
   *
   * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
   *
   * @sclass
   */
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 8003200:	b410      	push	{r4}
  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
  ibqp->brdptr += ibqp->bsize;
 8003202:	6983      	ldr	r3, [r0, #24]
 8003204:	6904      	ldr	r4, [r0, #16]
  if (ibqp->brdptr >= ibqp->btop) {
 8003206:	6941      	ldr	r1, [r0, #20]
  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
  ibqp->brdptr += ibqp->bsize;
 8003208:	4423      	add	r3, r4
  if (ibqp->brdptr >= ibqp->btop) {
 800320a:	428b      	cmp	r3, r1
  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
  ibqp->brdptr += ibqp->bsize;
 800320c:	6103      	str	r3, [r0, #16]

  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
 800320e:	6882      	ldr	r2, [r0, #8]
  ibqp->brdptr += ibqp->bsize;
  if (ibqp->brdptr >= ibqp->btop) {
    ibqp->brdptr = ibqp->buffers;
 8003210:	bf28      	it	cs
 8003212:	6a03      	ldrcs	r3, [r0, #32]

  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
 8003214:	f102 32ff 	add.w	r2, r2, #4294967295
  ibqp->brdptr += ibqp->bsize;
  if (ibqp->brdptr >= ibqp->btop) {
    ibqp->brdptr = ibqp->buffers;
 8003218:	bf28      	it	cs
 800321a:	6103      	strcs	r3, [r0, #16]

  /* No "current" buffer.*/
  ibqp->ptr = NULL;

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
 800321c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c

  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
 800321e:	6082      	str	r2, [r0, #8]
  if (ibqp->brdptr >= ibqp->btop) {
    ibqp->brdptr = ibqp->buffers;
  }

  /* No "current" buffer.*/
  ibqp->ptr = NULL;
 8003220:	2200      	movs	r2, #0
 8003222:	6242      	str	r2, [r0, #36]	; 0x24

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
 8003224:	b113      	cbz	r3, 800322c <ibqReleaseEmptyBufferS+0x2c>
    ibqp->notify(ibqp);
  }
}
 8003226:	f85d 4b04 	ldr.w	r4, [sp], #4
  /* No "current" buffer.*/
  ibqp->ptr = NULL;

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
    ibqp->notify(ibqp);
 800322a:	4718      	bx	r3
  }
}
 800322c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003230:	4770      	bx	lr
 8003232:	bf00      	nop
	...

08003240 <ibqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, systime_t timeout) {
 8003240:	b538      	push	{r3, r4, r5, lr}
 8003242:	4604      	mov	r4, r0

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003244:	2320      	movs	r3, #32
 8003246:	f383 8811 	msr	BASEPRI, r3
  msg_t msg;

  osalSysLock();

  /* This condition indicates that a new buffer must be acquired.*/
  if (ibqp->ptr == NULL) {
 800324a:	6a45      	ldr	r5, [r0, #36]	; 0x24
 800324c:	b19d      	cbz	r5, 8003276 <ibqGetTimeout+0x36>
      return msg;
    }
  }

  /* Next byte from the buffer.*/
  msg = (msg_t)*ibqp->ptr;
 800324e:	462b      	mov	r3, r5
  ibqp->ptr++;

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
 8003250:	6aa2      	ldr	r2, [r4, #40]	; 0x28
      return msg;
    }
  }

  /* Next byte from the buffer.*/
  msg = (msg_t)*ibqp->ptr;
 8003252:	f813 5b01 	ldrb.w	r5, [r3], #1
  ibqp->ptr++;

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
 8003256:	4293      	cmp	r3, r2
    }
  }

  /* Next byte from the buffer.*/
  msg = (msg_t)*ibqp->ptr;
  ibqp->ptr++;
 8003258:	6263      	str	r3, [r4, #36]	; 0x24

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
 800325a:	d204      	bcs.n	8003266 <ibqGetTimeout+0x26>
 800325c:	2300      	movs	r3, #0
 800325e:	f383 8811 	msr	BASEPRI, r3
    ibqReleaseEmptyBufferS(ibqp);
  }

  osalSysUnlock();
  return msg;
 8003262:	4628      	mov	r0, r5
}
 8003264:	bd38      	pop	{r3, r4, r5, pc}
  ibqp->ptr++;

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
    ibqReleaseEmptyBufferS(ibqp);
 8003266:	4620      	mov	r0, r4
 8003268:	f7ff ffca 	bl	8003200 <ibqReleaseEmptyBufferS>
 800326c:	2300      	movs	r3, #0
 800326e:	f383 8811 	msr	BASEPRI, r3
  }

  osalSysUnlock();
  return msg;
 8003272:	4628      	mov	r0, r5
}
 8003274:	bd38      	pop	{r3, r4, r5, pc}

  osalSysLock();

  /* This condition indicates that a new buffer must be acquired.*/
  if (ibqp->ptr == NULL) {
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8003276:	f7ff ffab 	bl	80031d0 <ibqGetFullBufferTimeoutS>
    if (msg != MSG_OK) {
 800327a:	b908      	cbnz	r0, 8003280 <ibqGetTimeout+0x40>
 800327c:	6a65      	ldr	r5, [r4, #36]	; 0x24
 800327e:	e7e6      	b.n	800324e <ibqGetTimeout+0xe>
 8003280:	f385 8811 	msr	BASEPRI, r5
      osalSysUnlock();
      return msg;
 8003284:	bd38      	pop	{r3, r4, r5, pc}
 8003286:	bf00      	nop
	...

08003290 <ibqReadTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, systime_t timeout) {
 8003290:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003294:	4698      	mov	r8, r3
 8003296:	b083      	sub	sp, #12
 8003298:	4604      	mov	r4, r0
 800329a:	460e      	mov	r6, r1
 800329c:	4692      	mov	sl, r2
 800329e:	2320      	movs	r3, #32
 80032a0:	f383 8811 	msr	BASEPRI, r3
 80032a4:	4b3c      	ldr	r3, [pc, #240]	; (8003398 <ibqReadTimeout+0x108>)

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (ibqp->ptr == NULL) {
 80032a6:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80032a8:	8bdb      	ldrh	r3, [r3, #30]
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80032aa:	f108 37ff 	add.w	r7, r8, #4294967295
  systime_t deadline;

  osalSysLock();

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 80032ae:	4443      	add	r3, r8
 80032b0:	b29b      	uxth	r3, r3
    if (ibqp->ptr == NULL) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80032b2:	f64f 79fd 	movw	r9, #65533	; 0xfffd
 80032b6:	b2bf      	uxth	r7, r7
  systime_t deadline;

  osalSysLock();

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 80032b8:	9301      	str	r3, [sp, #4]
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, systime_t timeout) {
  size_t r = 0;
 80032ba:	2500      	movs	r5, #0

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (ibqp->ptr == NULL) {
 80032bc:	b3a1      	cbz	r1, 8003328 <ibqReadTimeout+0x98>
        return r;
      }
    }

    /* Size of the data chunk present in the current buffer.*/
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 80032be:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    if (size > (n - r)) {
 80032c0:	ebc5 0b0a 	rsb	fp, r5, sl
        return r;
      }
    }

    /* Size of the data chunk present in the current buffer.*/
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 80032c4:	1a5b      	subs	r3, r3, r1
 80032c6:	459b      	cmp	fp, r3
 80032c8:	bf28      	it	cs
 80032ca:	469b      	movcs	fp, r3
      size = n - r;
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 80032cc:	f1bb 0f40 	cmp.w	fp, #64	; 0x40
 80032d0:	d93a      	bls.n	8003348 <ibqReadTimeout+0xb8>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, 64U);
 80032d2:	4633      	mov	r3, r6
 80032d4:	f101 0240 	add.w	r2, r1, #64	; 0x40
 80032d8:	f8d1 b000 	ldr.w	fp, [r1]
 80032dc:	f8d1 c004 	ldr.w	ip, [r1, #4]
 80032e0:	f8d1 e008 	ldr.w	lr, [r1, #8]
 80032e4:	68c8      	ldr	r0, [r1, #12]
 80032e6:	3110      	adds	r1, #16
 80032e8:	4291      	cmp	r1, r2
 80032ea:	f8c3 b000 	str.w	fp, [r3]
 80032ee:	f8c3 c004 	str.w	ip, [r3, #4]
 80032f2:	f8c3 e008 	str.w	lr, [r3, #8]
 80032f6:	60d8      	str	r0, [r3, #12]
 80032f8:	f103 0310 	add.w	r3, r3, #16
 80032fc:	d1ec      	bne.n	80032d8 <ibqReadTimeout+0x48>
      bp        += 64U;
      ibqp->ptr += 64U;
 80032fe:	6a63      	ldr	r3, [r4, #36]	; 0x24
      ibqp->ptr += size;
      r         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8003300:	6aa2      	ldr	r2, [r4, #40]	; 0x28
       this impacts throughput however.*/
    if (size > 64U) {
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, 64U);
      bp        += 64U;
      ibqp->ptr += 64U;
 8003302:	3340      	adds	r3, #64	; 0x40
      ibqp->ptr += size;
      r         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8003304:	429a      	cmp	r2, r3
    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, 64U);
      bp        += 64U;
 8003306:	f106 0640 	add.w	r6, r6, #64	; 0x40
      ibqp->ptr += 64U;
      r         += 64U;
 800330a:	f105 0540 	add.w	r5, r5, #64	; 0x40
       this impacts throughput however.*/
    if (size > 64U) {
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, 64U);
      bp        += 64U;
      ibqp->ptr += 64U;
 800330e:	6263      	str	r3, [r4, #36]	; 0x24
      ibqp->ptr += size;
      r         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8003310:	d926      	bls.n	8003360 <ibqReadTimeout+0xd0>
 8003312:	2300      	movs	r3, #0
 8003314:	f383 8811 	msr	BASEPRI, r3
      ibqReleaseEmptyBufferS(ibqp);
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
    if (r >= n) {
 8003318:	4555      	cmp	r5, sl
 800331a:	d229      	bcs.n	8003370 <ibqReadTimeout+0xe0>
 800331c:	2320      	movs	r3, #32
 800331e:	f383 8811 	msr	BASEPRI, r3

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (ibqp->ptr == NULL) {
 8003322:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8003324:	2900      	cmp	r1, #0
 8003326:	d1ca      	bne.n	80032be <ibqReadTimeout+0x2e>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8003328:	454f      	cmp	r7, r9
 800332a:	d825      	bhi.n	8003378 <ibqReadTimeout+0xe8>
 800332c:	4b1a      	ldr	r3, [pc, #104]	; (8003398 <ibqReadTimeout+0x108>)
        msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 800332e:	9a01      	ldr	r2, [sp, #4]
 8003330:	8bdb      	ldrh	r3, [r3, #30]
 8003332:	1ad3      	subs	r3, r2, r3
 8003334:	b29b      	uxth	r3, r3

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8003336:	4598      	cmp	r8, r3
 8003338:	d32b      	bcc.n	8003392 <ibqReadTimeout+0x102>
          osalSysUnlock();
          return r;
        }
        msg = ibqGetFullBufferTimeoutS(ibqp, next_timeout);
 800333a:	4619      	mov	r1, r3
 800333c:	4620      	mov	r0, r4
 800333e:	f7ff ff47 	bl	80031d0 <ibqGetFullBufferTimeoutS>
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 8003342:	b9f8      	cbnz	r0, 8003384 <ibqReadTimeout+0xf4>
 8003344:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8003346:	e7ba      	b.n	80032be <ibqReadTimeout+0x2e>
      bp        += 64U;
      ibqp->ptr += 64U;
      r         += 64U;
    }
    else {
      memcpy(bp, ibqp->ptr, size);
 8003348:	4630      	mov	r0, r6
 800334a:	465a      	mov	r2, fp
 800334c:	f7fd ff78 	bl	8001240 <memcpy>
      bp        += size;
      ibqp->ptr += size;
 8003350:	6a63      	ldr	r3, [r4, #36]	; 0x24
      r         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8003352:	6aa2      	ldr	r2, [r4, #40]	; 0x28
      r         += 64U;
    }
    else {
      memcpy(bp, ibqp->ptr, size);
      bp        += size;
      ibqp->ptr += size;
 8003354:	445b      	add	r3, fp
      r         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8003356:	429a      	cmp	r2, r3
    }
    else {
      memcpy(bp, ibqp->ptr, size);
      bp        += size;
      ibqp->ptr += size;
      r         += size;
 8003358:	445d      	add	r5, fp
      ibqp->ptr += 64U;
      r         += 64U;
    }
    else {
      memcpy(bp, ibqp->ptr, size);
      bp        += size;
 800335a:	445e      	add	r6, fp
      ibqp->ptr += size;
 800335c:	6263      	str	r3, [r4, #36]	; 0x24
      r         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 800335e:	d8d8      	bhi.n	8003312 <ibqReadTimeout+0x82>
      ibqReleaseEmptyBufferS(ibqp);
 8003360:	4620      	mov	r0, r4
 8003362:	f7ff ff4d 	bl	8003200 <ibqReleaseEmptyBufferS>
 8003366:	2300      	movs	r3, #0
 8003368:	f383 8811 	msr	BASEPRI, r3
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
    if (r >= n) {
 800336c:	4555      	cmp	r5, sl
 800336e:	d3d5      	bcc.n	800331c <ibqReadTimeout+0x8c>
      return r;
    }
    osalSysLock();
  }
}
 8003370:	4628      	mov	r0, r5
 8003372:	b003      	add	sp, #12
 8003374:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
        msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8003378:	4620      	mov	r0, r4
 800337a:	4641      	mov	r1, r8
 800337c:	f7ff ff28 	bl	80031d0 <ibqGetFullBufferTimeoutS>
        }
        msg = ibqGetFullBufferTimeoutS(ibqp, next_timeout);
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 8003380:	2800      	cmp	r0, #0
 8003382:	d0df      	beq.n	8003344 <ibqReadTimeout+0xb4>
 8003384:	2300      	movs	r3, #0
 8003386:	f383 8811 	msr	BASEPRI, r3
    if (r >= n) {
      return r;
    }
    osalSysLock();
  }
}
 800338a:	4628      	mov	r0, r5
 800338c:	b003      	add	sp, #12
 800338e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003392:	f381 8811 	msr	BASEPRI, r1
        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
          osalSysUnlock();
          return r;
 8003396:	e7eb      	b.n	8003370 <ibqReadTimeout+0xe0>
 8003398:	20001160 	.word	0x20001160
 800339c:	00000000 	.word	0x00000000

080033a0 <obqObjectInit>:
 *
 * @init
 */
void obqObjectInit(output_buffers_queue_t *obqp, uint8_t *bp,
                   size_t size, size_t n,
                   bqnotify_t onfy, void *link) {
 80033a0:	b4f0      	push	{r4, r5, r6, r7}

  osalThreadQueueObjectInit(&obqp->waiting);
  obqp->bcounter = n;
  obqp->brdptr   = bp;
  obqp->bwrptr   = bp;
  obqp->btop     = bp + ((size + sizeof (size_t)) * n);
 80033a2:	3204      	adds	r2, #4
 80033a4:	fb02 1703 	mla	r7, r2, r3, r1
 *
 * @init
 */
void obqObjectInit(output_buffers_queue_t *obqp, uint8_t *bp,
                   size_t size, size_t n,
                   bqnotify_t onfy, void *link) {
 80033a8:	9e04      	ldr	r6, [sp, #16]
 80033aa:	9d05      	ldr	r5, [sp, #20]
  obqp->bwrptr   = bp;
  obqp->btop     = bp + ((size + sizeof (size_t)) * n);
  obqp->bsize    = size + sizeof (size_t);
  obqp->bn       = n;
  obqp->buffers  = bp;
  obqp->ptr      = NULL;
 80033ac:	2400      	movs	r4, #0

  osalThreadQueueObjectInit(&obqp->waiting);
  obqp->bcounter = n;
  obqp->brdptr   = bp;
  obqp->bwrptr   = bp;
  obqp->btop     = bp + ((size + sizeof (size_t)) * n);
 80033ae:	6147      	str	r7, [r0, #20]
  obqp->bsize    = size + sizeof (size_t);
  obqp->bn       = n;
  obqp->buffers  = bp;
  obqp->ptr      = NULL;
  obqp->top      = NULL;
  obqp->notify   = onfy;
 80033b0:	62c6      	str	r6, [r0, #44]	; 0x2c
  obqp->link     = link;
 80033b2:	6305      	str	r5, [r0, #48]	; 0x30
  obqp->bwrptr   = bp;
  obqp->btop     = bp + ((size + sizeof (size_t)) * n);
  obqp->bsize    = size + sizeof (size_t);
  obqp->bn       = n;
  obqp->buffers  = bp;
  obqp->ptr      = NULL;
 80033b4:	6244      	str	r4, [r0, #36]	; 0x24
  obqp->top      = NULL;
 80033b6:	6284      	str	r4, [r0, #40]	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80033b8:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 80033ba:	6040      	str	r0, [r0, #4]
                   bqnotify_t onfy, void *link) {

  osalDbgCheck((obqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&obqp->waiting);
  obqp->bcounter = n;
 80033bc:	6083      	str	r3, [r0, #8]
  obqp->brdptr   = bp;
 80033be:	6101      	str	r1, [r0, #16]
  obqp->bwrptr   = bp;
 80033c0:	60c1      	str	r1, [r0, #12]
  obqp->btop     = bp + ((size + sizeof (size_t)) * n);
  obqp->bsize    = size + sizeof (size_t);
 80033c2:	6182      	str	r2, [r0, #24]
  obqp->bn       = n;
 80033c4:	61c3      	str	r3, [r0, #28]
  obqp->buffers  = bp;
 80033c6:	6201      	str	r1, [r0, #32]
  obqp->ptr      = NULL;
  obqp->top      = NULL;
  obqp->notify   = onfy;
  obqp->link     = link;
}
 80033c8:	bcf0      	pop	{r4, r5, r6, r7}
 80033ca:	4770      	bx	lr
 80033cc:	0000      	movs	r0, r0
	...

080033d0 <obqResetI>:
void obqResetI(output_buffers_queue_t *obqp) {

  osalDbgCheckClassI();

  obqp->bcounter = bqSizeX(obqp);
  obqp->brdptr   = obqp->buffers;
 80033d0:	6a01      	ldr	r1, [r0, #32]
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqResetI(output_buffers_queue_t *obqp) {
 80033d2:	b410      	push	{r4}

  osalDbgCheckClassI();

  obqp->bcounter = bqSizeX(obqp);
 80033d4:	69c4      	ldr	r4, [r0, #28]
  obqp->brdptr   = obqp->buffers;
  obqp->bwrptr   = obqp->buffers;
  obqp->ptr      = NULL;
 80033d6:	2200      	movs	r2, #0
 */
void obqResetI(output_buffers_queue_t *obqp) {

  osalDbgCheckClassI();

  obqp->bcounter = bqSizeX(obqp);
 80033d8:	6084      	str	r4, [r0, #8]
  obqp->brdptr   = obqp->buffers;
 80033da:	6101      	str	r1, [r0, #16]
  obqp->bwrptr   = obqp->buffers;
 80033dc:	60c1      	str	r1, [r0, #12]
  obqp->ptr      = NULL;
 80033de:	6242      	str	r2, [r0, #36]	; 0x24
  obqp->top      = NULL;
 80033e0:	6282      	str	r2, [r0, #40]	; 0x28
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 80033e2:	f06f 0101 	mvn.w	r1, #1
  osalThreadDequeueAllI(&obqp->waiting, MSG_RESET);
}
 80033e6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80033ea:	f7fe bc99 	b.w	8001d20 <chThdDequeueAllI>
 80033ee:	bf00      	nop

080033f0 <obqGetFullBufferI>:
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp,
                           size_t *sizep) {

  osalDbgCheckClassI();

  if (obqIsEmptyI(obqp)) {
 80033f0:	6903      	ldr	r3, [r0, #16]
 80033f2:	68c2      	ldr	r2, [r0, #12]
 80033f4:	429a      	cmp	r2, r3
 80033f6:	d004      	beq.n	8003402 <obqGetFullBufferI+0x12>
    return NULL;
  }

  /* Buffer size.*/
  *sizep = *((size_t *)obqp->brdptr);
 80033f8:	4618      	mov	r0, r3
 80033fa:	f850 3b04 	ldr.w	r3, [r0], #4
 80033fe:	600b      	str	r3, [r1, #0]

  return obqp->brdptr + sizeof (size_t);
}
 8003400:	4770      	bx	lr
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp,
                           size_t *sizep) {

  osalDbgCheckClassI();

  if (obqIsEmptyI(obqp)) {
 8003402:	6882      	ldr	r2, [r0, #8]
 8003404:	2a00      	cmp	r2, #0
 8003406:	d0f7      	beq.n	80033f8 <obqGetFullBufferI+0x8>
    return NULL;
 8003408:	2000      	movs	r0, #0
 800340a:	4770      	bx	lr
 800340c:	0000      	movs	r0, r0
	...

08003410 <obqReleaseEmptyBufferI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqReleaseEmptyBufferI(output_buffers_queue_t *obqp) {
 8003410:	b410      	push	{r4}
  osalDbgCheckClassI();
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
  obqp->brdptr += obqp->bsize;
 8003412:	6983      	ldr	r3, [r0, #24]
 8003414:	6904      	ldr	r4, [r0, #16]
  if (obqp->brdptr >= obqp->btop) {
 8003416:	6941      	ldr	r1, [r0, #20]
  osalDbgCheckClassI();
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
  obqp->brdptr += obqp->bsize;
 8003418:	4423      	add	r3, r4
  if (obqp->brdptr >= obqp->btop) {
 800341a:	428b      	cmp	r3, r1

  osalDbgCheckClassI();
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
 800341c:	6882      	ldr	r2, [r0, #8]
  obqp->brdptr += obqp->bsize;
 800341e:	6103      	str	r3, [r0, #16]
  if (obqp->brdptr >= obqp->btop) {
    obqp->brdptr = obqp->buffers;
 8003420:	bf28      	it	cs
 8003422:	6a03      	ldrcs	r3, [r0, #32]

  osalDbgCheckClassI();
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
 8003424:	f102 0201 	add.w	r2, r2, #1
 8003428:	6082      	str	r2, [r0, #8]
  obqp->brdptr += obqp->bsize;
  if (obqp->brdptr >= obqp->btop) {
    obqp->brdptr = obqp->buffers;
 800342a:	bf28      	it	cs
 800342c:	6103      	strcs	r3, [r0, #16]
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueNextI(tqp, msg);
 800342e:	2100      	movs	r1, #0
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&obqp->waiting, MSG_OK);
}
 8003430:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003434:	f7fe bc64 	b.w	8001d00 <chThdDequeueNextI>
	...

08003440 <obqGetEmptyBufferTimeoutS>:
   * @retval MSG_RESET    if the queue has been reset.
   *
   * @sclass
   */
  msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                  systime_t timeout) {
 8003440:	b538      	push	{r3, r4, r5, lr}
 8003442:	4604      	mov	r4, r0
 8003444:	460d      	mov	r5, r1

  osalDbgCheckClassS();

  while (obqIsFullI(obqp)) {
 8003446:	e005      	b.n	8003454 <obqGetEmptyBufferTimeoutS+0x14>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chThdEnqueueTimeoutS(tqp, time);
 8003448:	4620      	mov	r0, r4
 800344a:	4629      	mov	r1, r5
 800344c:	f7fe fc40 	bl	8001cd0 <chThdEnqueueTimeoutS>
    msg_t msg = osalThreadEnqueueTimeoutS(&obqp->waiting, timeout);
    if (msg < MSG_OK) {
 8003450:	2800      	cmp	r0, #0
 8003452:	db09      	blt.n	8003468 <obqGetEmptyBufferTimeoutS+0x28>
  msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                  systime_t timeout) {

  osalDbgCheckClassS();

  while (obqIsFullI(obqp)) {
 8003454:	68a3      	ldr	r3, [r4, #8]
 8003456:	2b00      	cmp	r3, #0
 8003458:	d0f6      	beq.n	8003448 <obqGetEmptyBufferTimeoutS+0x8>
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");

  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 800345a:	68e2      	ldr	r2, [r4, #12]
  obqp->top = obqp->bwrptr + obqp->bsize;
 800345c:	69a3      	ldr	r3, [r4, #24]
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");

  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 800345e:	1d11      	adds	r1, r2, #4
  obqp->top = obqp->bwrptr + obqp->bsize;
 8003460:	4413      	add	r3, r2
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");

  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 8003462:	6261      	str	r1, [r4, #36]	; 0x24
  obqp->top = obqp->bwrptr + obqp->bsize;
 8003464:	62a3      	str	r3, [r4, #40]	; 0x28
 8003466:	2000      	movs	r0, #0

  return MSG_OK;
}
 8003468:	bd38      	pop	{r3, r4, r5, pc}
 800346a:	bf00      	nop
 800346c:	0000      	movs	r0, r0
	...

08003470 <obqPostFullBufferS>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 8003470:	b430      	push	{r4, r5}
  osalDbgCheckClassS();
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
 8003472:	68c4      	ldr	r4, [r0, #12]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
  obqp->bwrptr += obqp->bsize;
  if (obqp->bwrptr >= obqp->btop) {
 8003474:	6945      	ldr	r5, [r0, #20]
  osalDbgCheckClassS();
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
 8003476:	6021      	str	r1, [r4, #0]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
  obqp->bwrptr += obqp->bsize;
 8003478:	6983      	ldr	r3, [r0, #24]

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
 800347a:	6882      	ldr	r2, [r0, #8]
  obqp->bwrptr += obqp->bsize;
 800347c:	4423      	add	r3, r4
  if (obqp->bwrptr >= obqp->btop) {
 800347e:	42ab      	cmp	r3, r5
  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
  obqp->bwrptr += obqp->bsize;
 8003480:	60c3      	str	r3, [r0, #12]
  if (obqp->bwrptr >= obqp->btop) {
    obqp->bwrptr = obqp->buffers;
 8003482:	bf28      	it	cs
 8003484:	6a03      	ldrcs	r3, [r0, #32]

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
 8003486:	f102 32ff 	add.w	r2, r2, #4294967295
  obqp->bwrptr += obqp->bsize;
  if (obqp->bwrptr >= obqp->btop) {
    obqp->bwrptr = obqp->buffers;
 800348a:	bf28      	it	cs
 800348c:	60c3      	strcs	r3, [r0, #12]

  /* No "current" buffer.*/
  obqp->ptr = NULL;

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 800348e:	6ac3      	ldr	r3, [r0, #44]	; 0x2c

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
 8003490:	6082      	str	r2, [r0, #8]
  if (obqp->bwrptr >= obqp->btop) {
    obqp->bwrptr = obqp->buffers;
  }

  /* No "current" buffer.*/
  obqp->ptr = NULL;
 8003492:	2200      	movs	r2, #0
 8003494:	6242      	str	r2, [r0, #36]	; 0x24

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 8003496:	b10b      	cbz	r3, 800349c <obqPostFullBufferS+0x2c>
    obqp->notify(obqp);
  }
}
 8003498:	bc30      	pop	{r4, r5}
  /* No "current" buffer.*/
  obqp->ptr = NULL;

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
    obqp->notify(obqp);
 800349a:	4718      	bx	r3
  }
}
 800349c:	bc30      	pop	{r4, r5}
 800349e:	4770      	bx	lr

080034a0 <obqPutTimeout>:
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t obqPutTimeout(output_buffers_queue_t *obqp, uint8_t b,
                    systime_t timeout) {
 80034a0:	b570      	push	{r4, r5, r6, lr}
 80034a2:	2320      	movs	r3, #32
 80034a4:	460e      	mov	r6, r1
 80034a6:	4604      	mov	r4, r0
 80034a8:	f383 8811 	msr	BASEPRI, r3
  msg_t msg;

  osalSysLock();

  /* This condition indicates that a new buffer must be acquired.*/
  if (obqp->ptr == NULL) {
 80034ac:	6a45      	ldr	r5, [r0, #36]	; 0x24
 80034ae:	b19d      	cbz	r5, 80034d8 <obqPutTimeout+0x38>
      return msg;
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
 80034b0:	702e      	strb	r6, [r5, #0]
  obqp->ptr++;
 80034b2:	6a63      	ldr	r3, [r4, #36]	; 0x24

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 80034b4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
  obqp->ptr++;
 80034b6:	3301      	adds	r3, #1

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 80034b8:	4293      	cmp	r3, r2
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
  obqp->ptr++;
 80034ba:	6263      	str	r3, [r4, #36]	; 0x24

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 80034bc:	d203      	bcs.n	80034c6 <obqPutTimeout+0x26>
 80034be:	2000      	movs	r0, #0
 80034c0:	f380 8811 	msr	BASEPRI, r0
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
  }

  osalSysUnlock();
  return MSG_OK;
}
 80034c4:	bd70      	pop	{r4, r5, r6, pc}
  obqp->ptr++;

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 80034c6:	69a1      	ldr	r1, [r4, #24]
 80034c8:	4620      	mov	r0, r4
 80034ca:	3904      	subs	r1, #4
 80034cc:	f7ff ffd0 	bl	8003470 <obqPostFullBufferS>
 80034d0:	2000      	movs	r0, #0
 80034d2:	f380 8811 	msr	BASEPRI, r0
  }

  osalSysUnlock();
  return MSG_OK;
}
 80034d6:	bd70      	pop	{r4, r5, r6, pc}

  osalSysLock();

  /* This condition indicates that a new buffer must be acquired.*/
  if (obqp->ptr == NULL) {
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 80034d8:	4611      	mov	r1, r2
 80034da:	f7ff ffb1 	bl	8003440 <obqGetEmptyBufferTimeoutS>
    if (msg != MSG_OK) {
 80034de:	b908      	cbnz	r0, 80034e4 <obqPutTimeout+0x44>
 80034e0:	6a65      	ldr	r5, [r4, #36]	; 0x24
 80034e2:	e7e5      	b.n	80034b0 <obqPutTimeout+0x10>
 80034e4:	f385 8811 	msr	BASEPRI, r5
      osalSysUnlock();
      return msg;
 80034e8:	bd70      	pop	{r4, r5, r6, pc}
 80034ea:	bf00      	nop
 80034ec:	0000      	movs	r0, r0
	...

080034f0 <obqWriteTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, systime_t timeout) {
 80034f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80034f4:	461f      	mov	r7, r3
 80034f6:	b083      	sub	sp, #12
 80034f8:	4604      	mov	r4, r0
 80034fa:	2320      	movs	r3, #32
 80034fc:	f383 8811 	msr	BASEPRI, r3
 8003500:	4b3c      	ldr	r3, [pc, #240]	; (80035f4 <obqWriteTimeout+0x104>)

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (obqp->ptr == NULL) {
 8003502:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8003504:	8bdb      	ldrh	r3, [r3, #30]
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8003506:	1e7e      	subs	r6, r7, #1
  systime_t deadline;

  osalSysLock();

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8003508:	443b      	add	r3, r7
 800350a:	b29b      	uxth	r3, r3
    if (obqp->ptr == NULL) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 800350c:	f64f 78fd 	movw	r8, #65533	; 0xfffd
 8003510:	b2b6      	uxth	r6, r6
  systime_t deadline;

  osalSysLock();

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8003512:	9301      	str	r3, [sp, #4]
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, systime_t timeout) {
  size_t w = 0;
 8003514:	2500      	movs	r5, #0
 8003516:	468a      	mov	sl, r1
 8003518:	4693      	mov	fp, r2

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (obqp->ptr == NULL) {
 800351a:	b398      	cbz	r0, 8003584 <obqWriteTimeout+0x94>
        return w;
      }
    }

    /* Size of the space available in the current buffer.*/
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 800351c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    if (size > (n - w)) {
 800351e:	ebc5 090b 	rsb	r9, r5, fp
        return w;
      }
    }

    /* Size of the space available in the current buffer.*/
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 8003522:	1a12      	subs	r2, r2, r0
 8003524:	4591      	cmp	r9, r2
 8003526:	bf28      	it	cs
 8003528:	4691      	movcs	r9, r2
      size = n - w;
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 800352a:	f1b9 0f40 	cmp.w	r9, #64	; 0x40
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, 64U);
 800352e:	4651      	mov	r1, sl
      size = n - w;
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 8003530:	d937      	bls.n	80035a2 <obqWriteTimeout+0xb2>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, 64U);
 8003532:	f10a 0340 	add.w	r3, sl, #64	; 0x40
 8003536:	f8d1 9000 	ldr.w	r9, [r1]
 800353a:	f8d1 c004 	ldr.w	ip, [r1, #4]
 800353e:	f8d1 e008 	ldr.w	lr, [r1, #8]
 8003542:	68ca      	ldr	r2, [r1, #12]
 8003544:	3110      	adds	r1, #16
 8003546:	4299      	cmp	r1, r3
 8003548:	f8c0 9000 	str.w	r9, [r0]
 800354c:	f8c0 c004 	str.w	ip, [r0, #4]
 8003550:	f8c0 e008 	str.w	lr, [r0, #8]
 8003554:	60c2      	str	r2, [r0, #12]
 8003556:	f100 0010 	add.w	r0, r0, #16
 800355a:	d1ec      	bne.n	8003536 <obqWriteTimeout+0x46>
      bp        += 64U;
      obqp->ptr += 64U;
 800355c:	6a62      	ldr	r2, [r4, #36]	; 0x24
    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, 64U);
      bp        += 64U;
 800355e:	468a      	mov	sl, r1
      obqp->ptr += size;
      w         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 8003560:	6aa1      	ldr	r1, [r4, #40]	; 0x28
       this impacts throughput however.*/
    if (size > 64U) {
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, 64U);
      bp        += 64U;
      obqp->ptr += 64U;
 8003562:	3240      	adds	r2, #64	; 0x40
      obqp->ptr += size;
      w         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 8003564:	4291      	cmp	r1, r2
    if (size > 64U) {
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, 64U);
      bp        += 64U;
      obqp->ptr += 64U;
      w         += 64U;
 8003566:	f105 0540 	add.w	r5, r5, #64	; 0x40
       this impacts throughput however.*/
    if (size > 64U) {
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, 64U);
      bp        += 64U;
      obqp->ptr += 64U;
 800356a:	6262      	str	r2, [r4, #36]	; 0x24
      obqp->ptr += size;
      w         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 800356c:	d924      	bls.n	80035b8 <obqWriteTimeout+0xc8>
 800356e:	2200      	movs	r2, #0
 8003570:	f382 8811 	msr	BASEPRI, r2
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
    if (w >= n) {
 8003574:	455d      	cmp	r5, fp
 8003576:	d229      	bcs.n	80035cc <obqWriteTimeout+0xdc>
 8003578:	2220      	movs	r2, #32
 800357a:	f382 8811 	msr	BASEPRI, r2

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (obqp->ptr == NULL) {
 800357e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8003580:	2800      	cmp	r0, #0
 8003582:	d1cb      	bne.n	800351c <obqWriteTimeout+0x2c>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8003584:	4546      	cmp	r6, r8
 8003586:	d825      	bhi.n	80035d4 <obqWriteTimeout+0xe4>
 8003588:	4b1a      	ldr	r3, [pc, #104]	; (80035f4 <obqWriteTimeout+0x104>)
 800358a:	8bd9      	ldrh	r1, [r3, #30]
        msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 800358c:	9b01      	ldr	r3, [sp, #4]
 800358e:	1a59      	subs	r1, r3, r1
 8003590:	b289      	uxth	r1, r1

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8003592:	428f      	cmp	r7, r1
 8003594:	d32b      	bcc.n	80035ee <obqWriteTimeout+0xfe>
          osalSysUnlock();
          return w;
        }
        msg = obqGetEmptyBufferTimeoutS(obqp, next_timeout);
 8003596:	4620      	mov	r0, r4
 8003598:	f7ff ff52 	bl	8003440 <obqGetEmptyBufferTimeoutS>
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 800359c:	bb00      	cbnz	r0, 80035e0 <obqWriteTimeout+0xf0>
 800359e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80035a0:	e7bc      	b.n	800351c <obqWriteTimeout+0x2c>
      bp        += 64U;
      obqp->ptr += 64U;
      w         += 64U;
    }
    else {
      memcpy(obqp->ptr, bp, size);
 80035a2:	464a      	mov	r2, r9
 80035a4:	f7fd fe4c 	bl	8001240 <memcpy>
      bp        += size;
      obqp->ptr += size;
 80035a8:	6a62      	ldr	r2, [r4, #36]	; 0x24
      w         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 80035aa:	6aa1      	ldr	r1, [r4, #40]	; 0x28
      w         += 64U;
    }
    else {
      memcpy(obqp->ptr, bp, size);
      bp        += size;
      obqp->ptr += size;
 80035ac:	444a      	add	r2, r9
      w         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 80035ae:	4291      	cmp	r1, r2
    }
    else {
      memcpy(obqp->ptr, bp, size);
      bp        += size;
      obqp->ptr += size;
      w         += size;
 80035b0:	444d      	add	r5, r9
      obqp->ptr += 64U;
      w         += 64U;
    }
    else {
      memcpy(obqp->ptr, bp, size);
      bp        += size;
 80035b2:	44ca      	add	sl, r9
      obqp->ptr += size;
 80035b4:	6262      	str	r2, [r4, #36]	; 0x24
      w         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 80035b6:	d8da      	bhi.n	800356e <obqWriteTimeout+0x7e>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 80035b8:	69a1      	ldr	r1, [r4, #24]
 80035ba:	4620      	mov	r0, r4
 80035bc:	3904      	subs	r1, #4
 80035be:	f7ff ff57 	bl	8003470 <obqPostFullBufferS>
 80035c2:	2200      	movs	r2, #0
 80035c4:	f382 8811 	msr	BASEPRI, r2
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
    if (w >= n) {
 80035c8:	455d      	cmp	r5, fp
 80035ca:	d3d5      	bcc.n	8003578 <obqWriteTimeout+0x88>
      return w;
    }
    osalSysLock();
  }
}
 80035cc:	4628      	mov	r0, r5
 80035ce:	b003      	add	sp, #12
 80035d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
        msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 80035d4:	4620      	mov	r0, r4
 80035d6:	4639      	mov	r1, r7
 80035d8:	f7ff ff32 	bl	8003440 <obqGetEmptyBufferTimeoutS>
        }
        msg = obqGetEmptyBufferTimeoutS(obqp, next_timeout);
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 80035dc:	2800      	cmp	r0, #0
 80035de:	d0de      	beq.n	800359e <obqWriteTimeout+0xae>
 80035e0:	2300      	movs	r3, #0
 80035e2:	f383 8811 	msr	BASEPRI, r3
    if (w >= n) {
      return w;
    }
    osalSysLock();
  }
}
 80035e6:	4628      	mov	r0, r5
 80035e8:	b003      	add	sp, #12
 80035ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80035ee:	f380 8811 	msr	BASEPRI, r0
        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
          osalSysUnlock();
          return w;
 80035f2:	e7eb      	b.n	80035cc <obqWriteTimeout+0xdc>
 80035f4:	20001160 	.word	0x20001160
	...

08003600 <adcInit>:
 *
 * @init
 */
void adcInit(void) {

  adc_lld_init();
 8003600:	f001 b8d6 	b.w	80047b0 <adc_lld_init>
	...

08003610 <adcObjectInit>:
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
  adcp->config   = NULL;
 8003610:	2300      	movs	r3, #0
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
 8003612:	2201      	movs	r2, #1
 8003614:	7002      	strb	r2, [r0, #0]
  adcp->config   = NULL;
 8003616:	6043      	str	r3, [r0, #4]
  adcp->samples  = NULL;
 8003618:	6083      	str	r3, [r0, #8]
  adcp->depth    = 0;
 800361a:	60c3      	str	r3, [r0, #12]
  adcp->grpp     = NULL;
 800361c:	6103      	str	r3, [r0, #16]
 800361e:	4770      	bx	lr

08003620 <i2cInit>:
 *
 * @init
 */
void i2cInit(void) {

  i2c_lld_init();
 8003620:	f001 bace 	b.w	8004bc0 <i2c_lld_init>
	...

08003630 <i2cObjectInit>:
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 8003630:	2201      	movs	r2, #1
  i2cp->config = NULL;
 8003632:	2300      	movs	r3, #0
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 8003634:	7002      	strb	r2, [r0, #0]
  i2cp->config = NULL;
 8003636:	6043      	str	r3, [r0, #4]
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8003638:	300c      	adds	r0, #12
 800363a:	f7fe bd51 	b.w	80020e0 <chMtxObjectInit>
 800363e:	bf00      	nop

08003640 <i2cStart>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] config    pointer to the @p I2CConfig object
 *
 * @api
 */
void i2cStart(I2CDriver *i2cp, const I2CConfig *config) {
 8003640:	b510      	push	{r4, lr}
 8003642:	2320      	movs	r3, #32
 8003644:	4604      	mov	r4, r0
 8003646:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 800364a:	6041      	str	r1, [r0, #4]
  i2c_lld_start(i2cp);
 800364c:	f001 fad0 	bl	8004bf0 <i2c_lld_start>
  i2cp->state = I2C_READY;
 8003650:	2302      	movs	r3, #2
 8003652:	7023      	strb	r3, [r4, #0]
 8003654:	2300      	movs	r3, #0
 8003656:	f383 8811 	msr	BASEPRI, r3
 800365a:	bd10      	pop	{r4, pc}
 800365c:	0000      	movs	r0, r0
	...

08003660 <i2cStop>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @api
 */
void i2cStop(I2CDriver *i2cp) {
 8003660:	b510      	push	{r4, lr}
 8003662:	2320      	movs	r3, #32
 8003664:	4604      	mov	r4, r0
 8003666:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(i2cp != NULL);
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2c_lld_stop(i2cp);
 800366a:	f001 fb79 	bl	8004d60 <i2c_lld_stop>
  i2cp->state = I2C_STOP;
 800366e:	2301      	movs	r3, #1
 8003670:	7023      	strb	r3, [r4, #0]
 8003672:	2300      	movs	r3, #0
 8003674:	f383 8811 	msr	BASEPRI, r3
 8003678:	bd10      	pop	{r4, pc}
 800367a:	bf00      	nop
 800367c:	0000      	movs	r0, r0
	...

08003680 <i2cGetErrors>:
i2cflags_t i2cGetErrors(I2CDriver *i2cp) {

  osalDbgCheck(i2cp != NULL);

  return i2c_lld_get_errors(i2cp);
}
 8003680:	6880      	ldr	r0, [r0, #8]
 8003682:	4770      	bx	lr
	...

08003690 <i2cMasterTransmitTimeout>:
                               i2caddr_t addr,
                               const uint8_t *txbuf,
                               size_t txbytes,
                               uint8_t *rxbuf,
                               size_t rxbytes,
                               systime_t timeout) {
 8003690:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003692:	b085      	sub	sp, #20
 8003694:	4604      	mov	r4, r0
 8003696:	f8bd 7030 	ldrh.w	r7, [sp, #48]	; 0x30
 800369a:	2520      	movs	r5, #32
 800369c:	f385 8811 	msr	BASEPRI, r5
  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 80036a0:	9d0a      	ldr	r5, [sp, #40]	; 0x28

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
 80036a2:	f04f 0e03 	mov.w	lr, #3
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 80036a6:	9500      	str	r5, [sp, #0]
 80036a8:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 80036aa:	2600      	movs	r6, #0
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 80036ac:	9501      	str	r5, [sp, #4]
 80036ae:	9702      	str	r7, [sp, #8]
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 80036b0:	6086      	str	r6, [r0, #8]
  i2cp->state = I2C_ACTIVE_TX;
 80036b2:	f880 e000 	strb.w	lr, [r0]
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 80036b6:	f001 fb93 	bl	8004de0 <i2c_lld_master_transmit_timeout>
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
 80036ba:	1c43      	adds	r3, r0, #1
    i2cp->state = I2C_LOCKED;
 80036bc:	bf0c      	ite	eq
 80036be:	2305      	moveq	r3, #5
  }
  else {
    i2cp->state = I2C_READY;
 80036c0:	2302      	movne	r3, #2
 80036c2:	7023      	strb	r3, [r4, #0]
 80036c4:	2300      	movs	r3, #0
 80036c6:	f383 8811 	msr	BASEPRI, r3
  }
  osalSysUnlock();
  return rdymsg;
}
 80036ca:	b005      	add	sp, #20
 80036cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80036ce:	bf00      	nop

080036d0 <i2cAcquireBus>:
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 80036d0:	300c      	adds	r0, #12
 80036d2:	f7fe bd75 	b.w	80021c0 <chMtxLock>
 80036d6:	bf00      	nop
	...

080036e0 <i2cReleaseBus>:
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 80036e0:	300c      	adds	r0, #12
 80036e2:	f7fe bd95 	b.w	8002210 <chMtxUnlock>
 80036e6:	bf00      	nop
	...

080036f0 <pwmInit>:
 *
 * @init
 */
void pwmInit(void) {

  pwm_lld_init();
 80036f0:	f001 bbc6 	b.w	8004e80 <pwm_lld_init>
	...

08003700 <pwmObjectInit>:
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
  pwmp->config   = NULL;
 8003700:	2300      	movs	r3, #0
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
 8003702:	2201      	movs	r2, #1
 8003704:	7002      	strb	r2, [r0, #0]
  pwmp->config   = NULL;
 8003706:	6043      	str	r3, [r0, #4]
  pwmp->enabled  = 0;
 8003708:	60c3      	str	r3, [r0, #12]
  pwmp->channels = 0;
 800370a:	7403      	strb	r3, [r0, #16]
 800370c:	4770      	bx	lr
 800370e:	bf00      	nop

08003710 <readt>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8003710:	300c      	adds	r0, #12
 8003712:	f7ff ba55 	b.w	8002bc0 <chIQReadTimeout>
 8003716:	bf00      	nop
	...

08003720 <read>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8003720:	300c      	adds	r0, #12
 8003722:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8003726:	f7ff ba4b 	b.w	8002bc0 <chIQReadTimeout>
 800372a:	bf00      	nop
 800372c:	0000      	movs	r0, r0
	...

08003730 <writet>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8003730:	3030      	adds	r0, #48	; 0x30
 8003732:	f7ff baf5 	b.w	8002d20 <chOQWriteTimeout>
 8003736:	bf00      	nop
	...

08003740 <write>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8003740:	3030      	adds	r0, #48	; 0x30
 8003742:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8003746:	f7ff baeb 	b.w	8002d20 <chOQWriteTimeout>
 800374a:	bf00      	nop
 800374c:	0000      	movs	r0, r0
	...

08003750 <gett>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8003750:	300c      	adds	r0, #12
 8003752:	f7ff ba0d 	b.w	8002b70 <chIQGetTimeout>
 8003756:	bf00      	nop
	...

08003760 <get>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8003760:	300c      	adds	r0, #12
 8003762:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8003766:	f7ff ba03 	b.w	8002b70 <chIQGetTimeout>
 800376a:	bf00      	nop
 800376c:	0000      	movs	r0, r0
	...

08003770 <putt>:
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8003770:	3030      	adds	r0, #48	; 0x30
 8003772:	f7ff ba85 	b.w	8002c80 <chOQPutTimeout>
 8003776:	bf00      	nop
	...

08003780 <put>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8003780:	3030      	adds	r0, #48	; 0x30
 8003782:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8003786:	f7ff ba7b 	b.w	8002c80 <chOQPutTimeout>
 800378a:	bf00      	nop
 800378c:	0000      	movs	r0, r0
	...

08003790 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
 8003790:	f001 bcbe 	b.w	8005110 <sd_lld_init>
	...

080037a0 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 80037a0:	b530      	push	{r4, r5, lr}
 80037a2:	4604      	mov	r4, r0
 80037a4:	4615      	mov	r5, r2
 80037a6:	460b      	mov	r3, r1

  sdp->vmt = &vmt;
 80037a8:	490c      	ldr	r1, [pc, #48]	; (80037dc <sdObjectInit+0x3c>)
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 80037aa:	b083      	sub	sp, #12

  sdp->vmt = &vmt;
 80037ac:	f840 1b04 	str.w	r1, [r0], #4
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 80037b0:	2201      	movs	r2, #1
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80037b2:	9400      	str	r4, [sp, #0]
 80037b4:	f104 0154 	add.w	r1, r4, #84	; 0x54
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 80037b8:	6060      	str	r0, [r4, #4]
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 80037ba:	7222      	strb	r2, [r4, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80037bc:	f104 000c 	add.w	r0, r4, #12
 80037c0:	2280      	movs	r2, #128	; 0x80
 80037c2:	f7ff f995 	bl	8002af0 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 80037c6:	9400      	str	r4, [sp, #0]
 80037c8:	462b      	mov	r3, r5
 80037ca:	f104 0030 	add.w	r0, r4, #48	; 0x30
 80037ce:	f104 01d4 	add.w	r1, r4, #212	; 0xd4
 80037d2:	2280      	movs	r2, #128	; 0x80
 80037d4:	f7ff fa34 	bl	8002c40 <chOQObjectInit>
}
 80037d8:	b003      	add	sp, #12
 80037da:	bd30      	pop	{r4, r5, pc}
 80037dc:	0800d560 	.word	0x0800d560

080037e0 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 80037e0:	b510      	push	{r4, lr}
 80037e2:	2320      	movs	r3, #32
 80037e4:	4604      	mov	r4, r0
 80037e6:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(sdp != NULL);

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 80037ea:	f001 fca9 	bl	8005140 <sd_lld_start>
  sdp->state = SD_READY;
 80037ee:	2302      	movs	r3, #2
 80037f0:	7223      	strb	r3, [r4, #8]
 80037f2:	2300      	movs	r3, #0
 80037f4:	f383 8811 	msr	BASEPRI, r3
 80037f8:	bd10      	pop	{r4, pc}
 80037fa:	bf00      	nop
 80037fc:	0000      	movs	r0, r0
	...

08003800 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8003800:	b538      	push	{r3, r4, r5, lr}
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8003802:	6943      	ldr	r3, [r0, #20]
 8003804:	4604      	mov	r4, r0
 8003806:	460d      	mov	r5, r1

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8003808:	b13b      	cbz	r3, 800381a <sdIncomingDataI+0x1a>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 800380a:	4629      	mov	r1, r5
 800380c:	f104 000c 	add.w	r0, r4, #12
 8003810:	f7ff f98e 	bl	8002b30 <chIQPutI>
 8003814:	2800      	cmp	r0, #0
 8003816:	db0b      	blt.n	8003830 <sdIncomingDataI+0x30>
 8003818:	bd38      	pop	{r3, r4, r5, pc}
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800381a:	3004      	adds	r0, #4
 800381c:	2104      	movs	r1, #4
 800381e:	f7fe febf 	bl	80025a0 <chEvtBroadcastFlagsI>
 8003822:	4629      	mov	r1, r5
 8003824:	f104 000c 	add.w	r0, r4, #12
 8003828:	f7ff f982 	bl	8002b30 <chIQPutI>
 800382c:	2800      	cmp	r0, #0
 800382e:	daf3      	bge.n	8003818 <sdIncomingDataI+0x18>
 8003830:	1d20      	adds	r0, r4, #4
 8003832:	2180      	movs	r1, #128	; 0x80
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
}
 8003834:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8003838:	f7fe beb2 	b.w	80025a0 <chEvtBroadcastFlagsI>
 800383c:	0000      	movs	r0, r0
	...

08003840 <obnotify>:
/**
 * @brief   Notification of filled buffer inserted into the output buffers queue.
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void obnotify(io_buffers_queue_t *bqp) {
 8003840:	b510      	push	{r4, lr}
  size_t n;
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 8003842:	6b04      	ldr	r4, [r0, #48]	; 0x30
/**
 * @brief   Notification of filled buffer inserted into the output buffers queue.
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void obnotify(io_buffers_queue_t *bqp) {
 8003844:	b082      	sub	sp, #8
  size_t n;
  SerialUSBDriver *sdup = bqGetLinkX(bqp);

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8003846:	f8d4 2484 	ldr.w	r2, [r4, #1156]	; 0x484
 800384a:	6813      	ldr	r3, [r2, #0]
 800384c:	7819      	ldrb	r1, [r3, #0]
 800384e:	2904      	cmp	r1, #4
 8003850:	d001      	beq.n	8003856 <obnotify+0x16>
    if (buf != NULL) {
      /* Buffer found, starting a new transaction.*/
      usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
    }
  }
}
 8003852:	b002      	add	sp, #8
 8003854:	bd10      	pop	{r4, pc}
  size_t n;
  SerialUSBDriver *sdup = bqGetLinkX(bqp);

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8003856:	7a21      	ldrb	r1, [r4, #8]
 8003858:	2902      	cmp	r1, #2
 800385a:	d1fa      	bne.n	8003852 <obnotify+0x12>
      (sdup->state != SDU_READY)) {
    return;
  }

  /* Checking if there is already a transaction ongoing on the endpoint.*/
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 800385c:	7911      	ldrb	r1, [r2, #4]
 800385e:	891a      	ldrh	r2, [r3, #8]
 8003860:	2301      	movs	r3, #1
 8003862:	408b      	lsls	r3, r1
 8003864:	4213      	tst	r3, r2
 8003866:	d1f4      	bne.n	8003852 <obnotify+0x12>
    /* Trying to get a full buffer.*/
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8003868:	f104 0040 	add.w	r0, r4, #64	; 0x40
 800386c:	a901      	add	r1, sp, #4
 800386e:	f7ff fdbf 	bl	80033f0 <obqGetFullBufferI>
    if (buf != NULL) {
 8003872:	2800      	cmp	r0, #0
 8003874:	d0ed      	beq.n	8003852 <obnotify+0x12>
      /* Buffer found, starting a new transaction.*/
      usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 8003876:	f8d4 3484 	ldr.w	r3, [r4, #1156]	; 0x484
 800387a:	4602      	mov	r2, r0
 800387c:	7919      	ldrb	r1, [r3, #4]
 800387e:	6818      	ldr	r0, [r3, #0]
 8003880:	9b01      	ldr	r3, [sp, #4]
 8003882:	f000 fa7d 	bl	8003d80 <usbStartTransmitI>
 8003886:	e7e4      	b.n	8003852 <obnotify+0x12>
	...

08003890 <readt>:
  }

  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8003890:	b410      	push	{r4}

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8003892:	f8d0 4484 	ldr.w	r4, [r0, #1156]	; 0x484
 8003896:	6824      	ldr	r4, [r4, #0]
 8003898:	7824      	ldrb	r4, [r4, #0]
 800389a:	2c04      	cmp	r4, #4
 800389c:	d003      	beq.n	80038a6 <readt+0x16>
    return 0;
  }

  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
}
 800389e:	2000      	movs	r0, #0
 80038a0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80038a4:	4770      	bx	lr

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
    return 0;
  }

  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
 80038a6:	300c      	adds	r0, #12
}
 80038a8:	f85d 4b04 	ldr.w	r4, [sp], #4

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
    return 0;
  }

  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
 80038ac:	f7ff bcf0 	b.w	8003290 <ibqReadTimeout>

080038b0 <writet>:
  }

  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 80038b0:	b410      	push	{r4}

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 80038b2:	f8d0 4484 	ldr.w	r4, [r0, #1156]	; 0x484
 80038b6:	6824      	ldr	r4, [r4, #0]
 80038b8:	7824      	ldrb	r4, [r4, #0]
 80038ba:	2c04      	cmp	r4, #4
 80038bc:	d003      	beq.n	80038c6 <writet+0x16>
    return 0;
  }

  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
}
 80038be:	2000      	movs	r0, #0
 80038c0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80038c4:	4770      	bx	lr

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
    return 0;
  }

  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
 80038c6:	3040      	adds	r0, #64	; 0x40
}
 80038c8:	f85d 4b04 	ldr.w	r4, [sp], #4

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
    return 0;
  }

  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
 80038cc:	f7ff be10 	b.w	80034f0 <obqWriteTimeout>

080038d0 <gett>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 80038d0:	f8d0 3484 	ldr.w	r3, [r0, #1156]	; 0x484
 80038d4:	681b      	ldr	r3, [r3, #0]
 80038d6:	781b      	ldrb	r3, [r3, #0]
 80038d8:	2b04      	cmp	r3, #4
 80038da:	d102      	bne.n	80038e2 <gett+0x12>
    return MSG_RESET;
  }

  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
 80038dc:	300c      	adds	r0, #12
 80038de:	f7ff bcaf 	b.w	8003240 <ibqGetTimeout>
}
 80038e2:	f06f 0001 	mvn.w	r0, #1
 80038e6:	4770      	bx	lr
	...

080038f0 <get>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 80038f0:	f8d0 3484 	ldr.w	r3, [r0, #1156]	; 0x484
 80038f4:	681b      	ldr	r3, [r3, #0]
 80038f6:	781b      	ldrb	r3, [r3, #0]
 80038f8:	2b04      	cmp	r3, #4
 80038fa:	d104      	bne.n	8003906 <get+0x16>
    return MSG_RESET;
  }

  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
 80038fc:	300c      	adds	r0, #12
 80038fe:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8003902:	f7ff bc9d 	b.w	8003240 <ibqGetTimeout>
}
 8003906:	f06f 0001 	mvn.w	r0, #1
 800390a:	4770      	bx	lr
 800390c:	0000      	movs	r0, r0
	...

08003910 <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8003910:	f8d0 3484 	ldr.w	r3, [r0, #1156]	; 0x484
 8003914:	681b      	ldr	r3, [r3, #0]
 8003916:	781b      	ldrb	r3, [r3, #0]
 8003918:	2b04      	cmp	r3, #4
 800391a:	d102      	bne.n	8003922 <putt+0x12>
    return MSG_RESET;
  }

  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
 800391c:	3040      	adds	r0, #64	; 0x40
 800391e:	f7ff bdbf 	b.w	80034a0 <obqPutTimeout>
}
 8003922:	f06f 0001 	mvn.w	r0, #1
 8003926:	4770      	bx	lr
	...

08003930 <put>:
                        n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8003930:	f8d0 3484 	ldr.w	r3, [r0, #1156]	; 0x484
 8003934:	681b      	ldr	r3, [r3, #0]
 8003936:	781b      	ldrb	r3, [r3, #0]
 8003938:	2b04      	cmp	r3, #4
 800393a:	d104      	bne.n	8003946 <put+0x16>
    return MSG_RESET;
  }

  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
 800393c:	3040      	adds	r0, #64	; 0x40
 800393e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8003942:	f7ff bdad 	b.w	80034a0 <obqPutTimeout>
}
 8003946:	f06f 0001 	mvn.w	r0, #1
 800394a:	4770      	bx	lr
 800394c:	0000      	movs	r0, r0
	...

08003950 <sdu_start_receive>:
static bool sdu_start_receive(SerialUSBDriver *sdup) {
  uint8_t *buf;

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8003950:	f8d0 2484 	ldr.w	r2, [r0, #1156]	; 0x484

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static bool sdu_start_receive(SerialUSBDriver *sdup) {
 8003954:	b538      	push	{r3, r4, r5, lr}
  uint8_t *buf;

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8003956:	6813      	ldr	r3, [r2, #0]
 8003958:	7819      	ldrb	r1, [r3, #0]
 800395a:	2904      	cmp	r1, #4
 800395c:	d001      	beq.n	8003962 <sdu_start_receive+0x12>
      (sdup->state != SDU_READY)) {
    return true;
 800395e:	2001      	movs	r0, #1
 8003960:	bd38      	pop	{r3, r4, r5, pc}
static bool sdu_start_receive(SerialUSBDriver *sdup) {
  uint8_t *buf;

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8003962:	7a01      	ldrb	r1, [r0, #8]
 8003964:	2902      	cmp	r1, #2
 8003966:	d1fa      	bne.n	800395e <sdu_start_receive+0xe>
      (sdup->state != SDU_READY)) {
    return true;
  }

  /* Checking if there is already a transaction ongoing on the endpoint.*/
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8003968:	7912      	ldrb	r2, [r2, #4]
 800396a:	895c      	ldrh	r4, [r3, #10]
 800396c:	2301      	movs	r3, #1
 800396e:	4093      	lsls	r3, r2
 8003970:	401c      	ands	r4, r3
 8003972:	d1f4      	bne.n	800395e <sdu_start_receive+0xe>
 8003974:	4605      	mov	r5, r0
    return true;
  }

  /* Checking if there is a buffer ready for incoming data.*/
  buf = ibqGetEmptyBufferI(&sdup->ibqueue);
 8003976:	300c      	adds	r0, #12
 8003978:	f7ff fc02 	bl	8003180 <ibqGetEmptyBufferI>
  if (buf == NULL) {
 800397c:	2800      	cmp	r0, #0
 800397e:	d0ee      	beq.n	800395e <sdu_start_receive+0xe>
    return true;
  }

  /* Buffer found, starting a new transaction.*/
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 8003980:	f8d5 3484 	ldr.w	r3, [r5, #1156]	; 0x484
 8003984:	4602      	mov	r2, r0
 8003986:	7959      	ldrb	r1, [r3, #5]
 8003988:	6818      	ldr	r0, [r3, #0]
 800398a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800398e:	f000 f9df 	bl	8003d50 <usbStartReceiveI>
                   buf, SERIAL_USB_BUFFERS_SIZE);

  return false;
 8003992:	4620      	mov	r0, r4
}
 8003994:	bd38      	pop	{r3, r4, r5, pc}
 8003996:	bf00      	nop
	...

080039a0 <ibnotify>:
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void ibnotify(io_buffers_queue_t *bqp) {
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
  (void) sdu_start_receive(sdup);
 80039a0:	6b00      	ldr	r0, [r0, #48]	; 0x30
 80039a2:	f7ff bfd5 	b.w	8003950 <sdu_start_receive>
 80039a6:	bf00      	nop
	...

080039b0 <read>:
                         n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 80039b0:	f8d0 3484 	ldr.w	r3, [r0, #1156]	; 0x484
 80039b4:	681b      	ldr	r3, [r3, #0]
 80039b6:	781b      	ldrb	r3, [r3, #0]
 80039b8:	2b04      	cmp	r3, #4
 80039ba:	d001      	beq.n	80039c0 <read+0x10>
    return 0;
  }

  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp,
                        n, TIME_INFINITE);
}
 80039bc:	2000      	movs	r0, #0
 80039be:	4770      	bx	lr

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
    return 0;
  }

  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp,
 80039c0:	300c      	adds	r0, #12
 80039c2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80039c6:	f7ff bc63 	b.w	8003290 <ibqReadTimeout>
 80039ca:	bf00      	nop
 80039cc:	0000      	movs	r0, r0
	...

080039d0 <write>:
 * Interface implementation.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 80039d0:	f8d0 3484 	ldr.w	r3, [r0, #1156]	; 0x484
 80039d4:	681b      	ldr	r3, [r3, #0]
 80039d6:	781b      	ldrb	r3, [r3, #0]
 80039d8:	2b04      	cmp	r3, #4
 80039da:	d001      	beq.n	80039e0 <write+0x10>
    return 0;
  }

  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp,
                         n, TIME_INFINITE);
}
 80039dc:	2000      	movs	r0, #0
 80039de:	4770      	bx	lr

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
    return 0;
  }

  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp,
 80039e0:	3040      	adds	r0, #64	; 0x40
 80039e2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80039e6:	f7ff bd83 	b.w	80034f0 <obqWriteTimeout>
 80039ea:	bf00      	nop
 80039ec:	0000      	movs	r0, r0
	...

080039f0 <sduInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sduInit(void) {
 80039f0:	4770      	bx	lr
 80039f2:	bf00      	nop
	...

08003a00 <sduObjectInit>:
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {

  sdup->vmt = &vmt;
 8003a00:	4603      	mov	r3, r0
 *
 * @param[out] sdup     pointer to a @p SerialUSBDriver structure
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {
 8003a02:	b510      	push	{r4, lr}
 8003a04:	4604      	mov	r4, r0

  sdup->vmt = &vmt;
 8003a06:	4910      	ldr	r1, [pc, #64]	; (8003a48 <sduObjectInit+0x48>)
  osalEventObjectInit(&sdup->event);
  sdup->state = SDU_STOP;
  ibqObjectInit(&sdup->ibqueue, sdup->ib,
 8003a08:	4a10      	ldr	r2, [pc, #64]	; (8003a4c <sduObjectInit+0x4c>)
 *
 * @param[out] sdup     pointer to a @p SerialUSBDriver structure
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {
 8003a0a:	b082      	sub	sp, #8

  sdup->vmt = &vmt;
 8003a0c:	f843 1b04 	str.w	r1, [r3], #4
  osalEventObjectInit(&sdup->event);
  sdup->state = SDU_STOP;
 8003a10:	2101      	movs	r1, #1
  ibqObjectInit(&sdup->ibqueue, sdup->ib,
 8003a12:	9001      	str	r0, [sp, #4]
 8003a14:	6043      	str	r3, [r0, #4]
 */
void sduObjectInit(SerialUSBDriver *sdup) {

  sdup->vmt = &vmt;
  osalEventObjectInit(&sdup->event);
  sdup->state = SDU_STOP;
 8003a16:	7201      	strb	r1, [r0, #8]
  ibqObjectInit(&sdup->ibqueue, sdup->ib,
 8003a18:	2302      	movs	r3, #2
 8003a1a:	f104 0174 	add.w	r1, r4, #116	; 0x74
 8003a1e:	9200      	str	r2, [sp, #0]
 8003a20:	300c      	adds	r0, #12
 8003a22:	f44f 7280 	mov.w	r2, #256	; 0x100
 8003a26:	f7ff fb83 	bl	8003130 <ibqObjectInit>
                SERIAL_USB_BUFFERS_SIZE, SERIAL_USB_BUFFERS_NUMBER,
                ibnotify, sdup);
  obqObjectInit(&sdup->obqueue, sdup->ob,
 8003a2a:	4b09      	ldr	r3, [pc, #36]	; (8003a50 <sduObjectInit+0x50>)
 8003a2c:	9401      	str	r4, [sp, #4]
 8003a2e:	9300      	str	r3, [sp, #0]
 8003a30:	f104 0040 	add.w	r0, r4, #64	; 0x40
 8003a34:	f504 711f 	add.w	r1, r4, #636	; 0x27c
 8003a38:	f44f 7280 	mov.w	r2, #256	; 0x100
 8003a3c:	2302      	movs	r3, #2
 8003a3e:	f7ff fcaf 	bl	80033a0 <obqObjectInit>
                SERIAL_USB_BUFFERS_SIZE, SERIAL_USB_BUFFERS_NUMBER,
                obnotify, sdup);
}
 8003a42:	b002      	add	sp, #8
 8003a44:	bd10      	pop	{r4, pc}
 8003a46:	bf00      	nop
 8003a48:	0800d580 	.word	0x0800d580
 8003a4c:	080039a1 	.word	0x080039a1
 8003a50:	08003841 	.word	0x08003841
	...

08003a60 <sduStart>:
 * @param[in] config    the serial over USB driver configuration
 *
 * @api
 */
void sduStart(SerialUSBDriver *sdup, const SerialUSBConfig *config) {
  USBDriver *usbp = config->usbp;
 8003a60:	680b      	ldr	r3, [r1, #0]
 8003a62:	2220      	movs	r2, #32
 8003a64:	f382 8811 	msr	BASEPRI, r2
  osalDbgCheck(sdup != NULL);

  osalSysLock();
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
                "invalid state");
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 8003a68:	790a      	ldrb	r2, [r1, #4]
 8003a6a:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8003a6e:	6290      	str	r0, [r2, #40]	; 0x28
  usbp->out_params[config->bulk_out - 1U] = sdup;
 8003a70:	794a      	ldrb	r2, [r1, #5]
 8003a72:	3211      	adds	r2, #17
 8003a74:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  if (config->int_in > 0U) {
 8003a78:	798a      	ldrb	r2, [r1, #6]
 8003a7a:	b112      	cbz	r2, 8003a82 <sduStart+0x22>
    usbp->in_params[config->int_in - 1U]  = sdup;
 8003a7c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8003a80:	6298      	str	r0, [r3, #40]	; 0x28
  }
  sdup->config = config;
  sdup->state = SDU_READY;
 8003a82:	2302      	movs	r3, #2
 8003a84:	7203      	strb	r3, [r0, #8]
  usbp->in_params[config->bulk_in - 1U]   = sdup;
  usbp->out_params[config->bulk_out - 1U] = sdup;
  if (config->int_in > 0U) {
    usbp->in_params[config->int_in - 1U]  = sdup;
  }
  sdup->config = config;
 8003a86:	f8c0 1484 	str.w	r1, [r0, #1156]	; 0x484
 8003a8a:	2300      	movs	r3, #0
 8003a8c:	f383 8811 	msr	BASEPRI, r3
 8003a90:	4770      	bx	lr
 8003a92:	bf00      	nop
	...

08003aa0 <sduConfigureHookI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {
 8003aa0:	b510      	push	{r4, lr}
 8003aa2:	4604      	mov	r4, r0

  ibqResetI(&sdup->ibqueue);
 8003aa4:	300c      	adds	r0, #12
 8003aa6:	f7ff fb5b 	bl	8003160 <ibqResetI>
  obqResetI(&sdup->obqueue);
 8003aaa:	f104 0040 	add.w	r0, r4, #64	; 0x40
 8003aae:	f7ff fc8f 	bl	80033d0 <obqResetI>
 8003ab2:	1d20      	adds	r0, r4, #4
 8003ab4:	2101      	movs	r1, #1
 8003ab6:	f7fe fd73 	bl	80025a0 <chEvtBroadcastFlagsI>
  chnAddFlagsI(sdup, CHN_CONNECTED);
  (void) sdu_start_receive(sdup);
 8003aba:	4620      	mov	r0, r4
}
 8003abc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void sduConfigureHookI(SerialUSBDriver *sdup) {

  ibqResetI(&sdup->ibqueue);
  obqResetI(&sdup->obqueue);
  chnAddFlagsI(sdup, CHN_CONNECTED);
  (void) sdu_start_receive(sdup);
 8003ac0:	f7ff bf46 	b.w	8003950 <sdu_start_receive>
	...

08003ad0 <sduRequestsHook>:
 * @retval true         Message handled internally.
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8003ad0:	f890 3074 	ldrb.w	r3, [r0, #116]	; 0x74
 8003ad4:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8003ad8:	2b20      	cmp	r3, #32
 8003ada:	d001      	beq.n	8003ae0 <sduRequestsHook+0x10>
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
      return true;
    default:
      return false;
 8003adc:	2000      	movs	r0, #0
    }
  }
  return false;
}
 8003ade:	4770      	bx	lr
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
    switch (usbp->setup[1]) {
 8003ae0:	f890 3075 	ldrb.w	r3, [r0, #117]	; 0x75
 8003ae4:	2b21      	cmp	r3, #33	; 0x21
 8003ae6:	d003      	beq.n	8003af0 <sduRequestsHook+0x20>
 8003ae8:	2b22      	cmp	r3, #34	; 0x22
 8003aea:	d009      	beq.n	8003b00 <sduRequestsHook+0x30>
 8003aec:	2b20      	cmp	r3, #32
 8003aee:	d1f5      	bne.n	8003adc <sduRequestsHook+0xc>
    case CDC_GET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
      return true;
    case CDC_SET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 8003af0:	4906      	ldr	r1, [pc, #24]	; (8003b0c <sduRequestsHook+0x3c>)
 8003af2:	2207      	movs	r2, #7
 8003af4:	2300      	movs	r3, #0
 8003af6:	6681      	str	r1, [r0, #104]	; 0x68
 8003af8:	66c2      	str	r2, [r0, #108]	; 0x6c
 8003afa:	6703      	str	r3, [r0, #112]	; 0x70
      return true;
 8003afc:	2001      	movs	r0, #1
 8003afe:	4770      	bx	lr
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8003b00:	2300      	movs	r3, #0
 8003b02:	6683      	str	r3, [r0, #104]	; 0x68
 8003b04:	66c3      	str	r3, [r0, #108]	; 0x6c
 8003b06:	6703      	str	r3, [r0, #112]	; 0x70
      return true;
 8003b08:	2001      	movs	r0, #1
 8003b0a:	4770      	bx	lr
 8003b0c:	20000800 	.word	0x20000800

08003b10 <sduDataTransmitted>:
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        IN endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8003b10:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint8_t *buf;
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 8003b12:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 8003b16:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        IN endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8003b18:	b083      	sub	sp, #12
  uint8_t *buf;
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];

  if (sdup == NULL) {
 8003b1a:	b1ec      	cbz	r4, 8003b58 <sduDataTransmitted+0x48>
 8003b1c:	460e      	mov	r6, r1
 8003b1e:	4605      	mov	r5, r0
 8003b20:	2320      	movs	r3, #32
 8003b22:	f383 8811 	msr	BASEPRI, r3
 8003b26:	2108      	movs	r1, #8
 8003b28:	1d20      	adds	r0, r4, #4
 8003b2a:	eb05 0786 	add.w	r7, r5, r6, lsl #2
 8003b2e:	f7fe fd37 	bl	80025a0 <chEvtBroadcastFlagsI>

  /* Signaling that space is available in the output queue.*/
  chnAddFlagsI(sdup, CHN_OUTPUT_EMPTY);

  /* Freeing the buffer just transmitted, if it was not a zero size packet.*/
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 8003b32:	68fb      	ldr	r3, [r7, #12]
    obqReleaseEmptyBufferI(&sdup->obqueue);
 8003b34:	3440      	adds	r4, #64	; 0x40

  /* Signaling that space is available in the output queue.*/
  chnAddFlagsI(sdup, CHN_OUTPUT_EMPTY);

  /* Freeing the buffer just transmitted, if it was not a zero size packet.*/
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 8003b36:	695b      	ldr	r3, [r3, #20]
 8003b38:	681b      	ldr	r3, [r3, #0]
 8003b3a:	b9fb      	cbnz	r3, 8003b7c <sduDataTransmitted+0x6c>
    obqReleaseEmptyBufferI(&sdup->obqueue);
  }

  /* Checking if there is a buffer ready for transmission.*/
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8003b3c:	4620      	mov	r0, r4
 8003b3e:	a901      	add	r1, sp, #4
 8003b40:	f7ff fc56 	bl	80033f0 <obqGetFullBufferI>

  if (buf != NULL) {
 8003b44:	4602      	mov	r2, r0
 8003b46:	b148      	cbz	r0, 8003b5c <sduDataTransmitted+0x4c>
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    usbStartTransmitI(usbp, ep, buf, n);
 8003b48:	4628      	mov	r0, r5
 8003b4a:	4631      	mov	r1, r6
 8003b4c:	9b01      	ldr	r3, [sp, #4]
 8003b4e:	f000 f917 	bl	8003d80 <usbStartTransmitI>
 8003b52:	2300      	movs	r3, #0
 8003b54:	f383 8811 	msr	BASEPRI, r3
  else {
    /* Nothing to transmit.*/
  }

  osalSysUnlockFromISR();
}
 8003b58:	b003      	add	sp, #12
 8003b5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (buf != NULL) {
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    usbStartTransmitI(usbp, ep, buf, n);
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 8003b5c:	68fb      	ldr	r3, [r7, #12]
 8003b5e:	695a      	ldr	r2, [r3, #20]
 8003b60:	6812      	ldr	r2, [r2, #0]
 8003b62:	2a00      	cmp	r2, #0
 8003b64:	d0f5      	beq.n	8003b52 <sduDataTransmitted+0x42>
           ((usbp->epc[ep]->in_state->txsize &
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 8003b66:	8a1b      	ldrh	r3, [r3, #16]
 8003b68:	3b01      	subs	r3, #1
  if (buf != NULL) {
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    usbStartTransmitI(usbp, ep, buf, n);
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 8003b6a:	4013      	ands	r3, r2
 8003b6c:	d1f1      	bne.n	8003b52 <sduDataTransmitted+0x42>
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
    /* Transmit zero sized packet in case the last one has maximum allowed
       size. Otherwise the recipient may expect more data coming soon and
       not return buffered data to app. See section 5.8.3 Bulk Transfer
       Packet Size Constraints of the USB Specification document.*/
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
 8003b6e:	4631      	mov	r1, r6
 8003b70:	4628      	mov	r0, r5
 8003b72:	f105 0274 	add.w	r2, r5, #116	; 0x74
 8003b76:	f000 f903 	bl	8003d80 <usbStartTransmitI>
 8003b7a:	e7ea      	b.n	8003b52 <sduDataTransmitted+0x42>
  /* Signaling that space is available in the output queue.*/
  chnAddFlagsI(sdup, CHN_OUTPUT_EMPTY);

  /* Freeing the buffer just transmitted, if it was not a zero size packet.*/
  if (usbp->epc[ep]->in_state->txsize > 0U) {
    obqReleaseEmptyBufferI(&sdup->obqueue);
 8003b7c:	4620      	mov	r0, r4
 8003b7e:	f7ff fc47 	bl	8003410 <obqReleaseEmptyBufferI>
  }

  /* Checking if there is a buffer ready for transmission.*/
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8003b82:	4620      	mov	r0, r4
 8003b84:	a901      	add	r1, sp, #4
 8003b86:	f7ff fc33 	bl	80033f0 <obqGetFullBufferI>

  if (buf != NULL) {
 8003b8a:	4602      	mov	r2, r0
 8003b8c:	2800      	cmp	r0, #0
 8003b8e:	d1db      	bne.n	8003b48 <sduDataTransmitted+0x38>
 8003b90:	e7e4      	b.n	8003b5c <sduDataTransmitted+0x4c>
 8003b92:	bf00      	nop
	...

08003ba0 <sduDataReceived>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        OUT endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 8003ba0:	3111      	adds	r1, #17
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        OUT endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 8003ba2:	b510      	push	{r4, lr}
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 8003ba4:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
  if (sdup == NULL) {
 8003ba8:	b1cc      	cbz	r4, 8003bde <sduDataReceived+0x3e>
 8003baa:	2320      	movs	r3, #32
 8003bac:	f383 8811 	msr	BASEPRI, r3
 8003bb0:	2104      	movs	r1, #4
 8003bb2:	1860      	adds	r0, r4, r1
 8003bb4:	f7fe fcf4 	bl	80025a0 <chEvtBroadcastFlagsI>
  /* Signaling that data is available in the input queue.*/
  chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);

  /* Posting the filled buffer in the queue.*/
  ibqPostFullBufferI(&sdup->ibqueue,
                     usbGetReceiveTransactionSizeX(sdup->config->usbp,
 8003bb8:	f8d4 2484 	ldr.w	r2, [r4, #1156]	; 0x484

  /* Signaling that data is available in the input queue.*/
  chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);

  /* Posting the filled buffer in the queue.*/
  ibqPostFullBufferI(&sdup->ibqueue,
 8003bbc:	f104 000c 	add.w	r0, r4, #12
                     usbGetReceiveTransactionSizeX(sdup->config->usbp,
 8003bc0:	6813      	ldr	r3, [r2, #0]
 8003bc2:	7952      	ldrb	r2, [r2, #5]
 8003bc4:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8003bc8:	68db      	ldr	r3, [r3, #12]

  /* Signaling that data is available in the input queue.*/
  chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);

  /* Posting the filled buffer in the queue.*/
  ibqPostFullBufferI(&sdup->ibqueue,
 8003bca:	699b      	ldr	r3, [r3, #24]
 8003bcc:	6859      	ldr	r1, [r3, #4]
 8003bce:	f7ff fae7 	bl	80031a0 <ibqPostFullBufferI>
                                                   sdup->config->bulk_out));

  /* The endpoint cannot be busy, we are in the context of the callback,
     so a packet is in the buffer for sure. Trying to get a free buffer
     for the next transaction.*/
  sdu_start_receive(sdup);
 8003bd2:	4620      	mov	r0, r4
 8003bd4:	f7ff febc 	bl	8003950 <sdu_start_receive>
 8003bd8:	2300      	movs	r3, #0
 8003bda:	f383 8811 	msr	BASEPRI, r3
 8003bde:	bd10      	pop	{r4, pc}

08003be0 <sduInterruptTransmitted>:
 *          interrupt endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {
 8003be0:	4770      	bx	lr
 8003be2:	bf00      	nop
	...

08003bf0 <set_address>:
/**
 * @brief  SET ADDRESS transaction callback.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {
 8003bf0:	b510      	push	{r4, lr}
 8003bf2:	4604      	mov	r4, r0

  usbp->address = usbp->setup[2];
 8003bf4:	f890 3076 	ldrb.w	r3, [r0, #118]	; 0x76
 8003bf8:	f880 307e 	strb.w	r3, [r0, #126]	; 0x7e
  usb_lld_set_address(usbp);
 8003bfc:	f001 fc90 	bl	8005520 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8003c00:	6863      	ldr	r3, [r4, #4]
 8003c02:	681b      	ldr	r3, [r3, #0]
 8003c04:	b113      	cbz	r3, 8003c0c <set_address+0x1c>
 8003c06:	4620      	mov	r0, r4
 8003c08:	2101      	movs	r1, #1
 8003c0a:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 8003c0c:	2303      	movs	r3, #3
 8003c0e:	7023      	strb	r3, [r4, #0]
 8003c10:	bd10      	pop	{r4, pc}
 8003c12:	bf00      	nop
	...

08003c20 <usbInit>:
 *
 * @init
 */
void usbInit(void) {

  usb_lld_init();
 8003c20:	f001 bc2e 	b.w	8005480 <usb_lld_init>
	...

08003c30 <usbObjectInit>:
 *
 * @param[out] usbp     pointer to the @p USBDriver object
 *
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
 8003c30:	b430      	push	{r4, r5}
 8003c32:	f100 0544 	add.w	r5, r0, #68	; 0x44
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
 8003c36:	4629      	mov	r1, r5
 8003c38:	2300      	movs	r3, #0
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 8003c3a:	2401      	movs	r4, #1
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 8003c3c:	461a      	mov	r2, r3
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
 8003c3e:	6043      	str	r3, [r0, #4]
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 8003c40:	7004      	strb	r4, [r0, #0]
 8003c42:	f100 0328 	add.w	r3, r0, #40	; 0x28
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 8003c46:	f843 2f04 	str.w	r2, [r3, #4]!
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8003c4a:	42ab      	cmp	r3, r5
    usbp->in_params[i]  = NULL;
 8003c4c:	f04f 0400 	mov.w	r4, #0
    usbp->out_params[i] = NULL;
 8003c50:	f841 2f04 	str.w	r2, [r1, #4]!
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8003c54:	d1f7      	bne.n	8003c46 <usbObjectInit+0x16>
    usbp->in_params[i]  = NULL;
    usbp->out_params[i] = NULL;
  }
  usbp->transmitting = 0;
 8003c56:	8104      	strh	r4, [r0, #8]
  usbp->receiving    = 0;
 8003c58:	8144      	strh	r4, [r0, #10]
}
 8003c5a:	bc30      	pop	{r4, r5}
 8003c5c:	4770      	bx	lr
 8003c5e:	bf00      	nop

08003c60 <usbStart>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] config    pointer to the @p USBConfig object
 *
 * @api
 */
void usbStart(USBDriver *usbp, const USBConfig *config) {
 8003c60:	b538      	push	{r3, r4, r5, lr}
 8003c62:	4605      	mov	r5, r0
 8003c64:	2320      	movs	r3, #32
 8003c66:	f383 8811 	msr	BASEPRI, r3
  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 8003c6a:	2000      	movs	r0, #0
  osalDbgCheck((usbp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
 8003c6c:	6069      	str	r1, [r5, #4]
 8003c6e:	f105 0308 	add.w	r3, r5, #8
 8003c72:	f105 0228 	add.w	r2, r5, #40	; 0x28
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 8003c76:	f843 0f04 	str.w	r0, [r3, #4]!

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8003c7a:	4293      	cmp	r3, r2
    usbp->epc[i] = NULL;
 8003c7c:	f04f 0400 	mov.w	r4, #0

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8003c80:	d1f9      	bne.n	8003c76 <usbStart+0x16>
    usbp->epc[i] = NULL;
  }
  usb_lld_start(usbp);
 8003c82:	4628      	mov	r0, r5
 8003c84:	f001 fc04 	bl	8005490 <usb_lld_start>
  usbp->state = USB_READY;
 8003c88:	2302      	movs	r3, #2
 8003c8a:	702b      	strb	r3, [r5, #0]
 8003c8c:	f384 8811 	msr	BASEPRI, r4
 8003c90:	bd38      	pop	{r3, r4, r5, pc}
 8003c92:	bf00      	nop
	...

08003ca0 <usbStop>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @api
 */
void usbStop(USBDriver *usbp) {
 8003ca0:	b510      	push	{r4, lr}
 8003ca2:	2320      	movs	r3, #32
 8003ca4:	4604      	mov	r4, r0
 8003ca6:	f383 8811 	msr	BASEPRI, r3
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY) ||
                (usbp->state == USB_SELECTED) || (usbp->state == USB_ACTIVE) ||
                (usbp->state == USB_SUSPENDED),
                "invalid state");

  usb_lld_stop(usbp);
 8003caa:	f001 fc19 	bl	80054e0 <usb_lld_stop>
  usbp->state = USB_STOP;
 8003cae:	4620      	mov	r0, r4
 8003cb0:	2301      	movs	r3, #1
 8003cb2:	f800 3b08 	strb.w	r3, [r0], #8
 8003cb6:	f104 0228 	add.w	r2, r4, #40	; 0x28
      if (usbp->epc[i]->out_state != NULL) {
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
    }
#endif
    usbp->epc[i] = NULL;
 8003cba:	2300      	movs	r3, #0
 8003cbc:	f840 3f04 	str.w	r3, [r0, #4]!

  usb_lld_stop(usbp);
  usbp->state = USB_STOP;

  /* Resetting all ongoing synchronous operations.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8003cc0:	4290      	cmp	r0, r2
      if (usbp->epc[i]->out_state != NULL) {
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
    }
#endif
    usbp->epc[i] = NULL;
 8003cc2:	f04f 0400 	mov.w	r4, #0

  usb_lld_stop(usbp);
  usbp->state = USB_STOP;

  /* Resetting all ongoing synchronous operations.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8003cc6:	d1f9      	bne.n	8003cbc <usbStop+0x1c>
 *
 * @sclass
 */
static inline void osalOsRescheduleS(void) {

  chSchRescheduleS();
 8003cc8:	f7fd fe9a 	bl	8001a00 <chSchRescheduleS>
 8003ccc:	f384 8811 	msr	BASEPRI, r4
 8003cd0:	bd10      	pop	{r4, pc}
 8003cd2:	bf00      	nop
	...

08003ce0 <usbInitEndpointI>:
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 8003ce0:	b570      	push	{r4, r5, r6, lr}
 8003ce2:	4606      	mov	r6, r0

  /* Logically enabling the endpoint in the USBDriver structure.*/
  usbp->epc[ep] = epcp;

  /* Clearing the state structures, custom fields as well.*/
  if (epcp->in_state != NULL) {
 8003ce4:	6950      	ldr	r0, [r2, #20]
  osalDbgAssert(usbp->state == USB_ACTIVE,
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");

  /* Logically enabling the endpoint in the USBDriver structure.*/
  usbp->epc[ep] = epcp;
 8003ce6:	eb06 0381 	add.w	r3, r6, r1, lsl #2
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 8003cea:	4614      	mov	r4, r2
 8003cec:	460d      	mov	r5, r1
  osalDbgAssert(usbp->state == USB_ACTIVE,
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");

  /* Logically enabling the endpoint in the USBDriver structure.*/
  usbp->epc[ep] = epcp;
 8003cee:	60da      	str	r2, [r3, #12]

  /* Clearing the state structures, custom fields as well.*/
  if (epcp->in_state != NULL) {
 8003cf0:	b118      	cbz	r0, 8003cfa <usbInitEndpointI+0x1a>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 8003cf2:	2100      	movs	r1, #0
 8003cf4:	2210      	movs	r2, #16
 8003cf6:	f009 fb2b 	bl	800d350 <memset>
  }
  if (epcp->out_state != NULL) {
 8003cfa:	69a0      	ldr	r0, [r4, #24]
 8003cfc:	b118      	cbz	r0, 8003d06 <usbInitEndpointI+0x26>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 8003cfe:	2100      	movs	r1, #0
 8003d00:	2210      	movs	r2, #16
 8003d02:	f009 fb25 	bl	800d350 <memset>
  }

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 8003d06:	4630      	mov	r0, r6
 8003d08:	4629      	mov	r1, r5
}
 8003d0a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if (epcp->out_state != NULL) {
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
  }

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 8003d0e:	f001 bc17 	b.w	8005540 <usb_lld_init_endpoint>
 8003d12:	bf00      	nop
	...

08003d20 <usbDisableEndpointsI>:

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 8003d20:	8902      	ldrh	r2, [r0, #8]
  usbp->receiving    &= 1U;
 8003d22:	8943      	ldrh	r3, [r0, #10]

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 8003d24:	f002 0201 	and.w	r2, r2, #1
  usbp->receiving    &= 1U;
 8003d28:	f003 0301 	and.w	r3, r3, #1

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 8003d2c:	8102      	strh	r2, [r0, #8]
  usbp->receiving    &= 1U;
 8003d2e:	8143      	strh	r3, [r0, #10]
 8003d30:	f100 0128 	add.w	r1, r0, #40	; 0x28
 8003d34:	f100 030c 	add.w	r3, r0, #12
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8003d38:	2200      	movs	r2, #0
 8003d3a:	f843 2f04 	str.w	r2, [r3, #4]!
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
  usbp->receiving    &= 1U;

  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8003d3e:	428b      	cmp	r3, r1
 8003d40:	d1fb      	bne.n	8003d3a <usbDisableEndpointsI+0x1a>
#endif
    usbp->epc[i] = NULL;
  }

  /* Low level endpoints deactivation.*/
  usb_lld_disable_endpoints(usbp);
 8003d42:	f001 bc95 	b.w	8005670 <usb_lld_disable_endpoints>
 8003d46:	bf00      	nop
	...

08003d50 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
 8003d50:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 8003d52:	eb00 0681 	add.w	r6, r0, r1, lsl #2
 8003d56:	f8d6 e00c 	ldr.w	lr, [r6, #12]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8003d5a:	8947      	ldrh	r7, [r0, #10]
 8003d5c:	2601      	movs	r6, #1

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 8003d5e:	f8de 4018 	ldr.w	r4, [lr, #24]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8003d62:	408e      	lsls	r6, r1
 8003d64:	433e      	orrs	r6, r7
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
  /*lint -restore*/
  osp->rxbuf  = buf;
  osp->rxsize = n;
  osp->rxcnt  = 0;
 8003d66:	2700      	movs	r7, #0
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8003d68:	8146      	strh	r6, [r0, #10]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
  /*lint -restore*/
  osp->rxbuf  = buf;
 8003d6a:	60a2      	str	r2, [r4, #8]
  osp->rxsize = n;
  osp->rxcnt  = 0;
 8003d6c:	e884 0088 	stmia.w	r4, {r3, r7}
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
}
 8003d70:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 8003d74:	f001 bcdc 	b.w	8005730 <usb_lld_start_out>
	...

08003d80 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 8003d80:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8003d82:	eb00 0681 	add.w	r6, r0, r1, lsl #2
 8003d86:	f8d6 e00c 	ldr.w	lr, [r6, #12]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8003d8a:	8907      	ldrh	r7, [r0, #8]
 8003d8c:	2601      	movs	r6, #1

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8003d8e:	f8de 4014 	ldr.w	r4, [lr, #20]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8003d92:	408e      	lsls	r6, r1
 8003d94:	433e      	orrs	r6, r7
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
  /*lint -restore*/
  isp->txbuf  = buf;
  isp->txsize = n;
  isp->txcnt  = 0;
 8003d96:	2700      	movs	r7, #0
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8003d98:	8106      	strh	r6, [r0, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
  /*lint -restore*/
  isp->txbuf  = buf;
 8003d9a:	60a2      	str	r2, [r4, #8]
  isp->txsize = n;
  isp->txcnt  = 0;
 8003d9c:	e884 0088 	stmia.w	r4, {r3, r7}
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
}
 8003da0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 8003da4:	f001 bcec 	b.w	8005780 <usb_lld_start_in>
	...

08003db0 <_usb_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
 8003db0:	b570      	push	{r4, r5, r6, lr}
 8003db2:	4604      	mov	r4, r0

  /* State transition.*/
  usbp->state         = USB_READY;

  /* Resetting internal state.*/
  usbp->status        = 0;
 8003db4:	2300      	movs	r3, #0
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8003db6:	2202      	movs	r2, #2
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8003db8:	4619      	mov	r1, r3
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8003dba:	7002      	strb	r2, [r0, #0]

  /* Resetting internal state.*/
  usbp->status        = 0;
 8003dbc:	f8a0 307c 	strh.w	r3, [r0, #124]	; 0x7c
  usbp->address       = 0;
 8003dc0:	f880 307e 	strb.w	r3, [r0, #126]	; 0x7e
  usbp->configuration = 0;
 8003dc4:	f880 307f 	strb.w	r3, [r0, #127]	; 0x7f
  usbp->transmitting  = 0;
 8003dc8:	8103      	strh	r3, [r0, #8]
  usbp->receiving     = 0;
 8003dca:	8143      	strh	r3, [r0, #10]
 8003dcc:	f100 0228 	add.w	r2, r0, #40	; 0x28
 8003dd0:	f100 0308 	add.w	r3, r0, #8
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8003dd4:	f843 1f04 	str.w	r1, [r3, #4]!
  usbp->configuration = 0;
  usbp->transmitting  = 0;
  usbp->receiving     = 0;

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8003dd8:	4293      	cmp	r3, r2
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8003dda:	f04f 0500 	mov.w	r5, #0
  usbp->configuration = 0;
  usbp->transmitting  = 0;
  usbp->receiving     = 0;

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8003dde:	d1f9      	bne.n	8003dd4 <_usb_reset+0x24>
#endif
    usbp->epc[i] = NULL;
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8003de0:	f884 5064 	strb.w	r5, [r4, #100]	; 0x64

  /* Low level reset.*/
  usb_lld_reset(usbp);
 8003de4:	4620      	mov	r0, r4
 8003de6:	f001 fc1b 	bl	8005620 <usb_lld_reset>

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8003dea:	6863      	ldr	r3, [r4, #4]
 8003dec:	681b      	ldr	r3, [r3, #0]
 8003dee:	b123      	cbz	r3, 8003dfa <_usb_reset+0x4a>
 8003df0:	4620      	mov	r0, r4
 8003df2:	4629      	mov	r1, r5
}
 8003df4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  /* Low level reset.*/
  usb_lld_reset(usbp);

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8003df8:	4718      	bx	r3
 8003dfa:	bd70      	pop	{r4, r5, r6, pc}
 8003dfc:	0000      	movs	r0, r0
	...

08003e00 <_usb_suspend>:
  /* State transition.*/
  usbp->saved_state = usbp->state;
  usbp->state       = USB_SUSPENDED;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8003e00:	6842      	ldr	r2, [r0, #4]
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_suspend(USBDriver *usbp) {
 8003e02:	b410      	push	{r4}
  /* State transition.*/
  usbp->saved_state = usbp->state;
  usbp->state       = USB_SUSPENDED;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8003e04:	6812      	ldr	r2, [r2, #0]
 */
void _usb_suspend(USBDriver *usbp) {
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 8003e06:	7804      	ldrb	r4, [r0, #0]
  usbp->state       = USB_SUSPENDED;
 8003e08:	2105      	movs	r1, #5
 */
void _usb_suspend(USBDriver *usbp) {
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 8003e0a:	f880 4080 	strb.w	r4, [r0, #128]	; 0x80
  usbp->state       = USB_SUSPENDED;
 8003e0e:	7001      	strb	r1, [r0, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8003e10:	b11a      	cbz	r2, 8003e1a <_usb_suspend+0x1a>
 8003e12:	2104      	movs	r1, #4
        osalSysUnlockFromISR();
      }
    }
  }
#endif
}
 8003e14:	f85d 4b04 	ldr.w	r4, [sp], #4
  /* State transition.*/
  usbp->saved_state = usbp->state;
  usbp->state       = USB_SUSPENDED;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8003e18:	4710      	bx	r2
        osalSysUnlockFromISR();
      }
    }
  }
#endif
}
 8003e1a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003e1e:	4770      	bx	lr

08003e20 <_usb_wakeup>:

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8003e20:	6842      	ldr	r2, [r0, #4]
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;
 8003e22:	f890 1080 	ldrb.w	r1, [r0, #128]	; 0x80

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8003e26:	6812      	ldr	r2, [r2, #0]
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;
 8003e28:	7001      	strb	r1, [r0, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8003e2a:	b10a      	cbz	r2, 8003e30 <_usb_wakeup+0x10>
 8003e2c:	2105      	movs	r1, #5
 8003e2e:	4710      	bx	r2
 8003e30:	4770      	bx	lr
 8003e32:	bf00      	nop
	...

08003e40 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8003e40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003e42:	4604      	mov	r4, r0
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8003e44:	2300      	movs	r3, #0
 8003e46:	f880 3064 	strb.w	r3, [r0, #100]	; 0x64
  usbReadSetup(usbp, ep, usbp->setup);
 8003e4a:	f100 0274 	add.w	r2, r0, #116	; 0x74
 8003e4e:	f001 fc4f 	bl	80056f0 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8003e52:	6863      	ldr	r3, [r4, #4]
 8003e54:	689b      	ldr	r3, [r3, #8]
 8003e56:	b313      	cbz	r3, 8003e9e <_usb_ep0setup+0x5e>
      !(usbp->config->requests_hook_cb(usbp))) {
 8003e58:	4620      	mov	r0, r4
 8003e5a:	4798      	blx	r3
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8003e5c:	b1f8      	cbz	r0, 8003e9e <_usb_ep0setup+0x5e>
 8003e5e:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
 8003e60:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 8003e64:	f894 107b 	ldrb.w	r1, [r4, #123]	; 0x7b
 8003e68:	f894 207a 	ldrb.w	r2, [r4, #122]	; 0x7a
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 8003e6c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 8003e70:	42aa      	cmp	r2, r5
    usbp->ep0n = max;
 8003e72:	bf3c      	itt	cc
 8003e74:	4615      	movcc	r5, r2
 8003e76:	66e2      	strcc	r2, [r4, #108]	; 0x6c
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8003e78:	061b      	lsls	r3, r3, #24
 8003e7a:	d47a      	bmi.n	8003f72 <_usb_ep0setup+0x132>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 8003e7c:	2d00      	cmp	r5, #0
 8003e7e:	d168      	bne.n	8003f52 <_usb_ep0setup+0x112>
      osalSysUnlockFromISR();
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
 8003e80:	2305      	movs	r3, #5
 8003e82:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 8003e86:	2320      	movs	r3, #32
 8003e88:	f383 8811 	msr	BASEPRI, r3
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
      usbStartTransmitI(usbp, 0, NULL, 0);
 8003e8c:	4620      	mov	r0, r4
 8003e8e:	4629      	mov	r1, r5
 8003e90:	462a      	mov	r2, r5
 8003e92:	462b      	mov	r3, r5
 8003e94:	f7ff ff74 	bl	8003d80 <usbStartTransmitI>
 8003e98:	f385 8811 	msr	BASEPRI, r5
 8003e9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8003e9e:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 8003ea2:	f013 0760 	ands.w	r7, r3, #96	; 0x60
 8003ea6:	d011      	beq.n	8003ecc <_usb_ep0setup+0x8c>
        !default_handler(usbp)) {
    /*lint -restore*/
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
 8003ea8:	4620      	mov	r0, r4
 8003eaa:	2100      	movs	r1, #0
 8003eac:	f001 fca8 	bl	8005800 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 8003eb0:	4620      	mov	r0, r4
 8003eb2:	2100      	movs	r1, #0
 8003eb4:	f001 fc8c 	bl	80057d0 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8003eb8:	6863      	ldr	r3, [r4, #4]
 8003eba:	681b      	ldr	r3, [r3, #0]
 8003ebc:	b113      	cbz	r3, 8003ec4 <_usb_ep0setup+0x84>
 8003ebe:	4620      	mov	r0, r4
 8003ec0:	2106      	movs	r1, #6
 8003ec2:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 8003ec4:	2306      	movs	r3, #6
 8003ec6:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
      return;
 8003eca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
 8003ecc:	f894 5075 	ldrb.w	r5, [r4, #117]	; 0x75
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8003ed0:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
 8003ed4:	ea42 2605 	orr.w	r6, r2, r5, lsl #8
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8003ed8:	f5b6 7f40 	cmp.w	r6, #768	; 0x300
 8003edc:	f000 8104 	beq.w	80040e8 <_usb_ep0setup+0x2a8>
 8003ee0:	d916      	bls.n	8003f10 <_usb_ep0setup+0xd0>
 8003ee2:	f5b6 6fc0 	cmp.w	r6, #1536	; 0x600
 8003ee6:	f000 80e6 	beq.w	80040b6 <_usb_ep0setup+0x276>
 8003eea:	d962      	bls.n	8003fb2 <_usb_ep0setup+0x172>
 8003eec:	f5b6 6f10 	cmp.w	r6, #2304	; 0x900
 8003ef0:	d06d      	beq.n	8003fce <_usb_ep0setup+0x18e>
 8003ef2:	f640 4202 	movw	r2, #3074	; 0xc02
 8003ef6:	4296      	cmp	r6, r2
 8003ef8:	f000 80d6 	beq.w	80040a8 <_usb_ep0setup+0x268>
 8003efc:	f5b6 6f00 	cmp.w	r6, #2048	; 0x800
 8003f00:	d1d2      	bne.n	8003ea8 <_usb_ep0setup+0x68>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8003f02:	f104 027f 	add.w	r2, r4, #127	; 0x7f
 8003f06:	2501      	movs	r5, #1
 8003f08:	6727      	str	r7, [r4, #112]	; 0x70
 8003f0a:	66a2      	str	r2, [r4, #104]	; 0x68
 8003f0c:	66e5      	str	r5, [r4, #108]	; 0x6c
 8003f0e:	e7a9      	b.n	8003e64 <_usb_ep0setup+0x24>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8003f10:	2e02      	cmp	r6, #2
 8003f12:	f000 80af 	beq.w	8004074 <_usb_ep0setup+0x234>
 8003f16:	f240 80a5 	bls.w	8004064 <_usb_ep0setup+0x224>
 8003f1a:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 8003f1e:	d06b      	beq.n	8003ff8 <_usb_ep0setup+0x1b8>
 8003f20:	f5b6 7f81 	cmp.w	r6, #258	; 0x102
 8003f24:	d1c0      	bne.n	8003ea8 <_usb_ep0setup+0x68>
        return false;
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8003f26:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 8003f2a:	2a00      	cmp	r2, #0
 8003f2c:	d1bc      	bne.n	8003ea8 <_usb_ep0setup+0x68>
      return false;
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8003f2e:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
 8003f32:	f012 010f 	ands.w	r1, r2, #15
 8003f36:	d007      	beq.n	8003f48 <_usb_ep0setup+0x108>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8003f38:	0615      	lsls	r5, r2, #24
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 8003f3a:	4620      	mov	r0, r4
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
      return false;
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8003f3c:	f100 80f0 	bmi.w	8004120 <_usb_ep0setup+0x2e0>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
      }
      else {
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
 8003f40:	f001 fc76 	bl	8005830 <usb_lld_clear_out>
 8003f44:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8003f48:	2500      	movs	r5, #0
 8003f4a:	66a5      	str	r5, [r4, #104]	; 0x68
 8003f4c:	66e5      	str	r5, [r4, #108]	; 0x6c
 8003f4e:	6725      	str	r5, [r4, #112]	; 0x70
 8003f50:	e788      	b.n	8003e64 <_usb_ep0setup+0x24>
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
 8003f52:	2304      	movs	r3, #4
 8003f54:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 8003f58:	2320      	movs	r3, #32
 8003f5a:	f383 8811 	msr	BASEPRI, r3
      osalSysLockFromISR();
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8003f5e:	2100      	movs	r1, #0
 8003f60:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8003f62:	4620      	mov	r0, r4
 8003f64:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 8003f66:	f7ff fef3 	bl	8003d50 <usbStartReceiveI>
 8003f6a:	2300      	movs	r3, #0
 8003f6c:	f383 8811 	msr	BASEPRI, r3
 8003f70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (usbp->ep0n > max) {
    usbp->ep0n = max;
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 8003f72:	b17d      	cbz	r5, 8003f94 <_usb_ep0setup+0x154>
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
 8003f74:	2301      	movs	r3, #1
 8003f76:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 8003f7a:	2320      	movs	r3, #32
 8003f7c:	f383 8811 	msr	BASEPRI, r3
      osalSysLockFromISR();
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8003f80:	2100      	movs	r1, #0
 8003f82:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8003f84:	4620      	mov	r0, r4
 8003f86:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 8003f88:	f7ff fefa 	bl	8003d80 <usbStartTransmitI>
 8003f8c:	2300      	movs	r3, #0
 8003f8e:	f383 8811 	msr	BASEPRI, r3
 8003f92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      osalSysUnlockFromISR();
    }
    else {
      /* No transmission phase, directly receiving the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
 8003f94:	2303      	movs	r3, #3
 8003f96:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 8003f9a:	2320      	movs	r3, #32
 8003f9c:	f383 8811 	msr	BASEPRI, r3
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
      usbStartReceiveI(usbp, 0, NULL, 0);
 8003fa0:	4620      	mov	r0, r4
 8003fa2:	4629      	mov	r1, r5
 8003fa4:	462a      	mov	r2, r5
 8003fa6:	462b      	mov	r3, r5
 8003fa8:	f7ff fed2 	bl	8003d50 <usbStartReceiveI>
 8003fac:	f385 8811 	msr	BASEPRI, r5
 8003fb0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8003fb2:	f240 3202 	movw	r2, #770	; 0x302
 8003fb6:	4296      	cmp	r6, r2
 8003fb8:	d02e      	beq.n	8004018 <_usb_ep0setup+0x1d8>
 8003fba:	f5b6 6fa0 	cmp.w	r6, #1280	; 0x500
 8003fbe:	f47f af73 	bne.w	8003ea8 <_usb_ep0setup+0x68>
        (usbp->setup[1] == USB_REQ_SET_ADDRESS)) {
      set_address(usbp);
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
#else
    usbSetupTransfer(usbp, NULL, 0, set_address);
 8003fc2:	4a5c      	ldr	r2, [pc, #368]	; (8004134 <_usb_ep0setup+0x2f4>)
 8003fc4:	66a7      	str	r7, [r4, #104]	; 0x68
 8003fc6:	66e7      	str	r7, [r4, #108]	; 0x6c
 8003fc8:	463d      	mov	r5, r7
 8003fca:	6722      	str	r2, [r4, #112]	; 0x70
 8003fcc:	e74a      	b.n	8003e64 <_usb_ep0setup+0x24>
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_CONFIGURATION << 8):
    /* Handling configuration selection from the host only if it is different
       from the current configuration.*/
    if (usbp->configuration != usbp->setup[2]) {
 8003fce:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 8003fd2:	f894 107f 	ldrb.w	r1, [r4, #127]	; 0x7f
 8003fd6:	4291      	cmp	r1, r2
 8003fd8:	d0b6      	beq.n	8003f48 <_usb_ep0setup+0x108>
      /* If the USB device is already active then we have to perform the clear
         procedure on the current configuration.*/
      if (usbp->state == USB_ACTIVE) {
 8003fda:	7823      	ldrb	r3, [r4, #0]
 8003fdc:	2b04      	cmp	r3, #4
 8003fde:	d02d      	beq.n	800403c <_usb_ep0setup+0x1fc>
        chSysUnlockFromISR ();
        usbp->configuration = 0U;
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
      }
      if (usbp->setup[2] != 0U) {
 8003fe0:	b34a      	cbz	r2, 8004036 <_usb_ep0setup+0x1f6>
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
        usbp->state = USB_ACTIVE;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8003fe2:	6863      	ldr	r3, [r4, #4]
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
      }
      if (usbp->setup[2] != 0U) {
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
 8003fe4:	f884 207f 	strb.w	r2, [r4, #127]	; 0x7f
        usbp->state = USB_ACTIVE;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8003fe8:	681b      	ldr	r3, [r3, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
      }
      if (usbp->setup[2] != 0U) {
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
        usbp->state = USB_ACTIVE;
 8003fea:	2204      	movs	r2, #4
 8003fec:	7022      	strb	r2, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8003fee:	b313      	cbz	r3, 8004036 <_usb_ep0setup+0x1f6>
 8003ff0:	4620      	mov	r0, r4
 8003ff2:	2102      	movs	r1, #2
 8003ff4:	4798      	blx	r3
 8003ff6:	e01e      	b.n	8004036 <_usb_ep0setup+0x1f6>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8003ff8:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 8003ffc:	2a01      	cmp	r2, #1
 8003ffe:	f47f af53 	bne.w	8003ea8 <_usb_ep0setup+0x68>
      usbp->status &= ~2U;
 8004002:	f8b4 207c 	ldrh.w	r2, [r4, #124]	; 0x7c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8004006:	66a7      	str	r7, [r4, #104]	; 0x68
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 8004008:	f022 0202 	bic.w	r2, r2, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800400c:	66e7      	str	r7, [r4, #108]	; 0x6c
 800400e:	6727      	str	r7, [r4, #112]	; 0x70
 8004010:	463d      	mov	r5, r7
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 8004012:	f8a4 207c 	strh.w	r2, [r4, #124]	; 0x7c
 8004016:	e725      	b.n	8003e64 <_usb_ep0setup+0x24>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8004018:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 800401c:	2a00      	cmp	r2, #0
 800401e:	f47f af43 	bne.w	8003ea8 <_usb_ep0setup+0x68>
      return false;
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8004022:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
 8004026:	f012 010f 	ands.w	r1, r2, #15
 800402a:	d08d      	beq.n	8003f48 <_usb_ep0setup+0x108>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800402c:	0612      	lsls	r2, r2, #24
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 800402e:	4620      	mov	r0, r4
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
      return false;
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8004030:	d47b      	bmi.n	800412a <_usb_ep0setup+0x2ea>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
 8004032:	f001 fbcd 	bl	80057d0 <usb_lld_stall_out>
 8004036:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 800403a:	e785      	b.n	8003f48 <_usb_ep0setup+0x108>
 800403c:	2320      	movs	r3, #32
 800403e:	f383 8811 	msr	BASEPRI, r3
      /* If the USB device is already active then we have to perform the clear
         procedure on the current configuration.*/
      if (usbp->state == USB_ACTIVE) {
        /* Current configuration cleared.*/
        chSysLockFromISR ();
        usbDisableEndpointsI(usbp);
 8004042:	4620      	mov	r0, r4
 8004044:	f7ff fe6c 	bl	8003d20 <usbDisableEndpointsI>
 8004048:	f387 8811 	msr	BASEPRI, r7
        chSysUnlockFromISR ();
        usbp->configuration = 0U;
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 800404c:	6863      	ldr	r3, [r4, #4]
      if (usbp->state == USB_ACTIVE) {
        /* Current configuration cleared.*/
        chSysLockFromISR ();
        usbDisableEndpointsI(usbp);
        chSysUnlockFromISR ();
        usbp->configuration = 0U;
 800404e:	f884 707f 	strb.w	r7, [r4, #127]	; 0x7f
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8004052:	681b      	ldr	r3, [r3, #0]
        /* Current configuration cleared.*/
        chSysLockFromISR ();
        usbDisableEndpointsI(usbp);
        chSysUnlockFromISR ();
        usbp->configuration = 0U;
        usbp->state = USB_SELECTED;
 8004054:	2103      	movs	r1, #3
 8004056:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8004058:	b10b      	cbz	r3, 800405e <_usb_ep0setup+0x21e>
 800405a:	4620      	mov	r0, r4
 800405c:	4798      	blx	r3
 800405e:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 8004062:	e7bd      	b.n	8003fe0 <_usb_ep0setup+0x1a0>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8004064:	b9ee      	cbnz	r6, 80040a2 <_usb_ep0setup+0x262>
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8004066:	f104 027c 	add.w	r2, r4, #124	; 0x7c
 800406a:	2502      	movs	r5, #2
 800406c:	6726      	str	r6, [r4, #112]	; 0x70
 800406e:	66a2      	str	r2, [r4, #104]	; 0x68
 8004070:	66e5      	str	r5, [r4, #108]	; 0x6c
 8004072:	e6f7      	b.n	8003e64 <_usb_ep0setup+0x24>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8004074:	f894 1078 	ldrb.w	r1, [r4, #120]	; 0x78
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 8004078:	4620      	mov	r0, r4
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 800407a:	f011 0f80 	tst.w	r1, #128	; 0x80
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 800407e:	f001 010f 	and.w	r1, r1, #15
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8004082:	d141      	bne.n	8004108 <_usb_ep0setup+0x2c8>
      default:
        return false;
      }
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
 8004084:	f001 fb14 	bl	80056b0 <usb_lld_get_status_out>
 8004088:	2801      	cmp	r0, #1
 800408a:	d041      	beq.n	8004110 <_usb_ep0setup+0x2d0>
 800408c:	2802      	cmp	r0, #2
 800408e:	f47f af0b 	bne.w	8003ea8 <_usb_ep0setup+0x68>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
        /*lint -restore*/
        return true;
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8004092:	4b29      	ldr	r3, [pc, #164]	; (8004138 <_usb_ep0setup+0x2f8>)
 8004094:	66e0      	str	r0, [r4, #108]	; 0x6c
 8004096:	66a3      	str	r3, [r4, #104]	; 0x68
 8004098:	6727      	str	r7, [r4, #112]	; 0x70
 800409a:	4605      	mov	r5, r0
 800409c:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 80040a0:	e6e0      	b.n	8003e64 <_usb_ep0setup+0x24>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80040a2:	2e01      	cmp	r6, #1
 80040a4:	f47f af00 	bne.w	8003ea8 <_usb_ep0setup+0x68>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 80040a8:	4924      	ldr	r1, [pc, #144]	; (800413c <_usb_ep0setup+0x2fc>)
 80040aa:	2502      	movs	r5, #2
 80040ac:	2200      	movs	r2, #0
 80040ae:	66a1      	str	r1, [r4, #104]	; 0x68
 80040b0:	66e5      	str	r5, [r4, #108]	; 0x6c
 80040b2:	6722      	str	r2, [r4, #112]	; 0x70
 80040b4:	e6d6      	b.n	8003e64 <_usb_ep0setup+0x24>
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 80040b6:	6861      	ldr	r1, [r4, #4]

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 80040b8:	f894 2079 	ldrb.w	r2, [r4, #121]	; 0x79
 80040bc:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 80040c0:	684d      	ldr	r5, [r1, #4]
 80040c2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80040c6:	4620      	mov	r0, r4
 80040c8:	f894 1077 	ldrb.w	r1, [r4, #119]	; 0x77
 80040cc:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 80040d0:	47a8      	blx	r5
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 80040d2:	2800      	cmp	r0, #0
 80040d4:	f43f aee8 	beq.w	8003ea8 <_usb_ep0setup+0x68>
      return false;
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 80040d8:	6843      	ldr	r3, [r0, #4]
 80040da:	6805      	ldr	r5, [r0, #0]
 80040dc:	66a3      	str	r3, [r4, #104]	; 0x68
 80040de:	66e5      	str	r5, [r4, #108]	; 0x6c
 80040e0:	6727      	str	r7, [r4, #112]	; 0x70
 80040e2:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 80040e6:	e6bd      	b.n	8003e64 <_usb_ep0setup+0x24>
    }
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 80040e8:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 80040ec:	2a01      	cmp	r2, #1
 80040ee:	f47f aedb 	bne.w	8003ea8 <_usb_ep0setup+0x68>
      usbp->status |= 2U;
 80040f2:	f8b4 207c 	ldrh.w	r2, [r4, #124]	; 0x7c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80040f6:	66a7      	str	r7, [r4, #104]	; 0x68
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 80040f8:	f042 0202 	orr.w	r2, r2, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80040fc:	66e7      	str	r7, [r4, #108]	; 0x6c
 80040fe:	6727      	str	r7, [r4, #112]	; 0x70
 8004100:	463d      	mov	r5, r7
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 8004102:	f8a4 207c 	strh.w	r2, [r4, #124]	; 0x7c
 8004106:	e6ad      	b.n	8003e64 <_usb_ep0setup+0x24>
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 8004108:	f001 fae2 	bl	80056d0 <usb_lld_get_status_in>
 800410c:	2801      	cmp	r0, #1
 800410e:	d1bd      	bne.n	800408c <_usb_ep0setup+0x24c>
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8004110:	4b0b      	ldr	r3, [pc, #44]	; (8004140 <_usb_ep0setup+0x300>)
 8004112:	66e6      	str	r6, [r4, #108]	; 0x6c
 8004114:	66a3      	str	r3, [r4, #104]	; 0x68
 8004116:	6727      	str	r7, [r4, #112]	; 0x70
 8004118:	4635      	mov	r5, r6
 800411a:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 800411e:	e6a1      	b.n	8003e64 <_usb_ep0setup+0x24>
      return false;
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
      if ((usbp->setup[4] & 0x80U) != 0U) {
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 8004120:	f001 fb9e 	bl	8005860 <usb_lld_clear_in>
 8004124:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 8004128:	e70e      	b.n	8003f48 <_usb_ep0setup+0x108>
      return false;
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
      if ((usbp->setup[4] & 0x80U) != 0U) {
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 800412a:	f001 fb69 	bl	8005800 <usb_lld_stall_in>
 800412e:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 8004132:	e709      	b.n	8003f48 <_usb_ep0setup+0x108>
 8004134:	08003bf1 	.word	0x08003bf1
 8004138:	0800d5b0 	.word	0x0800d5b0
 800413c:	0800d5a0 	.word	0x0800d5a0
 8004140:	0800d5c0 	.word	0x0800d5c0
	...

08004150 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8004150:	b538      	push	{r3, r4, r5, lr}
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 8004152:	f890 3064 	ldrb.w	r3, [r0, #100]	; 0x64
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8004156:	4604      	mov	r4, r0
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 8004158:	2b06      	cmp	r3, #6
 800415a:	d815      	bhi.n	8004188 <_usb_ep0in+0x38>
 800415c:	e8df f003 	tbb	[pc, r3]
 8004160:	04251504 	.word	0x04251504
 8004164:	3504      	.short	0x3504
 8004166:	04          	.byte	0x04
 8004167:	00          	.byte	0x00
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 8004168:	2100      	movs	r1, #0
 800416a:	f001 fb49 	bl	8005800 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 800416e:	4620      	mov	r0, r4
 8004170:	2100      	movs	r1, #0
 8004172:	f001 fb2d 	bl	80057d0 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8004176:	6863      	ldr	r3, [r4, #4]
 8004178:	681b      	ldr	r3, [r3, #0]
 800417a:	b113      	cbz	r3, 8004182 <_usb_ep0in+0x32>
 800417c:	4620      	mov	r0, r4
 800417e:	2106      	movs	r1, #6
 8004180:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8004182:	2306      	movs	r3, #6
 8004184:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 8004188:	bd38      	pop	{r3, r4, r5, pc}

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 800418a:	f890 107b 	ldrb.w	r1, [r0, #123]	; 0x7b
 800418e:	f890 307a 	ldrb.w	r3, [r0, #122]	; 0x7a
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8004192:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
 8004194:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8004198:	4293      	cmp	r3, r2
 800419a:	d906      	bls.n	80041aa <_usb_ep0in+0x5a>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 800419c:	68c3      	ldr	r3, [r0, #12]
 800419e:	8a1d      	ldrh	r5, [r3, #16]
 80041a0:	fbb2 f3f5 	udiv	r3, r2, r5
 80041a4:	fb05 2513 	mls	r5, r5, r3, r2
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 80041a8:	b1b5      	cbz	r5, 80041d8 <_usb_ep0in+0x88>
      return;
    }
    /* Falls into, it is intentional.*/
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
 80041aa:	2303      	movs	r3, #3
 80041ac:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 80041b0:	2320      	movs	r3, #32
 80041b2:	f383 8811 	msr	BASEPRI, r3
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
    usbStartReceiveI(usbp, 0, NULL, 0);
 80041b6:	2100      	movs	r1, #0
 80041b8:	460b      	mov	r3, r1
 80041ba:	4620      	mov	r0, r4
 80041bc:	460a      	mov	r2, r1
 80041be:	f7ff fdc7 	bl	8003d50 <usbStartReceiveI>
 80041c2:	2300      	movs	r3, #0
 80041c4:	f383 8811 	msr	BASEPRI, r3
 80041c8:	bd38      	pop	{r3, r4, r5, pc}
    usb_lld_end_setup(usbp, ep);
#endif
    return;
  case USB_EP0_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 80041ca:	6f03      	ldr	r3, [r0, #112]	; 0x70
 80041cc:	b103      	cbz	r3, 80041d0 <_usb_ep0in+0x80>
      usbp->ep0endcb(usbp);
 80041ce:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 80041d0:	2300      	movs	r3, #0
 80041d2:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
    return;
 80041d6:	bd38      	pop	{r3, r4, r5, pc}
 80041d8:	2320      	movs	r3, #32
 80041da:	f383 8811 	msr	BASEPRI, r3
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
      osalSysLockFromISR();
      usbStartTransmitI(usbp, 0, NULL, 0);
 80041de:	4629      	mov	r1, r5
 80041e0:	462a      	mov	r2, r5
 80041e2:	462b      	mov	r3, r5
 80041e4:	f7ff fdcc 	bl	8003d80 <usbStartTransmitI>
 80041e8:	f385 8811 	msr	BASEPRI, r5
      osalSysUnlockFromISR();
      usbp->ep0state = USB_EP0_WAITING_TX0;
 80041ec:	2302      	movs	r3, #2
 80041ee:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
      return;
 80041f2:	bd38      	pop	{r3, r4, r5, pc}
	...

08004200 <_usb_ep0out>:
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {

  (void)ep;
  switch (usbp->ep0state) {
 8004200:	f890 2064 	ldrb.w	r2, [r0, #100]	; 0x64
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8004204:	b538      	push	{r3, r4, r5, lr}
 8004206:	2a06      	cmp	r2, #6
 8004208:	d80a      	bhi.n	8004220 <_usb_ep0out+0x20>
 800420a:	2301      	movs	r3, #1
 800420c:	4093      	lsls	r3, r2
 800420e:	f013 0f67 	tst.w	r3, #103	; 0x67
 8004212:	4604      	mov	r4, r0
 8004214:	d111      	bne.n	800423a <_usb_ep0out+0x3a>
 8004216:	f013 0508 	ands.w	r5, r3, #8
 800421a:	d102      	bne.n	8004222 <_usb_ep0out+0x22>
 800421c:	06db      	lsls	r3, r3, #27
 800421e:	d41d      	bmi.n	800425c <_usb_ep0out+0x5c>
 8004220:	bd38      	pop	{r3, r4, r5, pc}
    return;
  case USB_EP0_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 8004222:	68c3      	ldr	r3, [r0, #12]
 8004224:	699b      	ldr	r3, [r3, #24]
 8004226:	685b      	ldr	r3, [r3, #4]
 8004228:	2b00      	cmp	r3, #0
 800422a:	d1f9      	bne.n	8004220 <_usb_ep0out+0x20>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 800422c:	6f03      	ldr	r3, [r0, #112]	; 0x70
 800422e:	b103      	cbz	r3, 8004232 <_usb_ep0out+0x32>
      usbp->ep0endcb(usbp);
 8004230:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8004232:	2300      	movs	r3, #0
 8004234:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
    return;
 8004238:	bd38      	pop	{r3, r4, r5, pc}
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 800423a:	2100      	movs	r1, #0
 800423c:	f001 fae0 	bl	8005800 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 8004240:	4620      	mov	r0, r4
 8004242:	2100      	movs	r1, #0
 8004244:	f001 fac4 	bl	80057d0 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8004248:	6863      	ldr	r3, [r4, #4]
 800424a:	681b      	ldr	r3, [r3, #0]
 800424c:	b113      	cbz	r3, 8004254 <_usb_ep0out+0x54>
 800424e:	4620      	mov	r0, r4
 8004250:	2106      	movs	r1, #6
 8004252:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8004254:	2306      	movs	r3, #6
 8004256:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 800425a:	bd38      	pop	{r3, r4, r5, pc}

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
 800425c:	2305      	movs	r3, #5
 800425e:	f880 3064 	strb.w	r3, [r0, #100]	; 0x64
 8004262:	2320      	movs	r3, #32
 8004264:	f383 8811 	msr	BASEPRI, r3
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
    usbStartTransmitI(usbp, 0, NULL, 0);
 8004268:	4629      	mov	r1, r5
 800426a:	462a      	mov	r2, r5
 800426c:	462b      	mov	r3, r5
 800426e:	f7ff fd87 	bl	8003d80 <usbStartTransmitI>
 8004272:	f385 8811 	msr	BASEPRI, r5
 8004276:	bd38      	pop	{r3, r4, r5, pc}
	...

08004280 <nvicEnableVector>:
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8004280:	0943      	lsrs	r3, r0, #5
 8004282:	009b      	lsls	r3, r3, #2
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8004284:	b410      	push	{r4}

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8004286:	0109      	lsls	r1, r1, #4
 8004288:	f100 4460 	add.w	r4, r0, #3758096384	; 0xe0000000
 800428c:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8004290:	f000 001f 	and.w	r0, r0, #31
 8004294:	2201      	movs	r2, #1

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8004296:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
 800429a:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800429e:	4082      	lsls	r2, r0

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80042a0:	b2c9      	uxtb	r1, r1
 80042a2:	f884 1300 	strb.w	r1, [r4, #768]	; 0x300
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80042a6:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80042aa:	601a      	str	r2, [r3, #0]
}
 80042ac:	f85d 4b04 	ldr.w	r4, [sp], #4
 80042b0:	4770      	bx	lr
 80042b2:	bf00      	nop
	...

080042c0 <nvicDisableVector>:
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 80042c0:	4908      	ldr	r1, [pc, #32]	; (80042e4 <nvicDisableVector+0x24>)
/**
 * @brief   Disables an interrupt handler.
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {
 80042c2:	b410      	push	{r4}

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 80042c4:	0943      	lsrs	r3, r0, #5
 80042c6:	f000 041f 	and.w	r4, r0, #31
 80042ca:	2201      	movs	r2, #1
 80042cc:	40a2      	lsls	r2, r4
 80042ce:	3320      	adds	r3, #32
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 80042d0:	2400      	movs	r4, #0
 80042d2:	4408      	add	r0, r1
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 80042d4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 80042d8:	f880 4300 	strb.w	r4, [r0, #768]	; 0x300
#endif
}
 80042dc:	f85d 4b04 	ldr.w	r4, [sp], #4
 80042e0:	4770      	bx	lr
 80042e2:	bf00      	nop
 80042e4:	e000e100 	.word	0xe000e100
	...

080042f0 <nvicSetSystemHandlerPriority>:
  SCB->SHP[_SHP_IDX(handler)] = (SCB->SHP[_SHP_IDX(handler)] & ~(0xFFU << _BIT_SHIFT(handler))) |
                                (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(handler));
#elif defined(__CORE_CM7_H_GENERIC)
  SCB->SHPR[handler] = NVIC_PRIORITY_MASK(prio);
#else
  SCB->SHP[handler] = NVIC_PRIORITY_MASK(prio);
 80042f0:	0109      	lsls	r1, r1, #4
 80042f2:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 80042f6:	b2c9      	uxtb	r1, r1
 80042f8:	f500 406d 	add.w	r0, r0, #60672	; 0xed00
 80042fc:	7601      	strb	r1, [r0, #24]
 80042fe:	4770      	bx	lr

08004300 <Vector12C>:
/**
 * @brief   DMA2 streams 4 and 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH45_HANDLER) {
 8004300:	b570      	push	{r4, r5, r6, lr}

  OSAL_IRQ_PROLOGUE();

  /* Check on channel 4 of DMA2.*/
  dmaServeInterrupt(STM32_DMA2_STREAM4);
 8004302:	4c18      	ldr	r4, [pc, #96]	; (8004364 <Vector12C+0x64>)
 8004304:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 8004308:	f894 20d8 	ldrb.w	r2, [r4, #216]	; 0xd8
 800430c:	6819      	ldr	r1, [r3, #0]
 800430e:	f894 50d9 	ldrb.w	r5, [r4, #217]	; 0xd9
 8004312:	40d1      	lsrs	r1, r2
 8004314:	f011 010f 	ands.w	r1, r1, #15
 8004318:	d00a      	beq.n	8004330 <Vector12C+0x30>
 800431a:	4813      	ldr	r0, [pc, #76]	; (8004368 <Vector12C+0x68>)
 800431c:	fa01 f602 	lsl.w	r6, r1, r2
 8004320:	f850 2035 	ldr.w	r2, [r0, r5, lsl #3]
 8004324:	605e      	str	r6, [r3, #4]
 8004326:	b11a      	cbz	r2, 8004330 <Vector12C+0x30>
 8004328:	eb00 00c5 	add.w	r0, r0, r5, lsl #3
 800432c:	6840      	ldr	r0, [r0, #4]
 800432e:	4790      	blx	r2

  /* Check on channel 5 of DMA2.*/
  dmaServeInterrupt(STM32_DMA2_STREAM5);
 8004330:	f8d4 20dc 	ldr.w	r2, [r4, #220]	; 0xdc
 8004334:	f894 00ec 	ldrb.w	r0, [r4, #236]	; 0xec
 8004338:	6811      	ldr	r1, [r2, #0]
 800433a:	f894 40ed 	ldrb.w	r4, [r4, #237]	; 0xed
 800433e:	40c1      	lsrs	r1, r0
 8004340:	f011 010f 	ands.w	r1, r1, #15
 8004344:	d00a      	beq.n	800435c <Vector12C+0x5c>
 8004346:	4b08      	ldr	r3, [pc, #32]	; (8004368 <Vector12C+0x68>)
 8004348:	fa01 f000 	lsl.w	r0, r1, r0
 800434c:	f853 5034 	ldr.w	r5, [r3, r4, lsl #3]
 8004350:	6050      	str	r0, [r2, #4]
 8004352:	b11d      	cbz	r5, 800435c <Vector12C+0x5c>
 8004354:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 8004358:	6858      	ldr	r0, [r3, #4]
 800435a:	47a8      	blx	r5

  OSAL_IRQ_EPILOGUE();
}
 800435c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  dmaServeInterrupt(STM32_DMA2_STREAM4);

  /* Check on channel 5 of DMA2.*/
  dmaServeInterrupt(STM32_DMA2_STREAM5);

  OSAL_IRQ_EPILOGUE();
 8004360:	f7fe be96 	b.w	8003090 <_port_irq_epilogue>
 8004364:	0800d5d0 	.word	0x0800d5d0
 8004368:	200012b8 	.word	0x200012b8
 800436c:	00000000 	.word	0x00000000

08004370 <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAPB1(0xFFFFFFFF);
 8004370:	4b0c      	ldr	r3, [pc, #48]	; (80043a4 <hal_lld_init+0x34>)
 8004372:	f04f 31ff 	mov.w	r1, #4294967295
 8004376:	2200      	movs	r2, #0
 8004378:	6918      	ldr	r0, [r3, #16]
 800437a:	6119      	str	r1, [r3, #16]
 800437c:	611a      	str	r2, [r3, #16]
  rccResetAPB2(0xFFFFFFFF);
 800437e:	68d8      	ldr	r0, [r3, #12]
 8004380:	60d9      	str	r1, [r3, #12]
 8004382:	60da      	str	r2, [r3, #12]

  /* PWR and BD clocks enabled.*/
  rccEnablePWRInterface(FALSE);
 8004384:	69da      	ldr	r2, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8004386:	4908      	ldr	r1, [pc, #32]	; (80043a8 <hal_lld_init+0x38>)
  /* Reset of all peripherals.*/
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(0xFFFFFFFF);

  /* PWR and BD clocks enabled.*/
  rccEnablePWRInterface(FALSE);
 8004388:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800438c:	61da      	str	r2, [r3, #28]
  rccEnableBKPInterface(FALSE);
 800438e:	69da      	ldr	r2, [r3, #28]
 8004390:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 8004394:	61da      	str	r2, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8004396:	680b      	ldr	r3, [r1, #0]
 8004398:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800439c:	600b      	str	r3, [r1, #0]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 800439e:	f000 b93f 	b.w	8004620 <dmaInit>
 80043a2:	bf00      	nop
 80043a4:	40021000 	.word	0x40021000
 80043a8:	40007000 	.word	0x40007000
 80043ac:	00000000 	.word	0x00000000

080043b0 <stm32_clock_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80043b0:	4b1f      	ldr	r3, [pc, #124]	; (8004430 <stm32_clock_init+0x80>)
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80043b2:	4619      	mov	r1, r3
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80043b4:	681a      	ldr	r2, [r3, #0]
 80043b6:	f042 0201 	orr.w	r2, r2, #1
 80043ba:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80043bc:	680b      	ldr	r3, [r1, #0]
 80043be:	4a1c      	ldr	r2, [pc, #112]	; (8004430 <stm32_clock_init+0x80>)
 80043c0:	079b      	lsls	r3, r3, #30
 80043c2:	d5fb      	bpl.n	80043bc <stm32_clock_init+0xc>
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  RCC->CFGR = 0;                            /* CFGR reset value.            */
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80043c4:	4611      	mov	r1, r2
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  while (!(RCC->CR & RCC_CR_HSIRDY))
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80043c6:	6813      	ldr	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 80043c8:	2000      	movs	r0, #0
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  while (!(RCC->CR & RCC_CR_HSIRDY))
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80043ca:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 80043ce:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 80043d0:	6050      	str	r0, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80043d2:	684b      	ldr	r3, [r1, #4]
 80043d4:	4a16      	ldr	r2, [pc, #88]	; (8004430 <stm32_clock_init+0x80>)
 80043d6:	f013 0f0c 	tst.w	r3, #12
 80043da:	d1fa      	bne.n	80043d2 <stm32_clock_init+0x22>
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#endif
  /* HSE activation.*/
  RCC->CR |= RCC_CR_HSEON;
  while (!(RCC->CR & RCC_CR_HSERDY))
 80043dc:	4611      	mov	r1, r2
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#endif
  /* HSE activation.*/
  RCC->CR |= RCC_CR_HSEON;
 80043de:	6813      	ldr	r3, [r2, #0]
 80043e0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80043e4:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSERDY))
 80043e6:	680b      	ldr	r3, [r1, #0]
 80043e8:	4a11      	ldr	r2, [pc, #68]	; (8004430 <stm32_clock_init+0x80>)
 80043ea:	0398      	lsls	r0, r3, #14
 80043ec:	d5fb      	bpl.n	80043e6 <stm32_clock_init+0x36>

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLMUL | STM32_PLLXTPRE | STM32_PLLSRC;
  RCC->CR   |= RCC_CR_PLLON;
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80043ee:	4611      	mov	r1, r2
    ;                                       /* Waits until LSI is stable.   */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLMUL | STM32_PLLXTPRE | STM32_PLLSRC;
 80043f0:	6853      	ldr	r3, [r2, #4]
 80043f2:	f443 13e8 	orr.w	r3, r3, #1900544	; 0x1d0000
 80043f6:	6053      	str	r3, [r2, #4]
  RCC->CR   |= RCC_CR_PLLON;
 80043f8:	6813      	ldr	r3, [r2, #0]
 80043fa:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80043fe:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8004400:	680b      	ldr	r3, [r1, #0]
 8004402:	4a0b      	ldr	r2, [pc, #44]	; (8004430 <stm32_clock_init+0x80>)
 8004404:	019b      	lsls	r3, r3, #6
 8004406:	d5fb      	bpl.n	8004400 <stm32_clock_init+0x50>

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8004408:	4611      	mov	r1, r2
    defined(STM32F10X_HD) || defined(STM32F10X_XL) ||                       \
    defined(__DOXYGEN__)
/*
 * Clocks initialization for all sub-families except CL.
 */
void stm32_clock_init(void) {
 800440a:	b410      	push	{r4}
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 800440c:	4b09      	ldr	r3, [pc, #36]	; (8004434 <stm32_clock_init+0x84>)
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Clock settings.*/
#if STM32_HAS_USB
  RCC->CFGR = STM32_MCOSEL | STM32_USBPRE | STM32_PLLMUL | STM32_PLLXTPRE |
 800440e:	4c0a      	ldr	r4, [pc, #40]	; (8004438 <stm32_clock_init+0x88>)
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8004410:	2012      	movs	r0, #18
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Clock settings.*/
#if STM32_HAS_USB
  RCC->CFGR = STM32_MCOSEL | STM32_USBPRE | STM32_PLLMUL | STM32_PLLXTPRE |
 8004412:	6054      	str	r4, [r2, #4]
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8004414:	6018      	str	r0, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8004416:	6853      	ldr	r3, [r2, #4]
 8004418:	f043 0302 	orr.w	r3, r3, #2
 800441c:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800441e:	684b      	ldr	r3, [r1, #4]
 8004420:	f003 030c 	and.w	r3, r3, #12
 8004424:	2b08      	cmp	r3, #8
 8004426:	d1fa      	bne.n	800441e <stm32_clock_init+0x6e>

#if !STM32_HSI_ENABLED
  RCC->CR &= ~RCC_CR_HSION;
#endif
#endif /* !STM32_NO_INIT */
}
 8004428:	f85d 4b04 	ldr.w	r4, [sp], #4
 800442c:	4770      	bx	lr
 800442e:	bf00      	nop
 8004430:	40021000 	.word	0x40021000
 8004434:	40022000 	.word	0x40022000
 8004438:	001de400 	.word	0x001de400
 800443c:	00000000 	.word	0x00000000

08004440 <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8004440:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8004442:	4b07      	ldr	r3, [pc, #28]	; (8004460 <Vector6C+0x20>)
 8004444:	6819      	ldr	r1, [r3, #0]
 8004446:	f011 010f 	ands.w	r1, r1, #15
 800444a:	d005      	beq.n	8004458 <Vector6C+0x18>
 800444c:	4a05      	ldr	r2, [pc, #20]	; (8004464 <Vector6C+0x24>)
 800444e:	6059      	str	r1, [r3, #4]
 8004450:	6813      	ldr	r3, [r2, #0]
 8004452:	b10b      	cbz	r3, 8004458 <Vector6C+0x18>
 8004454:	6850      	ldr	r0, [r2, #4]
 8004456:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8004458:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);

  OSAL_IRQ_EPILOGUE();
 800445c:	f7fe be18 	b.w	8003090 <_port_irq_epilogue>
 8004460:	40020000 	.word	0x40020000
 8004464:	200012b8 	.word	0x200012b8
	...

08004470 <Vector70>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8004470:	4b09      	ldr	r3, [pc, #36]	; (8004498 <Vector70+0x28>)
 8004472:	6819      	ldr	r1, [r3, #0]
 8004474:	f3c1 1103 	ubfx	r1, r1, #4, #4
 8004478:	b159      	cbz	r1, 8004492 <Vector70+0x22>
 800447a:	4808      	ldr	r0, [pc, #32]	; (800449c <Vector70+0x2c>)
/**
 * @brief   DMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 800447c:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 800447e:	6884      	ldr	r4, [r0, #8]
 8004480:	010a      	lsls	r2, r1, #4
 8004482:	605a      	str	r2, [r3, #4]
 8004484:	b10c      	cbz	r4, 800448a <Vector70+0x1a>
 8004486:	68c0      	ldr	r0, [r0, #12]
 8004488:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 800448a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);

  OSAL_IRQ_EPILOGUE();
 800448e:	f7fe bdff 	b.w	8003090 <_port_irq_epilogue>
 8004492:	f7fe bdfd 	b.w	8003090 <_port_irq_epilogue>
 8004496:	bf00      	nop
 8004498:	40020000 	.word	0x40020000
 800449c:	200012b8 	.word	0x200012b8

080044a0 <Vector74>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 80044a0:	4b09      	ldr	r3, [pc, #36]	; (80044c8 <Vector74+0x28>)
 80044a2:	6819      	ldr	r1, [r3, #0]
 80044a4:	f3c1 2103 	ubfx	r1, r1, #8, #4
 80044a8:	b159      	cbz	r1, 80044c2 <Vector74+0x22>
 80044aa:	4808      	ldr	r0, [pc, #32]	; (80044cc <Vector74+0x2c>)
/**
 * @brief   DMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 80044ac:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 80044ae:	6904      	ldr	r4, [r0, #16]
 80044b0:	020a      	lsls	r2, r1, #8
 80044b2:	605a      	str	r2, [r3, #4]
 80044b4:	b10c      	cbz	r4, 80044ba <Vector74+0x1a>
 80044b6:	6940      	ldr	r0, [r0, #20]
 80044b8:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 80044ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);

  OSAL_IRQ_EPILOGUE();
 80044be:	f7fe bde7 	b.w	8003090 <_port_irq_epilogue>
 80044c2:	f7fe bde5 	b.w	8003090 <_port_irq_epilogue>
 80044c6:	bf00      	nop
 80044c8:	40020000 	.word	0x40020000
 80044cc:	200012b8 	.word	0x200012b8

080044d0 <Vector78>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 80044d0:	4b09      	ldr	r3, [pc, #36]	; (80044f8 <Vector78+0x28>)
 80044d2:	6819      	ldr	r1, [r3, #0]
 80044d4:	f3c1 3103 	ubfx	r1, r1, #12, #4
 80044d8:	b159      	cbz	r1, 80044f2 <Vector78+0x22>
 80044da:	4808      	ldr	r0, [pc, #32]	; (80044fc <Vector78+0x2c>)
/**
 * @brief   DMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 80044dc:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 80044de:	6984      	ldr	r4, [r0, #24]
 80044e0:	030a      	lsls	r2, r1, #12
 80044e2:	605a      	str	r2, [r3, #4]
 80044e4:	b10c      	cbz	r4, 80044ea <Vector78+0x1a>
 80044e6:	69c0      	ldr	r0, [r0, #28]
 80044e8:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 80044ea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);

  OSAL_IRQ_EPILOGUE();
 80044ee:	f7fe bdcf 	b.w	8003090 <_port_irq_epilogue>
 80044f2:	f7fe bdcd 	b.w	8003090 <_port_irq_epilogue>
 80044f6:	bf00      	nop
 80044f8:	40020000 	.word	0x40020000
 80044fc:	200012b8 	.word	0x200012b8

08004500 <Vector7C>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 8004500:	4b09      	ldr	r3, [pc, #36]	; (8004528 <Vector7C+0x28>)
 8004502:	6819      	ldr	r1, [r3, #0]
 8004504:	f3c1 4103 	ubfx	r1, r1, #16, #4
 8004508:	b159      	cbz	r1, 8004522 <Vector7C+0x22>
 800450a:	4808      	ldr	r0, [pc, #32]	; (800452c <Vector7C+0x2c>)
/**
 * @brief   DMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 800450c:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 800450e:	6a04      	ldr	r4, [r0, #32]
 8004510:	040a      	lsls	r2, r1, #16
 8004512:	605a      	str	r2, [r3, #4]
 8004514:	b10c      	cbz	r4, 800451a <Vector7C+0x1a>
 8004516:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8004518:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 800451a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);

  OSAL_IRQ_EPILOGUE();
 800451e:	f7fe bdb7 	b.w	8003090 <_port_irq_epilogue>
 8004522:	f7fe bdb5 	b.w	8003090 <_port_irq_epilogue>
 8004526:	bf00      	nop
 8004528:	40020000 	.word	0x40020000
 800452c:	200012b8 	.word	0x200012b8

08004530 <Vector80>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 8004530:	4b09      	ldr	r3, [pc, #36]	; (8004558 <Vector80+0x28>)
 8004532:	6819      	ldr	r1, [r3, #0]
 8004534:	f3c1 5103 	ubfx	r1, r1, #20, #4
 8004538:	b159      	cbz	r1, 8004552 <Vector80+0x22>
 800453a:	4808      	ldr	r0, [pc, #32]	; (800455c <Vector80+0x2c>)
/**
 * @brief   DMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 800453c:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 800453e:	6a84      	ldr	r4, [r0, #40]	; 0x28
 8004540:	050a      	lsls	r2, r1, #20
 8004542:	605a      	str	r2, [r3, #4]
 8004544:	b10c      	cbz	r4, 800454a <Vector80+0x1a>
 8004546:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8004548:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 800454a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);

  OSAL_IRQ_EPILOGUE();
 800454e:	f7fe bd9f 	b.w	8003090 <_port_irq_epilogue>
 8004552:	f7fe bd9d 	b.w	8003090 <_port_irq_epilogue>
 8004556:	bf00      	nop
 8004558:	40020000 	.word	0x40020000
 800455c:	200012b8 	.word	0x200012b8

08004560 <Vector84>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 8004560:	4b09      	ldr	r3, [pc, #36]	; (8004588 <Vector84+0x28>)
 8004562:	6819      	ldr	r1, [r3, #0]
 8004564:	f3c1 6103 	ubfx	r1, r1, #24, #4
 8004568:	b159      	cbz	r1, 8004582 <Vector84+0x22>
 800456a:	4808      	ldr	r0, [pc, #32]	; (800458c <Vector84+0x2c>)
/**
 * @brief   DMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 800456c:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 800456e:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8004570:	060a      	lsls	r2, r1, #24
 8004572:	605a      	str	r2, [r3, #4]
 8004574:	b10c      	cbz	r4, 800457a <Vector84+0x1a>
 8004576:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8004578:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 800457a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);

  OSAL_IRQ_EPILOGUE();
 800457e:	f7fe bd87 	b.w	8003090 <_port_irq_epilogue>
 8004582:	f7fe bd85 	b.w	8003090 <_port_irq_epilogue>
 8004586:	bf00      	nop
 8004588:	40020000 	.word	0x40020000
 800458c:	200012b8 	.word	0x200012b8

08004590 <Vector120>:
/**
 * @brief   DMA2 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8004590:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM1);
 8004592:	4b07      	ldr	r3, [pc, #28]	; (80045b0 <Vector120+0x20>)
 8004594:	6819      	ldr	r1, [r3, #0]
 8004596:	f011 010f 	ands.w	r1, r1, #15
 800459a:	d005      	beq.n	80045a8 <Vector120+0x18>
 800459c:	4a05      	ldr	r2, [pc, #20]	; (80045b4 <Vector120+0x24>)
 800459e:	6059      	str	r1, [r3, #4]
 80045a0:	6b93      	ldr	r3, [r2, #56]	; 0x38
 80045a2:	b10b      	cbz	r3, 80045a8 <Vector120+0x18>
 80045a4:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
 80045a6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 80045a8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM1);

  OSAL_IRQ_EPILOGUE();
 80045ac:	f7fe bd70 	b.w	8003090 <_port_irq_epilogue>
 80045b0:	40020400 	.word	0x40020400
 80045b4:	200012b8 	.word	0x200012b8
	...

080045c0 <Vector124>:
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM2);
 80045c0:	4b09      	ldr	r3, [pc, #36]	; (80045e8 <Vector124+0x28>)
 80045c2:	6819      	ldr	r1, [r3, #0]
 80045c4:	f3c1 1103 	ubfx	r1, r1, #4, #4
 80045c8:	b159      	cbz	r1, 80045e2 <Vector124+0x22>
 80045ca:	4808      	ldr	r0, [pc, #32]	; (80045ec <Vector124+0x2c>)
/**
 * @brief   DMA2 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 80045cc:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM2);
 80045ce:	6c04      	ldr	r4, [r0, #64]	; 0x40
 80045d0:	010a      	lsls	r2, r1, #4
 80045d2:	605a      	str	r2, [r3, #4]
 80045d4:	b10c      	cbz	r4, 80045da <Vector124+0x1a>
 80045d6:	6c40      	ldr	r0, [r0, #68]	; 0x44
 80045d8:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 80045da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM2);

  OSAL_IRQ_EPILOGUE();
 80045de:	f7fe bd57 	b.w	8003090 <_port_irq_epilogue>
 80045e2:	f7fe bd55 	b.w	8003090 <_port_irq_epilogue>
 80045e6:	bf00      	nop
 80045e8:	40020400 	.word	0x40020400
 80045ec:	200012b8 	.word	0x200012b8

080045f0 <Vector128>:
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM3);
 80045f0:	4b09      	ldr	r3, [pc, #36]	; (8004618 <Vector128+0x28>)
 80045f2:	6819      	ldr	r1, [r3, #0]
 80045f4:	f3c1 2103 	ubfx	r1, r1, #8, #4
 80045f8:	b159      	cbz	r1, 8004612 <Vector128+0x22>
 80045fa:	4808      	ldr	r0, [pc, #32]	; (800461c <Vector128+0x2c>)
/**
 * @brief   DMA2 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 80045fc:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM3);
 80045fe:	6c84      	ldr	r4, [r0, #72]	; 0x48
 8004600:	020a      	lsls	r2, r1, #8
 8004602:	605a      	str	r2, [r3, #4]
 8004604:	b10c      	cbz	r4, 800460a <Vector128+0x1a>
 8004606:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 8004608:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 800460a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM3);

  OSAL_IRQ_EPILOGUE();
 800460e:	f7fe bd3f 	b.w	8003090 <_port_irq_epilogue>
 8004612:	f7fe bd3d 	b.w	8003090 <_port_irq_epilogue>
 8004616:	bf00      	nop
 8004618:	40020400 	.word	0x40020400
 800461c:	200012b8 	.word	0x200012b8

08004620 <dmaInit>:
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
 8004620:	2000      	movs	r0, #0
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8004622:	4603      	mov	r3, r0
    _stm32_dma_streams[i].channel->CCR = 0U;
 8004624:	4601      	mov	r1, r0
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8004626:	b430      	push	{r4, r5}
  int i;

  dma_streams_mask = 0U;
 8004628:	4d09      	ldr	r5, [pc, #36]	; (8004650 <dmaInit+0x30>)
 800462a:	4a0a      	ldr	r2, [pc, #40]	; (8004654 <dmaInit+0x34>)
 800462c:	4c0a      	ldr	r4, [pc, #40]	; (8004658 <dmaInit+0x38>)
 800462e:	6028      	str	r0, [r5, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0U;
 8004630:	6850      	ldr	r0, [r2, #4]
 8004632:	3214      	adds	r2, #20
 8004634:	6001      	str	r1, [r0, #0]
    _stm32_dma_isr_redir[i].dma_func = NULL;
 8004636:	f844 1033 	str.w	r1, [r4, r3, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800463a:	3301      	adds	r3, #1
 800463c:	2b0c      	cmp	r3, #12
 800463e:	d1f7      	bne.n	8004630 <dmaInit+0x10>
    _stm32_dma_streams[i].channel->CCR = 0U;
    _stm32_dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8004640:	4906      	ldr	r1, [pc, #24]	; (800465c <dmaInit+0x3c>)
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
 8004642:	4a07      	ldr	r2, [pc, #28]	; (8004660 <dmaInit+0x40>)
  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0U;
    _stm32_dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8004644:	f04f 33ff 	mov.w	r3, #4294967295
 8004648:	604b      	str	r3, [r1, #4]
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
#endif
}
 800464a:	bc30      	pop	{r4, r5}
    _stm32_dma_streams[i].channel->CCR = 0U;
    _stm32_dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFFU;
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
 800464c:	6053      	str	r3, [r2, #4]
#endif
}
 800464e:	4770      	bx	lr
 8004650:	20001318 	.word	0x20001318
 8004654:	0800d5d0 	.word	0x0800d5d0
 8004658:	200012b8 	.word	0x200012b8
 800465c:	40020000 	.word	0x40020000
 8004660:	40020400 	.word	0x40020400
	...

08004670 <dmaStreamAllocate>:
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {
 8004670:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8004672:	4f21      	ldr	r7, [pc, #132]	; (80046f8 <dmaStreamAllocate+0x88>)
 8004674:	7c46      	ldrb	r6, [r0, #17]
 8004676:	2401      	movs	r4, #1
 8004678:	683d      	ldr	r5, [r7, #0]
 800467a:	fa04 fe06 	lsl.w	lr, r4, r6
 800467e:	ea1e 0f05 	tst.w	lr, r5
 8004682:	d137      	bne.n	80046f4 <dmaStreamAllocate+0x84>
    return true;

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8004684:	4c1d      	ldr	r4, [pc, #116]	; (80046fc <dmaStreamAllocate+0x8c>)
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 8004686:	eb04 0ec6 	add.w	lr, r4, r6, lsl #3
 800468a:	f8ce 3004 	str.w	r3, [lr, #4]

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 800468e:	066b      	lsls	r3, r5, #25
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8004690:	f844 2036 	str.w	r2, [r4, r6, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8004694:	d104      	bne.n	80046a0 <dmaStreamAllocate+0x30>
    rccEnableDMA1(false);
 8004696:	4c1a      	ldr	r4, [pc, #104]	; (8004700 <dmaStreamAllocate+0x90>)
 8004698:	6963      	ldr	r3, [r4, #20]
 800469a:	f043 0301 	orr.w	r3, r3, #1
 800469e:	6163      	str	r3, [r4, #20]
  }
#if STM32_DMA2_NUM_CHANNELS > 0
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 80046a0:	f415 6f78 	tst.w	r5, #3968	; 0xf80
 80046a4:	d104      	bne.n	80046b0 <dmaStreamAllocate+0x40>
    rccEnableDMA2(false);
 80046a6:	4c16      	ldr	r4, [pc, #88]	; (8004700 <dmaStreamAllocate+0x90>)
 80046a8:	6963      	ldr	r3, [r4, #20]
 80046aa:	f043 0302 	orr.w	r3, r3, #2
 80046ae:	6163      	str	r3, [r4, #20]
 80046b0:	4604      	mov	r4, r0
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 80046b2:	6843      	ldr	r3, [r0, #4]
 80046b4:	f8d4 c000 	ldr.w	ip, [r4]
 80046b8:	681e      	ldr	r6, [r3, #0]
 80046ba:	200f      	movs	r0, #15
 80046bc:	f026 060f 	bic.w	r6, r6, #15
 80046c0:	601e      	str	r6, [r3, #0]
 80046c2:	f894 e010 	ldrb.w	lr, [r4, #16]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 80046c6:	68a6      	ldr	r6, [r4, #8]
    rccEnableDMA2(false);
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 80046c8:	fa00 f00e 	lsl.w	r0, r0, lr
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 80046cc:	4235      	tst	r5, r6
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 80046ce:	f04f 0e00 	mov.w	lr, #0
    rccEnableDMA2(false);
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 80046d2:	f8cc 0004 	str.w	r0, [ip, #4]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 80046d6:	f8c3 e000 	str.w	lr, [r3]

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 80046da:	d104      	bne.n	80046e6 <dmaStreamAllocate+0x76>
 80046dc:	b11a      	cbz	r2, 80046e6 <dmaStreamAllocate+0x76>
      (func != NULL)) {
    nvicEnableVector(dmastp->vector, priority);
 80046de:	7ca0      	ldrb	r0, [r4, #18]
 80046e0:	f7ff fdce 	bl	8004280 <nvicEnableVector>
 80046e4:	683d      	ldr	r5, [r7, #0]
  }

  /* Marks the stream as allocated.*/
  dma_streams_mask |= (1U << dmastp->selfindex);
 80046e6:	7c62      	ldrb	r2, [r4, #17]
 80046e8:	2301      	movs	r3, #1
 80046ea:	4093      	lsls	r3, r2
 80046ec:	431d      	orrs	r5, r3
 80046ee:	603d      	str	r5, [r7, #0]

  return false;
 80046f0:	2000      	movs	r0, #0
 80046f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;
 80046f4:	4620      	mov	r0, r4

  /* Marks the stream as allocated.*/
  dma_streams_mask |= (1U << dmastp->selfindex);

  return false;
}
 80046f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80046f8:	20001318 	.word	0x20001318
 80046fc:	200012b8 	.word	0x200012b8
 8004700:	40021000 	.word	0x40021000
	...

08004710 <dmaStreamRelease>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @special
 */
void dmaStreamRelease(const stm32_dma_stream_t *dmastp) {
 8004710:	b538      	push	{r3, r4, r5, lr}
  /* Check if the streams is not taken.*/
  osalDbgAssert((dma_streams_mask & (1 << dmastp->selfindex)) != 0U,
                "not allocated");

  /* Marks the stream as not allocated.*/
  dma_streams_mask &= ~(1U << dmastp->selfindex);
 8004712:	4d14      	ldr	r5, [pc, #80]	; (8004764 <dmaStreamRelease+0x54>)
 8004714:	7c41      	ldrb	r1, [r0, #17]
 8004716:	682a      	ldr	r2, [r5, #0]
 8004718:	2301      	movs	r3, #1
 800471a:	408b      	lsls	r3, r1

  /* Disables the associated IRQ vector if it is no more in use.*/
  if ((dma_streams_mask & dmastp->cmask) == 0U) {
 800471c:	6884      	ldr	r4, [r0, #8]
  /* Check if the streams is not taken.*/
  osalDbgAssert((dma_streams_mask & (1 << dmastp->selfindex)) != 0U,
                "not allocated");

  /* Marks the stream as not allocated.*/
  dma_streams_mask &= ~(1U << dmastp->selfindex);
 800471e:	ea22 0303 	bic.w	r3, r2, r3

  /* Disables the associated IRQ vector if it is no more in use.*/
  if ((dma_streams_mask & dmastp->cmask) == 0U) {
 8004722:	4223      	tst	r3, r4
  /* Check if the streams is not taken.*/
  osalDbgAssert((dma_streams_mask & (1 << dmastp->selfindex)) != 0U,
                "not allocated");

  /* Marks the stream as not allocated.*/
  dma_streams_mask &= ~(1U << dmastp->selfindex);
 8004724:	602b      	str	r3, [r5, #0]

  /* Disables the associated IRQ vector if it is no more in use.*/
  if ((dma_streams_mask & dmastp->cmask) == 0U) {
 8004726:	d016      	beq.n	8004756 <dmaStreamRelease+0x46>
    nvicDisableVector(dmastp->vector);
  }

  /* Removes the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = NULL;
 8004728:	4a0f      	ldr	r2, [pc, #60]	; (8004768 <dmaStreamRelease+0x58>)
 800472a:	2000      	movs	r0, #0
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = NULL;
 800472c:	eb02 04c1 	add.w	r4, r2, r1, lsl #3
  if ((dma_streams_mask & dmastp->cmask) == 0U) {
    nvicDisableVector(dmastp->vector);
  }

  /* Removes the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = NULL;
 8004730:	f842 0031 	str.w	r0, [r2, r1, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = NULL;

  /* Shutting down clocks that are no more required, if any.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8004734:	065a      	lsls	r2, r3, #25
    nvicDisableVector(dmastp->vector);
  }

  /* Removes the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = NULL;
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = NULL;
 8004736:	6060      	str	r0, [r4, #4]

  /* Shutting down clocks that are no more required, if any.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8004738:	d104      	bne.n	8004744 <dmaStreamRelease+0x34>
    rccDisableDMA1(false);
 800473a:	490c      	ldr	r1, [pc, #48]	; (800476c <dmaStreamRelease+0x5c>)
 800473c:	694a      	ldr	r2, [r1, #20]
 800473e:	f022 0201 	bic.w	r2, r2, #1
 8004742:	614a      	str	r2, [r1, #20]
  }
#if STM32_DMA2_NUM_CHANNELS > 0
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 8004744:	f413 6f78 	tst.w	r3, #3968	; 0xf80
 8004748:	d104      	bne.n	8004754 <dmaStreamRelease+0x44>
    rccDisableDMA2(false);
 800474a:	4a08      	ldr	r2, [pc, #32]	; (800476c <dmaStreamRelease+0x5c>)
 800474c:	6953      	ldr	r3, [r2, #20]
 800474e:	f023 0302 	bic.w	r3, r3, #2
 8004752:	6153      	str	r3, [r2, #20]
 8004754:	bd38      	pop	{r3, r4, r5, pc}
 8004756:	4604      	mov	r4, r0
  /* Marks the stream as not allocated.*/
  dma_streams_mask &= ~(1U << dmastp->selfindex);

  /* Disables the associated IRQ vector if it is no more in use.*/
  if ((dma_streams_mask & dmastp->cmask) == 0U) {
    nvicDisableVector(dmastp->vector);
 8004758:	7c80      	ldrb	r0, [r0, #18]
 800475a:	f7ff fdb1 	bl	80042c0 <nvicDisableVector>
 800475e:	7c61      	ldrb	r1, [r4, #17]
 8004760:	682b      	ldr	r3, [r5, #0]
 8004762:	e7e1      	b.n	8004728 <dmaStreamRelease+0x18>
 8004764:	20001318 	.word	0x20001318
 8004768:	200012b8 	.word	0x200012b8
 800476c:	40021000 	.word	0x40021000

08004770 <SysTick_Handler>:
 * @brief   System Timer vector.
 * @details This interrupt is used for system tick in periodic mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SysTick_Handler) {
 8004770:	b508      	push	{r3, lr}
 8004772:	2320      	movs	r3, #32
 8004774:	f383 8811 	msr	BASEPRI, r3
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
 8004778:	f7fc ff9a 	bl	80016b0 <chSysTimerHandlerI>
 800477c:	2300      	movs	r3, #0
 800477e:	f383 8811 	msr	BASEPRI, r3
  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
}
 8004782:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
 8004786:	f7fe bc83 	b.w	8003090 <_port_irq_epilogue>
 800478a:	bf00      	nop
 800478c:	0000      	movs	r0, r0
	...

08004790 <st_lld_init>:
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
 8004790:	f648 409f 	movw	r0, #35999	; 0x8c9f
 8004794:	4b04      	ldr	r3, [pc, #16]	; (80047a8 <st_lld_init+0x18>)
  SysTick->VAL = 0;
 8004796:	2100      	movs	r1, #0
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 8004798:	2207      	movs	r2, #7
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
 800479a:	6058      	str	r0, [r3, #4]
  SysTick->VAL = 0;
 800479c:	6099      	str	r1, [r3, #8]
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
 800479e:	200b      	movs	r0, #11
 80047a0:	2108      	movs	r1, #8
#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
  SysTick->VAL = 0;
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 80047a2:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
 80047a4:	f7ff bda4 	b.w	80042f0 <nvicSetSystemHandlerPriority>
 80047a8:	e000e010 	.word	0xe000e010
 80047ac:	00000000 	.word	0x00000000

080047b0 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
 80047b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
 80047b2:	4c16      	ldr	r4, [pc, #88]	; (800480c <adc_lld_init+0x5c>)
                  STM32_DMA_CR_MINC        | STM32_DMA_CR_TCIE        |
                  STM32_DMA_CR_TEIE;

  /* Temporary activation.*/
  rccEnableADC1(FALSE);
  ADC1->CR1 = 0;
 80047b4:	2700      	movs	r7, #0
 */
void adc_lld_init(void) {

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
 80047b6:	4620      	mov	r0, r4
 80047b8:	f7fe ff2a 	bl	8003610 <adcObjectInit>
  ADCD1.adc = ADC1;
 80047bc:	4b14      	ldr	r3, [pc, #80]	; (8004810 <adc_lld_init+0x60>)
  ADCD1.dmastp  = STM32_DMA1_STREAM1;
  ADCD1.dmamode = STM32_DMA_CR_PL(STM32_ADC_ADC1_DMA_PRIORITY) |
 80047be:	f242 5e8a 	movw	lr, #9610	; 0x258a
  ADC1->CR1 = 0;
  ADC1->CR2 = ADC_CR2_ADON;

  /* Reset calibration just to be safe.*/
  ADC1->CR2 = ADC_CR2_ADON | ADC_CR2_RSTCAL;
  while ((ADC1->CR2 & ADC_CR2_RSTCAL) != 0)
 80047c2:	4619      	mov	r1, r3
                  STM32_DMA_CR_MSIZE_HWORD | STM32_DMA_CR_PSIZE_HWORD |
                  STM32_DMA_CR_MINC        | STM32_DMA_CR_TCIE        |
                  STM32_DMA_CR_TEIE;

  /* Temporary activation.*/
  rccEnableADC1(FALSE);
 80047c4:	4813      	ldr	r0, [pc, #76]	; (8004814 <adc_lld_init+0x64>)

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
  ADCD1.dmastp  = STM32_DMA1_STREAM1;
 80047c6:	f8df c050 	ldr.w	ip, [pc, #80]	; 8004818 <adc_lld_init+0x68>
                  STM32_DMA_CR_MSIZE_HWORD | STM32_DMA_CR_PSIZE_HWORD |
                  STM32_DMA_CR_MINC        | STM32_DMA_CR_TCIE        |
                  STM32_DMA_CR_TEIE;

  /* Temporary activation.*/
  rccEnableADC1(FALSE);
 80047ca:	6982      	ldr	r2, [r0, #24]
  ADC1->CR1 = 0;
  ADC1->CR2 = ADC_CR2_ADON;
 80047cc:	2601      	movs	r6, #1
                  STM32_DMA_CR_MSIZE_HWORD | STM32_DMA_CR_PSIZE_HWORD |
                  STM32_DMA_CR_MINC        | STM32_DMA_CR_TCIE        |
                  STM32_DMA_CR_TEIE;

  /* Temporary activation.*/
  rccEnableADC1(FALSE);
 80047ce:	f442 7200 	orr.w	r2, r2, #512	; 0x200
  ADC1->CR1 = 0;
  ADC1->CR2 = ADC_CR2_ADON;

  /* Reset calibration just to be safe.*/
  ADC1->CR2 = ADC_CR2_ADON | ADC_CR2_RSTCAL;
 80047d2:	2509      	movs	r5, #9

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
  ADCD1.dmastp  = STM32_DMA1_STREAM1;
 80047d4:	f8c4 c018 	str.w	ip, [r4, #24]
  ADCD1.dmamode = STM32_DMA_CR_PL(STM32_ADC_ADC1_DMA_PRIORITY) |
 80047d8:	f8c4 e01c 	str.w	lr, [r4, #28]
void adc_lld_init(void) {

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
 80047dc:	6163      	str	r3, [r4, #20]
                  STM32_DMA_CR_MSIZE_HWORD | STM32_DMA_CR_PSIZE_HWORD |
                  STM32_DMA_CR_MINC        | STM32_DMA_CR_TCIE        |
                  STM32_DMA_CR_TEIE;

  /* Temporary activation.*/
  rccEnableADC1(FALSE);
 80047de:	6182      	str	r2, [r0, #24]
  ADC1->CR1 = 0;
 80047e0:	605f      	str	r7, [r3, #4]
  ADC1->CR2 = ADC_CR2_ADON;
 80047e2:	609e      	str	r6, [r3, #8]

  /* Reset calibration just to be safe.*/
  ADC1->CR2 = ADC_CR2_ADON | ADC_CR2_RSTCAL;
 80047e4:	609d      	str	r5, [r3, #8]
  while ((ADC1->CR2 & ADC_CR2_RSTCAL) != 0)
 80047e6:	688b      	ldr	r3, [r1, #8]
 80047e8:	4a09      	ldr	r2, [pc, #36]	; (8004810 <adc_lld_init+0x60>)
 80047ea:	071b      	lsls	r3, r3, #28
 80047ec:	d4fb      	bmi.n	80047e6 <adc_lld_init+0x36>
    ;

  /* Calibration.*/
  ADC1->CR2 = ADC_CR2_ADON | ADC_CR2_CAL;
  while ((ADC1->CR2 & ADC_CR2_CAL) != 0)
 80047ee:	4611      	mov	r1, r2
  ADC1->CR2 = ADC_CR2_ADON | ADC_CR2_RSTCAL;
  while ((ADC1->CR2 & ADC_CR2_RSTCAL) != 0)
    ;

  /* Calibration.*/
  ADC1->CR2 = ADC_CR2_ADON | ADC_CR2_CAL;
 80047f0:	2305      	movs	r3, #5
 80047f2:	6093      	str	r3, [r2, #8]
  while ((ADC1->CR2 & ADC_CR2_CAL) != 0)
 80047f4:	688b      	ldr	r3, [r1, #8]
 80047f6:	4a06      	ldr	r2, [pc, #24]	; (8004810 <adc_lld_init+0x60>)
 80047f8:	f013 0304 	ands.w	r3, r3, #4
 80047fc:	d1fa      	bne.n	80047f4 <adc_lld_init+0x44>
    ;

  /* Return the ADC in low power mode.*/
  ADC1->CR2 = 0;
  rccDisableADC1(FALSE);
 80047fe:	4905      	ldr	r1, [pc, #20]	; (8004814 <adc_lld_init+0x64>)
  ADC1->CR2 = ADC_CR2_ADON | ADC_CR2_CAL;
  while ((ADC1->CR2 & ADC_CR2_CAL) != 0)
    ;

  /* Return the ADC in low power mode.*/
  ADC1->CR2 = 0;
 8004800:	6093      	str	r3, [r2, #8]
  rccDisableADC1(FALSE);
 8004802:	698b      	ldr	r3, [r1, #24]
 8004804:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8004808:	618b      	str	r3, [r1, #24]
 800480a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800480c:	2000131c 	.word	0x2000131c
 8004810:	40012400 	.word	0x40012400
 8004814:	40021000 	.word	0x40021000
 8004818:	0800d5d0 	.word	0x0800d5d0
 800481c:	00000000 	.word	0x00000000

08004820 <_pal_lld_init>:
void _pal_lld_init(const PALConfig *config) {

  /*
   * Enables the GPIO related clocks.
   */
  rccEnableAPB2(APB2_EN_MASK, FALSE);
 8004820:	491e      	ldr	r1, [pc, #120]	; (800489c <_pal_lld_init+0x7c>)
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8004822:	b4f0      	push	{r4, r5, r6, r7}

  /*
   * Enables the GPIO related clocks.
   */
  rccEnableAPB2(APB2_EN_MASK, FALSE);
 8004824:	698b      	ldr	r3, [r1, #24]

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
 8004826:	4a1e      	ldr	r2, [pc, #120]	; (80048a0 <_pal_lld_init+0x80>)
void _pal_lld_init(const PALConfig *config) {

  /*
   * Enables the GPIO related clocks.
   */
  rccEnableAPB2(APB2_EN_MASK, FALSE);
 8004828:	f443 73fe 	orr.w	r3, r3, #508	; 0x1fc
 800482c:	f043 0301 	orr.w	r3, r3, #1
 8004830:	618b      	str	r3, [r1, #24]

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
 8004832:	6803      	ldr	r3, [r0, #0]
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
 8004834:	4e1b      	ldr	r6, [pc, #108]	; (80048a4 <_pal_lld_init+0x84>)
  rccEnableAPB2(APB2_EN_MASK, FALSE);

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
 8004836:	60d3      	str	r3, [r2, #12]
  GPIOA->CRH = config->PAData.crh;
 8004838:	6883      	ldr	r3, [r0, #8]
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
 800483a:	4d1b      	ldr	r5, [pc, #108]	; (80048a8 <_pal_lld_init+0x88>)

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
 800483c:	6053      	str	r3, [r2, #4]
  GPIOA->CRL = config->PAData.crl;
 800483e:	6843      	ldr	r3, [r0, #4]
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
  GPIOC->CRH = config->PCData.crh;
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
 8004840:	4c1a      	ldr	r4, [pc, #104]	; (80048ac <_pal_lld_init+0x8c>)
  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
 8004842:	6013      	str	r3, [r2, #0]
  GPIOB->ODR = config->PBData.odr;
 8004844:	68c3      	ldr	r3, [r0, #12]
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
  GPIOD->CRH = config->PDData.crh;
  GPIOD->CRL = config->PDData.crl;
#if STM32_HAS_GPIOE || defined(__DOXYGEN__)
  GPIOE->ODR = config->PEData.odr;
 8004846:	f5a1 4178 	sub.w	r1, r1, #63488	; 0xf800
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
 800484a:	60f3      	str	r3, [r6, #12]
  GPIOB->CRH = config->PBData.crh;
 800484c:	6947      	ldr	r7, [r0, #20]
#if STM32_HAS_GPIOE || defined(__DOXYGEN__)
  GPIOE->ODR = config->PEData.odr;
  GPIOE->CRH = config->PEData.crh;
  GPIOE->CRL = config->PEData.crl;
#if STM32_HAS_GPIOF || defined(__DOXYGEN__)
  GPIOF->ODR = config->PFData.odr;
 800484e:	f502 52a0 	add.w	r2, r2, #5120	; 0x1400
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
 8004852:	6077      	str	r7, [r6, #4]
  GPIOB->CRL = config->PBData.crl;
 8004854:	6907      	ldr	r7, [r0, #16]
#if STM32_HAS_GPIOF || defined(__DOXYGEN__)
  GPIOF->ODR = config->PFData.odr;
  GPIOF->CRH = config->PFData.crh;
  GPIOF->CRL = config->PFData.crl;
#if STM32_HAS_GPIOG || defined(__DOXYGEN__)
  GPIOG->ODR = config->PGData.odr;
 8004856:	4b16      	ldr	r3, [pc, #88]	; (80048b0 <_pal_lld_init+0x90>)
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
 8004858:	6037      	str	r7, [r6, #0]
  GPIOC->ODR = config->PCData.odr;
 800485a:	6986      	ldr	r6, [r0, #24]
 800485c:	60ee      	str	r6, [r5, #12]
  GPIOC->CRH = config->PCData.crh;
 800485e:	6a06      	ldr	r6, [r0, #32]
 8004860:	606e      	str	r6, [r5, #4]
  GPIOC->CRL = config->PCData.crl;
 8004862:	69c6      	ldr	r6, [r0, #28]
 8004864:	602e      	str	r6, [r5, #0]
  GPIOD->ODR = config->PDData.odr;
 8004866:	6a45      	ldr	r5, [r0, #36]	; 0x24
 8004868:	60e5      	str	r5, [r4, #12]
  GPIOD->CRH = config->PDData.crh;
 800486a:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 800486c:	6065      	str	r5, [r4, #4]
  GPIOD->CRL = config->PDData.crl;
 800486e:	6a85      	ldr	r5, [r0, #40]	; 0x28
 8004870:	6025      	str	r5, [r4, #0]
#if STM32_HAS_GPIOE || defined(__DOXYGEN__)
  GPIOE->ODR = config->PEData.odr;
 8004872:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8004874:	60cc      	str	r4, [r1, #12]
  GPIOE->CRH = config->PEData.crh;
 8004876:	6b84      	ldr	r4, [r0, #56]	; 0x38
 8004878:	604c      	str	r4, [r1, #4]
  GPIOE->CRL = config->PEData.crl;
 800487a:	6b44      	ldr	r4, [r0, #52]	; 0x34
 800487c:	600c      	str	r4, [r1, #0]
#if STM32_HAS_GPIOF || defined(__DOXYGEN__)
  GPIOF->ODR = config->PFData.odr;
 800487e:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
  GPIOG->CRH = config->PGData.crh;
  GPIOG->CRL = config->PGData.crl;
#endif
#endif
#endif
}
 8004880:	bcf0      	pop	{r4, r5, r6, r7}
#if STM32_HAS_GPIOE || defined(__DOXYGEN__)
  GPIOE->ODR = config->PEData.odr;
  GPIOE->CRH = config->PEData.crh;
  GPIOE->CRL = config->PEData.crl;
#if STM32_HAS_GPIOF || defined(__DOXYGEN__)
  GPIOF->ODR = config->PFData.odr;
 8004882:	60d1      	str	r1, [r2, #12]
  GPIOF->CRH = config->PFData.crh;
 8004884:	6c41      	ldr	r1, [r0, #68]	; 0x44
 8004886:	6051      	str	r1, [r2, #4]
  GPIOF->CRL = config->PFData.crl;
 8004888:	6c01      	ldr	r1, [r0, #64]	; 0x40
 800488a:	6011      	str	r1, [r2, #0]
#if STM32_HAS_GPIOG || defined(__DOXYGEN__)
  GPIOG->ODR = config->PGData.odr;
 800488c:	6c82      	ldr	r2, [r0, #72]	; 0x48
 800488e:	60da      	str	r2, [r3, #12]
  GPIOG->CRH = config->PGData.crh;
 8004890:	6d02      	ldr	r2, [r0, #80]	; 0x50
 8004892:	605a      	str	r2, [r3, #4]
  GPIOG->CRL = config->PGData.crl;
 8004894:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 8004896:	601a      	str	r2, [r3, #0]
#endif
#endif
#endif
}
 8004898:	4770      	bx	lr
 800489a:	bf00      	nop
 800489c:	40021000 	.word	0x40021000
 80048a0:	40010800 	.word	0x40010800
 80048a4:	40010c00 	.word	0x40010c00
 80048a8:	40011000 	.word	0x40011000
 80048ac:	40011400 	.word	0x40011400
 80048b0:	40012000 	.word	0x40012000
	...

080048c0 <_pal_lld_setgroupmode>:
    0xF,        /* PAL_MODE_STM32_ALTERNATE_OPENDRAIN, 50MHz.*/
  };
  uint32_t mh, ml, crh, crl, cfg;
  unsigned i;

  if (mode == PAL_MODE_INPUT_PULLUP)
 80048c0:	2a03      	cmp	r2, #3
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 80048c2:	b5f0      	push	{r4, r5, r6, r7, lr}
    0xF,        /* PAL_MODE_STM32_ALTERNATE_OPENDRAIN, 50MHz.*/
  };
  uint32_t mh, ml, crh, crl, cfg;
  unsigned i;

  if (mode == PAL_MODE_INPUT_PULLUP)
 80048c4:	d02c      	beq.n	8004920 <_pal_lld_setgroupmode+0x60>
    port->BSRR = mask;
  else if (mode == PAL_MODE_INPUT_PULLDOWN)
 80048c6:	2a04      	cmp	r2, #4
    port->BRR = mask;
 80048c8:	bf08      	it	eq
 80048ca:	6141      	streq	r1, [r0, #20]
  cfg = cfgtab[mode];
  mh = ml = crh = crl = 0;
 80048cc:	2300      	movs	r3, #0
 80048ce:	461c      	mov	r4, r3
 80048d0:	461d      	mov	r5, r3
 80048d2:	461e      	mov	r6, r3

  if (mode == PAL_MODE_INPUT_PULLUP)
    port->BSRR = mask;
  else if (mode == PAL_MODE_INPUT_PULLDOWN)
    port->BRR = mask;
  cfg = cfgtab[mode];
 80048d4:	f8df e04c 	ldr.w	lr, [pc, #76]	; 8004924 <_pal_lld_setgroupmode+0x64>
 80048d8:	2708      	movs	r7, #8
 80048da:	f81e 2002 	ldrb.w	r2, [lr, r2]
  for (i = 0; i < 8; i++) {
    ml <<= 4;
    mh <<= 4;
    crl <<= 4;
    crh <<= 4;
    if ((mask & 0x0080) == 0)
 80048de:	f011 0f80 	tst.w	r1, #128	; 0x80
  else if (mode == PAL_MODE_INPUT_PULLDOWN)
    port->BRR = mask;
  cfg = cfgtab[mode];
  mh = ml = crh = crl = 0;
  for (i = 0; i < 8; i++) {
    ml <<= 4;
 80048e2:	ea4f 1505 	mov.w	r5, r5, lsl #4
    mh <<= 4;
    crl <<= 4;
 80048e6:	ea4f 1303 	mov.w	r3, r3, lsl #4
    port->BRR = mask;
  cfg = cfgtab[mode];
  mh = ml = crh = crl = 0;
  for (i = 0; i < 8; i++) {
    ml <<= 4;
    mh <<= 4;
 80048ea:	ea4f 1606 	mov.w	r6, r6, lsl #4
    crl <<= 4;
    crh <<= 4;
 80048ee:	ea4f 1404 	mov.w	r4, r4, lsl #4
    if ((mask & 0x0080) == 0)
      ml |= 0xf;
 80048f2:	bf0c      	ite	eq
 80048f4:	f045 050f 	orreq.w	r5, r5, #15
    else
      crl |= cfg;
 80048f8:	4313      	orrne	r3, r2
    if ((mask & 0x8000) == 0)
 80048fa:	f411 4f00 	tst.w	r1, #32768	; 0x8000
      mh |= 0xf;
 80048fe:	bf0c      	ite	eq
 8004900:	f046 060f 	orreq.w	r6, r6, #15
    else
      crh |= cfg;
 8004904:	4314      	orrne	r4, r2
    port->BSRR = mask;
  else if (mode == PAL_MODE_INPUT_PULLDOWN)
    port->BRR = mask;
  cfg = cfgtab[mode];
  mh = ml = crh = crl = 0;
  for (i = 0; i < 8; i++) {
 8004906:	3f01      	subs	r7, #1
      crl |= cfg;
    if ((mask & 0x8000) == 0)
      mh |= 0xf;
    else
      crh |= cfg;
    mask <<= 1;
 8004908:	ea4f 0141 	mov.w	r1, r1, lsl #1
    port->BSRR = mask;
  else if (mode == PAL_MODE_INPUT_PULLDOWN)
    port->BRR = mask;
  cfg = cfgtab[mode];
  mh = ml = crh = crl = 0;
  for (i = 0; i < 8; i++) {
 800490c:	d1e7      	bne.n	80048de <_pal_lld_setgroupmode+0x1e>
      mh |= 0xf;
    else
      crh |= cfg;
    mask <<= 1;
  }
  port->CRH = (port->CRH & mh) | crh;
 800490e:	6842      	ldr	r2, [r0, #4]
 8004910:	4016      	ands	r6, r2
 8004912:	4334      	orrs	r4, r6
 8004914:	6044      	str	r4, [r0, #4]
  port->CRL = (port->CRL & ml) | crl;
 8004916:	6802      	ldr	r2, [r0, #0]
 8004918:	4015      	ands	r5, r2
 800491a:	432b      	orrs	r3, r5
 800491c:	6003      	str	r3, [r0, #0]
 800491e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  };
  uint32_t mh, ml, crh, crl, cfg;
  unsigned i;

  if (mode == PAL_MODE_INPUT_PULLUP)
    port->BSRR = mask;
 8004920:	6101      	str	r1, [r0, #16]
 8004922:	e7d3      	b.n	80048cc <_pal_lld_setgroupmode+0xc>
 8004924:	0800d6c0 	.word	0x0800d6c0
	...

08004930 <i2c_lld_serve_tx_end_irq>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 8004930:	b538      	push	{r3, r4, r5, lr}
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8004932:	070b      	lsls	r3, r1, #28
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 8004934:	4605      	mov	r5, r0
  I2C_TypeDef *dp = i2cp->i2c;
 8004936:	6b44      	ldr	r4, [r0, #52]	; 0x34

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8004938:	d502      	bpl.n	8004940 <i2c_lld_serve_tx_end_irq+0x10>
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 800493a:	4809      	ldr	r0, [pc, #36]	; (8004960 <i2c_lld_serve_tx_end_irq+0x30>)
 800493c:	f7fc fe70 	bl	8001620 <chSysHalt>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmatx);
 8004940:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8004942:	230f      	movs	r3, #15
 8004944:	6850      	ldr	r0, [r2, #4]
 8004946:	6815      	ldr	r5, [r2, #0]
 8004948:	6801      	ldr	r1, [r0, #0]
 800494a:	f021 010f 	bic.w	r1, r1, #15
 800494e:	6001      	str	r1, [r0, #0]
 8004950:	7c12      	ldrb	r2, [r2, #16]
 8004952:	4093      	lsls	r3, r2
 8004954:	606b      	str	r3, [r5, #4]
  /* Enables interrupts to catch BTF event meaning transmission part complete.
     Interrupt handler will decide to generate STOP or to begin receiving part
     of R/W transaction itself.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8004956:	6863      	ldr	r3, [r4, #4]
 8004958:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800495c:	6063      	str	r3, [r4, #4]
 800495e:	bd38      	pop	{r3, r4, r5, pc}
 8004960:	0800d6e0 	.word	0x0800d6e0
	...

08004970 <i2c_lld_serve_rx_end_irq>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 *
 * @notapi
 */
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 8004970:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8004972:	070b      	lsls	r3, r1, #28
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 *
 * @notapi
 */
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 8004974:	4605      	mov	r5, r0
  I2C_TypeDef *dp = i2cp->i2c;
 8004976:	6b44      	ldr	r4, [r0, #52]	; 0x34

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8004978:	d502      	bpl.n	8004980 <i2c_lld_serve_rx_end_irq+0x10>
 800497a:	4813      	ldr	r0, [pc, #76]	; (80049c8 <i2c_lld_serve_rx_end_irq+0x58>)
 800497c:	f7fc fe50 	bl	8001620 <chSysHalt>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmarx);
 8004980:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8004982:	230f      	movs	r3, #15
 8004984:	6856      	ldr	r6, [r2, #4]
 8004986:	6817      	ldr	r7, [r2, #0]
 8004988:	6831      	ldr	r1, [r6, #0]
 800498a:	2020      	movs	r0, #32
 800498c:	f021 010f 	bic.w	r1, r1, #15
 8004990:	6031      	str	r1, [r6, #0]
 8004992:	7c12      	ldrb	r2, [r2, #16]
 8004994:	4093      	lsls	r3, r2
 8004996:	607b      	str	r3, [r7, #4]

  dp->CR2 &= ~I2C_CR2_LAST;
 8004998:	6863      	ldr	r3, [r4, #4]
 800499a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800499e:	6063      	str	r3, [r4, #4]
  dp->CR1 &= ~I2C_CR1_ACK;
 80049a0:	6823      	ldr	r3, [r4, #0]
 80049a2:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80049a6:	6023      	str	r3, [r4, #0]
  dp->CR1 |= I2C_CR1_STOP;
 80049a8:	6823      	ldr	r3, [r4, #0]
 80049aa:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80049ae:	6023      	str	r3, [r4, #0]
 80049b0:	f380 8811 	msr	BASEPRI, r0
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 80049b4:	2100      	movs	r1, #0
 80049b6:	f105 001c 	add.w	r0, r5, #28
 80049ba:	f7fd f979 	bl	8001cb0 <chThdResumeI>
 80049be:	2300      	movs	r3, #0
 80049c0:	f383 8811 	msr	BASEPRI, r3
 80049c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80049c6:	bf00      	nop
 80049c8:	0800d6e0 	.word	0x0800d6e0
 80049cc:	00000000 	.word	0x00000000

080049d0 <VectorC4>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 80049d0:	483a      	ldr	r0, [pc, #232]	; (8004abc <VectorC4+0xec>)
/**
 * @brief   I2C2 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_EVENT_HANDLER) {
 80049d2:	b570      	push	{r4, r5, r6, lr}
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 80049d4:	6b44      	ldr	r4, [r0, #52]	; 0x34
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 80049d6:	4a3a      	ldr	r2, [pc, #232]	; (8004ac0 <VectorC4+0xf0>)
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t regSR2 = dp->SR2;
 80049d8:	69a3      	ldr	r3, [r4, #24]
  uint32_t event = dp->SR1;
 80049da:	6965      	ldr	r5, [r4, #20]

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 80049dc:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
 80049e0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80049e4:	4293      	cmp	r3, r2
 80049e6:	d04c      	beq.n	8004a82 <VectorC4+0xb2>
 80049e8:	d81e      	bhi.n	8004a28 <VectorC4+0x58>
 80049ea:	3a07      	subs	r2, #7
 80049ec:	4293      	cmp	r3, r2
 80049ee:	d03c      	beq.n	8004a6a <VectorC4+0x9a>
 80049f0:	3201      	adds	r2, #1
 80049f2:	4293      	cmp	r3, r2
 80049f4:	d110      	bne.n	8004a18 <VectorC4+0x48>
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 80049f6:	6862      	ldr	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 80049f8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 80049fa:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    dmaStreamEnable(i2cp->dmarx);
 80049fe:	685b      	ldr	r3, [r3, #4]
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8004a00:	6062      	str	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 8004a02:	681a      	ldr	r2, [r3, #0]
 8004a04:	f042 0201 	orr.w	r2, r2, #1
 8004a08:	601a      	str	r2, [r3, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
 8004a0a:	6862      	ldr	r2, [r4, #4]
 8004a0c:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8004a10:	6062      	str	r2, [r4, #4]
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
 8004a12:	685b      	ldr	r3, [r3, #4]
 8004a14:	2b01      	cmp	r3, #1
 8004a16:	d94b      	bls.n	8004ab0 <VectorC4+0xe0>
    break;
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 8004a18:	f015 0f0a 	tst.w	r5, #10
    (void)dp->SR2;
 8004a1c:	bf18      	it	ne
 8004a1e:	69a3      	ldrne	r3, [r4, #24]
  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD2);

  OSAL_IRQ_EPILOGUE();
}
 8004a20:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD2);

  OSAL_IRQ_EPILOGUE();
 8004a24:	f7fe bb34 	b.w	8003090 <_port_irq_epilogue>
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 8004a28:	4a26      	ldr	r2, [pc, #152]	; (8004ac4 <VectorC4+0xf4>)
 8004a2a:	4293      	cmp	r3, r2
 8004a2c:	d012      	beq.n	8004a54 <VectorC4+0x84>
 8004a2e:	3202      	adds	r2, #2
 8004a30:	4293      	cmp	r3, r2
 8004a32:	d1f1      	bne.n	8004a18 <VectorC4+0x48>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmatx);
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
 8004a34:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8004a36:	685b      	ldr	r3, [r3, #4]
 8004a38:	685e      	ldr	r6, [r3, #4]
 8004a3a:	b33e      	cbz	r6, 8004a8c <VectorC4+0xbc>
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8004a3c:	6823      	ldr	r3, [r4, #0]
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 8004a3e:	8c02      	ldrh	r2, [r0, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8004a40:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 8004a44:	f042 0201 	orr.w	r2, r2, #1
 8004a48:	8402      	strh	r2, [r0, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8004a4a:	6023      	str	r3, [r4, #0]
  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD2);

  OSAL_IRQ_EPILOGUE();
}
 8004a4c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD2);

  OSAL_IRQ_EPILOGUE();
 8004a50:	f7fe bb1e 	b.w	8003090 <_port_irq_epilogue>
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8004a54:	6863      	ldr	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 8004a56:	6b02      	ldr	r2, [r0, #48]	; 0x30
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8004a58:	f423 7300 	bic.w	r3, r3, #512	; 0x200
    dmaStreamEnable(i2cp->dmatx);
 8004a5c:	6852      	ldr	r2, [r2, #4]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8004a5e:	6063      	str	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 8004a60:	6813      	ldr	r3, [r2, #0]
 8004a62:	f043 0301 	orr.w	r3, r3, #1
 8004a66:	6013      	str	r3, [r2, #0]
 8004a68:	e7d6      	b.n	8004a18 <VectorC4+0x48>
  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
  case I2C_EV5_MASTER_MODE_SELECT:
    if ((i2cp->addr >> 8) > 0) { 
 8004a6a:	8c03      	ldrh	r3, [r0, #32]
 8004a6c:	0a1a      	lsrs	r2, r3, #8
 8004a6e:	d00b      	beq.n	8004a88 <VectorC4+0xb8>
      /* 10-bit address: 1 1 1 1 0 X X R/W */
      dp->DR = 0xF0 | (0x6 & (i2cp->addr >> 8)) | (0x1 & i2cp->addr);
 8004a70:	f003 0301 	and.w	r3, r3, #1
 8004a74:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 8004a78:	f002 0206 	and.w	r2, r2, #6
 8004a7c:	4313      	orrs	r3, r2
 8004a7e:	6123      	str	r3, [r4, #16]
 8004a80:	e7ca      	b.n	8004a18 <VectorC4+0x48>
      dp->DR = i2cp->addr;
    }
    break;
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
 8004a82:	8c03      	ldrh	r3, [r0, #32]
 8004a84:	f3c3 0347 	ubfx	r3, r3, #1, #8
 8004a88:	6123      	str	r3, [r4, #16]
 8004a8a:	e7c5      	b.n	8004a18 <VectorC4+0x48>
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
      return;
    }
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8004a8c:	6863      	ldr	r3, [r4, #4]
 8004a8e:	2220      	movs	r2, #32
 8004a90:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8004a94:	6063      	str	r3, [r4, #4]
    dp->CR1 |= I2C_CR1_STOP;
 8004a96:	6823      	ldr	r3, [r4, #0]
 8004a98:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8004a9c:	6023      	str	r3, [r4, #0]
 8004a9e:	f382 8811 	msr	BASEPRI, r2
 8004aa2:	301c      	adds	r0, #28
 8004aa4:	4631      	mov	r1, r6
 8004aa6:	f7fd f903 	bl	8001cb0 <chThdResumeI>
 8004aaa:	f386 8811 	msr	BASEPRI, r6
 8004aae:	e7b3      	b.n	8004a18 <VectorC4+0x48>
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmarx);
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
 8004ab0:	6823      	ldr	r3, [r4, #0]
 8004ab2:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8004ab6:	6023      	str	r3, [r4, #0]
 8004ab8:	e7ae      	b.n	8004a18 <VectorC4+0x48>
 8004aba:	bf00      	nop
 8004abc:	2000133c 	.word	0x2000133c
 8004ac0:	00030008 	.word	0x00030008
 8004ac4:	00070082 	.word	0x00070082
	...

08004ad0 <VectorC8>:
 * @brief   I2C2 error interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_ERROR_HANDLER) {
  uint16_t sr = I2CD2.i2c->SR1;
 8004ad0:	4936      	ldr	r1, [pc, #216]	; (8004bac <VectorC8+0xdc>)
/**
 * @brief   I2C2 error interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_ERROR_HANDLER) {
 8004ad2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint16_t sr = I2CD2.i2c->SR1;
 8004ad4:	6b48      	ldr	r0, [r1, #52]	; 0x34
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8004ad6:	6b0d      	ldr	r5, [r1, #48]	; 0x30
 * @brief   I2C2 error interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_ERROR_HANDLER) {
  uint16_t sr = I2CD2.i2c->SR1;
 8004ad8:	6947      	ldr	r7, [r0, #20]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8004ada:	f8d5 e004 	ldr.w	lr, [r5, #4]
 * @brief   I2C2 error interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_ERROR_HANDLER) {
  uint16_t sr = I2CD2.i2c->SR1;
 8004ade:	b2ba      	uxth	r2, r7

  OSAL_IRQ_PROLOGUE();

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 8004ae0:	f402 435f 	and.w	r3, r2, #57088	; 0xdf00
 8004ae4:	43db      	mvns	r3, r3
 8004ae6:	6143      	str	r3, [r0, #20]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8004ae8:	f8de 6000 	ldr.w	r6, [lr]
  dmaStreamDisable(i2cp->dmarx);
 8004aec:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8004aee:	f026 060f 	bic.w	r6, r6, #15
 8004af2:	f8ce 6000 	str.w	r6, [lr]
 8004af6:	7c2e      	ldrb	r6, [r5, #16]
 8004af8:	240f      	movs	r4, #15
 8004afa:	682d      	ldr	r5, [r5, #0]
 8004afc:	fa04 fe06 	lsl.w	lr, r4, r6
  dmaStreamDisable(i2cp->dmarx);
 8004b00:	685e      	ldr	r6, [r3, #4]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8004b02:	f8c5 e004 	str.w	lr, [r5, #4]
  dmaStreamDisable(i2cp->dmarx);
 8004b06:	6835      	ldr	r5, [r6, #0]
 8004b08:	f8d3 e000 	ldr.w	lr, [r3]
 8004b0c:	f025 050f 	bic.w	r5, r5, #15
 8004b10:	6035      	str	r5, [r6, #0]
 8004b12:	7c1d      	ldrb	r5, [r3, #16]

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 8004b14:	f402 7380 	and.w	r3, r2, #256	; 0x100
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
  dmaStreamDisable(i2cp->dmarx);
 8004b18:	40ac      	lsls	r4, r5

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 8004b1a:	b29b      	uxth	r3, r3
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
  dmaStreamDisable(i2cp->dmarx);
 8004b1c:	f8ce 4004 	str.w	r4, [lr, #4]

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 8004b20:	2b00      	cmp	r3, #0
 8004b22:	d13a      	bne.n	8004b9a <VectorC8+0xca>

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
  dmaStreamDisable(i2cp->dmarx);

  i2cp->errors = I2C_NO_ERROR;
 8004b24:	608b      	str	r3, [r1, #8]

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
    i2cp->errors |= I2C_BUS_ERROR;

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
 8004b26:	0595      	lsls	r5, r2, #22
    i2cp->errors |= I2C_ARBITRATION_LOST;
 8004b28:	bf44      	itt	mi
 8004b2a:	f043 0302 	orrmi.w	r3, r3, #2
 8004b2e:	608b      	strmi	r3, [r1, #8]

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
 8004b30:	0554      	lsls	r4, r2, #21
 8004b32:	d50a      	bpl.n	8004b4a <VectorC8+0x7a>
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 8004b34:	6844      	ldr	r4, [r0, #4]
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
    i2cp->errors |= I2C_ACK_FAILURE;
 8004b36:	f043 0304 	orr.w	r3, r3, #4

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
    i2cp->errors |= I2C_ARBITRATION_LOST;

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 8004b3a:	f424 7400 	bic.w	r4, r4, #512	; 0x200
 8004b3e:	6044      	str	r4, [r0, #4]
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 8004b40:	6804      	ldr	r4, [r0, #0]
 8004b42:	f444 7400 	orr.w	r4, r4, #512	; 0x200
 8004b46:	6004      	str	r4, [r0, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 8004b48:	608b      	str	r3, [r1, #8]
  }

  if (sr & I2C_SR1_OVR)                             /* Overrun.             */
 8004b4a:	0516      	lsls	r6, r2, #20
    i2cp->errors |= I2C_OVERRUN;
 8004b4c:	bf44      	itt	mi
 8004b4e:	f043 0308 	orrmi.w	r3, r3, #8
 8004b52:	608b      	strmi	r3, [r1, #8]

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
 8004b54:	0455      	lsls	r5, r2, #17
    i2cp->errors |= I2C_TIMEOUT;
 8004b56:	bf44      	itt	mi
 8004b58:	f043 0320 	orrmi.w	r3, r3, #32
 8004b5c:	608b      	strmi	r3, [r1, #8]

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
 8004b5e:	04d4      	lsls	r4, r2, #19
 8004b60:	d513      	bpl.n	8004b8a <VectorC8+0xba>
    i2cp->errors |= I2C_PEC_ERROR;
 8004b62:	f043 0310 	orr.w	r3, r3, #16

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8004b66:	0438      	lsls	r0, r7, #16

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
    i2cp->errors |= I2C_TIMEOUT;

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;
 8004b68:	608b      	str	r3, [r1, #8]

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8004b6a:	d41a      	bmi.n	8004ba2 <VectorC8+0xd2>
 8004b6c:	2320      	movs	r3, #32
 8004b6e:	f383 8811 	msr	BASEPRI, r3
 8004b72:	480f      	ldr	r0, [pc, #60]	; (8004bb0 <VectorC8+0xe0>)
 8004b74:	f06f 0101 	mvn.w	r1, #1
 8004b78:	f7fd f89a 	bl	8001cb0 <chThdResumeI>
 8004b7c:	2300      	movs	r3, #0
 8004b7e:	f383 8811 	msr	BASEPRI, r3

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD2, sr);

  OSAL_IRQ_EPILOGUE();
}
 8004b82:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  OSAL_IRQ_PROLOGUE();

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD2, sr);

  OSAL_IRQ_EPILOGUE();
 8004b86:	f7fe ba83 	b.w	8003090 <_port_irq_epilogue>
    i2cp->errors |= I2C_TIMEOUT;

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8004b8a:	043a      	lsls	r2, r7, #16
 8004b8c:	d409      	bmi.n	8004ba2 <VectorC8+0xd2>
    i2cp->errors |= I2C_SMB_ALERT;

  /* If some error has been identified then sends wakes the waiting thread.*/
  if (i2cp->errors != I2C_NO_ERROR)
 8004b8e:	2b00      	cmp	r3, #0
 8004b90:	d1ec      	bne.n	8004b6c <VectorC8+0x9c>

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD2, sr);

  OSAL_IRQ_EPILOGUE();
}
 8004b92:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  OSAL_IRQ_PROLOGUE();

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD2, sr);

  OSAL_IRQ_EPILOGUE();
 8004b96:	f7fe ba7b 	b.w	8003090 <_port_irq_epilogue>
  dmaStreamDisable(i2cp->dmarx);

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
    i2cp->errors |= I2C_BUS_ERROR;
 8004b9a:	2401      	movs	r4, #1
 8004b9c:	4623      	mov	r3, r4
 8004b9e:	608c      	str	r4, [r1, #8]
 8004ba0:	e7c1      	b.n	8004b26 <VectorC8+0x56>

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
    i2cp->errors |= I2C_SMB_ALERT;
 8004ba2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8004ba6:	608b      	str	r3, [r1, #8]
 8004ba8:	e7e0      	b.n	8004b6c <VectorC8+0x9c>
 8004baa:	bf00      	nop
 8004bac:	2000133c 	.word	0x2000133c
 8004bb0:	20001358 	.word	0x20001358
	...

08004bc0 <i2c_lld_init>:
/**
 * @brief   Low level I2C driver initialization.
 *
 * @notapi
 */
void i2c_lld_init(void) {
 8004bc0:	b510      	push	{r4, lr}
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
 8004bc2:	4c07      	ldr	r4, [pc, #28]	; (8004be0 <i2c_lld_init+0x20>)
 8004bc4:	4620      	mov	r0, r4
 8004bc6:	f7fe fd33 	bl	8003630 <i2cObjectInit>
  I2CD2.thread = NULL;
  I2CD2.i2c    = I2C2;
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
 8004bca:	4b06      	ldr	r3, [pc, #24]	; (8004be4 <i2c_lld_init+0x24>)
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
  I2CD2.i2c    = I2C2;
 8004bcc:	4906      	ldr	r1, [pc, #24]	; (8004be8 <i2c_lld_init+0x28>)
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
 8004bce:	2000      	movs	r0, #0
  I2CD2.i2c    = I2C2;
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
  I2CD2.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C2_TX_DMA_STREAM);
 8004bd0:	f1a3 0214 	sub.w	r2, r3, #20
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
 8004bd4:	61e0      	str	r0, [r4, #28]
  I2CD2.i2c    = I2C2;
 8004bd6:	6361      	str	r1, [r4, #52]	; 0x34
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
 8004bd8:	62e3      	str	r3, [r4, #44]	; 0x2c
  I2CD2.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C2_TX_DMA_STREAM);
 8004bda:	6322      	str	r2, [r4, #48]	; 0x30
 8004bdc:	bd10      	pop	{r4, pc}
 8004bde:	bf00      	nop
 8004be0:	2000133c 	.word	0x2000133c
 8004be4:	0800d620 	.word	0x0800d620
 8004be8:	40005800 	.word	0x40005800
 8004bec:	00000000 	.word	0x00000000

08004bf0 <i2c_lld_start>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
 8004bf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 8004bf2:	7803      	ldrb	r3, [r0, #0]
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 8004bf4:	219a      	movs	r1, #154	; 0x9a
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_M2P;
  i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 8004bf6:	228a      	movs	r2, #138	; 0x8a
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 8004bf8:	2b01      	cmp	r3, #1
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
 8004bfa:	4604      	mov	r4, r0
  I2C_TypeDef *dp = i2cp->i2c;

  i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 8004bfc:	6281      	str	r1, [r0, #40]	; 0x28
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_M2P;
  i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 8004bfe:	6242      	str	r2, [r0, #36]	; 0x24
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 8004c00:	6b45      	ldr	r5, [r0, #52]	; 0x34
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 8004c02:	d03e      	beq.n	8004c82 <i2c_lld_start+0x92>
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 8004c04:	462b      	mov	r3, r5
  osalDbgCheck((i2cp != NULL) &&
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 8004c06:	f64f 76c0 	movw	r6, #65472	; 0xffc0
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 8004c0a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 8004c0c:	6b22      	ldr	r2, [r4, #48]	; 0x30
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 8004c0e:	f8d1 c004 	ldr.w	ip, [r1, #4]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 8004c12:	f8d2 e004 	ldr.w	lr, [r2, #4]
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 8004c16:	f105 0110 	add.w	r1, r5, #16
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 8004c1a:	f44f 4700 	mov.w	r7, #32768	; 0x8000
  dp->CR1 = 0;
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 8004c1e:	f44f 6010 	mov.w	r0, #2304	; 0x900
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
  dp->CR1 = 0;
 8004c22:	2200      	movs	r2, #0
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 8004c24:	f8cc 1008 	str.w	r1, [ip, #8]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 8004c28:	f8ce 1008 	str.w	r1, [lr, #8]

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 8004c2c:	602f      	str	r7, [r5, #0]
  dp->CR1 = 0;
 8004c2e:	602a      	str	r2, [r5, #0]
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 8004c30:	6068      	str	r0, [r5, #4]
  osalDbgCheck((i2cp != NULL) &&
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 8004c32:	6859      	ldr	r1, [r3, #4]
 8004c34:	6864      	ldr	r4, [r4, #4]
 8004c36:	400e      	ands	r6, r1
 * @notapi
 */
static void i2c_lld_set_clock(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
 8004c38:	6860      	ldr	r0, [r4, #4]
  i2cdutycycle_t duty = i2cp->config->duty_cycle;
 8004c3a:	7a27      	ldrb	r7, [r4, #8]
  osalDbgCheck((i2cp != NULL) &&
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 8004c3c:	605e      	str	r6, [r3, #4]
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 8004c3e:	6859      	ldr	r1, [r3, #4]

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 8004c40:	4e3d      	ldr	r6, [pc, #244]	; (8004d38 <i2c_lld_start+0x148>)
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 8004c42:	f041 0124 	orr.w	r1, r1, #36	; 0x24

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 8004c46:	42b0      	cmp	r0, r6
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 8004c48:	6059      	str	r1, [r3, #4]

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 8004c4a:	dd4a      	ble.n	8004ce2 <i2c_lld_start+0xf2>
    regCCR |= (clock_div & I2C_CCR_CCR);

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
  }
  else if (clock_speed <= 400000) {
 8004c4c:	493b      	ldr	r1, [pc, #236]	; (8004d3c <i2c_lld_start+0x14c>)
 8004c4e:	4288      	cmp	r0, r1
 8004c50:	dc07      	bgt.n	8004c62 <i2c_lld_start+0x72>
    /* Configure clock_div in fast mode.*/
    osalDbgAssert((duty == FAST_DUTY_CYCLE_2) ||
                  (duty == FAST_DUTY_CYCLE_16_9),
                  "invalid fast mode duty cycle");

    if (duty == FAST_DUTY_CYCLE_2) {
 8004c52:	2f02      	cmp	r7, #2
 8004c54:	d064      	beq.n	8004d20 <i2c_lld_start+0x130>
      /* Fast mode clock_div calculate: Tlow/Thigh = 2/1.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 3)) == 0,
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
    }
    else if (duty == FAST_DUTY_CYCLE_16_9) {
 8004c56:	2f03      	cmp	r7, #3
 8004c58:	d055      	beq.n	8004d06 <i2c_lld_start+0x116>
 8004c5a:	f648 72ff 	movw	r2, #36863	; 0x8fff
    osalDbgAssert(clock_div >= 0x01,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (I2C_CCR_FS | (clock_div & I2C_CCR_CCR));

    /* Sets the Maximum Rise Time for fast mode.*/
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
 8004c5e:	210b      	movs	r1, #11
 8004c60:	6219      	str	r1, [r3, #32]
  }

  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");

  dp->CCR = regCCR;
 8004c62:	61da      	str	r2, [r3, #28]
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
  switch (opmode) {
 8004c64:	7821      	ldrb	r1, [r4, #0]
static void i2c_lld_set_opmode(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
 8004c66:	681a      	ldr	r2, [r3, #0]
  switch (opmode) {
 8004c68:	2902      	cmp	r1, #2
static void i2c_lld_set_opmode(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
 8004c6a:	b292      	uxth	r2, r2
  switch (opmode) {
 8004c6c:	d045      	beq.n	8004cfa <i2c_lld_start+0x10a>
 8004c6e:	2903      	cmp	r1, #3
 8004c70:	d040      	beq.n	8004cf4 <i2c_lld_start+0x104>
 8004c72:	2901      	cmp	r1, #1
 8004c74:	d031      	beq.n	8004cda <i2c_lld_start+0xea>
    break;
  case OPMODE_SMBUS_HOST:
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
    break;
  }
  dp->CR1 = regCR1;
 8004c76:	601a      	str	r2, [r3, #0]
  /* Setup I2C parameters.*/
  i2c_lld_set_clock(i2cp);
  i2c_lld_set_opmode(i2cp);

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
 8004c78:	682b      	ldr	r3, [r5, #0]
 8004c7a:	f043 0301 	orr.w	r3, r3, #1
 8004c7e:	602b      	str	r3, [r5, #0]
 8004c80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
    }
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
    if (&I2CD2 == i2cp) {
 8004c82:	4b2f      	ldr	r3, [pc, #188]	; (8004d40 <i2c_lld_start+0x150>)
 8004c84:	4298      	cmp	r0, r3
 8004c86:	d1bd      	bne.n	8004c04 <i2c_lld_start+0x14>
      bool b;

      rccResetI2C2();
 8004c88:	4e2e      	ldr	r6, [pc, #184]	; (8004d44 <i2c_lld_start+0x154>)
 8004c8a:	2200      	movs	r2, #0
 8004c8c:	6933      	ldr	r3, [r6, #16]
      b = dmaStreamAllocate(i2cp->dmarx,
 8004c8e:	6ac0      	ldr	r0, [r0, #44]	; 0x2c

#if STM32_I2C_USE_I2C2
    if (&I2CD2 == i2cp) {
      bool b;

      rccResetI2C2();
 8004c90:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8004c94:	6133      	str	r3, [r6, #16]
      b = dmaStreamAllocate(i2cp->dmarx,
 8004c96:	2105      	movs	r1, #5

#if STM32_I2C_USE_I2C2
    if (&I2CD2 == i2cp) {
      bool b;

      rccResetI2C2();
 8004c98:	6132      	str	r2, [r6, #16]
      b = dmaStreamAllocate(i2cp->dmarx,
 8004c9a:	4623      	mov	r3, r4
 8004c9c:	4a2a      	ldr	r2, [pc, #168]	; (8004d48 <i2c_lld_start+0x158>)
 8004c9e:	f7ff fce7 	bl	8004670 <dmaStreamAllocate>
                            STM32_I2C_I2C2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_rx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      b = dmaStreamAllocate(i2cp->dmatx,
 8004ca2:	4a2a      	ldr	r2, [pc, #168]	; (8004d4c <i2c_lld_start+0x15c>)
 8004ca4:	2105      	movs	r1, #5
 8004ca6:	4623      	mov	r3, r4
 8004ca8:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8004caa:	f7ff fce1 	bl	8004670 <dmaStreamAllocate>
                            STM32_I2C_I2C2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C2(FALSE);
 8004cae:	69f3      	ldr	r3, [r6, #28]
      nvicEnableVector(I2C2_EV_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);
 8004cb0:	2021      	movs	r0, #33	; 0x21
      b = dmaStreamAllocate(i2cp->dmatx,
                            STM32_I2C_I2C2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C2(FALSE);
 8004cb2:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8004cb6:	61f3      	str	r3, [r6, #28]
      nvicEnableVector(I2C2_EV_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);
 8004cb8:	2105      	movs	r1, #5
 8004cba:	f7ff fae1 	bl	8004280 <nvicEnableVector>
      nvicEnableVector(I2C2_ER_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);
 8004cbe:	2022      	movs	r0, #34	; 0x22
 8004cc0:	2105      	movs	r1, #5
 8004cc2:	f7ff fadd 	bl	8004280 <nvicEnableVector>

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C2_RX_DMA_CHANNEL) |
 8004cc6:	6a62      	ldr	r2, [r4, #36]	; 0x24
                       STM32_DMA_CR_PL(STM32_I2C_I2C2_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C2_TX_DMA_CHANNEL) |
 8004cc8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C2(FALSE);
      nvicEnableVector(I2C2_EV_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);
      nvicEnableVector(I2C2_ER_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C2_RX_DMA_CHANNEL) |
 8004cca:	f442 5240 	orr.w	r2, r2, #12288	; 0x3000
                       STM32_DMA_CR_PL(STM32_I2C_I2C2_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C2_TX_DMA_CHANNEL) |
 8004cce:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
 8004cd2:	62a3      	str	r3, [r4, #40]	; 0x28
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C2(FALSE);
      nvicEnableVector(I2C2_EV_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);
      nvicEnableVector(I2C2_ER_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C2_RX_DMA_CHANNEL) |
 8004cd4:	6262      	str	r2, [r4, #36]	; 0x24
 8004cd6:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8004cd8:	e795      	b.n	8004c06 <i2c_lld_start+0x16>
  uint16_t regCR1;

  regCR1 = dp->CR1;
  switch (opmode) {
  case OPMODE_I2C:
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 8004cda:	f022 020a 	bic.w	r2, r2, #10
 8004cde:	b292      	uxth	r2, r2
 8004ce0:	e7c9      	b.n	8004c76 <i2c_lld_start+0x86>
    osalDbgAssert(duty == STD_DUTY_CYCLE, "invalid standard mode duty cycle");

    /* Standard mode clock_div calculate: Tlow/Thigh = 1/1.*/
    osalDbgAssert((STM32_PCLK1 % (clock_speed * 2)) == 0,
                  "PCLK1 must be divisible without remainder");
    clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 2));
 8004ce2:	491b      	ldr	r1, [pc, #108]	; (8004d50 <i2c_lld_start+0x160>)
 8004ce4:	0042      	lsls	r2, r0, #1
 8004ce6:	fb91 f2f2 	sdiv	r2, r1, r2
    osalDbgAssert(clock_div >= 0x04,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (clock_div & I2C_CCR_CCR);

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
 8004cea:	2125      	movs	r1, #37	; 0x25
 8004cec:	f3c2 020b 	ubfx	r2, r2, #0, #12
 8004cf0:	6219      	str	r1, [r3, #32]
 8004cf2:	e7b6      	b.n	8004c62 <i2c_lld_start+0x72>
  case OPMODE_SMBUS_DEVICE:
    regCR1 |= I2C_CR1_SMBUS;
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
    break;
  case OPMODE_SMBUS_HOST:
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 8004cf4:	f042 020a 	orr.w	r2, r2, #10
 8004cf8:	e7bd      	b.n	8004c76 <i2c_lld_start+0x86>
  case OPMODE_I2C:
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
    break;
  case OPMODE_SMBUS_DEVICE:
    regCR1 |= I2C_CR1_SMBUS;
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
 8004cfa:	f022 0208 	bic.w	r2, r2, #8
 8004cfe:	b292      	uxth	r2, r2
 8004d00:	f042 0202 	orr.w	r2, r2, #2
 8004d04:	e7b7      	b.n	8004c76 <i2c_lld_start+0x86>
    }
    else if (duty == FAST_DUTY_CYCLE_16_9) {
      /* Fast mode clock_div calculate: Tlow/Thigh = 16/9.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 25)) == 0,
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 25));
 8004d06:	eb00 0280 	add.w	r2, r0, r0, lsl #2
 8004d0a:	4911      	ldr	r1, [pc, #68]	; (8004d50 <i2c_lld_start+0x160>)
 8004d0c:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8004d10:	fb91 f2f2 	sdiv	r2, r1, r2
 8004d14:	ea6f 4282 	mvn.w	r2, r2, lsl #18
 8004d18:	ea6f 4292 	mvn.w	r2, r2, lsr #18
 8004d1c:	b292      	uxth	r2, r2
 8004d1e:	e79e      	b.n	8004c5e <i2c_lld_start+0x6e>

    if (duty == FAST_DUTY_CYCLE_2) {
      /* Fast mode clock_div calculate: Tlow/Thigh = 2/1.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 3)) == 0,
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
 8004d20:	490b      	ldr	r1, [pc, #44]	; (8004d50 <i2c_lld_start+0x160>)
 8004d22:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 8004d26:	fb91 f2f2 	sdiv	r2, r1, r2
 8004d2a:	ea6f 4242 	mvn.w	r2, r2, lsl #17
 8004d2e:	ea6f 4252 	mvn.w	r2, r2, lsr #17
 8004d32:	b292      	uxth	r2, r2
 8004d34:	e793      	b.n	8004c5e <i2c_lld_start+0x6e>
 8004d36:	bf00      	nop
 8004d38:	000186a0 	.word	0x000186a0
 8004d3c:	00061a80 	.word	0x00061a80
 8004d40:	2000133c 	.word	0x2000133c
 8004d44:	40021000 	.word	0x40021000
 8004d48:	08004971 	.word	0x08004971
 8004d4c:	08004931 	.word	0x08004931
 8004d50:	02255100 	.word	0x02255100
	...

08004d60 <i2c_lld_stop>:
 * @notapi
 */
void i2c_lld_stop(I2CDriver *i2cp) {

  /* If not in stopped state then disables the I2C clock.*/
  if (i2cp->state != I2C_STOP) {
 8004d60:	7803      	ldrb	r3, [r0, #0]
 8004d62:	2b01      	cmp	r3, #1
 8004d64:	d028      	beq.n	8004db8 <i2c_lld_stop+0x58>
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_stop(I2CDriver *i2cp) {
 8004d66:	b570      	push	{r4, r5, r6, lr}
 8004d68:	4604      	mov	r4, r0
  dp->CR1 = 0;
  dp->CR2 = 0;
  dp->SR1 = 0;

  /* Stops the associated DMA streams.*/
  dmaStreamDisable(i2cp->dmatx);
 8004d6a:	6b00      	ldr	r0, [r0, #48]	; 0x30
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_abort_operation(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 8004d6c:	6b63      	ldr	r3, [r4, #52]	; 0x34
  dp->CR1 = 0;
  dp->CR2 = 0;
  dp->SR1 = 0;

  /* Stops the associated DMA streams.*/
  dmaStreamDisable(i2cp->dmatx);
 8004d6e:	6841      	ldr	r1, [r0, #4]
static void i2c_lld_abort_operation(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Stops the I2C peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
  dp->CR1 = 0;
 8004d70:	2200      	movs	r2, #0
 */
static void i2c_lld_abort_operation(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Stops the I2C peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 8004d72:	f44f 4500 	mov.w	r5, #32768	; 0x8000
 8004d76:	601d      	str	r5, [r3, #0]
  dp->CR1 = 0;
 8004d78:	601a      	str	r2, [r3, #0]
  dp->CR2 = 0;
 8004d7a:	605a      	str	r2, [r3, #4]
  dp->SR1 = 0;
 8004d7c:	615a      	str	r2, [r3, #20]

  /* Stops the associated DMA streams.*/
  dmaStreamDisable(i2cp->dmatx);
 8004d7e:	680b      	ldr	r3, [r1, #0]
  dmaStreamDisable(i2cp->dmarx);
 8004d80:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  dp->CR1 = 0;
  dp->CR2 = 0;
  dp->SR1 = 0;

  /* Stops the associated DMA streams.*/
  dmaStreamDisable(i2cp->dmatx);
 8004d82:	f023 030f 	bic.w	r3, r3, #15
 8004d86:	600b      	str	r3, [r1, #0]
 8004d88:	7c05      	ldrb	r5, [r0, #16]
 8004d8a:	6801      	ldr	r1, [r0, #0]
 8004d8c:	230f      	movs	r3, #15
 8004d8e:	fa03 f605 	lsl.w	r6, r3, r5
  dmaStreamDisable(i2cp->dmarx);
 8004d92:	6855      	ldr	r5, [r2, #4]
  dp->CR1 = 0;
  dp->CR2 = 0;
  dp->SR1 = 0;

  /* Stops the associated DMA streams.*/
  dmaStreamDisable(i2cp->dmatx);
 8004d94:	604e      	str	r6, [r1, #4]
  dmaStreamDisable(i2cp->dmarx);
 8004d96:	6829      	ldr	r1, [r5, #0]
 8004d98:	6816      	ldr	r6, [r2, #0]
 8004d9a:	f021 010f 	bic.w	r1, r1, #15
 8004d9e:	6029      	str	r1, [r5, #0]
 8004da0:	7c12      	ldrb	r2, [r2, #16]
 8004da2:	4093      	lsls	r3, r2
 8004da4:	6073      	str	r3, [r6, #4]
  /* If not in stopped state then disables the I2C clock.*/
  if (i2cp->state != I2C_STOP) {

    /* I2C disable.*/
    i2c_lld_abort_operation(i2cp);
    dmaStreamRelease(i2cp->dmatx);
 8004da6:	f7ff fcb3 	bl	8004710 <dmaStreamRelease>
    dmaStreamRelease(i2cp->dmarx);
 8004daa:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8004dac:	f7ff fcb0 	bl	8004710 <dmaStreamRelease>
      rccDisableI2C1(FALSE);
    }
#endif

#if STM32_I2C_USE_I2C2
    if (&I2CD2 == i2cp) {
 8004db0:	4b08      	ldr	r3, [pc, #32]	; (8004dd4 <i2c_lld_stop+0x74>)
 8004db2:	429c      	cmp	r4, r3
 8004db4:	d001      	beq.n	8004dba <i2c_lld_stop+0x5a>
 8004db6:	bd70      	pop	{r4, r5, r6, pc}
 8004db8:	4770      	bx	lr
      nvicDisableVector(I2C2_EV_IRQn);
 8004dba:	2021      	movs	r0, #33	; 0x21
 8004dbc:	f7ff fa80 	bl	80042c0 <nvicDisableVector>
      nvicDisableVector(I2C2_ER_IRQn);
 8004dc0:	2022      	movs	r0, #34	; 0x22
 8004dc2:	f7ff fa7d 	bl	80042c0 <nvicDisableVector>
      rccDisableI2C2(FALSE);
 8004dc6:	4a04      	ldr	r2, [pc, #16]	; (8004dd8 <i2c_lld_stop+0x78>)
 8004dc8:	69d3      	ldr	r3, [r2, #28]
 8004dca:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8004dce:	61d3      	str	r3, [r2, #28]
 8004dd0:	e7f1      	b.n	8004db6 <i2c_lld_stop+0x56>
 8004dd2:	bf00      	nop
 8004dd4:	2000133c 	.word	0x2000133c
 8004dd8:	40021000 	.word	0x40021000
 8004ddc:	00000000 	.word	0x00000000

08004de0 <i2c_lld_master_transmit_timeout>:
 * @notapi
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
 8004de0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;

  /* Initializes driver fields, LSB = 0 -> transmit.*/
  i2cp->addr = (addr << 1);
 8004de4:	0049      	lsls	r1, r1, #1
#if defined(STM32F1XX_I2C)
  osalDbgCheck((rxbytes == 0) || ((rxbytes > 1) && (rxbuf != NULL)));
#endif

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;
 8004de6:	2500      	movs	r5, #0
 * @notapi
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
 8004de8:	4694      	mov	ip, r2
 8004dea:	4698      	mov	r8, r3

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;

  /* Initializes driver fields, LSB = 0 -> transmit.*/
  i2cp->addr = (addr << 1);
 8004dec:	8401      	strh	r1, [r0, #32]
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
  I2C_TypeDef *dp = i2cp->i2c;
 8004dee:	6b44      	ldr	r4, [r0, #52]	; 0x34
#if defined(STM32F1XX_I2C)
  osalDbgCheck((rxbytes == 0) || ((rxbytes > 1) && (rxbuf != NULL)));
#endif

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;
 8004df0:	6085      	str	r5, [r0, #8]
 * @notapi
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
 8004df2:	9a08      	ldr	r2, [sp, #32]
 8004df4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004df6:	f8bd a028 	ldrh.w	sl, [sp, #40]	; 0x28
 8004dfa:	f385 8811 	msr	BASEPRI, r5

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8004dfe:	6b07      	ldr	r7, [r0, #48]	; 0x30
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8004e00:	6ac6      	ldr	r6, [r0, #44]	; 0x2c
 8004e02:	f8d0 9024 	ldr.w	r9, [r0, #36]	; 0x24

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8004e06:	6a81      	ldr	r1, [r0, #40]	; 0x28
 8004e08:	f8d7 e004 	ldr.w	lr, [r7, #4]
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8004e0c:	6877      	ldr	r7, [r6, #4]
 8004e0e:	4e18      	ldr	r6, [pc, #96]	; (8004e70 <i2c_lld_master_transmit_timeout+0x90>)

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8004e10:	f8ce 1000 	str.w	r1, [lr]
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
 8004e14:	f8ce c00c 	str.w	ip, [lr, #12]
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 8004e18:	f8ce 8004 	str.w	r8, [lr, #4]

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8004e1c:	f8c7 9000 	str.w	r9, [r7]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 8004e20:	60fa      	str	r2, [r7, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 8004e22:	607b      	str	r3, [r7, #4]
 8004e24:	8bf2      	ldrh	r2, [r6, #30]
 8004e26:	2720      	movs	r7, #32
 8004e28:	b292      	uxth	r2, r2
 8004e2a:	e001      	b.n	8004e30 <i2c_lld_master_transmit_timeout+0x50>
 8004e2c:	f385 8811 	msr	BASEPRI, r5
 8004e30:	f387 8811 	msr	BASEPRI, r7
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if (!(dp->SR2 & I2C_SR2_BUSY) && !(dp->CR1 & I2C_CR1_STOP))
 8004e34:	69a3      	ldr	r3, [r4, #24]
 8004e36:	0799      	lsls	r1, r3, #30
 8004e38:	d402      	bmi.n	8004e40 <i2c_lld_master_transmit_timeout+0x60>
 8004e3a:	6823      	ldr	r3, [r4, #0]
 8004e3c:	059b      	lsls	r3, r3, #22
 8004e3e:	d508      	bpl.n	8004e52 <i2c_lld_master_transmit_timeout+0x72>
 8004e40:	8bf3      	ldrh	r3, [r6, #30]
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 8004e42:	1a9b      	subs	r3, r3, r2
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end))
 8004e44:	b29b      	uxth	r3, r3
 8004e46:	2b63      	cmp	r3, #99	; 0x63
 8004e48:	d9f0      	bls.n	8004e2c <i2c_lld_master_transmit_timeout+0x4c>
  dp->CR2 |= I2C_CR2_ITEVTEN;
  dp->CR1 |= I2C_CR1_START;

  /* Waits for the operation completion or a timeout.*/
  return osalThreadSuspendTimeoutS(&i2cp->thread, timeout);
}
 8004e4a:	f04f 30ff 	mov.w	r0, #4294967295
 8004e4e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

    osalSysUnlock();
  }

  /* Starts the operation.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8004e52:	6863      	ldr	r3, [r4, #4]
 * @sclass
 */
static inline msg_t osalThreadSuspendTimeoutS(thread_reference_t *trp,
                                              systime_t timeout) {

  return chThdSuspendTimeoutS(trp, timeout);
 8004e54:	4651      	mov	r1, sl
 8004e56:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8004e5a:	6063      	str	r3, [r4, #4]
  dp->CR1 |= I2C_CR1_START;
 8004e5c:	6823      	ldr	r3, [r4, #0]
 8004e5e:	301c      	adds	r0, #28
 8004e60:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8004e64:	6023      	str	r3, [r4, #0]

  /* Waits for the operation completion or a timeout.*/
  return osalThreadSuspendTimeoutS(&i2cp->thread, timeout);
}
 8004e66:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004e6a:	f7fc bf11 	b.w	8001c90 <chThdSuspendTimeoutS>
 8004e6e:	bf00      	nop
 8004e70:	20001160 	.word	0x20001160
	...

08004e80 <pwm_lld_init>:
/**
 * @brief   Low level PWM driver initialization.
 *
 * @notapi
 */
void pwm_lld_init(void) {
 8004e80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
 8004e82:	4d0f      	ldr	r5, [pc, #60]	; (8004ec0 <pwm_lld_init+0x40>)
  PWMD1.tim = STM32_TIM1;
#endif

#if STM32_PWM_USE_TIM2
  /* Driver initialization.*/
  pwmObjectInit(&PWMD2);
 8004e84:	4f0f      	ldr	r7, [pc, #60]	; (8004ec4 <pwm_lld_init+0x44>)
 */
void pwm_lld_init(void) {

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
 8004e86:	4628      	mov	r0, r5
 8004e88:	f7fe fc3a 	bl	8003700 <pwmObjectInit>
  PWMD2.tim = STM32_TIM2;
#endif

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
 8004e8c:	4e0e      	ldr	r6, [pc, #56]	; (8004ec8 <pwm_lld_init+0x48>)

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
  PWMD1.channels = STM32_TIM1_CHANNELS;
  PWMD1.tim = STM32_TIM1;
 8004e8e:	4b0f      	ldr	r3, [pc, #60]	; (8004ecc <pwm_lld_init+0x4c>)
void pwm_lld_init(void) {

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
  PWMD1.channels = STM32_TIM1_CHANNELS;
 8004e90:	2404      	movs	r4, #4
  PWMD1.tim = STM32_TIM1;
#endif

#if STM32_PWM_USE_TIM2
  /* Driver initialization.*/
  pwmObjectInit(&PWMD2);
 8004e92:	4638      	mov	r0, r7

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
  PWMD1.channels = STM32_TIM1_CHANNELS;
  PWMD1.tim = STM32_TIM1;
 8004e94:	61ab      	str	r3, [r5, #24]
void pwm_lld_init(void) {

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
  PWMD1.channels = STM32_TIM1_CHANNELS;
 8004e96:	742c      	strb	r4, [r5, #16]
  PWMD1.tim = STM32_TIM1;
#endif

#if STM32_PWM_USE_TIM2
  /* Driver initialization.*/
  pwmObjectInit(&PWMD2);
 8004e98:	f7fe fc32 	bl	8003700 <pwmObjectInit>
  PWMD3.tim = STM32_TIM3;
#endif

#if STM32_PWM_USE_TIM4
  /* Driver initialization.*/
  pwmObjectInit(&PWMD4);
 8004e9c:	4d0c      	ldr	r5, [pc, #48]	; (8004ed0 <pwm_lld_init+0x50>)

#if STM32_PWM_USE_TIM2
  /* Driver initialization.*/
  pwmObjectInit(&PWMD2);
  PWMD2.channels = STM32_TIM2_CHANNELS;
  PWMD2.tim = STM32_TIM2;
 8004e9e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#endif

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
 8004ea2:	4630      	mov	r0, r6

#if STM32_PWM_USE_TIM2
  /* Driver initialization.*/
  pwmObjectInit(&PWMD2);
  PWMD2.channels = STM32_TIM2_CHANNELS;
  PWMD2.tim = STM32_TIM2;
 8004ea4:	61bb      	str	r3, [r7, #24]
#endif

#if STM32_PWM_USE_TIM2
  /* Driver initialization.*/
  pwmObjectInit(&PWMD2);
  PWMD2.channels = STM32_TIM2_CHANNELS;
 8004ea6:	743c      	strb	r4, [r7, #16]
  PWMD2.tim = STM32_TIM2;
#endif

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
 8004ea8:	f7fe fc2a 	bl	8003700 <pwmObjectInit>
  PWMD3.channels = STM32_TIM3_CHANNELS;
  PWMD3.tim = STM32_TIM3;
 8004eac:	4b09      	ldr	r3, [pc, #36]	; (8004ed4 <pwm_lld_init+0x54>)
#endif

#if STM32_PWM_USE_TIM4
  /* Driver initialization.*/
  pwmObjectInit(&PWMD4);
 8004eae:	4628      	mov	r0, r5

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
  PWMD3.channels = STM32_TIM3_CHANNELS;
  PWMD3.tim = STM32_TIM3;
 8004eb0:	61b3      	str	r3, [r6, #24]
#endif

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
  PWMD3.channels = STM32_TIM3_CHANNELS;
 8004eb2:	7434      	strb	r4, [r6, #16]
  PWMD3.tim = STM32_TIM3;
#endif

#if STM32_PWM_USE_TIM4
  /* Driver initialization.*/
  pwmObjectInit(&PWMD4);
 8004eb4:	f7fe fc24 	bl	8003700 <pwmObjectInit>
  PWMD4.channels = STM32_TIM4_CHANNELS;
  PWMD4.tim = STM32_TIM4;
 8004eb8:	4b07      	ldr	r3, [pc, #28]	; (8004ed8 <pwm_lld_init+0x58>)
#endif

#if STM32_PWM_USE_TIM4
  /* Driver initialization.*/
  pwmObjectInit(&PWMD4);
  PWMD4.channels = STM32_TIM4_CHANNELS;
 8004eba:	742c      	strb	r4, [r5, #16]
  PWMD4.tim = STM32_TIM4;
 8004ebc:	61ab      	str	r3, [r5, #24]
 8004ebe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004ec0:	20001374 	.word	0x20001374
 8004ec4:	20001390 	.word	0x20001390
 8004ec8:	200013ac 	.word	0x200013ac
 8004ecc:	40012c00 	.word	0x40012c00
 8004ed0:	200013c8 	.word	0x200013c8
 8004ed4:	40000400 	.word	0x40000400
 8004ed8:	40000800 	.word	0x40000800
 8004edc:	00000000 	.word	0x00000000

08004ee0 <pwm_lld_serve_interrupt>:
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8004ee0:	6983      	ldr	r3, [r0, #24]
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8004ee2:	b570      	push	{r4, r5, r6, lr}
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8004ee4:	691a      	ldr	r2, [r3, #16]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8004ee6:	68dc      	ldr	r4, [r3, #12]
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8004ee8:	4605      	mov	r5, r0
 8004eea:	4014      	ands	r4, r2
  uint32_t sr;

  sr  = pwmp->tim->SR;
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8004eec:	b2e2      	uxtb	r2, r4
  pwmp->tim->SR = ~sr;
 8004eee:	43d2      	mvns	r2, r2
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8004ef0:	07a6      	lsls	r6, r4, #30
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  uint32_t sr;

  sr  = pwmp->tim->SR;
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
 8004ef2:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8004ef4:	d503      	bpl.n	8004efe <pwm_lld_serve_interrupt+0x1e>
      (pwmp->config->channels[0].callback != NULL))
 8004ef6:	6843      	ldr	r3, [r0, #4]
 8004ef8:	691b      	ldr	r3, [r3, #16]
  uint32_t sr;

  sr  = pwmp->tim->SR;
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8004efa:	b103      	cbz	r3, 8004efe <pwm_lld_serve_interrupt+0x1e>
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
 8004efc:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8004efe:	0760      	lsls	r0, r4, #29
 8004f00:	d504      	bpl.n	8004f0c <pwm_lld_serve_interrupt+0x2c>
      (pwmp->config->channels[1].callback != NULL))
 8004f02:	686b      	ldr	r3, [r5, #4]
 8004f04:	699b      	ldr	r3, [r3, #24]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8004f06:	b10b      	cbz	r3, 8004f0c <pwm_lld_serve_interrupt+0x2c>
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
 8004f08:	4628      	mov	r0, r5
 8004f0a:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8004f0c:	0721      	lsls	r1, r4, #28
 8004f0e:	d504      	bpl.n	8004f1a <pwm_lld_serve_interrupt+0x3a>
      (pwmp->config->channels[2].callback != NULL))
 8004f10:	686b      	ldr	r3, [r5, #4]
 8004f12:	6a1b      	ldr	r3, [r3, #32]
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8004f14:	b10b      	cbz	r3, 8004f1a <pwm_lld_serve_interrupt+0x3a>
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
 8004f16:	4628      	mov	r0, r5
 8004f18:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8004f1a:	06e2      	lsls	r2, r4, #27
 8004f1c:	d504      	bpl.n	8004f28 <pwm_lld_serve_interrupt+0x48>
      (pwmp->config->channels[3].callback != NULL))
 8004f1e:	686b      	ldr	r3, [r5, #4]
 8004f20:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8004f22:	b10b      	cbz	r3, 8004f28 <pwm_lld_serve_interrupt+0x48>
      (pwmp->config->channels[3].callback != NULL))
    pwmp->config->channels[3].callback(pwmp);
 8004f24:	4628      	mov	r0, r5
 8004f26:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 8004f28:	07e3      	lsls	r3, r4, #31
 8004f2a:	d506      	bpl.n	8004f3a <pwm_lld_serve_interrupt+0x5a>
 8004f2c:	686b      	ldr	r3, [r5, #4]
 8004f2e:	689b      	ldr	r3, [r3, #8]
 8004f30:	b11b      	cbz	r3, 8004f3a <pwm_lld_serve_interrupt+0x5a>
    pwmp->config->callback(pwmp);
 8004f32:	4628      	mov	r0, r5
}
 8004f34:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    pwmp->config->channels[2].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
      (pwmp->config->channels[3].callback != NULL))
    pwmp->config->channels[3].callback(pwmp);
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
    pwmp->config->callback(pwmp);
 8004f38:	4718      	bx	r3
 8004f3a:	bd70      	pop	{r4, r5, r6, pc}
 8004f3c:	0000      	movs	r0, r0
	...

08004f40 <VectorA4>:
 *          pointer is not equal to @p NULL in order to not perform an extra
 *          check in a potentially critical interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {
 8004f40:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD1);
 8004f42:	4803      	ldr	r0, [pc, #12]	; (8004f50 <VectorA4+0x10>)
 8004f44:	f7ff ffcc 	bl	8004ee0 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 8004f48:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD1);

  OSAL_IRQ_EPILOGUE();
 8004f4c:	f7fe b8a0 	b.w	8003090 <_port_irq_epilogue>
 8004f50:	20001374 	.word	0x20001374
	...

08004f60 <VectorAC>:
 *          associated callback pointer is not equal to @p NULL in order to not
 *          perform an extra check in a potentially critical interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_CC_HANDLER) {
 8004f60:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD1);
 8004f62:	4803      	ldr	r0, [pc, #12]	; (8004f70 <VectorAC+0x10>)
 8004f64:	f7ff ffbc 	bl	8004ee0 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 8004f68:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD1);

  OSAL_IRQ_EPILOGUE();
 8004f6c:	f7fe b890 	b.w	8003090 <_port_irq_epilogue>
 8004f70:	20001374 	.word	0x20001374
	...

08004f80 <VectorB0>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 8004f80:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD2);
 8004f82:	4803      	ldr	r0, [pc, #12]	; (8004f90 <VectorB0+0x10>)
 8004f84:	f7ff ffac 	bl	8004ee0 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 8004f88:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD2);

  OSAL_IRQ_EPILOGUE();
 8004f8c:	f7fe b880 	b.w	8003090 <_port_irq_epilogue>
 8004f90:	20001390 	.word	0x20001390
	...

08004fa0 <VectorB4>:
/**
 * @brief   TIM3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM3_HANDLER) {
 8004fa0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD3);
 8004fa2:	4803      	ldr	r0, [pc, #12]	; (8004fb0 <VectorB4+0x10>)
 8004fa4:	f7ff ff9c 	bl	8004ee0 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 8004fa8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD3);

  OSAL_IRQ_EPILOGUE();
 8004fac:	f7fe b870 	b.w	8003090 <_port_irq_epilogue>
 8004fb0:	200013ac 	.word	0x200013ac
	...

08004fc0 <VectorB8>:
/**
 * @brief   TIM4 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM4_HANDLER) {
 8004fc0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD4);
 8004fc2:	4803      	ldr	r0, [pc, #12]	; (8004fd0 <VectorB8+0x10>)
 8004fc4:	f7ff ff8c 	bl	8004ee0 <pwm_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 8004fc8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD4);

  OSAL_IRQ_EPILOGUE();
 8004fcc:	f7fe b860 	b.w	8003090 <_port_irq_epilogue>
 8004fd0:	200013c8 	.word	0x200013c8
	...

08004fe0 <notify4>:

#if STM32_SERIAL_USE_UART4 || defined(__DOXYGEN__)
static void notify4(io_queue_t *qp) {

  (void)qp;
  UART4->CR1 |= USART_CR1_TXEIE;
 8004fe0:	4a02      	ldr	r2, [pc, #8]	; (8004fec <notify4+0xc>)
 8004fe2:	68d3      	ldr	r3, [r2, #12]
 8004fe4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004fe8:	60d3      	str	r3, [r2, #12]
 8004fea:	4770      	bx	lr
 8004fec:	40004c00 	.word	0x40004c00

08004ff0 <Vector110>:
/**
 * @brief   UART4 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_UART4_HANDLER) {
 8004ff0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8004ff2:	4e43      	ldr	r6, [pc, #268]	; (8005100 <Vector110+0x110>)
 8004ff4:	f8d6 5154 	ldr.w	r5, [r6, #340]	; 0x154
  uint16_t cr1 = u->CR1;
 8004ff8:	68ef      	ldr	r7, [r5, #12]
  uint16_t sr = u->SR;
 8004ffa:	682b      	ldr	r3, [r5, #0]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8004ffc:	05da      	lsls	r2, r3, #23
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
  uint16_t cr1 = u->CR1;
  uint16_t sr = u->SR;
 8004ffe:	b29c      	uxth	r4, r3

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8005000:	d44f      	bmi.n	80050a2 <Vector110+0xb2>
 8005002:	2320      	movs	r3, #32
 8005004:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8005008:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 800500c:	d108      	bne.n	8005020 <Vector110+0x30>
 800500e:	e029      	b.n	8005064 <Vector110+0x74>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 8005010:	06a0      	lsls	r0, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 8005012:	6869      	ldr	r1, [r5, #4]
    if (sr & USART_SR_RXNE)
 8005014:	d41d      	bmi.n	8005052 <Vector110+0x62>
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 8005016:	682c      	ldr	r4, [r5, #0]
 8005018:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800501a:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 800501e:	d021      	beq.n	8005064 <Vector110+0x74>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 8005020:	0723      	lsls	r3, r4, #28
 8005022:	d0f5      	beq.n	8005010 <Vector110+0x20>
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
  eventflags_t sts = 0;

  if (sr & USART_SR_ORE)
    sts |= SD_OVERRUN_ERROR;
 8005024:	f014 0f08 	tst.w	r4, #8
 8005028:	bf0c      	ite	eq
 800502a:	2100      	moveq	r1, #0
 800502c:	2180      	movne	r1, #128	; 0x80
  if (sr & USART_SR_PE)
 800502e:	07e0      	lsls	r0, r4, #31
    sts |= SD_PARITY_ERROR;
 8005030:	bf48      	it	mi
 8005032:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_FE)
 8005036:	07a2      	lsls	r2, r4, #30
    sts |= SD_FRAMING_ERROR;
 8005038:	bf48      	it	mi
 800503a:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 800503e:	0763      	lsls	r3, r4, #29
    sts |= SD_NOISE_ERROR;
 8005040:	bf48      	it	mi
 8005042:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8005046:	482f      	ldr	r0, [pc, #188]	; (8005104 <Vector110+0x114>)
 8005048:	f7fd faaa 	bl	80025a0 <chEvtBroadcastFlagsI>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 800504c:	06a0      	lsls	r0, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 800504e:	6869      	ldr	r1, [r5, #4]
    if (sr & USART_SR_RXNE)
 8005050:	d5e1      	bpl.n	8005016 <Vector110+0x26>
      sdIncomingDataI(sdp, b);
 8005052:	b2c9      	uxtb	r1, r1
 8005054:	482a      	ldr	r0, [pc, #168]	; (8005100 <Vector110+0x110>)
 8005056:	f7fe fbd3 	bl	8003800 <sdIncomingDataI>
    sr = u->SR;
 800505a:	682c      	ldr	r4, [r5, #0]
 800505c:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800505e:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8005062:	d1dd      	bne.n	8005020 <Vector110+0x30>
 8005064:	2300      	movs	r3, #0
 8005066:	f383 8811 	msr	BASEPRI, r3
    sr = u->SR;
  }
  osalSysUnlockFromISR();

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 800506a:	0639      	lsls	r1, r7, #24
 800506c:	d501      	bpl.n	8005072 <Vector110+0x82>
 800506e:	0622      	lsls	r2, r4, #24
 8005070:	d426      	bmi.n	80050c0 <Vector110+0xd0>
      u->DR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 8005072:	0663      	lsls	r3, r4, #25
 8005074:	d511      	bpl.n	800509a <Vector110+0xaa>
 8005076:	2320      	movs	r3, #32
 8005078:	f383 8811 	msr	BASEPRI, r3
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 800507c:	6c72      	ldr	r2, [r6, #68]	; 0x44
 800507e:	6cb3      	ldr	r3, [r6, #72]	; 0x48
 8005080:	481f      	ldr	r0, [pc, #124]	; (8005100 <Vector110+0x110>)
 8005082:	429a      	cmp	r2, r3
 8005084:	d029      	beq.n	80050da <Vector110+0xea>
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8005086:	f64f 73bf 	movw	r3, #65471	; 0xffbf
    u->SR = ~USART_SR_TC;
 800508a:	f06f 0240 	mvn.w	r2, #64	; 0x40
  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 800508e:	403b      	ands	r3, r7
 8005090:	60eb      	str	r3, [r5, #12]
 8005092:	2300      	movs	r3, #0
    u->SR = ~USART_SR_TC;
 8005094:	602a      	str	r2, [r5, #0]
 8005096:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD4);

  OSAL_IRQ_EPILOGUE();
}
 800509a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD4);

  OSAL_IRQ_EPILOGUE();
 800509e:	f7fd bff7 	b.w	8003090 <_port_irq_epilogue>
 80050a2:	2320      	movs	r3, #32
 80050a4:	f383 8811 	msr	BASEPRI, r3
 80050a8:	f44f 7100 	mov.w	r1, #512	; 0x200
 80050ac:	1d30      	adds	r0, r6, #4
 80050ae:	f7fd fa77 	bl	80025a0 <chEvtBroadcastFlagsI>

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    u->SR = ~USART_SR_LBD;
 80050b2:	f46f 7380 	mvn.w	r3, #256	; 0x100
 80050b6:	602b      	str	r3, [r5, #0]
 80050b8:	2300      	movs	r3, #0
 80050ba:	f383 8811 	msr	BASEPRI, r3
 80050be:	e7a0      	b.n	8005002 <Vector110+0x12>
 80050c0:	2320      	movs	r3, #32
 80050c2:	f383 8811 	msr	BASEPRI, r3

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
 80050c6:	4810      	ldr	r0, [pc, #64]	; (8005108 <Vector110+0x118>)
 80050c8:	f7fd fe0a 	bl	8002ce0 <chOQGetI>
    if (b < Q_OK) {
 80050cc:	2800      	cmp	r0, #0
 80050ce:	db0c      	blt.n	80050ea <Vector110+0xfa>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->DR = b;
 80050d0:	6068      	str	r0, [r5, #4]
 80050d2:	2300      	movs	r3, #0
 80050d4:	f383 8811 	msr	BASEPRI, r3
 80050d8:	e7cb      	b.n	8005072 <Vector110+0x82>
 80050da:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80050dc:	2b00      	cmp	r3, #0
 80050de:	d0d2      	beq.n	8005086 <Vector110+0x96>
 80050e0:	3004      	adds	r0, #4
 80050e2:	2110      	movs	r1, #16
 80050e4:	f7fd fa5c 	bl	80025a0 <chEvtBroadcastFlagsI>
 80050e8:	e7cd      	b.n	8005086 <Vector110+0x96>
 80050ea:	4806      	ldr	r0, [pc, #24]	; (8005104 <Vector110+0x114>)
 80050ec:	2108      	movs	r1, #8
 80050ee:	f7fd fa57 	bl	80025a0 <chEvtBroadcastFlagsI>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 80050f2:	f64f 733f 	movw	r3, #65343	; 0xff3f
 80050f6:	403b      	ands	r3, r7
 80050f8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80050fc:	60eb      	str	r3, [r5, #12]
 80050fe:	e7e8      	b.n	80050d2 <Vector110+0xe2>
 8005100:	200013e4 	.word	0x200013e4
 8005104:	200013e8 	.word	0x200013e8
 8005108:	20001414 	.word	0x20001414
 800510c:	00000000 	.word	0x00000000

08005110 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8005110:	b510      	push	{r4, lr}
  sdObjectInit(&SD3, NULL, notify3);
  SD3.usart = USART3;
#endif

#if STM32_SERIAL_USE_UART4
  sdObjectInit(&SD4, NULL, notify4);
 8005112:	4c05      	ldr	r4, [pc, #20]	; (8005128 <sd_lld_init+0x18>)
 8005114:	2100      	movs	r1, #0
 8005116:	4620      	mov	r0, r4
 8005118:	4a04      	ldr	r2, [pc, #16]	; (800512c <sd_lld_init+0x1c>)
 800511a:	f7fe fb41 	bl	80037a0 <sdObjectInit>
  SD4.usart = UART4;
 800511e:	4b04      	ldr	r3, [pc, #16]	; (8005130 <sd_lld_init+0x20>)
 8005120:	f8c4 3154 	str.w	r3, [r4, #340]	; 0x154
 8005124:	bd10      	pop	{r4, pc}
 8005126:	bf00      	nop
 8005128:	200013e4 	.word	0x200013e4
 800512c:	08004fe1 	.word	0x08004fe1
 8005130:	40004c00 	.word	0x40004c00
	...

08005140 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8005140:	b538      	push	{r3, r4, r5, lr}

  if (config == NULL)
    config = &default_config;
 8005142:	4c19      	ldr	r4, [pc, #100]	; (80051a8 <sd_lld_start+0x68>)

  if (sdp->state == SD_STOP) {
 8005144:	7a03      	ldrb	r3, [r0, #8]
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;
 8005146:	2900      	cmp	r1, #0
 8005148:	bf18      	it	ne
 800514a:	460c      	movne	r4, r1

  if (sdp->state == SD_STOP) {
 800514c:	2b01      	cmp	r3, #1
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 800514e:	4605      	mov	r5, r0

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8005150:	d01c      	beq.n	800518c <sd_lld_start+0x4c>
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8005152:	6821      	ldr	r1, [r4, #0]
 8005154:	4a15      	ldr	r2, [pc, #84]	; (80051ac <sd_lld_start+0x6c>)
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8005156:	f8d5 3154 	ldr.w	r3, [r5, #340]	; 0x154
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 800515a:	fbb2 f2f1 	udiv	r2, r2, r1
 800515e:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8005160:	88a2      	ldrh	r2, [r4, #4]
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8005162:	88e0      	ldrh	r0, [r4, #6]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8005164:	8921      	ldrh	r1, [r4, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8005166:	f442 5204 	orr.w	r2, r2, #8448	; 0x2100
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800516a:	f040 0040 	orr.w	r0, r0, #64	; 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 800516e:	f042 022c 	orr.w	r2, r2, #44	; 0x2c
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8005172:	f041 0101 	orr.w	r1, r1, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8005176:	b292      	uxth	r2, r2
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8005178:	b280      	uxth	r0, r0
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800517a:	b289      	uxth	r1, r1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 800517c:	2400      	movs	r4, #0
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800517e:	6118      	str	r0, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8005180:	6159      	str	r1, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8005182:	60da      	str	r2, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8005184:	601c      	str	r4, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8005186:	681a      	ldr	r2, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8005188:	685b      	ldr	r3, [r3, #4]
 800518a:	bd38      	pop	{r3, r4, r5, pc}
      rccEnableUSART3(FALSE);
      nvicEnableVector(STM32_USART3_NUMBER, STM32_SERIAL_USART3_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_UART4
    if (&SD4 == sdp) {
 800518c:	4b08      	ldr	r3, [pc, #32]	; (80051b0 <sd_lld_start+0x70>)
 800518e:	4298      	cmp	r0, r3
 8005190:	d1df      	bne.n	8005152 <sd_lld_start+0x12>
      rccEnableUART4(FALSE);
 8005192:	4a08      	ldr	r2, [pc, #32]	; (80051b4 <sd_lld_start+0x74>)
      nvicEnableVector(STM32_UART4_NUMBER, STM32_SERIAL_UART4_PRIORITY);
 8005194:	2034      	movs	r0, #52	; 0x34
      nvicEnableVector(STM32_USART3_NUMBER, STM32_SERIAL_USART3_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_UART4
    if (&SD4 == sdp) {
      rccEnableUART4(FALSE);
 8005196:	69d3      	ldr	r3, [r2, #28]
      nvicEnableVector(STM32_UART4_NUMBER, STM32_SERIAL_UART4_PRIORITY);
 8005198:	210c      	movs	r1, #12
      nvicEnableVector(STM32_USART3_NUMBER, STM32_SERIAL_USART3_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_UART4
    if (&SD4 == sdp) {
      rccEnableUART4(FALSE);
 800519a:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 800519e:	61d3      	str	r3, [r2, #28]
      nvicEnableVector(STM32_UART4_NUMBER, STM32_SERIAL_UART4_PRIORITY);
 80051a0:	f7ff f86e 	bl	8004280 <nvicEnableVector>
 80051a4:	e7d5      	b.n	8005152 <sd_lld_start+0x12>
 80051a6:	bf00      	nop
 80051a8:	0800d6f0 	.word	0x0800d6f0
 80051ac:	02255100 	.word	0x02255100
 80051b0:	200013e4 	.word	0x200013e4
 80051b4:	40021000 	.word	0x40021000
	...

080051c0 <usb_packet_write_from_buffer>:
 * @notapi
 */
static void usb_packet_write_from_buffer(usbep_t ep,
                                         const uint8_t *buf,
                                         size_t n) {
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 80051c0:	4b14      	ldr	r3, [pc, #80]	; (8005214 <usb_packet_write_from_buffer+0x54>)
 *
 * @notapi
 */
static void usb_packet_write_from_buffer(usbep_t ep,
                                         const uint8_t *buf,
                                         size_t n) {
 80051c2:	b410      	push	{r4}
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 80051c4:	6d1c      	ldr	r4, [r3, #80]	; 0x50
 80051c6:	0100      	lsls	r0, r0, #4
 80051c8:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 80051cc:	f504 44c0 	add.w	r4, r4, #24576	; 0x6000
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 80051d0:	5823      	ldr	r3, [r4, r0]
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i > 0) {
 80051d2:	2a00      	cmp	r2, #0
 */
static void usb_packet_write_from_buffer(usbep_t ep,
                                         const uint8_t *buf,
                                         size_t n) {
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 80051d4:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 * @notapi
 */
static void usb_packet_write_from_buffer(usbep_t ep,
                                         const uint8_t *buf,
                                         size_t n) {
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 80051d8:	4420      	add	r0, r4
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 80051da:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
  if (EPR_EP_TYPE_IS_ISO(epr) && (epr & EPR_DTOG_TX))
    udp->TXCOUNT1 = (stm32_usb_pma_t)n;
  else
    udp->TXCOUNT0 = (stm32_usb_pma_t)n;
#else
  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
 80051de:	6042      	str	r2, [r0, #4]
 */
static void usb_packet_write_from_buffer(usbep_t ep,
                                         const uint8_t *buf,
                                         size_t n) {
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 80051e0:	ea4f 0343 	mov.w	r3, r3, lsl #1
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i > 0) {
 80051e4:	dd13      	ble.n	800520e <usb_packet_write_from_buffer+0x4e>
 80051e6:	1e54      	subs	r4, r2, #1
 80051e8:	0864      	lsrs	r4, r4, #1
 80051ea:	3304      	adds	r3, #4
 80051ec:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 80051f0:	3102      	adds	r1, #2
 80051f2:	e000      	b.n	80051f6 <usb_packet_write_from_buffer+0x36>
 80051f4:	3304      	adds	r3, #4
    uint32_t w;

    w  = *buf++;
 80051f6:	f811 2c02 	ldrb.w	r2, [r1, #-2]
    w |= *buf++ << 8;
 80051fa:	f811 0c01 	ldrb.w	r0, [r1, #-1]
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i > 0) {
 80051fe:	42a3      	cmp	r3, r4
    uint32_t w;

    w  = *buf++;
    w |= *buf++ << 8;
 8005200:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8005204:	f101 0102 	add.w	r1, r1, #2
    *pmap++ = (stm32_usb_pma_t)w;
 8005208:	f843 2c04 	str.w	r2, [r3, #-4]
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i > 0) {
 800520c:	d1f2      	bne.n	80051f4 <usb_packet_write_from_buffer+0x34>
    w  = *buf++;
    w |= *buf++ << 8;
    *pmap++ = (stm32_usb_pma_t)w;
    i -= 2;
  }
}
 800520e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005212:	4770      	bx	lr
 8005214:	40005c00 	.word	0x40005c00
	...

08005220 <Vector90>:
/**
 * @brief   USB low priority interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USB1_LP_HANDLER) {
 8005220:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t istr;
  USBDriver *usbp = &USBD1;

  OSAL_IRQ_PROLOGUE();

  istr = STM32_USB->ISTR;
 8005224:	4b93      	ldr	r3, [pc, #588]	; (8005474 <Vector90+0x254>)
/**
 * @brief   USB low priority interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USB1_LP_HANDLER) {
 8005226:	b083      	sub	sp, #12
  uint32_t istr;
  USBDriver *usbp = &USBD1;

  OSAL_IRQ_PROLOGUE();

  istr = STM32_USB->ISTR;
 8005228:	6c5d      	ldr	r5, [r3, #68]	; 0x44

  /* USB bus reset condition handling.*/
  if (istr & ISTR_RESET) {
 800522a:	056f      	lsls	r7, r5, #21
 800522c:	f100 8113 	bmi.w	8005456 <Vector90+0x236>

    _usb_reset(usbp);
  }

  /* USB bus SUSPEND condition handling.*/
  if (istr & ISTR_SUSP) {
 8005230:	052e      	lsls	r6, r5, #20
 8005232:	f100 8104 	bmi.w	800543e <Vector90+0x21e>

    _usb_suspend(usbp);
  }

  /* USB bus WAKEUP condition handling.*/
  if (istr & ISTR_WKUP) {
 8005236:	04ec      	lsls	r4, r5, #19
 8005238:	d508      	bpl.n	800524c <Vector90+0x2c>
    uint32_t fnr = STM32_USB->FNR;
 800523a:	4b8e      	ldr	r3, [pc, #568]	; (8005474 <Vector90+0x254>)
 800523c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    if (!(fnr & FNR_RXDP)) {
 800523e:	0410      	lsls	r0, r2, #16
 8005240:	f140 8110 	bpl.w	8005464 <Vector90+0x244>
      /* Just noise, going back in SUSPEND mode, reference manual 22.4.5,
         table 169.*/
      STM32_USB->CNTR |= CNTR_LP_MODE;
    }
#endif
    STM32_USB->ISTR = ~ISTR_WKUP;
 8005244:	4b8b      	ldr	r3, [pc, #556]	; (8005474 <Vector90+0x254>)
 8005246:	f46f 5280 	mvn.w	r2, #4096	; 0x1000
 800524a:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* SOF handling.*/
  if (istr & ISTR_SOF) {
 800524c:	05a9      	lsls	r1, r5, #22
 800524e:	d50b      	bpl.n	8005268 <Vector90+0x48>
    _usb_isr_invoke_sof_cb(usbp);
 8005250:	f8df a224 	ldr.w	sl, [pc, #548]	; 8005478 <Vector90+0x258>
 8005254:	f8da 3004 	ldr.w	r3, [sl, #4]
 8005258:	68db      	ldr	r3, [r3, #12]
 800525a:	b10b      	cbz	r3, 8005260 <Vector90+0x40>
 800525c:	4650      	mov	r0, sl
 800525e:	4798      	blx	r3
    STM32_USB->ISTR = ~ISTR_SOF;
 8005260:	4b84      	ldr	r3, [pc, #528]	; (8005474 <Vector90+0x254>)
 8005262:	f46f 7200 	mvn.w	r2, #512	; 0x200
 8005266:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Endpoint events handling.*/
  while (istr & ISTR_CTR) {
 8005268:	042a      	lsls	r2, r5, #16
 800526a:	f140 80b7 	bpl.w	80053dc <Vector90+0x1bc>
 800526e:	f8df a208 	ldr.w	sl, [pc, #520]	; 8005478 <Vector90+0x258>
    usb_serve_endpoints(usbp, istr & ISTR_EP_ID_MASK);
 8005272:	f005 050f 	and.w	r5, r5, #15
 8005276:	00ac      	lsls	r4, r5, #2
 8005278:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 800527c:	f504 44b8 	add.w	r4, r4, #23552	; 0x5c00
 *
 * @notapi
 */
static void usb_serve_endpoints(USBDriver *usbp, uint32_t ep) {
  size_t n;
  uint32_t epr = STM32_USB->EPR[ep];
 8005280:	f8d4 8000 	ldr.w	r8, [r4]
  const USBEndpointConfig *epcp = usbp->epc[ep];
 8005284:	1cae      	adds	r6, r5, #2
 8005286:	eb0a 0386 	add.w	r3, sl, r6, lsl #2

  if (epr & EPR_CTR_TX) {
 800528a:	f018 0f80 	tst.w	r8, #128	; 0x80
 * @notapi
 */
static void usb_serve_endpoints(USBDriver *usbp, uint32_t ep) {
  size_t n;
  uint32_t epr = STM32_USB->EPR[ep];
  const USBEndpointConfig *epcp = usbp->epc[ep];
 800528e:	685f      	ldr	r7, [r3, #4]

  if (epr & EPR_CTR_TX) {
 8005290:	d02f      	beq.n	80052f2 <Vector90+0xd2>
    /* IN endpoint, transmission.*/
    USBInEndpointState *isp = epcp->in_state;
 8005292:	f8d7 e014 	ldr.w	lr, [r7, #20]

    EPR_CLEAR_CTR_TX(ep);
 8005296:	6823      	ldr	r3, [r4, #0]

    isp->txcnt += isp->txlast;
 8005298:	f8de 0004 	ldr.w	r0, [lr, #4]
 800529c:	f8de 100c 	ldr.w	r1, [lr, #12]

  if (epr & EPR_CTR_TX) {
    /* IN endpoint, transmission.*/
    USBInEndpointState *isp = epcp->in_state;

    EPR_CLEAR_CTR_TX(ep);
 80052a0:	f423 4378 	bic.w	r3, r3, #63488	; 0xf800

    isp->txcnt += isp->txlast;
    n = isp->txsize - isp->txcnt;
 80052a4:	f8de 2000 	ldr.w	r2, [lr]

  if (epr & EPR_CTR_TX) {
    /* IN endpoint, transmission.*/
    USBInEndpointState *isp = epcp->in_state;

    EPR_CLEAR_CTR_TX(ep);
 80052a8:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0

    isp->txcnt += isp->txlast;
 80052ac:	4408      	add	r0, r1

  if (epr & EPR_CTR_TX) {
    /* IN endpoint, transmission.*/
    USBInEndpointState *isp = epcp->in_state;

    EPR_CLEAR_CTR_TX(ep);
 80052ae:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80052b2:	6023      	str	r3, [r4, #0]

    isp->txcnt += isp->txlast;
 80052b4:	f8ce 0004 	str.w	r0, [lr, #4]
    n = isp->txsize - isp->txcnt;
    if (n > 0) {
 80052b8:	1a10      	subs	r0, r2, r0
 80052ba:	f000 80a6 	beq.w	800540a <Vector90+0x1ea>
      /* Transfer not completed, there are more packets to send.*/
      if (n > epcp->in_maxsize)
 80052be:	8a3a      	ldrh	r2, [r7, #16]
        n = epcp->in_maxsize;

      /* Writes the packet from the defined buffer.*/
      isp->txbuf += isp->txlast;
 80052c0:	f8de 3008 	ldr.w	r3, [lr, #8]
 80052c4:	4282      	cmp	r2, r0
 80052c6:	bf28      	it	cs
 80052c8:	4602      	movcs	r2, r0
 80052ca:	4419      	add	r1, r3
      isp->txlast = n;
 80052cc:	f8ce 200c 	str.w	r2, [lr, #12]
      /* Transfer not completed, there are more packets to send.*/
      if (n > epcp->in_maxsize)
        n = epcp->in_maxsize;

      /* Writes the packet from the defined buffer.*/
      isp->txbuf += isp->txlast;
 80052d0:	f8ce 1008 	str.w	r1, [lr, #8]
      isp->txlast = n;
      usb_packet_write_from_buffer(ep, isp->txbuf, n);
 80052d4:	4628      	mov	r0, r5
 80052d6:	f7ff ff73 	bl	80051c0 <usb_packet_write_from_buffer>

      /* Starting IN operation.*/
      EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 80052da:	6823      	ldr	r3, [r4, #0]
 80052dc:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 80052e0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80052e4:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 80052e8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80052ec:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80052f0:	6023      	str	r3, [r4, #0]
    else {
      /* Transfer completed, invokes the callback.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if (epr & EPR_CTR_RX) {
 80052f2:	f418 4f00 	tst.w	r8, #32768	; 0x8000
 80052f6:	d06c      	beq.n	80053d2 <Vector90+0x1b2>
    /* OUT endpoint, receive.*/

    EPR_CLEAR_CTR_RX(ep);
 80052f8:	6823      	ldr	r3, [r4, #0]

    if (epr & EPR_SETUP) {
 80052fa:	f418 6f00 	tst.w	r8, #2048	; 0x800
    }
  }
  if (epr & EPR_CTR_RX) {
    /* OUT endpoint, receive.*/

    EPR_CLEAR_CTR_RX(ep);
 80052fe:	f423 4378 	bic.w	r3, r3, #63488	; 0xf800
 8005302:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8005306:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800530a:	6023      	str	r3, [r4, #0]

    if (epr & EPR_SETUP) {
 800530c:	f040 808f 	bne.w	800542e <Vector90+0x20e>
 *
 * @notapi
 */
static size_t usb_packet_read_to_buffer(usbep_t ep, uint8_t *buf) {
  size_t i, n;
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8005310:	4b58      	ldr	r3, [pc, #352]	; (8005474 <Vector90+0x254>)
      /* Setup packets handling, setup packets are handled using a
         specific callback.*/
      _usb_isr_invoke_setup_cb(usbp, ep);
    }
    else {
      USBOutEndpointState *osp = epcp->out_state;
 8005312:	f8d7 e018 	ldr.w	lr, [r7, #24]
 *
 * @notapi
 */
static size_t usb_packet_read_to_buffer(usbep_t ep, uint8_t *buf) {
  size_t i, n;
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8005316:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    }
    else {
      USBOutEndpointState *osp = epcp->out_state;

      /* Reads the packet into the defined buffer.*/
      n = usb_packet_read_to_buffer(ep, osp->rxbuf);
 8005318:	f8de b008 	ldr.w	fp, [lr, #8]
 800531c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8005320:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
 *
 * @notapi
 */
static size_t usb_packet_read_to_buffer(usbep_t ep, uint8_t *buf) {
  size_t i, n;
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8005324:	eb03 1305 	add.w	r3, r3, r5, lsl #4
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 8005328:	689a      	ldr	r2, [r3, #8]
  if (EPR_EP_TYPE_IS_ISO(epr) && !(epr & EPR_DTOG_RX))
    n = (size_t)udp->RXCOUNT1 & RXCOUNT_COUNT_MASK;
  else
    n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
#else
  n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
 800532a:	68db      	ldr	r3, [r3, #12]
 * @notapi
 */
static size_t usb_packet_read_to_buffer(usbep_t ep, uint8_t *buf) {
  size_t i, n;
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 800532c:	f102 5900 	add.w	r9, r2, #536870912	; 0x20000000
  if (EPR_EP_TYPE_IS_ISO(epr) && !(epr & EPR_DTOG_RX))
    n = (size_t)udp->RXCOUNT1 & RXCOUNT_COUNT_MASK;
  else
    n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
#else
  n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
 8005330:	f3c3 0c09 	ubfx	ip, r3, #0, #10
 * @notapi
 */
static size_t usb_packet_read_to_buffer(usbep_t ep, uint8_t *buf) {
  size_t i, n;
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 8005334:	f509 5940 	add.w	r9, r9, #12288	; 0x3000
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i >= 2) {
 8005338:	f1bc 0f01 	cmp.w	ip, #1
  if (EPR_EP_TYPE_IS_ISO(epr) && !(epr & EPR_DTOG_RX))
    n = (size_t)udp->RXCOUNT1 & RXCOUNT_COUNT_MASK;
  else
    n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
#else
  n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
 800533c:	9301      	str	r3, [sp, #4]
 * @notapi
 */
static size_t usb_packet_read_to_buffer(usbep_t ep, uint8_t *buf) {
  size_t i, n;
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 800533e:	ea4f 0949 	mov.w	r9, r9, lsl #1
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i >= 2) {
 8005342:	4662      	mov	r2, ip
 8005344:	d91a      	bls.n	800537c <Vector90+0x15c>
 8005346:	4648      	mov	r0, r9
 8005348:	f10b 0302 	add.w	r3, fp, #2
    uint32_t w = *pmap++;
 800534c:	f850 1b04 	ldr.w	r1, [r0], #4
    *buf++ = (uint8_t)w;
    *buf++ = (uint8_t)(w >> 8);
    i -= 2;
 8005350:	3a02      	subs	r2, #2
#endif /* STM32_USB_USE_FAST_COPY */

  while (i >= 2) {
    uint32_t w = *pmap++;
    *buf++ = (uint8_t)w;
    *buf++ = (uint8_t)(w >> 8);
 8005352:	ea4f 2811 	mov.w	r8, r1, lsr #8
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i >= 2) {
 8005356:	2a01      	cmp	r2, #1
    uint32_t w = *pmap++;
    *buf++ = (uint8_t)w;
 8005358:	f803 1c02 	strb.w	r1, [r3, #-2]
    *buf++ = (uint8_t)(w >> 8);
 800535c:	f803 8c01 	strb.w	r8, [r3, #-1]
 8005360:	f103 0302 	add.w	r3, r3, #2
    buf += 16;
    pmap += 8;
  }
#endif /* STM32_USB_USE_FAST_COPY */

  while (i >= 2) {
 8005364:	d8f2      	bhi.n	800534c <Vector90+0x12c>
 8005366:	f1ac 0302 	sub.w	r3, ip, #2
 800536a:	085b      	lsrs	r3, r3, #1
 800536c:	9a01      	ldr	r2, [sp, #4]
 800536e:	3301      	adds	r3, #1
 8005370:	f002 0201 	and.w	r2, r2, #1
 8005374:	eb09 0983 	add.w	r9, r9, r3, lsl #2
 8005378:	eb0b 0b43 	add.w	fp, fp, r3, lsl #1
    *buf++ = (uint8_t)w;
    *buf++ = (uint8_t)(w >> 8);
    i -= 2;
  }

  if (i >= 1) {
 800537c:	b11a      	cbz	r2, 8005386 <Vector90+0x166>
    *buf = (uint8_t)*pmap;
 800537e:	f8d9 3000 	ldr.w	r3, [r9]
 8005382:	f88b 3000 	strb.w	r3, [fp]
      osp->rxbuf += n;

      /* Transaction data updated.*/
      osp->rxcnt  += n;
      osp->rxsize -= n;
      osp->rxpkts -= 1;
 8005386:	f8be 000c 	ldrh.w	r0, [lr, #12]

      /* The transaction is completed if the specified number of packets
         has been received or the current packet is a short packet.*/
      if ((n < epcp->out_maxsize) || (osp->rxpkts == 0)) {
 800538a:	8a7f      	ldrh	r7, [r7, #18]
    else {
      USBOutEndpointState *osp = epcp->out_state;

      /* Reads the packet into the defined buffer.*/
      n = usb_packet_read_to_buffer(ep, osp->rxbuf);
      osp->rxbuf += n;
 800538c:	f8de 1008 	ldr.w	r1, [lr, #8]

      /* Transaction data updated.*/
      osp->rxcnt  += n;
 8005390:	f8de 2004 	ldr.w	r2, [lr, #4]
      osp->rxsize -= n;
 8005394:	f8de 3000 	ldr.w	r3, [lr]
      osp->rxpkts -= 1;
 8005398:	3801      	subs	r0, #1
 800539a:	b280      	uxth	r0, r0
    else {
      USBOutEndpointState *osp = epcp->out_state;

      /* Reads the packet into the defined buffer.*/
      n = usb_packet_read_to_buffer(ep, osp->rxbuf);
      osp->rxbuf += n;
 800539c:	4461      	add	r1, ip

      /* Transaction data updated.*/
      osp->rxcnt  += n;
 800539e:	4462      	add	r2, ip
      osp->rxsize -= n;
 80053a0:	ebcc 0303 	rsb	r3, ip, r3
      osp->rxpkts -= 1;

      /* The transaction is completed if the specified number of packets
         has been received or the current packet is a short packet.*/
      if ((n < epcp->out_maxsize) || (osp->rxpkts == 0)) {
 80053a4:	4567      	cmp	r7, ip
      osp->rxbuf += n;

      /* Transaction data updated.*/
      osp->rxcnt  += n;
      osp->rxsize -= n;
      osp->rxpkts -= 1;
 80053a6:	f8ae 000c 	strh.w	r0, [lr, #12]
    else {
      USBOutEndpointState *osp = epcp->out_state;

      /* Reads the packet into the defined buffer.*/
      n = usb_packet_read_to_buffer(ep, osp->rxbuf);
      osp->rxbuf += n;
 80053aa:	f8ce 1008 	str.w	r1, [lr, #8]

      /* Transaction data updated.*/
      osp->rxcnt  += n;
 80053ae:	f8ce 2004 	str.w	r2, [lr, #4]
      osp->rxsize -= n;
 80053b2:	f8ce 3000 	str.w	r3, [lr]
      osp->rxpkts -= 1;

      /* The transaction is completed if the specified number of packets
         has been received or the current packet is a short packet.*/
      if ((n < epcp->out_maxsize) || (osp->rxpkts == 0)) {
 80053b6:	d816      	bhi.n	80053e6 <Vector90+0x1c6>
 80053b8:	b1a8      	cbz	r0, 80053e6 <Vector90+0x1c6>
        /* Transfer complete, invokes the callback.*/
        _usb_isr_invoke_out_cb(usbp, ep);
      }
      else {
        /* Transfer not complete, there are more packets to receive.*/
        EPR_SET_STAT_RX(ep, EPR_STAT_RX_VALID);
 80053ba:	6823      	ldr	r3, [r4, #0]
 80053bc:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 80053c0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80053c4:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 80053c8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80053cc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80053d0:	6023      	str	r3, [r4, #0]
  }

  /* Endpoint events handling.*/
  while (istr & ISTR_CTR) {
    usb_serve_endpoints(usbp, istr & ISTR_EP_ID_MASK);
    istr = STM32_USB->ISTR;
 80053d2:	4b28      	ldr	r3, [pc, #160]	; (8005474 <Vector90+0x254>)
 80053d4:	6c5d      	ldr	r5, [r3, #68]	; 0x44
    _usb_isr_invoke_sof_cb(usbp);
    STM32_USB->ISTR = ~ISTR_SOF;
  }

  /* Endpoint events handling.*/
  while (istr & ISTR_CTR) {
 80053d6:	042b      	lsls	r3, r5, #16
 80053d8:	f53f af4b 	bmi.w	8005272 <Vector90+0x52>
    usb_serve_endpoints(usbp, istr & ISTR_EP_ID_MASK);
    istr = STM32_USB->ISTR;
  }

  OSAL_IRQ_EPILOGUE();
}
 80053dc:	b003      	add	sp, #12
 80053de:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  while (istr & ISTR_CTR) {
    usb_serve_endpoints(usbp, istr & ISTR_EP_ID_MASK);
    istr = STM32_USB->ISTR;
  }

  OSAL_IRQ_EPILOGUE();
 80053e2:	f7fd be55 	b.w	8003090 <_port_irq_epilogue>

      /* The transaction is completed if the specified number of packets
         has been received or the current packet is a short packet.*/
      if ((n < epcp->out_maxsize) || (osp->rxpkts == 0)) {
        /* Transfer complete, invokes the callback.*/
        _usb_isr_invoke_out_cb(usbp, ep);
 80053e6:	eb0a 0686 	add.w	r6, sl, r6, lsl #2
 80053ea:	6872      	ldr	r2, [r6, #4]
 80053ec:	f8ba 300a 	ldrh.w	r3, [sl, #10]
 80053f0:	2101      	movs	r1, #1
 80053f2:	40a9      	lsls	r1, r5
 80053f4:	68d2      	ldr	r2, [r2, #12]
 80053f6:	ea23 0301 	bic.w	r3, r3, r1
 80053fa:	f8aa 300a 	strh.w	r3, [sl, #10]
 80053fe:	2a00      	cmp	r2, #0
 8005400:	d0e7      	beq.n	80053d2 <Vector90+0x1b2>
 8005402:	4629      	mov	r1, r5
 8005404:	481c      	ldr	r0, [pc, #112]	; (8005478 <Vector90+0x258>)
 8005406:	4790      	blx	r2
 8005408:	e7e3      	b.n	80053d2 <Vector90+0x1b2>
      /* Starting IN operation.*/
      EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
    }
    else {
      /* Transfer completed, invokes the callback.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 800540a:	4b1b      	ldr	r3, [pc, #108]	; (8005478 <Vector90+0x258>)
 800540c:	f8d7 c008 	ldr.w	ip, [r7, #8]
 8005410:	891a      	ldrh	r2, [r3, #8]
 8005412:	2301      	movs	r3, #1
 8005414:	40ab      	lsls	r3, r5
 8005416:	ea22 0303 	bic.w	r3, r2, r3
 800541a:	4a17      	ldr	r2, [pc, #92]	; (8005478 <Vector90+0x258>)
 800541c:	8113      	strh	r3, [r2, #8]
 800541e:	f1bc 0f00 	cmp.w	ip, #0
 8005422:	f43f af66 	beq.w	80052f2 <Vector90+0xd2>
 8005426:	4610      	mov	r0, r2
 8005428:	4629      	mov	r1, r5
 800542a:	47e0      	blx	ip
 800542c:	e761      	b.n	80052f2 <Vector90+0xd2>
    EPR_CLEAR_CTR_RX(ep);

    if (epr & EPR_SETUP) {
      /* Setup packets handling, setup packets are handled using a
         specific callback.*/
      _usb_isr_invoke_setup_cb(usbp, ep);
 800542e:	eb0a 0686 	add.w	r6, sl, r6, lsl #2
 8005432:	6873      	ldr	r3, [r6, #4]
 8005434:	4629      	mov	r1, r5
 8005436:	685b      	ldr	r3, [r3, #4]
 8005438:	480f      	ldr	r0, [pc, #60]	; (8005478 <Vector90+0x258>)
 800543a:	4798      	blx	r3
 800543c:	e7c9      	b.n	80053d2 <Vector90+0x1b2>
    _usb_reset(usbp);
  }

  /* USB bus SUSPEND condition handling.*/
  if (istr & ISTR_SUSP) {
    STM32_USB->CNTR |= CNTR_FSUSP;
 800543e:	4b0d      	ldr	r3, [pc, #52]	; (8005474 <Vector90+0x254>)
#if STM32_USB_LOW_POWER_ON_SUSPEND
    STM32_USB->CNTR |= CNTR_LP_MODE;
#endif
    STM32_USB->ISTR = ~ISTR_SUSP;
 8005440:	f46f 6100 	mvn.w	r1, #2048	; 0x800
    _usb_reset(usbp);
  }

  /* USB bus SUSPEND condition handling.*/
  if (istr & ISTR_SUSP) {
    STM32_USB->CNTR |= CNTR_FSUSP;
 8005444:	6c1a      	ldr	r2, [r3, #64]	; 0x40
#if STM32_USB_LOW_POWER_ON_SUSPEND
    STM32_USB->CNTR |= CNTR_LP_MODE;
#endif
    STM32_USB->ISTR = ~ISTR_SUSP;

    _usb_suspend(usbp);
 8005446:	480c      	ldr	r0, [pc, #48]	; (8005478 <Vector90+0x258>)
    _usb_reset(usbp);
  }

  /* USB bus SUSPEND condition handling.*/
  if (istr & ISTR_SUSP) {
    STM32_USB->CNTR |= CNTR_FSUSP;
 8005448:	f042 0208 	orr.w	r2, r2, #8
 800544c:	641a      	str	r2, [r3, #64]	; 0x40
#if STM32_USB_LOW_POWER_ON_SUSPEND
    STM32_USB->CNTR |= CNTR_LP_MODE;
#endif
    STM32_USB->ISTR = ~ISTR_SUSP;
 800544e:	6459      	str	r1, [r3, #68]	; 0x44

    _usb_suspend(usbp);
 8005450:	f7fe fcd6 	bl	8003e00 <_usb_suspend>
 8005454:	e6ef      	b.n	8005236 <Vector90+0x16>

  istr = STM32_USB->ISTR;

  /* USB bus reset condition handling.*/
  if (istr & ISTR_RESET) {
    STM32_USB->ISTR = ~ISTR_RESET;
 8005456:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 800545a:	645a      	str	r2, [r3, #68]	; 0x44

    _usb_reset(usbp);
 800545c:	4806      	ldr	r0, [pc, #24]	; (8005478 <Vector90+0x258>)
 800545e:	f7fe fca7 	bl	8003db0 <_usb_reset>
 8005462:	e6e5      	b.n	8005230 <Vector90+0x10>

  /* USB bus WAKEUP condition handling.*/
  if (istr & ISTR_WKUP) {
    uint32_t fnr = STM32_USB->FNR;
    if (!(fnr & FNR_RXDP)) {
      STM32_USB->CNTR &= ~CNTR_FSUSP;
 8005464:	6c1a      	ldr	r2, [r3, #64]	; 0x40

      _usb_wakeup(usbp);
 8005466:	4804      	ldr	r0, [pc, #16]	; (8005478 <Vector90+0x258>)

  /* USB bus WAKEUP condition handling.*/
  if (istr & ISTR_WKUP) {
    uint32_t fnr = STM32_USB->FNR;
    if (!(fnr & FNR_RXDP)) {
      STM32_USB->CNTR &= ~CNTR_FSUSP;
 8005468:	f022 0208 	bic.w	r2, r2, #8
 800546c:	641a      	str	r2, [r3, #64]	; 0x40

      _usb_wakeup(usbp);
 800546e:	f7fe fcd7 	bl	8003e20 <_usb_wakeup>
 8005472:	e6e7      	b.n	8005244 <Vector90+0x24>
 8005474:	40005c00 	.word	0x40005c00
 8005478:	2000153c 	.word	0x2000153c
 800547c:	00000000 	.word	0x00000000

08005480 <usb_lld_init>:
 * @notapi
 */
void usb_lld_init(void) {

  /* Driver initialization.*/
  usbObjectInit(&USBD1);
 8005480:	4801      	ldr	r0, [pc, #4]	; (8005488 <usb_lld_init+0x8>)
 8005482:	f7fe bbd5 	b.w	8003c30 <usbObjectInit>
 8005486:	bf00      	nop
 8005488:	2000153c 	.word	0x2000153c
 800548c:	00000000 	.word	0x00000000

08005490 <usb_lld_start>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 8005490:	b538      	push	{r3, r4, r5, lr}

  if (usbp->state == USB_STOP) {
 8005492:	7803      	ldrb	r3, [r0, #0]
 8005494:	2b01      	cmp	r3, #1
 8005496:	d000      	beq.n	800549a <usb_lld_start+0xa>
 8005498:	bd38      	pop	{r3, r4, r5, pc}
    /* Clock activation.*/
#if STM32_USB_USE_USB1
    if (&USBD1 == usbp) {
 800549a:	4a0d      	ldr	r2, [pc, #52]	; (80054d0 <usb_lld_start+0x40>)
 800549c:	4604      	mov	r4, r0
 800549e:	4290      	cmp	r0, r2
 80054a0:	d004      	beq.n	80054ac <usb_lld_start+0x1c>
      /* Releases the USB reset.*/
      STM32_USB->CNTR = 0;
    }
#endif
    /* Reset procedure enforced on driver start.*/
    _usb_reset(usbp);
 80054a2:	4620      	mov	r0, r4
  }
}
 80054a4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      /* Releases the USB reset.*/
      STM32_USB->CNTR = 0;
    }
#endif
    /* Reset procedure enforced on driver start.*/
    _usb_reset(usbp);
 80054a8:	f7fe bc82 	b.w	8003db0 <_usb_reset>
  if (usbp->state == USB_STOP) {
    /* Clock activation.*/
#if STM32_USB_USE_USB1
    if (&USBD1 == usbp) {
      /* USB clock enabled.*/
      rccEnableUSB(FALSE);
 80054ac:	4909      	ldr	r1, [pc, #36]	; (80054d4 <usb_lld_start+0x44>)
      /* Powers up the transceiver while holding the USB in reset state.*/
      STM32_USB->CNTR = CNTR_FRES;
 80054ae:	4d0a      	ldr	r5, [pc, #40]	; (80054d8 <usb_lld_start+0x48>)
  if (usbp->state == USB_STOP) {
    /* Clock activation.*/
#if STM32_USB_USE_USB1
    if (&USBD1 == usbp) {
      /* USB clock enabled.*/
      rccEnableUSB(FALSE);
 80054b0:	69ca      	ldr	r2, [r1, #28]
      /* Powers up the transceiver while holding the USB in reset state.*/
      STM32_USB->CNTR = CNTR_FRES;
      /* Enabling the USB IRQ vectors, this also gives enough time to allow
         the transceiver power up (1uS).*/
#if STM32_USB1_HP_NUMBER != STM32_USB1_LP_NUMBER
      nvicEnableVector(STM32_USB1_HP_NUMBER, STM32_USB_USB1_HP_IRQ_PRIORITY);
 80054b2:	2013      	movs	r0, #19
  if (usbp->state == USB_STOP) {
    /* Clock activation.*/
#if STM32_USB_USE_USB1
    if (&USBD1 == usbp) {
      /* USB clock enabled.*/
      rccEnableUSB(FALSE);
 80054b4:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 80054b8:	61ca      	str	r2, [r1, #28]
      /* Powers up the transceiver while holding the USB in reset state.*/
      STM32_USB->CNTR = CNTR_FRES;
 80054ba:	642b      	str	r3, [r5, #64]	; 0x40
      /* Enabling the USB IRQ vectors, this also gives enough time to allow
         the transceiver power up (1uS).*/
#if STM32_USB1_HP_NUMBER != STM32_USB1_LP_NUMBER
      nvicEnableVector(STM32_USB1_HP_NUMBER, STM32_USB_USB1_HP_IRQ_PRIORITY);
 80054bc:	210d      	movs	r1, #13
 80054be:	f7fe fedf 	bl	8004280 <nvicEnableVector>
#endif
      nvicEnableVector(STM32_USB1_LP_NUMBER, STM32_USB_USB1_LP_IRQ_PRIORITY);
 80054c2:	2014      	movs	r0, #20
 80054c4:	210e      	movs	r1, #14
 80054c6:	f7fe fedb 	bl	8004280 <nvicEnableVector>
      /* Releases the USB reset.*/
      STM32_USB->CNTR = 0;
 80054ca:	2300      	movs	r3, #0
 80054cc:	642b      	str	r3, [r5, #64]	; 0x40
 80054ce:	e7e8      	b.n	80054a2 <usb_lld_start+0x12>
 80054d0:	2000153c 	.word	0x2000153c
 80054d4:	40021000 	.word	0x40021000
 80054d8:	40005c00 	.word	0x40005c00
 80054dc:	00000000 	.word	0x00000000

080054e0 <usb_lld_stop>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_stop(USBDriver *usbp) {
 80054e0:	b508      	push	{r3, lr}

  /* If in ready state then disables the USB clock.*/
  if (usbp->state == USB_STOP) {
 80054e2:	7803      	ldrb	r3, [r0, #0]
 80054e4:	2b01      	cmp	r3, #1
 80054e6:	d000      	beq.n	80054ea <usb_lld_stop+0xa>
 80054e8:	bd08      	pop	{r3, pc}
#if STM32_USB_USE_USB1
    if (&USBD1 == usbp) {
 80054ea:	4b09      	ldr	r3, [pc, #36]	; (8005510 <usb_lld_stop+0x30>)
 80054ec:	4298      	cmp	r0, r3
 80054ee:	d1fb      	bne.n	80054e8 <usb_lld_stop+0x8>
#if STM32_USB1_HP_NUMBER != STM32_USB1_LP_NUMBER
      nvicDisableVector(STM32_USB1_HP_NUMBER);
 80054f0:	2013      	movs	r0, #19
 80054f2:	f7fe fee5 	bl	80042c0 <nvicDisableVector>
#endif
      nvicDisableVector(STM32_USB1_LP_NUMBER);
 80054f6:	2014      	movs	r0, #20
 80054f8:	f7fe fee2 	bl	80042c0 <nvicDisableVector>
      STM32_USB->CNTR = CNTR_PDWN | CNTR_FRES;
 80054fc:	4b05      	ldr	r3, [pc, #20]	; (8005514 <usb_lld_stop+0x34>)
      rccDisableUSB(FALSE);
 80054fe:	4a06      	ldr	r2, [pc, #24]	; (8005518 <usb_lld_stop+0x38>)
    if (&USBD1 == usbp) {
#if STM32_USB1_HP_NUMBER != STM32_USB1_LP_NUMBER
      nvicDisableVector(STM32_USB1_HP_NUMBER);
#endif
      nvicDisableVector(STM32_USB1_LP_NUMBER);
      STM32_USB->CNTR = CNTR_PDWN | CNTR_FRES;
 8005500:	2103      	movs	r1, #3
 8005502:	6419      	str	r1, [r3, #64]	; 0x40
      rccDisableUSB(FALSE);
 8005504:	69d3      	ldr	r3, [r2, #28]
 8005506:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 800550a:	61d3      	str	r3, [r2, #28]
 800550c:	e7ec      	b.n	80054e8 <usb_lld_stop+0x8>
 800550e:	bf00      	nop
 8005510:	2000153c 	.word	0x2000153c
 8005514:	40005c00 	.word	0x40005c00
 8005518:	40021000 	.word	0x40021000
 800551c:	00000000 	.word	0x00000000

08005520 <usb_lld_set_address>:
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {

  STM32_USB->DADDR = (uint32_t)(usbp->address) | DADDR_EF;
 8005520:	f890 307e 	ldrb.w	r3, [r0, #126]	; 0x7e
 8005524:	4a02      	ldr	r2, [pc, #8]	; (8005530 <usb_lld_set_address+0x10>)
 8005526:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800552a:	64d3      	str	r3, [r2, #76]	; 0x4c
 800552c:	4770      	bx	lr
 800552e:	bf00      	nop
 8005530:	40005c00 	.word	0x40005c00
	...

08005540 <usb_lld_init_endpoint>:
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
  uint16_t epr;
  stm32_usb_descriptor_t *dp;
  const USBEndpointConfig *epcp = usbp->epc[ep];
 8005540:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8005544:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint16_t epr;
  stm32_usb_descriptor_t *dp;
  const USBEndpointConfig *epcp = usbp->epc[ep];
 8005546:	68de      	ldr	r6, [r3, #12]

  /* Setting the endpoint type. Note that isochronous endpoints cannot be
     bidirectional because it uses double buffering and both transmit and
     receive descriptor fields are used for either direction.*/
  switch (epcp->ep_mode & USB_EP_MODE_TYPE) {
 8005548:	6833      	ldr	r3, [r6, #0]
 800554a:	f013 0303 	ands.w	r3, r3, #3
 800554e:	d057      	beq.n	8005600 <usb_lld_init_endpoint+0xc0>
 8005550:	2b02      	cmp	r3, #2
 8005552:	d961      	bls.n	8005618 <usb_lld_init_endpoint+0xd8>
 8005554:	2b03      	cmp	r3, #3
 8005556:	d153      	bne.n	8005600 <usb_lld_init_endpoint+0xc0>
#endif
  case USB_EP_MODE_TYPE_BULK:
    epr = EPR_EP_TYPE_BULK;
    break;
  case USB_EP_MODE_TYPE_INTR:
    epr = EPR_EP_TYPE_INTERRUPT;
 8005558:	f44f 64c0 	mov.w	r4, #1536	; 0x600
    break;
  default:
    epr = EPR_EP_TYPE_CONTROL;
  }

  dp = USB_GET_DESCRIPTOR(ep);
 800555c:	4b2f      	ldr	r3, [pc, #188]	; (800561c <usb_lld_init_endpoint+0xdc>)

  /* IN endpoint handling.*/
  if (epcp->in_state != NULL) {
 800555e:	6972      	ldr	r2, [r6, #20]
    break;
  default:
    epr = EPR_EP_TYPE_CONTROL;
  }

  dp = USB_GET_DESCRIPTOR(ep);
 8005560:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8005562:	010f      	lsls	r7, r1, #4
 8005564:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8005568:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
 800556c:	19dd      	adds	r5, r3, r7

  /* IN endpoint handling.*/
  if (epcp->in_state != NULL) {
 800556e:	b182      	cbz	r2, 8005592 <usb_lld_init_endpoint+0x52>
    dp->TXCOUNT0 = 0;
    dp->TXADDR0  = usb_pm_alloc(usbp, epcp->in_maxsize);
 8005570:	8a32      	ldrh	r2, [r6, #16]

  dp = USB_GET_DESCRIPTOR(ep);

  /* IN endpoint handling.*/
  if (epcp->in_state != NULL) {
    dp->TXCOUNT0 = 0;
 8005572:	f04f 0e00 	mov.w	lr, #0
 8005576:	f8c5 e004 	str.w	lr, [r5, #4]
 * @param[in] size      size of the packet buffer to allocate
 */
static uint32_t usb_pm_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
 800557a:	f8d0 e084 	ldr.w	lr, [r0, #132]	; 0x84
  usbp->pmnext += (size + 1) & ~1;
 800557e:	3201      	adds	r2, #1
 8005580:	f022 0201 	bic.w	r2, r2, #1
 8005584:	4472      	add	r2, lr
 8005586:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
    }
    else {
      epr |= EPR_STAT_TX_NAK;
    }
#else
    epr |= EPR_STAT_TX_NAK;
 800558a:	f044 0420 	orr.w	r4, r4, #32
  dp = USB_GET_DESCRIPTOR(ep);

  /* IN endpoint handling.*/
  if (epcp->in_state != NULL) {
    dp->TXCOUNT0 = 0;
    dp->TXADDR0  = usb_pm_alloc(usbp, epcp->in_maxsize);
 800558e:	f843 e007 	str.w	lr, [r3, r7]
    epr |= EPR_STAT_TX_NAK;
#endif
  }

  /* OUT endpoint handling.*/
  if (epcp->out_state != NULL) {
 8005592:	69b3      	ldr	r3, [r6, #24]
 8005594:	b1cb      	cbz	r3, 80055ca <usb_lld_init_endpoint+0x8a>
    uint16_t nblocks;

    /* Endpoint size and address initialization.*/
    if (epcp->out_maxsize > 62)
 8005596:	8a72      	ldrh	r2, [r6, #18]
 8005598:	2a3e      	cmp	r2, #62	; 0x3e
      nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
 800559a:	f102 33ff 	add.w	r3, r2, #4294967295
  /* OUT endpoint handling.*/
  if (epcp->out_state != NULL) {
    uint16_t nblocks;

    /* Endpoint size and address initialization.*/
    if (epcp->out_maxsize > 62)
 800559e:	d932      	bls.n	8005606 <usb_lld_init_endpoint+0xc6>
      nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
 80055a0:	f043 031f 	orr.w	r3, r3, #31
 80055a4:	3301      	adds	r3, #1
 80055a6:	115b      	asrs	r3, r3, #5
 80055a8:	ea6f 63c3 	mvn.w	r3, r3, lsl #27
 80055ac:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80055b0:	b29b      	uxth	r3, r3
                0x8000;
    else
      nblocks = ((((epcp->out_maxsize - 1) | 1) + 1) / 2) << 10;
    dp->RXCOUNT0 = nblocks;
 80055b2:	60eb      	str	r3, [r5, #12]
 * @param[in] size      size of the packet buffer to allocate
 */
static uint32_t usb_pm_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
 80055b4:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
  usbp->pmnext += (size + 1) & ~1;
 80055b8:	3201      	adds	r2, #1
 80055ba:	f022 0201 	bic.w	r2, r2, #1
 80055be:	441a      	add	r2, r3
 80055c0:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
    }
    else {
      epr |= EPR_STAT_RX_NAK;
    }
#else
    epr |= EPR_STAT_RX_NAK;
 80055c4:	f444 5400 	orr.w	r4, r4, #8192	; 0x2000
      nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
                0x8000;
    else
      nblocks = ((((epcp->out_maxsize - 1) | 1) + 1) / 2) << 10;
    dp->RXCOUNT0 = nblocks;
    dp->RXADDR0  = usb_pm_alloc(usbp, epcp->out_maxsize);
 80055c8:	60ab      	str	r3, [r5, #8]
#endif
  }

  /* EPxR register setup.*/
  EPR_SET(ep, epr | ep);
  EPR_TOGGLE(ep, epr);
 80055ca:	f647 0270 	movw	r2, #30832	; 0x7870
    epr |= EPR_STAT_RX_NAK;
#endif
  }

  /* EPxR register setup.*/
  EPR_SET(ep, epr | ep);
 80055ce:	ea44 0301 	orr.w	r3, r4, r1
 80055d2:	f423 4378 	bic.w	r3, r3, #63488	; 0xf800
 80055d6:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80055da:	0089      	lsls	r1, r1, #2
 80055dc:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80055e0:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 80055e4:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00
 80055e8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80055ec:	600b      	str	r3, [r1, #0]
  EPR_TOGGLE(ep, epr);
 80055ee:	680b      	ldr	r3, [r1, #0]
 80055f0:	4022      	ands	r2, r4
 80055f2:	4053      	eors	r3, r2
 80055f4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80055f8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80055fc:	600b      	str	r3, [r1, #0]
 80055fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
    break;
  case USB_EP_MODE_TYPE_INTR:
    epr = EPR_EP_TYPE_INTERRUPT;
    break;
  default:
    epr = EPR_EP_TYPE_CONTROL;
 8005600:	f44f 7400 	mov.w	r4, #512	; 0x200
 8005604:	e7aa      	b.n	800555c <usb_lld_init_endpoint+0x1c>
    /* Endpoint size and address initialization.*/
    if (epcp->out_maxsize > 62)
      nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
                0x8000;
    else
      nblocks = ((((epcp->out_maxsize - 1) | 1) + 1) / 2) << 10;
 8005606:	f043 0301 	orr.w	r3, r3, #1
 800560a:	3301      	adds	r3, #1
 800560c:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 8005610:	025b      	lsls	r3, r3, #9
 8005612:	f403 437c 	and.w	r3, r3, #64512	; 0xfc00
 8005616:	e7cc      	b.n	80055b2 <usb_lld_init_endpoint+0x72>
    break;
#else
    osalDbgAssert(false, "isochronous support disabled");
#endif
  case USB_EP_MODE_TYPE_BULK:
    epr = EPR_EP_TYPE_BULK;
 8005618:	2400      	movs	r4, #0
 800561a:	e79f      	b.n	800555c <usb_lld_init_endpoint+0x1c>
 800561c:	40005c00 	.word	0x40005c00

08005620 <usb_lld_reset>:
  STM32_USB->DADDR  = DADDR_EF;
  cntr              = /*CNTR_ESOFM | */ CNTR_RESETM  | CNTR_SUSPM |
                      CNTR_WKUPM | /*CNTR_ERRM | CNTR_PMAOVRM |*/ CNTR_CTRM;
  /* The SOF interrupt is only enabled if a callback is defined for
     this service because it is an high rate source.*/
  if (usbp->config->sof_cb != NULL)
 8005620:	6841      	ldr	r1, [r0, #4]
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 8005622:	b5f0      	push	{r4, r5, r6, r7, lr}
  STM32_USB->DADDR  = DADDR_EF;
  cntr              = /*CNTR_ESOFM | */ CNTR_RESETM  | CNTR_SUSPM |
                      CNTR_WKUPM | /*CNTR_ERRM | CNTR_PMAOVRM |*/ CNTR_CTRM;
  /* The SOF interrupt is only enabled if a callback is defined for
     this service because it is an high rate source.*/
  if (usbp->config->sof_cb != NULL)
 8005624:	68c9      	ldr	r1, [r1, #12]
 */
void usb_lld_reset(USBDriver *usbp) {
  uint32_t cntr;

  /* Post reset initialization.*/
  STM32_USB->BTABLE = BTABLE_ADDR;
 8005626:	4b0d      	ldr	r3, [pc, #52]	; (800565c <usb_lld_reset+0x3c>)
  STM32_USB->DADDR  = DADDR_EF;
  cntr              = /*CNTR_ESOFM | */ CNTR_RESETM  | CNTR_SUSPM |
                      CNTR_WKUPM | /*CNTR_ERRM | CNTR_PMAOVRM |*/ CNTR_CTRM;
  /* The SOF interrupt is only enabled if a callback is defined for
     this service because it is an high rate source.*/
  if (usbp->config->sof_cb != NULL)
 8005628:	2900      	cmp	r1, #0

  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* EP0 initialization.*/
  usbp->epc[0] = &ep0config;
 800562a:	4d0d      	ldr	r5, [pc, #52]	; (8005660 <usb_lld_reset+0x40>)
 */
void usb_lld_reset(USBDriver *usbp) {
  uint32_t cntr;

  /* Post reset initialization.*/
  STM32_USB->BTABLE = BTABLE_ADDR;
 800562c:	f04f 0400 	mov.w	r4, #0
  cntr              = /*CNTR_ESOFM | */ CNTR_RESETM  | CNTR_SUSPM |
                      CNTR_WKUPM | /*CNTR_ERRM | CNTR_PMAOVRM |*/ CNTR_CTRM;
  /* The SOF interrupt is only enabled if a callback is defined for
     this service because it is an high rate source.*/
  if (usbp->config->sof_cb != NULL)
    cntr |= CNTR_SOFM;
 8005630:	bf0c      	ite	eq
 8005632:	f44f 471c 	moveq.w	r7, #39936	; 0x9c00
 8005636:	f44f 471e 	movne.w	r7, #40448	; 0x9e00
  uint32_t cntr;

  /* Post reset initialization.*/
  STM32_USB->BTABLE = BTABLE_ADDR;
  STM32_USB->ISTR   = 0;
  STM32_USB->DADDR  = DADDR_EF;
 800563a:	f04f 0e80 	mov.w	lr, #128	; 0x80
 */
static void usb_pm_reset(USBDriver *usbp) {

  /* The first 64 bytes are reserved for the descriptors table. The effective
     available RAM for endpoint buffers is just 448 bytes.*/
  usbp->pmnext = 64;
 800563e:	2640      	movs	r6, #64	; 0x40
 */
void usb_lld_reset(USBDriver *usbp) {
  uint32_t cntr;

  /* Post reset initialization.*/
  STM32_USB->BTABLE = BTABLE_ADDR;
 8005640:	651c      	str	r4, [r3, #80]	; 0x50
  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* EP0 initialization.*/
  usbp->epc[0] = &ep0config;
  usb_lld_init_endpoint(usbp, 0);
 8005642:	4621      	mov	r1, r4
void usb_lld_reset(USBDriver *usbp) {
  uint32_t cntr;

  /* Post reset initialization.*/
  STM32_USB->BTABLE = BTABLE_ADDR;
  STM32_USB->ISTR   = 0;
 8005644:	645c      	str	r4, [r3, #68]	; 0x44
  STM32_USB->DADDR  = DADDR_EF;
 8005646:	f8c3 e04c 	str.w	lr, [r3, #76]	; 0x4c
                      CNTR_WKUPM | /*CNTR_ERRM | CNTR_PMAOVRM |*/ CNTR_CTRM;
  /* The SOF interrupt is only enabled if a callback is defined for
     this service because it is an high rate source.*/
  if (usbp->config->sof_cb != NULL)
    cntr |= CNTR_SOFM;
  STM32_USB->CNTR = cntr;
 800564a:	641f      	str	r7, [r3, #64]	; 0x40
 */
static void usb_pm_reset(USBDriver *usbp) {

  /* The first 64 bytes are reserved for the descriptors table. The effective
     available RAM for endpoint buffers is just 448 bytes.*/
  usbp->pmnext = 64;
 800564c:	f8c0 6084 	str.w	r6, [r0, #132]	; 0x84

  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* EP0 initialization.*/
  usbp->epc[0] = &ep0config;
 8005650:	60c5      	str	r5, [r0, #12]
  usb_lld_init_endpoint(usbp, 0);
}
 8005652:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* EP0 initialization.*/
  usbp->epc[0] = &ep0config;
  usb_lld_init_endpoint(usbp, 0);
 8005656:	f7ff bf73 	b.w	8005540 <usb_lld_init_endpoint>
 800565a:	bf00      	nop
 800565c:	40005c00 	.word	0x40005c00
 8005660:	0800d700 	.word	0x0800d700
	...

08005670 <usb_lld_disable_endpoints>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_disable_endpoints(USBDriver *usbp) {
 8005670:	b410      	push	{r4}
  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* Disabling all endpoints.*/
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
    EPR_TOGGLE(i, 0);
 8005672:	f248 0480 	movw	r4, #32896	; 0x8080
 */
static void usb_pm_reset(USBDriver *usbp) {

  /* The first 64 bytes are reserved for the descriptors table. The effective
     available RAM for endpoint buffers is just 448 bytes.*/
  usbp->pmnext = 64;
 8005676:	2340      	movs	r3, #64	; 0x40
 8005678:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84

  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* Disabling all endpoints.*/
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 800567c:	2101      	movs	r1, #1
 800567e:	008b      	lsls	r3, r1, #2
 8005680:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8005684:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
    EPR_TOGGLE(i, 0);
 8005688:	681a      	ldr	r2, [r3, #0]

  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* Disabling all endpoints.*/
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 800568a:	3101      	adds	r1, #1
    EPR_TOGGLE(i, 0);
 800568c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8005690:	f042 0280 	orr.w	r2, r2, #128	; 0x80

  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* Disabling all endpoints.*/
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 8005694:	2908      	cmp	r1, #8
    EPR_TOGGLE(i, 0);
 8005696:	601a      	str	r2, [r3, #0]
    EPR_SET(i, 0);
 8005698:	601c      	str	r4, [r3, #0]

  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* Disabling all endpoints.*/
  for (i = 1; i <= USB_ENDOPOINTS_NUMBER; i++) {
 800569a:	d1f0      	bne.n	800567e <usb_lld_disable_endpoints+0xe>
    EPR_TOGGLE(i, 0);
    EPR_SET(i, 0);
  }
}
 800569c:	f85d 4b04 	ldr.w	r4, [sp], #4
 80056a0:	4770      	bx	lr
 80056a2:	bf00      	nop
	...

080056b0 <usb_lld_get_status_out>:
 * @notapi
 */
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  switch (STM32_USB->EPR[ep] & EPR_STAT_RX_MASK) {
 80056b0:	4b05      	ldr	r3, [pc, #20]	; (80056c8 <usb_lld_get_status_out+0x18>)
 80056b2:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
 80056b6:	f410 5040 	ands.w	r0, r0, #12288	; 0x3000
 80056ba:	d004      	beq.n	80056c6 <usb_lld_get_status_out+0x16>
 80056bc:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
  case EPR_STAT_RX_DIS:
    return EP_STATUS_DISABLED;
  case EPR_STAT_RX_STALL:
    return EP_STATUS_STALLED;
  default:
    return EP_STATUS_ACTIVE;
 80056c0:	bf0c      	ite	eq
 80056c2:	2001      	moveq	r0, #1
 80056c4:	2002      	movne	r0, #2
  }
}
 80056c6:	4770      	bx	lr
 80056c8:	40005c00 	.word	0x40005c00
 80056cc:	00000000 	.word	0x00000000

080056d0 <usb_lld_get_status_in>:
 * @notapi
 */
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  switch (STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) {
 80056d0:	4b05      	ldr	r3, [pc, #20]	; (80056e8 <usb_lld_get_status_in+0x18>)
 80056d2:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
 80056d6:	f010 0030 	ands.w	r0, r0, #48	; 0x30
 80056da:	d003      	beq.n	80056e4 <usb_lld_get_status_in+0x14>
 80056dc:	2810      	cmp	r0, #16
  case EPR_STAT_TX_DIS:
    return EP_STATUS_DISABLED;
  case EPR_STAT_TX_STALL:
    return EP_STATUS_STALLED;
  default:
    return EP_STATUS_ACTIVE;
 80056de:	bf0c      	ite	eq
 80056e0:	2001      	moveq	r0, #1
 80056e2:	2002      	movne	r0, #2
  }
}
 80056e4:	4770      	bx	lr
 80056e6:	bf00      	nop
 80056e8:	40005c00 	.word	0x40005c00
 80056ec:	00000000 	.word	0x00000000

080056f0 <usb_lld_read_setup>:
  stm32_usb_pma_t *pmap;
  stm32_usb_descriptor_t *udp;
  uint32_t n;

  (void)usbp;
  udp = USB_GET_DESCRIPTOR(ep);
 80056f0:	4b0b      	ldr	r3, [pc, #44]	; (8005720 <usb_lld_read_setup+0x30>)
 80056f2:	f102 0008 	add.w	r0, r2, #8
 80056f6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80056f8:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80056fc:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
 8005700:	eb03 1101 	add.w	r1, r3, r1, lsl #4
  pmap = USB_ADDR2PTR(udp->RXADDR0);
 8005704:	688b      	ldr	r3, [r1, #8]
 8005706:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 800570a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800570e:	005b      	lsls	r3, r3, #1
  for (n = 0; n < 4; n++) {
    *(uint16_t *)buf = (uint16_t)*pmap++;
 8005710:	f853 1b04 	ldr.w	r1, [r3], #4
 8005714:	f822 1b02 	strh.w	r1, [r2], #2
  uint32_t n;

  (void)usbp;
  udp = USB_GET_DESCRIPTOR(ep);
  pmap = USB_ADDR2PTR(udp->RXADDR0);
  for (n = 0; n < 4; n++) {
 8005718:	4282      	cmp	r2, r0
 800571a:	d1f9      	bne.n	8005710 <usb_lld_read_setup+0x20>
    *(uint16_t *)buf = (uint16_t)*pmap++;
    buf += 2;
  }
}
 800571c:	4770      	bx	lr
 800571e:	bf00      	nop
 8005720:	40005c00 	.word	0x40005c00
	...

08005730 <usb_lld_start_out>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8005730:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 8005734:	68c0      	ldr	r0, [r0, #12]
 8005736:	6982      	ldr	r2, [r0, #24]

  /* Transfer initialization.*/
  if (osp->rxsize == 0)         /* Special case for zero sized packets.*/
 8005738:	6813      	ldr	r3, [r2, #0]
 800573a:	b1bb      	cbz	r3, 800576c <usb_lld_start_out+0x3c>
    osp->rxpkts = 1;
  else
    osp->rxpkts = (uint16_t)((osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
 800573c:	8a40      	ldrh	r0, [r0, #18]
 800573e:	3b01      	subs	r3, #1
 8005740:	4403      	add	r3, r0
 8005742:	fbb3 f3f0 	udiv	r3, r3, r0
 8005746:	8193      	strh	r3, [r2, #12]
 8005748:	0089      	lsls	r1, r1, #2
 800574a:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 800574e:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00
                             usbp->epc[ep]->out_maxsize);

  EPR_SET_STAT_RX(ep, EPR_STAT_RX_VALID);
 8005752:	680b      	ldr	r3, [r1, #0]
 8005754:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8005758:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800575c:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8005760:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8005764:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8005768:	600b      	str	r3, [r1, #0]
 800576a:	4770      	bx	lr
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  /* Transfer initialization.*/
  if (osp->rxsize == 0)         /* Special case for zero sized packets.*/
    osp->rxpkts = 1;
 800576c:	2301      	movs	r3, #1
 800576e:	8193      	strh	r3, [r2, #12]
 8005770:	e7ea      	b.n	8005748 <usb_lld_start_out+0x18>
 8005772:	bf00      	nop
	...

08005780 <usb_lld_start_in>:
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  size_t n;
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8005780:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8005784:	b538      	push	{r3, r4, r5, lr}
  size_t n;
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8005786:	68c3      	ldr	r3, [r0, #12]
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8005788:	460c      	mov	r4, r1
  size_t n;
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800578a:	695d      	ldr	r5, [r3, #20]

  /* Transfer initialization.*/
  n = isp->txsize;
  if (n > (size_t)usbp->epc[ep]->in_maxsize)
 800578c:	8a1a      	ldrh	r2, [r3, #16]
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  size_t n;
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  /* Transfer initialization.*/
  n = isp->txsize;
 800578e:	682b      	ldr	r3, [r5, #0]
  if (n > (size_t)usbp->epc[ep]->in_maxsize)
    n = (size_t)usbp->epc[ep]->in_maxsize;

  isp->txlast = n;
  usb_packet_write_from_buffer(ep, isp->txbuf, n);
 8005790:	4608      	mov	r0, r1
 8005792:	429a      	cmp	r2, r3
 8005794:	bf28      	it	cs
 8005796:	461a      	movcs	r2, r3
 8005798:	68a9      	ldr	r1, [r5, #8]
  /* Transfer initialization.*/
  n = isp->txsize;
  if (n > (size_t)usbp->epc[ep]->in_maxsize)
    n = (size_t)usbp->epc[ep]->in_maxsize;

  isp->txlast = n;
 800579a:	60ea      	str	r2, [r5, #12]
  usb_packet_write_from_buffer(ep, isp->txbuf, n);
 800579c:	f7ff fd10 	bl	80051c0 <usb_packet_write_from_buffer>
 80057a0:	00a1      	lsls	r1, r4, #2
 80057a2:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 80057a6:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 80057aa:	680b      	ldr	r3, [r1, #0]
 80057ac:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 80057b0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80057b4:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 80057b8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80057bc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80057c0:	600b      	str	r3, [r1, #0]
 80057c2:	bd38      	pop	{r3, r4, r5, pc}
	...

080057d0 <usb_lld_stall_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
 80057d0:	0089      	lsls	r1, r1, #2
 80057d2:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 80057d6:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00

  (void)usbp;

  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 80057da:	680b      	ldr	r3, [r1, #0]
 80057dc:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 80057e0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80057e4:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 80057e8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80057ec:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80057f0:	600b      	str	r3, [r1, #0]
 80057f2:	4770      	bx	lr
	...

08005800 <usb_lld_stall_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {
 8005800:	0089      	lsls	r1, r1, #2
 8005802:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8005806:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00

  (void)usbp;

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 800580a:	680b      	ldr	r3, [r1, #0]
 800580c:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 8005810:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8005814:	f083 0310 	eor.w	r3, r3, #16
 8005818:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800581c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8005820:	600b      	str	r3, [r1, #0]
 8005822:	4770      	bx	lr
	...

08005830 <usb_lld_clear_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
 8005830:	0089      	lsls	r1, r1, #2
 8005832:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8005836:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00

  (void)usbp;

  /* Makes sure to not put to NAK an endpoint that is already
     transferring.*/
  if ((STM32_USB->EPR[ep] & EPR_STAT_RX_MASK) != EPR_STAT_RX_VALID)
 800583a:	680b      	ldr	r3, [r1, #0]
 800583c:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 8005840:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 8005844:	d009      	beq.n	800585a <usb_lld_clear_out+0x2a>
    EPR_SET_STAT_TX(ep, EPR_STAT_RX_NAK);
 8005846:	680b      	ldr	r3, [r1, #0]
 8005848:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 800584c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8005850:	f443 4320 	orr.w	r3, r3, #40960	; 0xa000
 8005854:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8005858:	600b      	str	r3, [r1, #0]
 800585a:	4770      	bx	lr
 800585c:	0000      	movs	r0, r0
	...

08005860 <usb_lld_clear_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {
 8005860:	0089      	lsls	r1, r1, #2
 8005862:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8005866:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00

  (void)usbp;

  /* Makes sure to not put to NAK an endpoint that is already
     transferring.*/
  if ((STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) != EPR_STAT_TX_VALID)
 800586a:	680b      	ldr	r3, [r1, #0]
 800586c:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8005870:	2b30      	cmp	r3, #48	; 0x30
 8005872:	d00b      	beq.n	800588c <usb_lld_clear_in+0x2c>
    EPR_SET_STAT_TX(ep, EPR_STAT_TX_NAK);
 8005874:	680b      	ldr	r3, [r1, #0]
 8005876:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 800587a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800587e:	f083 0320 	eor.w	r3, r3, #32
 8005882:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8005886:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800588a:	600b      	str	r3, [r1, #0]
 800588c:	4770      	bx	lr
 800588e:	bf00      	nop

08005890 <__early_init>:
 * Early initialization code.
 * This initialization must be performed just after stack setup and before
 * any other initialization.
 */
void __early_init(void) {
  stm32_clock_init();
 8005890:	f7fe bd8e 	b.w	80043b0 <stm32_clock_init>
	...

080058a0 <boardInit>:
 */
void boardInit(void) {
  /*
   *   JTAG-DP Disabled and SW-DP Enabled.
   */
   AFIO->MAPR |= AFIO_MAPR_TIM3_REMAP_NOREMAP | AFIO_MAPR_SWJ_CFG_JTAGDISABLE;
 80058a0:	4a02      	ldr	r2, [pc, #8]	; (80058ac <boardInit+0xc>)
 80058a2:	6853      	ldr	r3, [r2, #4]
 80058a4:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 80058a8:	6053      	str	r3, [r2, #4]
 80058aa:	4770      	bx	lr
 80058ac:	40010000 	.word	0x40010000

080058b0 <pwmOutputUpdateRoll>:
/**
 *
 */
static void pwmOutputUpdateRoll(void) {
  /* Disable update event. */
  PWMD2.tim->CR1 |= STM32_TIM_CR1_UDIS;
 80058b0:	4b12      	ldr	r3, [pc, #72]	; (80058fc <pwmOutputUpdateRoll+0x4c>)
  PWMD3.tim->CR1 |= STM32_TIM_CR1_UDIS;
 80058b2:	4a13      	ldr	r2, [pc, #76]	; (8005900 <pwmOutputUpdateRoll+0x50>)
/**
 *
 */
static void pwmOutputUpdateRoll(void) {
  /* Disable update event. */
  PWMD2.tim->CR1 |= STM32_TIM_CR1_UDIS;
 80058b4:	699b      	ldr	r3, [r3, #24]
  PWMD3.tim->CR1 |= STM32_TIM_CR1_UDIS;
 80058b6:	6992      	ldr	r2, [r2, #24]
/**
 *
 */
static void pwmOutputUpdateRoll(void) {
  /* Disable update event. */
  PWMD2.tim->CR1 |= STM32_TIM_CR1_UDIS;
 80058b8:	6819      	ldr	r1, [r3, #0]
}

/**
 *
 */
static void pwmOutputUpdateRoll(void) {
 80058ba:	b410      	push	{r4}
  /* Disable update event. */
  PWMD2.tim->CR1 |= STM32_TIM_CR1_UDIS;
 80058bc:	f041 0102 	orr.w	r1, r1, #2
 80058c0:	6019      	str	r1, [r3, #0]
  PWMD3.tim->CR1 |= STM32_TIM_CR1_UDIS;
 80058c2:	6811      	ldr	r1, [r2, #0]

  /* Check if motor direction is reversed. */
  if (g_pwmOutput[PWM_OUT_ROLL].flags & PWM_OUT_REV_FLAG) {
 80058c4:	480f      	ldr	r0, [pc, #60]	; (8005904 <pwmOutputUpdateRoll+0x54>)
 *
 */
static void pwmOutputUpdateRoll(void) {
  /* Disable update event. */
  PWMD2.tim->CR1 |= STM32_TIM_CR1_UDIS;
  PWMD3.tim->CR1 |= STM32_TIM_CR1_UDIS;
 80058c6:	f041 0102 	orr.w	r1, r1, #2
 80058ca:	6011      	str	r1, [r2, #0]

  /* Check if motor direction is reversed. */
  if (g_pwmOutput[PWM_OUT_ROLL].flags & PWM_OUT_REV_FLAG) {
 80058cc:	7981      	ldrb	r1, [r0, #6]
 80058ce:	f011 0f01 	tst.w	r1, #1
	PWMD3.tim->CCR[0] = pwm3PhaseDrv[1];
 80058d2:	490d      	ldr	r1, [pc, #52]	; (8005908 <pwmOutputUpdateRoll+0x58>)
	PWMD2.tim->CCR[3] = pwm3PhaseDrv[0];
  } else {
	PWMD3.tim->CCR[0] = pwm3PhaseDrv[0];
 80058d4:	bf06      	itte	eq
 80058d6:	680c      	ldreq	r4, [r1, #0]
	PWMD2.tim->CCR[3] = pwm3PhaseDrv[1];
 80058d8:	6848      	ldreq	r0, [r1, #4]
  PWMD3.tim->CR1 |= STM32_TIM_CR1_UDIS;

  /* Check if motor direction is reversed. */
  if (g_pwmOutput[PWM_OUT_ROLL].flags & PWM_OUT_REV_FLAG) {
	PWMD3.tim->CCR[0] = pwm3PhaseDrv[1];
	PWMD2.tim->CCR[3] = pwm3PhaseDrv[0];
 80058da:	e891 0011 	ldmiane.w	r1, {r0, r4}
  } else {
	PWMD3.tim->CCR[0] = pwm3PhaseDrv[0];
 80058de:	6354      	str	r4, [r2, #52]	; 0x34
	PWMD2.tim->CCR[3] = pwm3PhaseDrv[1];
 80058e0:	6418      	str	r0, [r3, #64]	; 0x40
  }
  PWMD2.tim->CCR[2] = pwm3PhaseDrv[2];
 80058e2:	6889      	ldr	r1, [r1, #8]

  /* Enable update event. */
  PWMD2.tim->CR1 &= ~STM32_TIM_CR1_UDIS;
  PWMD3.tim->CR1 &= ~STM32_TIM_CR1_UDIS;
}
 80058e4:	f85d 4b04 	ldr.w	r4, [sp], #4
	PWMD2.tim->CCR[3] = pwm3PhaseDrv[0];
  } else {
	PWMD3.tim->CCR[0] = pwm3PhaseDrv[0];
	PWMD2.tim->CCR[3] = pwm3PhaseDrv[1];
  }
  PWMD2.tim->CCR[2] = pwm3PhaseDrv[2];
 80058e8:	63d9      	str	r1, [r3, #60]	; 0x3c

  /* Enable update event. */
  PWMD2.tim->CR1 &= ~STM32_TIM_CR1_UDIS;
 80058ea:	6819      	ldr	r1, [r3, #0]
 80058ec:	f021 0102 	bic.w	r1, r1, #2
 80058f0:	6019      	str	r1, [r3, #0]
  PWMD3.tim->CR1 &= ~STM32_TIM_CR1_UDIS;
 80058f2:	6813      	ldr	r3, [r2, #0]
 80058f4:	f023 0302 	bic.w	r3, r3, #2
 80058f8:	6013      	str	r3, [r2, #0]
}
 80058fa:	4770      	bx	lr
 80058fc:	20001390 	.word	0x20001390
 8005900:	200013ac 	.word	0x200013ac
 8005904:	20000808 	.word	0x20000808
 8005908:	200015dc 	.word	0x200015dc
 800590c:	00000000 	.word	0x00000000

08005910 <pwmOutputUpdatePitch>:
/**
 *
 */
static void pwmOutputUpdatePitch(void) {
  /* Disable update event. */
  PWMD3.tim->CR1 |= STM32_TIM_CR1_UDIS;
 8005910:	4b0c      	ldr	r3, [pc, #48]	; (8005944 <pwmOutputUpdatePitch+0x34>)

  /* Check if motor direction is reversed. */
  if (g_pwmOutput[PWM_OUT_PITCH].flags & PWM_OUT_REV_FLAG) {
 8005912:	490d      	ldr	r1, [pc, #52]	; (8005948 <pwmOutputUpdatePitch+0x38>)
/**
 *
 */
static void pwmOutputUpdatePitch(void) {
  /* Disable update event. */
  PWMD3.tim->CR1 |= STM32_TIM_CR1_UDIS;
 8005914:	699b      	ldr	r3, [r3, #24]
 8005916:	681a      	ldr	r2, [r3, #0]
 8005918:	f042 0202 	orr.w	r2, r2, #2
 800591c:	601a      	str	r2, [r3, #0]

  /* Check if motor direction is reversed. */
  if (g_pwmOutput[PWM_OUT_PITCH].flags & PWM_OUT_REV_FLAG) {
 800591e:	788a      	ldrb	r2, [r1, #2]
 8005920:	f012 0f01 	tst.w	r2, #1
    PWMD3.tim->CCR[3] = pwm3PhaseDrv[1];
 8005924:	4a09      	ldr	r2, [pc, #36]	; (800594c <pwmOutputUpdatePitch+0x3c>)
 8005926:	bf1a      	itte	ne
 8005928:	6850      	ldrne	r0, [r2, #4]
    PWMD3.tim->CCR[2] = pwm3PhaseDrv[0];
 800592a:	6811      	ldrne	r1, [r2, #0]
  } else {
    PWMD3.tim->CCR[3] = pwm3PhaseDrv[0];
    PWMD3.tim->CCR[2] = pwm3PhaseDrv[1];
 800592c:	e892 0003 	ldmiaeq.w	r2, {r0, r1}
  /* Check if motor direction is reversed. */
  if (g_pwmOutput[PWM_OUT_PITCH].flags & PWM_OUT_REV_FLAG) {
    PWMD3.tim->CCR[3] = pwm3PhaseDrv[1];
    PWMD3.tim->CCR[2] = pwm3PhaseDrv[0];
  } else {
    PWMD3.tim->CCR[3] = pwm3PhaseDrv[0];
 8005930:	6418      	str	r0, [r3, #64]	; 0x40
    PWMD3.tim->CCR[2] = pwm3PhaseDrv[1];
 8005932:	63d9      	str	r1, [r3, #60]	; 0x3c
  }
  PWMD3.tim->CCR[1] = pwm3PhaseDrv[2];
 8005934:	6892      	ldr	r2, [r2, #8]
 8005936:	639a      	str	r2, [r3, #56]	; 0x38

  /* Enable update event. */
  PWMD3.tim->CR1 &= ~STM32_TIM_CR1_UDIS;
 8005938:	681a      	ldr	r2, [r3, #0]
 800593a:	f022 0202 	bic.w	r2, r2, #2
 800593e:	601a      	str	r2, [r3, #0]
 8005940:	4770      	bx	lr
 8005942:	bf00      	nop
 8005944:	200013ac 	.word	0x200013ac
 8005948:	20000808 	.word	0x20000808
 800594c:	200015dc 	.word	0x200015dc

08005950 <pwmOutputUpdateYaw>:
}

/**
 *
 */
static void pwmOutputUpdateYaw(void) {
 8005950:	b470      	push	{r4, r5, r6}
 8005952:	2320      	movs	r3, #32
 8005954:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  /* Disable update event. */
  PWMD2.tim->CR1 |= STM32_TIM_CR1_UDIS;
 8005958:	4a18      	ldr	r2, [pc, #96]	; (80059bc <pwmOutputUpdateYaw+0x6c>)
  PWMD4.tim->CR1 |= STM32_TIM_CR1_UDIS;
 800595a:	4b19      	ldr	r3, [pc, #100]	; (80059c0 <pwmOutputUpdateYaw+0x70>)
 *
 */
static void pwmOutputUpdateYaw(void) {
  chSysLock();
  /* Disable update event. */
  PWMD2.tim->CR1 |= STM32_TIM_CR1_UDIS;
 800595c:	6994      	ldr	r4, [r2, #24]
  PWMD4.tim->CR1 |= STM32_TIM_CR1_UDIS;
 800595e:	6998      	ldr	r0, [r3, #24]
 *
 */
static void pwmOutputUpdateYaw(void) {
  chSysLock();
  /* Disable update event. */
  PWMD2.tim->CR1 |= STM32_TIM_CR1_UDIS;
 8005960:	6821      	ldr	r1, [r4, #0]
 8005962:	2500      	movs	r5, #0
 8005964:	f041 0102 	orr.w	r1, r1, #2
 8005968:	6021      	str	r1, [r4, #0]
  PWMD4.tim->CR1 |= STM32_TIM_CR1_UDIS;
 800596a:	6801      	ldr	r1, [r0, #0]
 800596c:	f041 0102 	orr.w	r1, r1, #2
 8005970:	6001      	str	r1, [r0, #0]
 8005972:	f385 8811 	msr	BASEPRI, r5
   * Apply dead-time to Yaw PWM:
   */
  /* Check if motor direction is reversed. */

  /* Check if motor direction is reversed. */
  if (g_pwmOutput[PWM_OUT_YAW].flags & PWM_OUT_REV_FLAG) {
 8005976:	4913      	ldr	r1, [pc, #76]	; (80059c4 <pwmOutputUpdateYaw+0x74>)
	  PWMD4.tim->CCR[3] = pwm3PhaseDrv[1];
 8005978:	6998      	ldr	r0, [r3, #24]
   * Apply dead-time to Yaw PWM:
   */
  /* Check if motor direction is reversed. */

  /* Check if motor direction is reversed. */
  if (g_pwmOutput[PWM_OUT_YAW].flags & PWM_OUT_REV_FLAG) {
 800597a:	7a89      	ldrb	r1, [r1, #10]
	  PWMD4.tim->CCR[3] = pwm3PhaseDrv[1];
	  PWMD2.tim->CCR[1] = pwm3PhaseDrv[0];
  } else {
	  PWMD4.tim->CCR[3] = pwm3PhaseDrv[0];
	  PWMD2.tim->CCR[1] = pwm3PhaseDrv[1];
 800597c:	6994      	ldr	r4, [r2, #24]
   * Apply dead-time to Yaw PWM:
   */
  /* Check if motor direction is reversed. */

  /* Check if motor direction is reversed. */
  if (g_pwmOutput[PWM_OUT_YAW].flags & PWM_OUT_REV_FLAG) {
 800597e:	f011 0f01 	tst.w	r1, #1
	  PWMD4.tim->CCR[3] = pwm3PhaseDrv[1];
 8005982:	4911      	ldr	r1, [pc, #68]	; (80059c8 <pwmOutputUpdateYaw+0x78>)
	  PWMD2.tim->CCR[1] = pwm3PhaseDrv[0];
  } else {
	  PWMD4.tim->CCR[3] = pwm3PhaseDrv[0];
 8005984:	bf06      	itte	eq
 8005986:	680e      	ldreq	r6, [r1, #0]
	  PWMD2.tim->CCR[1] = pwm3PhaseDrv[1];
 8005988:	684d      	ldreq	r5, [r1, #4]
  /* Check if motor direction is reversed. */

  /* Check if motor direction is reversed. */
  if (g_pwmOutput[PWM_OUT_YAW].flags & PWM_OUT_REV_FLAG) {
	  PWMD4.tim->CCR[3] = pwm3PhaseDrv[1];
	  PWMD2.tim->CCR[1] = pwm3PhaseDrv[0];
 800598a:	e891 0060 	ldmiane.w	r1, {r5, r6}
  } else {
	  PWMD4.tim->CCR[3] = pwm3PhaseDrv[0];
 800598e:	6406      	str	r6, [r0, #64]	; 0x40
	  PWMD2.tim->CCR[1] = pwm3PhaseDrv[1];
 8005990:	63a5      	str	r5, [r4, #56]	; 0x38
  }
  PWMD4.tim->CCR[2] = pwm3PhaseDrv[2];
 8005992:	688c      	ldr	r4, [r1, #8]
 8005994:	2120      	movs	r1, #32
 8005996:	63c4      	str	r4, [r0, #60]	; 0x3c
 8005998:	f381 8811 	msr	BASEPRI, r1

  chSysLock();
  /* Enable update event. */
  PWMD2.tim->CR1 &= ~STM32_TIM_CR1_UDIS;
 800599c:	6991      	ldr	r1, [r2, #24]
  PWMD4.tim->CR1 &= ~STM32_TIM_CR1_UDIS;
 800599e:	699a      	ldr	r2, [r3, #24]
  }
  PWMD4.tim->CCR[2] = pwm3PhaseDrv[2];

  chSysLock();
  /* Enable update event. */
  PWMD2.tim->CR1 &= ~STM32_TIM_CR1_UDIS;
 80059a0:	680b      	ldr	r3, [r1, #0]
 80059a2:	2000      	movs	r0, #0
 80059a4:	f023 0302 	bic.w	r3, r3, #2
 80059a8:	600b      	str	r3, [r1, #0]
  PWMD4.tim->CR1 &= ~STM32_TIM_CR1_UDIS;
 80059aa:	6813      	ldr	r3, [r2, #0]
 80059ac:	f023 0302 	bic.w	r3, r3, #2
 80059b0:	6013      	str	r3, [r2, #0]
 80059b2:	f380 8811 	msr	BASEPRI, r0
  chSysUnlock();
}
 80059b6:	bc70      	pop	{r4, r5, r6}
 80059b8:	4770      	bx	lr
 80059ba:	bf00      	nop
 80059bc:	20001390 	.word	0x20001390
 80059c0:	200013c8 	.word	0x200013c8
 80059c4:	20000808 	.word	0x20000808
 80059c8:	200015dc 	.word	0x200015dc
 80059cc:	00000000 	.word	0x00000000

080059d0 <pwmOutputCmdTo3PhasePWM>:
 * @param  cmd - new position of the motor.
 * @param  power - power of the motor in percent.
 * @param  thi - third harmonic injection enable flag.
 * @return none.
 */
static void pwmOutputCmdTo3PhasePWM(float cmd, uint8_t power, uint8_t thi) {
 80059d0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80059d4:	4616      	mov	r6, r2
  float halfPower = power * PWM_OUT_POWER_1PCT2;
 80059d6:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 * @param  cmd - new position of the motor.
 * @param  power - power of the motor in percent.
 * @param  thi - third harmonic injection enable flag.
 * @return none.
 */
static void pwmOutputCmdTo3PhasePWM(float cmd, uint8_t power, uint8_t thi) {
 80059da:	4604      	mov	r4, r0
  float halfPower = power * PWM_OUT_POWER_1PCT2;
 80059dc:	0048      	lsls	r0, r1, #1
 80059de:	f7fb f9c9 	bl	8000d74 <__aeabi_i2f>
  if (thi) {
 80059e2:	2e00      	cmp	r6, #0
 80059e4:	d13a      	bne.n	8005a5c <pwmOutputCmdTo3PhasePWM+0x8c>
 80059e6:	4605      	mov	r5, r0
    float thirdHarmonic = sinf(cmd * 3.0f) / 6.0f;
    pwm3PhaseDrv[0] = PWM_OUT_POWER_50PCT + (sinf(cmd) + thirdHarmonic)*halfPower;
    pwm3PhaseDrv[1] = PWM_OUT_POWER_50PCT + (sinf(cmd + M_2PI_3) + thirdHarmonic)*halfPower;
    pwm3PhaseDrv[2] = PWM_OUT_POWER_50PCT + (sinf(cmd - M_2PI_3) + thirdHarmonic)*halfPower;
  } else {
    pwm3PhaseDrv[0] = PWM_OUT_POWER_50PCT + sinf(cmd)*halfPower;
 80059e8:	4620      	mov	r0, r4
 80059ea:	f006 f901 	bl	800bbf0 <sinf>
 80059ee:	4629      	mov	r1, r5
 80059f0:	f7fb fa16 	bl	8000e20 <__aeabi_fmul>
 80059f4:	4944      	ldr	r1, [pc, #272]	; (8005b08 <pwmOutputCmdTo3PhasePWM+0x138>)
 80059f6:	f7fb f909 	bl	8000c0c <__addsf3>
 80059fa:	f7fb fc01 	bl	8001200 <__aeabi_f2uiz>
 80059fe:	4e43      	ldr	r6, [pc, #268]	; (8005b0c <pwmOutputCmdTo3PhasePWM+0x13c>)
 8005a00:	6030      	str	r0, [r6, #0]
    pwm3PhaseDrv[1] = PWM_OUT_POWER_50PCT + sinf(cmd + M_2PI_3)*halfPower;
 8005a02:	4620      	mov	r0, r4
 8005a04:	f7fa fd90 	bl	8000528 <__aeabi_f2d>
 8005a08:	a33d      	add	r3, pc, #244	; (adr r3, 8005b00 <pwmOutputCmdTo3PhasePWM+0x130>)
 8005a0a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005a0e:	4680      	mov	r8, r0
 8005a10:	4689      	mov	r9, r1
 8005a12:	f7fa fc2b 	bl	800026c <__adddf3>
 8005a16:	f7fb f8a3 	bl	8000b60 <__aeabi_d2f>
 8005a1a:	f006 f8e9 	bl	800bbf0 <sinf>
 8005a1e:	4629      	mov	r1, r5
 8005a20:	f7fb f9fe 	bl	8000e20 <__aeabi_fmul>
 8005a24:	4938      	ldr	r1, [pc, #224]	; (8005b08 <pwmOutputCmdTo3PhasePWM+0x138>)
 8005a26:	f7fb f8f1 	bl	8000c0c <__addsf3>
 8005a2a:	f7fb fbe9 	bl	8001200 <__aeabi_f2uiz>
    pwm3PhaseDrv[2] = PWM_OUT_POWER_50PCT + sinf(cmd - M_2PI_3)*halfPower;
 8005a2e:	a334      	add	r3, pc, #208	; (adr r3, 8005b00 <pwmOutputCmdTo3PhasePWM+0x130>)
 8005a30:	e9d3 2300 	ldrd	r2, r3, [r3]
    pwm3PhaseDrv[0] = PWM_OUT_POWER_50PCT + (sinf(cmd) + thirdHarmonic)*halfPower;
    pwm3PhaseDrv[1] = PWM_OUT_POWER_50PCT + (sinf(cmd + M_2PI_3) + thirdHarmonic)*halfPower;
    pwm3PhaseDrv[2] = PWM_OUT_POWER_50PCT + (sinf(cmd - M_2PI_3) + thirdHarmonic)*halfPower;
  } else {
    pwm3PhaseDrv[0] = PWM_OUT_POWER_50PCT + sinf(cmd)*halfPower;
    pwm3PhaseDrv[1] = PWM_OUT_POWER_50PCT + sinf(cmd + M_2PI_3)*halfPower;
 8005a34:	6070      	str	r0, [r6, #4]
    pwm3PhaseDrv[2] = PWM_OUT_POWER_50PCT + sinf(cmd - M_2PI_3)*halfPower;
 8005a36:	4649      	mov	r1, r9
 8005a38:	4640      	mov	r0, r8
 8005a3a:	f7fa fc15 	bl	8000268 <__aeabi_dsub>
 8005a3e:	f7fb f88f 	bl	8000b60 <__aeabi_d2f>
 8005a42:	f006 f8d5 	bl	800bbf0 <sinf>
 8005a46:	4629      	mov	r1, r5
 8005a48:	f7fb f9ea 	bl	8000e20 <__aeabi_fmul>
 8005a4c:	492e      	ldr	r1, [pc, #184]	; (8005b08 <pwmOutputCmdTo3PhasePWM+0x138>)
 8005a4e:	f7fb f8dd 	bl	8000c0c <__addsf3>
 8005a52:	f7fb fbd5 	bl	8001200 <__aeabi_f2uiz>
 8005a56:	60b0      	str	r0, [r6, #8]
 8005a58:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 * @return none.
 */
static void pwmOutputCmdTo3PhasePWM(float cmd, uint8_t power, uint8_t thi) {
  float halfPower = power * PWM_OUT_POWER_1PCT2;
  if (thi) {
    halfPower *= THI_PWM_K;
 8005a5c:	492c      	ldr	r1, [pc, #176]	; (8005b10 <pwmOutputCmdTo3PhasePWM+0x140>)
 8005a5e:	f7fb f9df 	bl	8000e20 <__aeabi_fmul>
    float thirdHarmonic = sinf(cmd * 3.0f) / 6.0f;
 8005a62:	492c      	ldr	r1, [pc, #176]	; (8005b14 <pwmOutputCmdTo3PhasePWM+0x144>)
 * @return none.
 */
static void pwmOutputCmdTo3PhasePWM(float cmd, uint8_t power, uint8_t thi) {
  float halfPower = power * PWM_OUT_POWER_1PCT2;
  if (thi) {
    halfPower *= THI_PWM_K;
 8005a64:	4606      	mov	r6, r0
    float thirdHarmonic = sinf(cmd * 3.0f) / 6.0f;
 8005a66:	4620      	mov	r0, r4
 8005a68:	f7fb f9da 	bl	8000e20 <__aeabi_fmul>
 8005a6c:	f006 f8c0 	bl	800bbf0 <sinf>
 8005a70:	4929      	ldr	r1, [pc, #164]	; (8005b18 <pwmOutputCmdTo3PhasePWM+0x148>)
 8005a72:	f7fb fa89 	bl	8000f88 <__aeabi_fdiv>
 8005a76:	4607      	mov	r7, r0
    pwm3PhaseDrv[0] = PWM_OUT_POWER_50PCT + (sinf(cmd) + thirdHarmonic)*halfPower;
 8005a78:	4620      	mov	r0, r4
 8005a7a:	f006 f8b9 	bl	800bbf0 <sinf>
 8005a7e:	4639      	mov	r1, r7
 8005a80:	f7fb f8c4 	bl	8000c0c <__addsf3>
 8005a84:	4631      	mov	r1, r6
 8005a86:	f7fb f9cb 	bl	8000e20 <__aeabi_fmul>
 8005a8a:	491f      	ldr	r1, [pc, #124]	; (8005b08 <pwmOutputCmdTo3PhasePWM+0x138>)
 8005a8c:	f7fb f8be 	bl	8000c0c <__addsf3>
 8005a90:	f7fb fbb6 	bl	8001200 <__aeabi_f2uiz>
 8005a94:	4d1d      	ldr	r5, [pc, #116]	; (8005b0c <pwmOutputCmdTo3PhasePWM+0x13c>)
 8005a96:	6028      	str	r0, [r5, #0]
    pwm3PhaseDrv[1] = PWM_OUT_POWER_50PCT + (sinf(cmd + M_2PI_3) + thirdHarmonic)*halfPower;
 8005a98:	4620      	mov	r0, r4
 8005a9a:	f7fa fd45 	bl	8000528 <__aeabi_f2d>
 8005a9e:	a318      	add	r3, pc, #96	; (adr r3, 8005b00 <pwmOutputCmdTo3PhasePWM+0x130>)
 8005aa0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005aa4:	4680      	mov	r8, r0
 8005aa6:	4689      	mov	r9, r1
 8005aa8:	f7fa fbe0 	bl	800026c <__adddf3>
 8005aac:	f7fb f858 	bl	8000b60 <__aeabi_d2f>
 8005ab0:	f006 f89e 	bl	800bbf0 <sinf>
 8005ab4:	4639      	mov	r1, r7
 8005ab6:	f7fb f8a9 	bl	8000c0c <__addsf3>
 8005aba:	4631      	mov	r1, r6
 8005abc:	f7fb f9b0 	bl	8000e20 <__aeabi_fmul>
 8005ac0:	4911      	ldr	r1, [pc, #68]	; (8005b08 <pwmOutputCmdTo3PhasePWM+0x138>)
 8005ac2:	f7fb f8a3 	bl	8000c0c <__addsf3>
 8005ac6:	f7fb fb9b 	bl	8001200 <__aeabi_f2uiz>
    pwm3PhaseDrv[2] = PWM_OUT_POWER_50PCT + (sinf(cmd - M_2PI_3) + thirdHarmonic)*halfPower;
 8005aca:	a30d      	add	r3, pc, #52	; (adr r3, 8005b00 <pwmOutputCmdTo3PhasePWM+0x130>)
 8005acc:	e9d3 2300 	ldrd	r2, r3, [r3]
  float halfPower = power * PWM_OUT_POWER_1PCT2;
  if (thi) {
    halfPower *= THI_PWM_K;
    float thirdHarmonic = sinf(cmd * 3.0f) / 6.0f;
    pwm3PhaseDrv[0] = PWM_OUT_POWER_50PCT + (sinf(cmd) + thirdHarmonic)*halfPower;
    pwm3PhaseDrv[1] = PWM_OUT_POWER_50PCT + (sinf(cmd + M_2PI_3) + thirdHarmonic)*halfPower;
 8005ad0:	6068      	str	r0, [r5, #4]
    pwm3PhaseDrv[2] = PWM_OUT_POWER_50PCT + (sinf(cmd - M_2PI_3) + thirdHarmonic)*halfPower;
 8005ad2:	4649      	mov	r1, r9
 8005ad4:	4640      	mov	r0, r8
 8005ad6:	f7fa fbc7 	bl	8000268 <__aeabi_dsub>
 8005ada:	f7fb f841 	bl	8000b60 <__aeabi_d2f>
 8005ade:	f006 f887 	bl	800bbf0 <sinf>
 8005ae2:	4639      	mov	r1, r7
 8005ae4:	f7fb f892 	bl	8000c0c <__addsf3>
 8005ae8:	4631      	mov	r1, r6
 8005aea:	f7fb f999 	bl	8000e20 <__aeabi_fmul>
 8005aee:	4906      	ldr	r1, [pc, #24]	; (8005b08 <pwmOutputCmdTo3PhasePWM+0x138>)
 8005af0:	f7fb f88c 	bl	8000c0c <__addsf3>
 8005af4:	f7fb fb84 	bl	8001200 <__aeabi_f2uiz>
 8005af8:	60a8      	str	r0, [r5, #8]
 8005afa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005afe:	bf00      	nop
 8005b00:	382d7365 	.word	0x382d7365
 8005b04:	4000c152 	.word	0x4000c152
 8005b08:	447a0000 	.word	0x447a0000
 8005b0c:	200015dc 	.word	0x200015dc
 8005b10:	3f93cd3a 	.word	0x3f93cd3a
 8005b14:	40400000 	.word	0x40400000
 8005b18:	40c00000 	.word	0x40c00000
 8005b1c:	00000000 	.word	0x00000000

08005b20 <pwmOutputUpdate>:
 * @param  channel_id - PWM output channel ID.
 * @param  cmd - new command to the motor driver.
 * @return none.
 */
void pwmOutputUpdate(const uint8_t channel_id, float cmd) {
  switch (channel_id) {
 8005b20:	2801      	cmp	r0, #1
 *         according to the given command.
 * @param  channel_id - PWM output channel ID.
 * @param  cmd - new command to the motor driver.
 * @return none.
 */
void pwmOutputUpdate(const uint8_t channel_id, float cmd) {
 8005b22:	b570      	push	{r4, r5, r6, lr}
  switch (channel_id) {
 8005b24:	d025      	beq.n	8005b72 <pwmOutputUpdate+0x52>
 8005b26:	d313      	bcc.n	8005b50 <pwmOutputUpdate+0x30>
 8005b28:	2802      	cmp	r0, #2
 8005b2a:	d110      	bne.n	8005b4e <pwmOutputUpdate+0x2e>
        g_pwmOutput[PWM_OUT_ROLL].flags & PWM_OUT_THI_FLAG);
      pwmOutputUpdateRoll();
    }
    break;
  case PWM_OUT_YAW:
    if ((g_pwmOutput[PWM_OUT_YAW].dt_cmd_id & PWM_OUT_CMD_ID_MASK) == PWM_OUT_CMD_DISABLED) {
 8005b2c:	4c40      	ldr	r4, [pc, #256]	; (8005c30 <pwmOutputUpdate+0x110>)
 8005b2e:	7ae3      	ldrb	r3, [r4, #11]
 8005b30:	f003 030f 	and.w	r3, r3, #15
 8005b34:	2b03      	cmp	r3, #3
 8005b36:	d055      	beq.n	8005be4 <pwmOutputUpdate+0xc4>
      pwmOutputDisableYaw();
    } else {
      pwmOutputCmdTo3PhasePWM(cmd, g_pwmOutput[PWM_OUT_YAW].power,
 8005b38:	7aa2      	ldrb	r2, [r4, #10]
 8005b3a:	4608      	mov	r0, r1
 8005b3c:	f002 0202 	and.w	r2, r2, #2
 8005b40:	7a21      	ldrb	r1, [r4, #8]
 8005b42:	f7ff ff45 	bl	80059d0 <pwmOutputCmdTo3PhasePWM>
      pwmOutputUpdateYaw();
    }
    break;
  default:;
  }
}
 8005b46:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    if ((g_pwmOutput[PWM_OUT_YAW].dt_cmd_id & PWM_OUT_CMD_ID_MASK) == PWM_OUT_CMD_DISABLED) {
      pwmOutputDisableYaw();
    } else {
      pwmOutputCmdTo3PhasePWM(cmd, g_pwmOutput[PWM_OUT_YAW].power,
        g_pwmOutput[PWM_OUT_YAW].flags & PWM_OUT_THI_FLAG);
      pwmOutputUpdateYaw();
 8005b4a:	f7ff bf01 	b.w	8005950 <pwmOutputUpdateYaw>
 8005b4e:	bd70      	pop	{r4, r5, r6, pc}
 * @return none.
 */
void pwmOutputUpdate(const uint8_t channel_id, float cmd) {
  switch (channel_id) {
  case PWM_OUT_PITCH:
    if ((g_pwmOutput[PWM_OUT_PITCH].dt_cmd_id & PWM_OUT_CMD_ID_MASK) == PWM_OUT_CMD_DISABLED) {
 8005b50:	4c37      	ldr	r4, [pc, #220]	; (8005c30 <pwmOutputUpdate+0x110>)
 8005b52:	78e3      	ldrb	r3, [r4, #3]
 8005b54:	f003 030f 	and.w	r3, r3, #15
 8005b58:	2b03      	cmp	r3, #3
 8005b5a:	d01b      	beq.n	8005b94 <pwmOutputUpdate+0x74>
      pwmOutputDisablePitch();
    } else {
      pwmOutputCmdTo3PhasePWM(cmd, g_pwmOutput[PWM_OUT_PITCH].power,
 8005b5c:	78a2      	ldrb	r2, [r4, #2]
 8005b5e:	4608      	mov	r0, r1
 8005b60:	f002 0202 	and.w	r2, r2, #2
 8005b64:	7821      	ldrb	r1, [r4, #0]
 8005b66:	f7ff ff33 	bl	80059d0 <pwmOutputCmdTo3PhasePWM>
      pwmOutputUpdateYaw();
    }
    break;
  default:;
  }
}
 8005b6a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    if ((g_pwmOutput[PWM_OUT_PITCH].dt_cmd_id & PWM_OUT_CMD_ID_MASK) == PWM_OUT_CMD_DISABLED) {
      pwmOutputDisablePitch();
    } else {
      pwmOutputCmdTo3PhasePWM(cmd, g_pwmOutput[PWM_OUT_PITCH].power,
        g_pwmOutput[PWM_OUT_PITCH].flags & PWM_OUT_THI_FLAG);
      pwmOutputUpdatePitch();
 8005b6e:	f7ff becf 	b.w	8005910 <pwmOutputUpdatePitch>
    }
    break;
  case PWM_OUT_ROLL:
    if ((g_pwmOutput[PWM_OUT_ROLL].dt_cmd_id & PWM_OUT_CMD_ID_MASK) == PWM_OUT_CMD_DISABLED) {
 8005b72:	4c2f      	ldr	r4, [pc, #188]	; (8005c30 <pwmOutputUpdate+0x110>)
 8005b74:	79e3      	ldrb	r3, [r4, #7]
 8005b76:	f003 030f 	and.w	r3, r3, #15
 8005b7a:	2b03      	cmp	r3, #3
 8005b7c:	d019      	beq.n	8005bb2 <pwmOutputUpdate+0x92>
      pwmOutputDisableRoll();
    } else {
      pwmOutputCmdTo3PhasePWM(cmd, g_pwmOutput[PWM_OUT_ROLL].power,
 8005b7e:	79a2      	ldrb	r2, [r4, #6]
 8005b80:	4608      	mov	r0, r1
 8005b82:	f002 0202 	and.w	r2, r2, #2
 8005b86:	7921      	ldrb	r1, [r4, #4]
 8005b88:	f7ff ff22 	bl	80059d0 <pwmOutputCmdTo3PhasePWM>
      pwmOutputUpdateYaw();
    }
    break;
  default:;
  }
}
 8005b8c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    if ((g_pwmOutput[PWM_OUT_ROLL].dt_cmd_id & PWM_OUT_CMD_ID_MASK) == PWM_OUT_CMD_DISABLED) {
      pwmOutputDisableRoll();
    } else {
      pwmOutputCmdTo3PhasePWM(cmd, g_pwmOutput[PWM_OUT_ROLL].power,
        g_pwmOutput[PWM_OUT_ROLL].flags & PWM_OUT_THI_FLAG);
      pwmOutputUpdateRoll();
 8005b90:	f7ff be8e 	b.w	80058b0 <pwmOutputUpdateRoll>
 * @brief  Disables PWM on pitch driver.
 * @return none.
 */
static void pwmOutputDisablePitch(void) {
  /* Disable update event. */
  PWMD3.tim->CR1 |= STM32_TIM_CR1_UDIS;
 8005b94:	4b27      	ldr	r3, [pc, #156]	; (8005c34 <pwmOutputUpdate+0x114>)

  PWMD3.tim->CCR[3] = 0;
 8005b96:	2200      	movs	r2, #0
 * @brief  Disables PWM on pitch driver.
 * @return none.
 */
static void pwmOutputDisablePitch(void) {
  /* Disable update event. */
  PWMD3.tim->CR1 |= STM32_TIM_CR1_UDIS;
 8005b98:	699b      	ldr	r3, [r3, #24]
 8005b9a:	6819      	ldr	r1, [r3, #0]
 8005b9c:	f041 0102 	orr.w	r1, r1, #2
 8005ba0:	6019      	str	r1, [r3, #0]

  PWMD3.tim->CCR[3] = 0;
 8005ba2:	641a      	str	r2, [r3, #64]	; 0x40
  PWMD3.tim->CCR[2] = 0;
 8005ba4:	63da      	str	r2, [r3, #60]	; 0x3c
  PWMD3.tim->CCR[1] = 0;
 8005ba6:	639a      	str	r2, [r3, #56]	; 0x38

  /* Enable update event. */
  PWMD3.tim->CR1 &= ~STM32_TIM_CR1_UDIS;
 8005ba8:	681a      	ldr	r2, [r3, #0]
 8005baa:	f022 0202 	bic.w	r2, r2, #2
 8005bae:	601a      	str	r2, [r3, #0]
 8005bb0:	bd70      	pop	{r4, r5, r6, pc}
 * @brief  Disables PWM on roll driver.
 * @return none.
 */
static void pwmOutputDisableRoll(void) {
  /* Disable update event. */
  PWMD2.tim->CR1 |= STM32_TIM_CR1_UDIS;
 8005bb2:	4b21      	ldr	r3, [pc, #132]	; (8005c38 <pwmOutputUpdate+0x118>)
  PWMD3.tim->CR1 |= STM32_TIM_CR1_UDIS;
 8005bb4:	4a1f      	ldr	r2, [pc, #124]	; (8005c34 <pwmOutputUpdate+0x114>)
 * @brief  Disables PWM on roll driver.
 * @return none.
 */
static void pwmOutputDisableRoll(void) {
  /* Disable update event. */
  PWMD2.tim->CR1 |= STM32_TIM_CR1_UDIS;
 8005bb6:	699b      	ldr	r3, [r3, #24]
  PWMD3.tim->CR1 |= STM32_TIM_CR1_UDIS;
 8005bb8:	6992      	ldr	r2, [r2, #24]
 * @brief  Disables PWM on roll driver.
 * @return none.
 */
static void pwmOutputDisableRoll(void) {
  /* Disable update event. */
  PWMD2.tim->CR1 |= STM32_TIM_CR1_UDIS;
 8005bba:	6818      	ldr	r0, [r3, #0]
  PWMD3.tim->CR1 |= STM32_TIM_CR1_UDIS;

  PWMD3.tim->CCR[0] = 0;
 8005bbc:	2100      	movs	r1, #0
 * @brief  Disables PWM on roll driver.
 * @return none.
 */
static void pwmOutputDisableRoll(void) {
  /* Disable update event. */
  PWMD2.tim->CR1 |= STM32_TIM_CR1_UDIS;
 8005bbe:	f040 0002 	orr.w	r0, r0, #2
 8005bc2:	6018      	str	r0, [r3, #0]
  PWMD3.tim->CR1 |= STM32_TIM_CR1_UDIS;
 8005bc4:	6810      	ldr	r0, [r2, #0]
 8005bc6:	f040 0002 	orr.w	r0, r0, #2
 8005bca:	6010      	str	r0, [r2, #0]

  PWMD3.tim->CCR[0] = 0;
 8005bcc:	6351      	str	r1, [r2, #52]	; 0x34
  PWMD2.tim->CCR[3] = 0;
 8005bce:	6419      	str	r1, [r3, #64]	; 0x40
  PWMD2.tim->CCR[2] = 0;
 8005bd0:	63d9      	str	r1, [r3, #60]	; 0x3c

  /* Enable update event. */
  PWMD2.tim->CR1 &= ~STM32_TIM_CR1_UDIS;
 8005bd2:	6819      	ldr	r1, [r3, #0]
 8005bd4:	f021 0102 	bic.w	r1, r1, #2
 8005bd8:	6019      	str	r1, [r3, #0]
  PWMD3.tim->CR1 &= ~STM32_TIM_CR1_UDIS;
 8005bda:	6813      	ldr	r3, [r2, #0]
 8005bdc:	f023 0302 	bic.w	r3, r3, #2
 8005be0:	6013      	str	r3, [r2, #0]
 8005be2:	bd70      	pop	{r4, r5, r6, pc}
 8005be4:	2420      	movs	r4, #32
 8005be6:	f384 8811 	msr	BASEPRI, r4
 * @return none.
 */
static void pwmOutputDisableYaw(void) {
  chSysLock();
  /* Disable update event. */
  PWMD2.tim->CR1 |= STM32_TIM_CR1_UDIS;
 8005bea:	4913      	ldr	r1, [pc, #76]	; (8005c38 <pwmOutputUpdate+0x118>)
  PWMD4.tim->CR1 |= STM32_TIM_CR1_UDIS;
 8005bec:	4a13      	ldr	r2, [pc, #76]	; (8005c3c <pwmOutputUpdate+0x11c>)
 * @return none.
 */
static void pwmOutputDisableYaw(void) {
  chSysLock();
  /* Disable update event. */
  PWMD2.tim->CR1 |= STM32_TIM_CR1_UDIS;
 8005bee:	698e      	ldr	r6, [r1, #24]
  PWMD4.tim->CR1 |= STM32_TIM_CR1_UDIS;
 8005bf0:	6995      	ldr	r5, [r2, #24]
 * @return none.
 */
static void pwmOutputDisableYaw(void) {
  chSysLock();
  /* Disable update event. */
  PWMD2.tim->CR1 |= STM32_TIM_CR1_UDIS;
 8005bf2:	6830      	ldr	r0, [r6, #0]
 8005bf4:	2300      	movs	r3, #0
 8005bf6:	f040 0002 	orr.w	r0, r0, #2
 8005bfa:	6030      	str	r0, [r6, #0]
  PWMD4.tim->CR1 |= STM32_TIM_CR1_UDIS;
 8005bfc:	6828      	ldr	r0, [r5, #0]
 8005bfe:	f040 0002 	orr.w	r0, r0, #2
 8005c02:	6028      	str	r0, [r5, #0]
 8005c04:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  PWMD4.tim->CCR[3] = 0;
 8005c08:	6990      	ldr	r0, [r2, #24]
  PWMD2.tim->CCR[1] = 0;
 8005c0a:	698d      	ldr	r5, [r1, #24]
  /* Disable update event. */
  PWMD2.tim->CR1 |= STM32_TIM_CR1_UDIS;
  PWMD4.tim->CR1 |= STM32_TIM_CR1_UDIS;
  chSysUnlock();

  PWMD4.tim->CCR[3] = 0;
 8005c0c:	6403      	str	r3, [r0, #64]	; 0x40
  PWMD2.tim->CCR[1] = 0;
 8005c0e:	63ab      	str	r3, [r5, #56]	; 0x38
  PWMD4.tim->CCR[2] = 0;
 8005c10:	63c3      	str	r3, [r0, #60]	; 0x3c
 8005c12:	f384 8811 	msr	BASEPRI, r4

  chSysLock();
  /* Enable update event. */
  PWMD2.tim->CR1 &= ~STM32_TIM_CR1_UDIS;
 8005c16:	6988      	ldr	r0, [r1, #24]
  PWMD4.tim->CR1 &= ~STM32_TIM_CR1_UDIS;
 8005c18:	6991      	ldr	r1, [r2, #24]
  PWMD2.tim->CCR[1] = 0;
  PWMD4.tim->CCR[2] = 0;

  chSysLock();
  /* Enable update event. */
  PWMD2.tim->CR1 &= ~STM32_TIM_CR1_UDIS;
 8005c1a:	6802      	ldr	r2, [r0, #0]
 8005c1c:	f022 0202 	bic.w	r2, r2, #2
 8005c20:	6002      	str	r2, [r0, #0]
  PWMD4.tim->CR1 &= ~STM32_TIM_CR1_UDIS;
 8005c22:	680a      	ldr	r2, [r1, #0]
 8005c24:	f022 0202 	bic.w	r2, r2, #2
 8005c28:	600a      	str	r2, [r1, #0]
 8005c2a:	f383 8811 	msr	BASEPRI, r3
 8005c2e:	bd70      	pop	{r4, r5, r6, pc}
 8005c30:	20000808 	.word	0x20000808
 8005c34:	200013ac 	.word	0x200013ac
 8005c38:	20001390 	.word	0x20001390
 8005c3c:	200013c8 	.word	0x200013c8

08005c40 <pwmOutputDisableAll>:

/**
 * @brief  Disables all PWM output channels.
 * @return none.
 */
void pwmOutputDisableAll(void) {
 8005c40:	b508      	push	{r3, lr}
  pwmOutputUpdatePitch();
 8005c42:	f7ff fe65 	bl	8005910 <pwmOutputUpdatePitch>
  pwmOutputUpdateRoll();
 8005c46:	f7ff fe33 	bl	80058b0 <pwmOutputUpdateRoll>
  pwmOutputUpdateYaw();
}
 8005c4a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 * @return none.
 */
void pwmOutputDisableAll(void) {
  pwmOutputUpdatePitch();
  pwmOutputUpdateRoll();
  pwmOutputUpdateYaw();
 8005c4e:	f7ff be7f 	b.w	8005950 <pwmOutputUpdateYaw>
 8005c52:	bf00      	nop
	...

08005c60 <pwmOutputSettingsUpdate>:
}

/**
 *
 */
void pwmOutputSettingsUpdate(const PPWMOutputStruct pNewSettings) {
 8005c60:	4602      	mov	r2, r0
  memcpy((void *)&g_pwmOutput, (void *)pNewSettings, sizeof(g_pwmOutput));
 8005c62:	4b03      	ldr	r3, [pc, #12]	; (8005c70 <pwmOutputSettingsUpdate+0x10>)
 8005c64:	6851      	ldr	r1, [r2, #4]
 8005c66:	6800      	ldr	r0, [r0, #0]
 8005c68:	6892      	ldr	r2, [r2, #8]
 8005c6a:	c307      	stmia	r3!, {r0, r1, r2}
 8005c6c:	4770      	bx	lr
 8005c6e:	bf00      	nop
 8005c70:	20000808 	.word	0x20000808
	...

08005c80 <mixedInputSettingsUpdate>:
}
//
///**
// *
// */
void mixedInputSettingsUpdate(const PMixedInputStruct pNewSettings) {
 8005c80:	4770      	bx	lr
 8005c82:	bf00      	nop
	...

08005c90 <tmr>:

static virtual_timer_t vt;
static void tmr(void *p) {
  (void)p;

  test_timer_done = TRUE;
 8005c90:	4b01      	ldr	r3, [pc, #4]	; (8005c98 <tmr+0x8>)
 8005c92:	2201      	movs	r2, #1
 8005c94:	701a      	strb	r2, [r3, #0]
 8005c96:	4770      	bx	lr
 8005c98:	20001c3d 	.word	0x20001c3d
 8005c9c:	00000000 	.word	0x00000000

08005ca0 <print_line>:
    tcp->teardown();

  test_wait_threads();
}

static void print_line(void) {
 8005ca0:	b570      	push	{r4, r5, r6, lr}
 8005ca2:	4e09      	ldr	r6, [pc, #36]	; (8005cc8 <print_line+0x28>)
 8005ca4:	244c      	movs	r4, #76	; 0x4c
  unsigned i;

  for (i = 0; i < 76; i++)
    chSequentialStreamPut(chp, '-');
 8005ca6:	6830      	ldr	r0, [r6, #0]
 8005ca8:	212d      	movs	r1, #45	; 0x2d
 8005caa:	6803      	ldr	r3, [r0, #0]
 8005cac:	4d06      	ldr	r5, [pc, #24]	; (8005cc8 <print_line+0x28>)
 8005cae:	689b      	ldr	r3, [r3, #8]
 8005cb0:	4798      	blx	r3
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
 8005cb2:	3c01      	subs	r4, #1
 8005cb4:	d1f7      	bne.n	8005ca6 <print_line+0x6>
    chSequentialStreamPut(chp, '-');
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 8005cb6:	6828      	ldr	r0, [r5, #0]
 8005cb8:	4904      	ldr	r1, [pc, #16]	; (8005ccc <print_line+0x2c>)
 8005cba:	6803      	ldr	r3, [r0, #0]
 8005cbc:	2202      	movs	r2, #2
 8005cbe:	681b      	ldr	r3, [r3, #0]
}
 8005cc0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
    chSequentialStreamPut(chp, '-');
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 8005cc4:	4718      	bx	r3
 8005cc6:	bf00      	nop
 8005cc8:	20001c6c 	.word	0x20001c6c
 8005ccc:	0800e608 	.word	0x0800e608

08005cd0 <test_printn>:
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
 8005cd0:	b310      	cbz	r0, 8005d18 <test_printn+0x48>
/**
 * @brief   Prints a decimal unsigned number.
 *
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
 8005cd2:	b570      	push	{r4, r5, r6, lr}
 8005cd4:	b084      	sub	sp, #16
  char buf[16], *p;

  if (!n)
 8005cd6:	466d      	mov	r5, sp
 8005cd8:	466c      	mov	r4, sp
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
 8005cda:	4a12      	ldr	r2, [pc, #72]	; (8005d24 <test_printn+0x54>)
 8005cdc:	fba2 1300 	umull	r1, r3, r2, r0
 8005ce0:	08db      	lsrs	r3, r3, #3
 8005ce2:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8005ce6:	eba0 0041 	sub.w	r0, r0, r1, lsl #1
 8005cea:	f100 0130 	add.w	r1, r0, #48	; 0x30
 8005cee:	b2c9      	uxtb	r1, r1
 8005cf0:	f804 1b01 	strb.w	r1, [r4], #1

  if (!n)
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
 8005cf4:	4618      	mov	r0, r3
 8005cf6:	2b00      	cmp	r3, #0
 8005cf8:	d1f0      	bne.n	8005cdc <test_printn+0xc>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 8005cfa:	42ac      	cmp	r4, r5
 8005cfc:	d90a      	bls.n	8005d14 <test_printn+0x44>
 8005cfe:	4e0a      	ldr	r6, [pc, #40]	; (8005d28 <test_printn+0x58>)
 8005d00:	3c01      	subs	r4, #1
 8005d02:	e001      	b.n	8005d08 <test_printn+0x38>
 8005d04:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
      chSequentialStreamPut(chp, *--p);
 8005d08:	6830      	ldr	r0, [r6, #0]
 8005d0a:	6803      	ldr	r3, [r0, #0]
 8005d0c:	689b      	ldr	r3, [r3, #8]
 8005d0e:	4798      	blx	r3
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 8005d10:	42ac      	cmp	r4, r5
 8005d12:	d1f7      	bne.n	8005d04 <test_printn+0x34>
      chSequentialStreamPut(chp, *--p);
  }
}
 8005d14:	b004      	add	sp, #16
 8005d16:	bd70      	pop	{r4, r5, r6, pc}
 */
void test_printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
    chSequentialStreamPut(chp, '0');
 8005d18:	4b03      	ldr	r3, [pc, #12]	; (8005d28 <test_printn+0x58>)
 8005d1a:	2130      	movs	r1, #48	; 0x30
 8005d1c:	6818      	ldr	r0, [r3, #0]
 8005d1e:	6803      	ldr	r3, [r0, #0]
 8005d20:	689b      	ldr	r3, [r3, #8]
 8005d22:	4718      	bx	r3
 8005d24:	cccccccd 	.word	0xcccccccd
 8005d28:	20001c6c 	.word	0x20001c6c
 8005d2c:	00000000 	.word	0x00000000

08005d30 <test_print>:
/**
 * @brief   Prints a line without final end-of-line.
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {
 8005d30:	b538      	push	{r3, r4, r5, lr}

  while (*msgp)
 8005d32:	7801      	ldrb	r1, [r0, #0]
/**
 * @brief   Prints a line without final end-of-line.
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {
 8005d34:	4604      	mov	r4, r0

  while (*msgp)
 8005d36:	b141      	cbz	r1, 8005d4a <test_print+0x1a>
 8005d38:	4d04      	ldr	r5, [pc, #16]	; (8005d4c <test_print+0x1c>)
    chSequentialStreamPut(chp, *msgp++);
 8005d3a:	6828      	ldr	r0, [r5, #0]
 8005d3c:	6803      	ldr	r3, [r0, #0]
 8005d3e:	689b      	ldr	r3, [r3, #8]
 8005d40:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005d42:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8005d46:	2900      	cmp	r1, #0
 8005d48:	d1f7      	bne.n	8005d3a <test_print+0xa>
 8005d4a:	bd38      	pop	{r3, r4, r5, pc}
 8005d4c:	20001c6c 	.word	0x20001c6c

08005d50 <test_println>:
/**
 * @brief   Prints a line.
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {
 8005d50:	b570      	push	{r4, r5, r6, lr}
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005d52:	7801      	ldrb	r1, [r0, #0]
/**
 * @brief   Prints a line.
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {
 8005d54:	4604      	mov	r4, r0
 8005d56:	4d09      	ldr	r5, [pc, #36]	; (8005d7c <test_println+0x2c>)
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005d58:	b139      	cbz	r1, 8005d6a <test_println+0x1a>
    chSequentialStreamPut(chp, *msgp++);
 8005d5a:	6828      	ldr	r0, [r5, #0]
 8005d5c:	6803      	ldr	r3, [r0, #0]
 8005d5e:	689b      	ldr	r3, [r3, #8]
 8005d60:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005d62:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8005d66:	2900      	cmp	r1, #0
 8005d68:	d1f7      	bne.n	8005d5a <test_println+0xa>
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {

  test_print(msgp);
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 8005d6a:	6828      	ldr	r0, [r5, #0]
 8005d6c:	4904      	ldr	r1, [pc, #16]	; (8005d80 <test_println+0x30>)
 8005d6e:	6803      	ldr	r3, [r0, #0]
 8005d70:	2202      	movs	r2, #2
 8005d72:	681b      	ldr	r3, [r3, #0]
}
 8005d74:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {

  test_print(msgp);
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 8005d78:	4718      	bx	r3
 8005d7a:	bf00      	nop
 8005d7c:	20001c6c 	.word	0x20001c6c
 8005d80:	0800e608 	.word	0x0800e608
	...

08005d90 <test_emit_token>:
/**
 * @brief   Emits a token into the tokens buffer.
 *
 * @param[in] token     the token as a char
 */
void test_emit_token(char token) {
 8005d90:	b410      	push	{r4}
 8005d92:	2320      	movs	r3, #32
 8005d94:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  *tokp++ = token;
 8005d98:	4b05      	ldr	r3, [pc, #20]	; (8005db0 <test_emit_token+0x20>)
 8005d9a:	2100      	movs	r1, #0
 8005d9c:	681a      	ldr	r2, [r3, #0]
 8005d9e:	1c54      	adds	r4, r2, #1
 8005da0:	7010      	strb	r0, [r2, #0]
 8005da2:	601c      	str	r4, [r3, #0]
 8005da4:	f381 8811 	msr	BASEPRI, r1
  chSysUnlock();
}
 8005da8:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005dac:	4770      	bx	lr
 8005dae:	bf00      	nop
 8005db0:	20001c40 	.word	0x20001c40
	...

08005dc0 <_test_assert>:
  return TRUE;
}

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
 8005dc0:	b959      	cbnz	r1, 8005dda <_test_assert+0x1a>
  local_fail = TRUE;
  failpoint = point;
  return TRUE;
}

bool _test_assert(unsigned point, bool condition) {
 8005dc2:	b410      	push	{r4}
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
  local_fail = TRUE;
 8005dc4:	4906      	ldr	r1, [pc, #24]	; (8005de0 <_test_assert+0x20>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8005dc6:	4c07      	ldr	r4, [pc, #28]	; (8005de4 <_test_assert+0x24>)
  local_fail = TRUE;
  failpoint = point;
 8005dc8:	4a07      	ldr	r2, [pc, #28]	; (8005de8 <_test_assert+0x28>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8005dca:	2301      	movs	r3, #1
 8005dcc:	7023      	strb	r3, [r4, #0]
  local_fail = TRUE;
  failpoint = point;
 8005dce:	6010      	str	r0, [r2, #0]
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
  local_fail = TRUE;
 8005dd0:	700b      	strb	r3, [r1, #0]
bool _test_assert(unsigned point, bool condition) {

  if (!condition)
    return _test_fail(point);
  return FALSE;
}
 8005dd2:	4618      	mov	r0, r3
 8005dd4:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005dd8:	4770      	bx	lr

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
    return _test_fail(point);
  return FALSE;
 8005dda:	2300      	movs	r3, #0
}
 8005ddc:	4618      	mov	r0, r3
 8005dde:	4770      	bx	lr
 8005de0:	20001c3c 	.word	0x20001c3c
 8005de4:	20001c80 	.word	0x20001c80
 8005de8:	20001c38 	.word	0x20001c38
 8005dec:	00000000 	.word	0x00000000

08005df0 <_test_assert_sequence>:

bool _test_assert_sequence(unsigned point, char *expected) {
 8005df0:	b4f0      	push	{r4, r5, r6, r7}
 8005df2:	4e0e      	ldr	r6, [pc, #56]	; (8005e2c <_test_assert_sequence+0x3c>)
  char *cp = tokens_buffer;
 8005df4:	4f0e      	ldr	r7, [pc, #56]	; (8005e30 <_test_assert_sequence+0x40>)
 8005df6:	6835      	ldr	r5, [r6, #0]
 8005df8:	463b      	mov	r3, r7
  while (cp < tokp) {
 8005dfa:	e005      	b.n	8005e08 <_test_assert_sequence+0x18>
    if (*cp++ != *expected++)
 8005dfc:	f813 4b01 	ldrb.w	r4, [r3], #1
 8005e00:	f811 2b01 	ldrb.w	r2, [r1], #1
 8005e04:	4294      	cmp	r4, r2
 8005e06:	d107      	bne.n	8005e18 <_test_assert_sequence+0x28>
  return FALSE;
}

bool _test_assert_sequence(unsigned point, char *expected) {
  char *cp = tokens_buffer;
  while (cp < tokp) {
 8005e08:	42ab      	cmp	r3, r5
 8005e0a:	d3f7      	bcc.n	8005dfc <_test_assert_sequence+0xc>
    if (*cp++ != *expected++)
     return _test_fail(point);
  }
  if (*expected)
 8005e0c:	780b      	ldrb	r3, [r1, #0]
 8005e0e:	b91b      	cbnz	r3, 8005e18 <_test_assert_sequence+0x28>
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 8005e10:	6037      	str	r7, [r6, #0]
  }
  if (*expected)
    return _test_fail(point);
  clear_tokens();
  return FALSE;
}
 8005e12:	4618      	mov	r0, r3
 8005e14:	bcf0      	pop	{r4, r5, r6, r7}
 8005e16:	4770      	bx	lr
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8005e18:	4c06      	ldr	r4, [pc, #24]	; (8005e34 <_test_assert_sequence+0x44>)
  local_fail = TRUE;
 8005e1a:	4907      	ldr	r1, [pc, #28]	; (8005e38 <_test_assert_sequence+0x48>)
  failpoint = point;
 8005e1c:	4a07      	ldr	r2, [pc, #28]	; (8005e3c <_test_assert_sequence+0x4c>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8005e1e:	2301      	movs	r3, #1
 8005e20:	7023      	strb	r3, [r4, #0]
  local_fail = TRUE;
  failpoint = point;
 8005e22:	6010      	str	r0, [r2, #0]
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
  local_fail = TRUE;
 8005e24:	700b      	strb	r3, [r1, #0]
  }
  if (*expected)
    return _test_fail(point);
  clear_tokens();
  return FALSE;
}
 8005e26:	4618      	mov	r0, r3
 8005e28:	bcf0      	pop	{r4, r5, r6, r7}
 8005e2a:	4770      	bx	lr
 8005e2c:	20001c40 	.word	0x20001c40
 8005e30:	20001c70 	.word	0x20001c70
 8005e34:	20001c80 	.word	0x20001c80
 8005e38:	20001c3c 	.word	0x20001c3c
 8005e3c:	20001c38 	.word	0x20001c38

08005e40 <_test_assert_time_window>:

bool _test_assert_time_window(unsigned point, systime_t start, systime_t end) {
 8005e40:	b410      	push	{r4}
 8005e42:	2320      	movs	r3, #32
 8005e44:	f383 8811 	msr	BASEPRI, r3
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 8005e48:	4b0d      	ldr	r3, [pc, #52]	; (8005e80 <_test_assert_time_window+0x40>)
 8005e4a:	2400      	movs	r4, #0
 8005e4c:	8bdb      	ldrh	r3, [r3, #30]
 8005e4e:	b29b      	uxth	r3, r3
 8005e50:	f384 8811 	msr	BASEPRI, r4
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 8005e54:	1a5b      	subs	r3, r3, r1
 8005e56:	1a52      	subs	r2, r2, r1
  return TRUE;
}

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
 8005e58:	b29b      	uxth	r3, r3
 8005e5a:	b292      	uxth	r2, r2
 8005e5c:	4293      	cmp	r3, r2
 8005e5e:	d30a      	bcc.n	8005e76 <_test_assert_time_window+0x36>
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8005e60:	4c08      	ldr	r4, [pc, #32]	; (8005e84 <_test_assert_time_window+0x44>)
  local_fail = TRUE;
 8005e62:	4909      	ldr	r1, [pc, #36]	; (8005e88 <_test_assert_time_window+0x48>)
  failpoint = point;
 8005e64:	4a09      	ldr	r2, [pc, #36]	; (8005e8c <_test_assert_time_window+0x4c>)
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8005e66:	2301      	movs	r3, #1
 8005e68:	7023      	strb	r3, [r4, #0]
  local_fail = TRUE;
  failpoint = point;
 8005e6a:	6010      	str	r0, [r2, #0]
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
  local_fail = TRUE;
 8005e6c:	700b      	strb	r3, [r1, #0]
}

bool _test_assert_time_window(unsigned point, systime_t start, systime_t end) {

  return _test_assert(point, chVTIsSystemTimeWithin(start, end));
}
 8005e6e:	4618      	mov	r0, r3
 8005e70:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005e74:	4770      	bx	lr

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
    return _test_fail(point);
  return FALSE;
 8005e76:	4623      	mov	r3, r4
}

bool _test_assert_time_window(unsigned point, systime_t start, systime_t end) {

  return _test_assert(point, chVTIsSystemTimeWithin(start, end));
}
 8005e78:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005e7c:	4618      	mov	r0, r3
 8005e7e:	4770      	bx	lr
 8005e80:	20001160 	.word	0x20001160
 8005e84:	20001c80 	.word	0x20001c80
 8005e88:	20001c3c 	.word	0x20001c3c
 8005e8c:	20001c38 	.word	0x20001c38

08005e90 <test_terminate_threads>:
 */

/**
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 8005e90:	b538      	push	{r3, r4, r5, lr}
 8005e92:	4c05      	ldr	r4, [pc, #20]	; (8005ea8 <test_terminate_threads+0x18>)
 8005e94:	f104 0514 	add.w	r5, r4, #20
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i])
 8005e98:	f854 0b04 	ldr.w	r0, [r4], #4
 8005e9c:	b108      	cbz	r0, 8005ea2 <test_terminate_threads+0x12>
      chThdTerminate(threads[i]);
 8005e9e:	f7fb fe67 	bl	8001b70 <chThdTerminate>
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 8005ea2:	42ac      	cmp	r4, r5
 8005ea4:	d1f8      	bne.n	8005e98 <test_terminate_threads+0x8>
    if (threads[i])
      chThdTerminate(threads[i]);
}
 8005ea6:	bd38      	pop	{r3, r4, r5, pc}
 8005ea8:	20001c58 	.word	0x20001c58
 8005eac:	00000000 	.word	0x00000000

08005eb0 <test_wait_threads>:

/**
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 8005eb0:	b570      	push	{r4, r5, r6, lr}
 8005eb2:	4c07      	ldr	r4, [pc, #28]	; (8005ed0 <test_wait_threads+0x20>)
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
 8005eb4:	2600      	movs	r6, #0
 8005eb6:	f104 0514 	add.w	r5, r4, #20
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
 8005eba:	f854 0b04 	ldr.w	r0, [r4], #4
 8005ebe:	b118      	cbz	r0, 8005ec8 <test_wait_threads+0x18>
      chThdWait(threads[i]);
 8005ec0:	f7fb fec6 	bl	8001c50 <chThdWait>
      threads[i] = NULL;
 8005ec4:	f844 6c04 	str.w	r6, [r4, #-4]
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 8005ec8:	42ac      	cmp	r4, r5
 8005eca:	d1f6      	bne.n	8005eba <test_wait_threads+0xa>
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
    }
}
 8005ecc:	bd70      	pop	{r4, r5, r6, pc}
 8005ece:	bf00      	nop
 8005ed0:	20001c58 	.word	0x20001c58
	...

08005ee0 <test_wait_tick>:
/**
 * @brief   Delays execution until next system time tick.
 *
 * @return              The system time.
 */
systime_t test_wait_tick(void) {
 8005ee0:	b508      	push	{r3, lr}

  chThdSleep(1);
 8005ee2:	2001      	movs	r0, #1
 8005ee4:	f7fb fe54 	bl	8001b90 <chThdSleep>
 8005ee8:	2320      	movs	r3, #32
 8005eea:	f383 8811 	msr	BASEPRI, r3
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 8005eee:	4a03      	ldr	r2, [pc, #12]	; (8005efc <test_wait_tick+0x1c>)
 8005ef0:	2300      	movs	r3, #0
 8005ef2:	8bd0      	ldrh	r0, [r2, #30]
 8005ef4:	b280      	uxth	r0, r0
 8005ef6:	f383 8811 	msr	BASEPRI, r3
  return chVTGetSystemTime();
}
 8005efa:	bd08      	pop	{r3, pc}
 8005efc:	20001160 	.word	0x20001160

08005f00 <test_start_timer>:
/**
 * @brief   Starts the test timer.
 *
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {
 8005f00:	b510      	push	{r4, lr}

  systime_t duration = MS2ST(ms);
 8005f02:	f44f 64fa 	mov.w	r4, #2000	; 0x7d0
 8005f06:	fb04 f000 	mul.w	r0, r4, r0
 8005f0a:	490e      	ldr	r1, [pc, #56]	; (8005f44 <test_start_timer+0x44>)
 8005f0c:	f200 34e7 	addw	r4, r0, #999	; 0x3e7
 8005f10:	fba1 3404 	umull	r3, r4, r1, r4
  test_timer_done = FALSE;
 8005f14:	4b0c      	ldr	r3, [pc, #48]	; (8005f48 <test_start_timer+0x48>)
 8005f16:	2200      	movs	r2, #0
 8005f18:	701a      	strb	r2, [r3, #0]
 *
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {

  systime_t duration = MS2ST(ms);
 8005f1a:	f3c4 148f 	ubfx	r4, r4, #6, #16
 8005f1e:	2320      	movs	r3, #32
 8005f20:	f383 8811 	msr	BASEPRI, r3
 8005f24:	4809      	ldr	r0, [pc, #36]	; (8005f4c <test_start_timer+0x4c>)
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8005f26:	68c3      	ldr	r3, [r0, #12]
 8005f28:	b10b      	cbz	r3, 8005f2e <test_start_timer+0x2e>
    chVTDoResetI(vtp);
 8005f2a:	f7fb fc39 	bl	80017a0 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8005f2e:	4621      	mov	r1, r4
 8005f30:	4806      	ldr	r0, [pc, #24]	; (8005f4c <test_start_timer+0x4c>)
 8005f32:	4a07      	ldr	r2, [pc, #28]	; (8005f50 <test_start_timer+0x50>)
 8005f34:	2300      	movs	r3, #0
 8005f36:	f7fb fc13 	bl	8001760 <chVTDoSetI>
 8005f3a:	2300      	movs	r3, #0
 8005f3c:	f383 8811 	msr	BASEPRI, r3
 8005f40:	bd10      	pop	{r4, pc}
 8005f42:	bf00      	nop
 8005f44:	10624dd3 	.word	0x10624dd3
 8005f48:	20001c3d 	.word	0x20001c3d
 8005f4c:	20001c44 	.word	0x20001c44
 8005f50:	08005c91 	.word	0x08005c91
	...

08005f60 <TestThread>:
/**
 * @brief   Test execution thread function.
 *
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
void TestThread(void *p) {
 8005f60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int i, j;

  chp = p;
 8005f64:	4c9f      	ldr	r4, [pc, #636]	; (80061e4 <TestThread+0x284>)
/**
 * @brief   Test execution thread function.
 *
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
void TestThread(void *p) {
 8005f66:	b083      	sub	sp, #12
  int i, j;

  chp = p;
 8005f68:	6020      	str	r0, [r4, #0]
  test_println("");
 8005f6a:	489f      	ldr	r0, [pc, #636]	; (80061e8 <TestThread+0x288>)
 8005f6c:	f7ff fef0 	bl	8005d50 <test_println>
  test_println("*** ChibiOS/RT test suite");
 8005f70:	489e      	ldr	r0, [pc, #632]	; (80061ec <TestThread+0x28c>)
 8005f72:	f7ff feed 	bl	8005d50 <test_println>
  test_println("***");
 8005f76:	4d9e      	ldr	r5, [pc, #632]	; (80061f0 <TestThread+0x290>)
 8005f78:	489e      	ldr	r0, [pc, #632]	; (80061f4 <TestThread+0x294>)
 8005f7a:	f7ff fee9 	bl	8005d50 <test_println>
 8005f7e:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005f80:	6820      	ldr	r0, [r4, #0]
 8005f82:	6803      	ldr	r3, [r0, #0]
 8005f84:	689b      	ldr	r3, [r3, #8]
 8005f86:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005f88:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005f8c:	2900      	cmp	r1, #0
 8005f8e:	d1f7      	bne.n	8005f80 <TestThread+0x20>
  chp = p;
  test_println("");
  test_println("*** ChibiOS/RT test suite");
  test_println("***");
  test_print("*** Kernel:       ");
  test_println(CH_KERNEL_VERSION);
 8005f90:	4899      	ldr	r0, [pc, #612]	; (80061f8 <TestThread+0x298>)
 8005f92:	4d9a      	ldr	r5, [pc, #616]	; (80061fc <TestThread+0x29c>)
 8005f94:	f7ff fedc 	bl	8005d50 <test_println>
 8005f98:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005f9a:	6820      	ldr	r0, [r4, #0]
 8005f9c:	6803      	ldr	r3, [r0, #0]
 8005f9e:	689b      	ldr	r3, [r3, #8]
 8005fa0:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005fa2:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005fa6:	2900      	cmp	r1, #0
 8005fa8:	d1f7      	bne.n	8005f9a <TestThread+0x3a>
  test_println("*** ChibiOS/RT test suite");
  test_println("***");
  test_print("*** Kernel:       ");
  test_println(CH_KERNEL_VERSION);
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
 8005faa:	4895      	ldr	r0, [pc, #596]	; (8006200 <TestThread+0x2a0>)
 8005fac:	4d95      	ldr	r5, [pc, #596]	; (8006204 <TestThread+0x2a4>)
 8005fae:	f7ff fecf 	bl	8005d50 <test_println>
 8005fb2:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005fb4:	6820      	ldr	r0, [r4, #0]
 8005fb6:	6803      	ldr	r3, [r0, #0]
 8005fb8:	689b      	ldr	r3, [r3, #8]
 8005fba:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005fbc:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005fc0:	2900      	cmp	r1, #0
 8005fc2:	d1f7      	bne.n	8005fb4 <TestThread+0x54>
  test_println(CH_KERNEL_VERSION);
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
  test_println(PORT_COMPILER_NAME);
 8005fc4:	4890      	ldr	r0, [pc, #576]	; (8006208 <TestThread+0x2a8>)
 8005fc6:	4d91      	ldr	r5, [pc, #580]	; (800620c <TestThread+0x2ac>)
 8005fc8:	f7ff fec2 	bl	8005d50 <test_println>
 8005fcc:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005fce:	6820      	ldr	r0, [r4, #0]
 8005fd0:	6803      	ldr	r3, [r0, #0]
 8005fd2:	689b      	ldr	r3, [r3, #8]
 8005fd4:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005fd6:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005fda:	2900      	cmp	r1, #0
 8005fdc:	d1f7      	bne.n	8005fce <TestThread+0x6e>
#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
  test_println(PORT_COMPILER_NAME);
#endif
  test_print("*** Architecture: ");
  test_println(PORT_ARCHITECTURE_NAME);
 8005fde:	488c      	ldr	r0, [pc, #560]	; (8006210 <TestThread+0x2b0>)
 8005fe0:	4d8c      	ldr	r5, [pc, #560]	; (8006214 <TestThread+0x2b4>)
 8005fe2:	f7ff feb5 	bl	8005d50 <test_println>
 8005fe6:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8005fe8:	6820      	ldr	r0, [r4, #0]
 8005fea:	6803      	ldr	r3, [r0, #0]
 8005fec:	689b      	ldr	r3, [r3, #8]
 8005fee:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005ff0:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8005ff4:	2900      	cmp	r1, #0
 8005ff6:	d1f7      	bne.n	8005fe8 <TestThread+0x88>
#endif
  test_print("*** Architecture: ");
  test_println(PORT_ARCHITECTURE_NAME);
#ifdef PORT_CORE_VARIANT_NAME
  test_print("*** Core Variant: ");
  test_println(PORT_CORE_VARIANT_NAME);
 8005ff8:	4887      	ldr	r0, [pc, #540]	; (8006218 <TestThread+0x2b8>)
 8005ffa:	4d88      	ldr	r5, [pc, #544]	; (800621c <TestThread+0x2bc>)
 8005ffc:	f7ff fea8 	bl	8005d50 <test_println>
 8006000:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8006002:	6820      	ldr	r0, [r4, #0]
 8006004:	6803      	ldr	r3, [r0, #0]
 8006006:	689b      	ldr	r3, [r3, #8]
 8006008:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 800600a:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 800600e:	2900      	cmp	r1, #0
 8006010:	d1f7      	bne.n	8006002 <TestThread+0xa2>
  test_print("*** Core Variant: ");
  test_println(PORT_CORE_VARIANT_NAME);
#endif
#ifdef PORT_INFO
  test_print("*** Port Info:    ");
  test_println(PORT_INFO);
 8006012:	4883      	ldr	r0, [pc, #524]	; (8006220 <TestThread+0x2c0>)
 8006014:	4d83      	ldr	r5, [pc, #524]	; (8006224 <TestThread+0x2c4>)
 8006016:	f7ff fe9b 	bl	8005d50 <test_println>
 800601a:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 800601c:	6820      	ldr	r0, [r4, #0]
 800601e:	6803      	ldr	r3, [r0, #0]
 8006020:	689b      	ldr	r3, [r3, #8]
 8006022:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006024:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8006028:	2900      	cmp	r1, #0
 800602a:	d1f7      	bne.n	800601c <TestThread+0xbc>
  test_print("*** Port Info:    ");
  test_println(PORT_INFO);
#endif
#ifdef PLATFORM_NAME
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
 800602c:	487e      	ldr	r0, [pc, #504]	; (8006228 <TestThread+0x2c8>)
 800602e:	4d7f      	ldr	r5, [pc, #508]	; (800622c <TestThread+0x2cc>)
 8006030:	f7ff fe8e 	bl	8005d50 <test_println>
 8006034:	212a      	movs	r1, #42	; 0x2a
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8006036:	6820      	ldr	r0, [r4, #0]
 8006038:	6803      	ldr	r3, [r0, #0]
 800603a:	689b      	ldr	r3, [r3, #8]
 800603c:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 800603e:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8006042:	2900      	cmp	r1, #0
 8006044:	d1f7      	bne.n	8006036 <TestThread+0xd6>
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
#endif
#ifdef BOARD_NAME
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
 8006046:	487a      	ldr	r0, [pc, #488]	; (8006230 <TestThread+0x2d0>)
 8006048:	9100      	str	r1, [sp, #0]
 800604a:	f7ff fe81 	bl	8005d50 <test_println>
#endif
  test_println("");
 800604e:	4866      	ldr	r0, [pc, #408]	; (80061e8 <TestThread+0x288>)
 8006050:	f7ff fe7e 	bl	8005d50 <test_println>

  test_global_fail = FALSE;
 8006054:	4b77      	ldr	r3, [pc, #476]	; (8006234 <TestThread+0x2d4>)
 8006056:	9900      	ldr	r1, [sp, #0]
 8006058:	4f77      	ldr	r7, [pc, #476]	; (8006238 <TestThread+0x2d8>)
 800605a:	7019      	strb	r1, [r3, #0]
 800605c:	4b77      	ldr	r3, [pc, #476]	; (800623c <TestThread+0x2dc>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 800605e:	f8df b184 	ldr.w	fp, [pc, #388]	; 80061e4 <TestThread+0x284>
 8006062:	9301      	str	r3, [sp, #4]
 8006064:	9b00      	ldr	r3, [sp, #0]
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 8006066:	2600      	movs	r6, #0
 8006068:	3301      	adds	r3, #1
 800606a:	9300      	str	r3, [sp, #0]

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
 800606c:	f857 3026 	ldr.w	r3, [r7, r6, lsl #2]
 8006070:	eb07 0886 	add.w	r8, r7, r6, lsl #2
 8006074:	2b00      	cmp	r3, #0
 8006076:	f000 808b 	beq.w	8006190 <TestThread+0x230>
      print_line();
 800607a:	4d71      	ldr	r5, [pc, #452]	; (8006240 <TestThread+0x2e0>)
 800607c:	f7ff fe10 	bl	8005ca0 <print_line>
 8006080:	212d      	movs	r1, #45	; 0x2d
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8006082:	6820      	ldr	r0, [r4, #0]
 8006084:	6803      	ldr	r3, [r0, #0]
 8006086:	689b      	ldr	r3, [r3, #8]
 8006088:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 800608a:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 800608e:	2900      	cmp	r1, #0
 8006090:	d1f7      	bne.n	8006082 <TestThread+0x122>
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
 8006092:	9800      	ldr	r0, [sp, #0]
 8006094:	f7ff fe1c 	bl	8005cd0 <test_printn>
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8006098:	f8db 0000 	ldr.w	r0, [fp]
 800609c:	212e      	movs	r1, #46	; 0x2e
 800609e:	6803      	ldr	r3, [r0, #0]
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 80060a0:	3601      	adds	r6, #1
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 80060a2:	689b      	ldr	r3, [r3, #8]
 80060a4:	4798      	blx	r3
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 80060a6:	4d67      	ldr	r5, [pc, #412]	; (8006244 <TestThread+0x2e4>)
 80060a8:	4630      	mov	r0, r6
 80060aa:	f7ff fe11 	bl	8005cd0 <test_printn>
 80060ae:	2120      	movs	r1, #32
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 80060b0:	6820      	ldr	r0, [r4, #0]
 80060b2:	6803      	ldr	r3, [r0, #0]
 80060b4:	689b      	ldr	r3, [r3, #8]
 80060b6:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80060b8:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 80060bc:	2900      	cmp	r1, #0
 80060be:	d1f7      	bne.n	80060b0 <TestThread+0x150>
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(patterns[i][j]->name);
 80060c0:	f8d8 3000 	ldr.w	r3, [r8]
 80060c4:	681d      	ldr	r5, [r3, #0]
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80060c6:	7829      	ldrb	r1, [r5, #0]
 80060c8:	b139      	cbz	r1, 80060da <TestThread+0x17a>
    chSequentialStreamPut(chp, *msgp++);
 80060ca:	6820      	ldr	r0, [r4, #0]
 80060cc:	6803      	ldr	r3, [r0, #0]
 80060ce:	689b      	ldr	r3, [r3, #8]
 80060d0:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80060d2:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 80060d6:	2900      	cmp	r1, #0
 80060d8:	d1f7      	bne.n	80060ca <TestThread+0x16a>
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(patterns[i][j]->name);
      test_println(")");
 80060da:	485b      	ldr	r0, [pc, #364]	; (8006248 <TestThread+0x2e8>)
 80060dc:	f7ff fe38 	bl	8005d50 <test_println>
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
 80060e0:	f44f 70c8 	mov.w	r0, #400	; 0x190
 80060e4:	f7fb fd54 	bl	8001b90 <chThdSleep>

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
  for (i = 0; i < MAX_THREADS; i++)
    threads[i] = NULL;
 80060e8:	4a58      	ldr	r2, [pc, #352]	; (800624c <TestThread+0x2ec>)
      test_print(patterns[i][j]->name);
      test_println(")");
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
 80060ea:	f8d8 a000 	ldr.w	sl, [r8]
static void execute_test(const struct testcase *tcp) {
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
 80060ee:	2300      	movs	r3, #0
  for (i = 0; i < MAX_THREADS; i++)
    threads[i] = NULL;
 80060f0:	6013      	str	r3, [r2, #0]
 80060f2:	6053      	str	r3, [r2, #4]
 80060f4:	6093      	str	r3, [r2, #8]
 80060f6:	60d3      	str	r3, [r2, #12]
 80060f8:	6113      	str	r3, [r2, #16]
static void execute_test(const struct testcase *tcp) {
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
 80060fa:	f8df 817c 	ldr.w	r8, [pc, #380]	; 8006278 <TestThread+0x318>
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 80060fe:	4d54      	ldr	r5, [pc, #336]	; (8006250 <TestThread+0x2f0>)
 8006100:	f8df 915c 	ldr.w	r9, [pc, #348]	; 8006260 <TestThread+0x300>
  clear_tokens();
  local_fail = FALSE;
  for (i = 0; i < MAX_THREADS; i++)
    threads[i] = NULL;

  if (tcp->setup != NULL)
 8006104:	f8da 2004 	ldr.w	r2, [sl, #4]
static void execute_test(const struct testcase *tcp) {
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
 8006108:	f888 3000 	strb.w	r3, [r8]
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 800610c:	f8c5 9000 	str.w	r9, [r5]
  clear_tokens();
  local_fail = FALSE;
  for (i = 0; i < MAX_THREADS; i++)
    threads[i] = NULL;

  if (tcp->setup != NULL)
 8006110:	b102      	cbz	r2, 8006114 <TestThread+0x1b4>
    tcp->setup();
 8006112:	4790      	blx	r2
  tcp->execute();
 8006114:	f8da 300c 	ldr.w	r3, [sl, #12]
 8006118:	4798      	blx	r3
  if (tcp->teardown != NULL)
 800611a:	f8da 3008 	ldr.w	r3, [sl, #8]
 800611e:	b103      	cbz	r3, 8006122 <TestThread+0x1c2>
    tcp->teardown();
 8006120:	4798      	blx	r3

  test_wait_threads();
 8006122:	f7ff fec5 	bl	8005eb0 <test_wait_threads>
      test_println(")");
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
      if (local_fail) {
 8006126:	f898 3000 	ldrb.w	r3, [r8]
 800612a:	2b00      	cmp	r3, #0
 800612c:	d04f      	beq.n	80061ce <TestThread+0x26e>
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 800612e:	4f49      	ldr	r7, [pc, #292]	; (8006254 <TestThread+0x2f4>)
 8006130:	212d      	movs	r1, #45	; 0x2d
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8006132:	6820      	ldr	r0, [r4, #0]
 8006134:	6803      	ldr	r3, [r0, #0]
 8006136:	689b      	ldr	r3, [r3, #8]
 8006138:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 800613a:	f817 1f01 	ldrb.w	r1, [r7, #1]!
 800613e:	2900      	cmp	r1, #0
 8006140:	d1f7      	bne.n	8006132 <TestThread+0x1d2>
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
      if (local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(failpoint);
 8006142:	4b45      	ldr	r3, [pc, #276]	; (8006258 <TestThread+0x2f8>)
 8006144:	4f45      	ldr	r7, [pc, #276]	; (800625c <TestThread+0x2fc>)
 8006146:	6818      	ldr	r0, [r3, #0]
 8006148:	f7ff fdc2 	bl	8005cd0 <test_printn>
 800614c:	2120      	movs	r1, #32
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 800614e:	6820      	ldr	r0, [r4, #0]
 8006150:	6803      	ldr	r3, [r0, #0]
 8006152:	689b      	ldr	r3, [r3, #8]
 8006154:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006156:	f817 1f01 	ldrb.w	r1, [r7, #1]!
 800615a:	2900      	cmp	r1, #0
 800615c:	d1f7      	bne.n	800614e <TestThread+0x1ee>
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 800615e:	682b      	ldr	r3, [r5, #0]
 8006160:	454b      	cmp	r3, r9
 8006162:	d909      	bls.n	8006178 <TestThread+0x218>
 8006164:	4f3e      	ldr	r7, [pc, #248]	; (8006260 <TestThread+0x300>)
    chSequentialStreamPut(chp, *cp++);
 8006166:	6820      	ldr	r0, [r4, #0]
 8006168:	f817 1b01 	ldrb.w	r1, [r7], #1
 800616c:	6803      	ldr	r3, [r0, #0]
 800616e:	689b      	ldr	r3, [r3, #8]
 8006170:	4798      	blx	r3
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 8006172:	682b      	ldr	r3, [r5, #0]
 8006174:	429f      	cmp	r7, r3
 8006176:	d3f6      	bcc.n	8006166 <TestThread+0x206>
      if (local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(failpoint);
        test_print(" [");
        print_tokens();
        test_println("])");
 8006178:	483a      	ldr	r0, [pc, #232]	; (8006264 <TestThread+0x304>)
 800617a:	f7ff fde9 	bl	8005d50 <test_println>
 800617e:	9b01      	ldr	r3, [sp, #4]
 8006180:	681f      	ldr	r7, [r3, #0]

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
 8006182:	f857 3026 	ldr.w	r3, [r7, r6, lsl #2]
 8006186:	eb07 0886 	add.w	r8, r7, r6, lsl #2
 800618a:	2b00      	cmp	r3, #0
 800618c:	f47f af75 	bne.w	800607a <TestThread+0x11a>
#endif
  test_println("");

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
 8006190:	9b01      	ldr	r3, [sp, #4]
 8006192:	f853 7f04 	ldr.w	r7, [r3, #4]!
 8006196:	9301      	str	r3, [sp, #4]
 8006198:	2f00      	cmp	r7, #0
 800619a:	f47f af63 	bne.w	8006064 <TestThread+0x104>
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
  }
  print_line();
 800619e:	f7ff fd7f 	bl	8005ca0 <print_line>
  test_println("");
 80061a2:	4d31      	ldr	r5, [pc, #196]	; (8006268 <TestThread+0x308>)
 80061a4:	4810      	ldr	r0, [pc, #64]	; (80061e8 <TestThread+0x288>)
 80061a6:	f7ff fdd3 	bl	8005d50 <test_println>
 80061aa:	2146      	movs	r1, #70	; 0x46
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 80061ac:	6820      	ldr	r0, [r4, #0]
 80061ae:	6803      	ldr	r3, [r0, #0]
 80061b0:	689b      	ldr	r3, [r3, #8]
 80061b2:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80061b4:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 80061b8:	2900      	cmp	r1, #0
 80061ba:	d1f7      	bne.n	80061ac <TestThread+0x24c>
    i++;
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
 80061bc:	4b1d      	ldr	r3, [pc, #116]	; (8006234 <TestThread+0x2d4>)
 80061be:	781b      	ldrb	r3, [r3, #0]
 80061c0:	b94b      	cbnz	r3, 80061d6 <TestThread+0x276>
    test_println("FAILURE");
  else
    test_println("SUCCESS");
 80061c2:	482a      	ldr	r0, [pc, #168]	; (800626c <TestThread+0x30c>)
}
 80061c4:	b003      	add	sp, #12
 80061c6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
    test_println("FAILURE");
  else
    test_println("SUCCESS");
 80061ca:	f7ff bdc1 	b.w	8005d50 <test_println>
        test_print(" [");
        print_tokens();
        test_println("])");
      }
      else
        test_println("--- Result: SUCCESS");
 80061ce:	4828      	ldr	r0, [pc, #160]	; (8006270 <TestThread+0x310>)
 80061d0:	f7ff fdbe 	bl	8005d50 <test_println>
 80061d4:	e74a      	b.n	800606c <TestThread+0x10c>
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
    test_println("FAILURE");
 80061d6:	4827      	ldr	r0, [pc, #156]	; (8006274 <TestThread+0x314>)
  else
    test_println("SUCCESS");
}
 80061d8:	b003      	add	sp, #12
 80061da:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
    test_println("FAILURE");
  else
    test_println("SUCCESS");
 80061de:	f7ff bdb7 	b.w	8005d50 <test_println>
 80061e2:	bf00      	nop
 80061e4:	20001c6c 	.word	0x20001c6c
 80061e8:	0800e534 	.word	0x0800e534
 80061ec:	0800d8d0 	.word	0x0800d8d0
 80061f0:	0800d7f0 	.word	0x0800d7f0
 80061f4:	0800d8ec 	.word	0x0800d8ec
 80061f8:	0800d914 	.word	0x0800d914
 80061fc:	0800d804 	.word	0x0800d804
 8006200:	0800d91c 	.word	0x0800d91c
 8006204:	0800d818 	.word	0x0800d818
 8006208:	0800d934 	.word	0x0800d934
 800620c:	0800d82c 	.word	0x0800d82c
 8006210:	0800d97c 	.word	0x0800d97c
 8006214:	0800d840 	.word	0x0800d840
 8006218:	0800d984 	.word	0x0800d984
 800621c:	0800d854 	.word	0x0800d854
 8006220:	0800d990 	.word	0x0800d990
 8006224:	0800d868 	.word	0x0800d868
 8006228:	0800d9a8 	.word	0x0800d9a8
 800622c:	0800d87c 	.word	0x0800d87c
 8006230:	0800d9d0 	.word	0x0800d9d0
 8006234:	20001c80 	.word	0x20001c80
 8006238:	0800dfe0 	.word	0x0800dfe0
 800623c:	0800d7b0 	.word	0x0800d7b0
 8006240:	0800d890 	.word	0x0800d890
 8006244:	0800d8a0 	.word	0x0800d8a0
 8006248:	0800d8f0 	.word	0x0800d8f0
 800624c:	20001c58 	.word	0x20001c58
 8006250:	20001c40 	.word	0x20001c40
 8006254:	0800d8a4 	.word	0x0800d8a4
 8006258:	20001c38 	.word	0x20001c38
 800625c:	0800d8bc 	.word	0x0800d8bc
 8006260:	20001c70 	.word	0x20001c70
 8006264:	0800d8f4 	.word	0x0800d8f4
 8006268:	0800d8c0 	.word	0x0800d8c0
 800626c:	0800d904 	.word	0x0800d904
 8006270:	0800d8f8 	.word	0x0800d8f8
 8006274:	0800d90c 	.word	0x0800d90c
 8006278:	20001c3c 	.word	0x20001c3c
 800627c:	00000000 	.word	0x00000000

08006280 <thd1_execute>:
static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
}

static void thd1_execute(void) {
 8006280:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006282:	4f27      	ldr	r7, [pc, #156]	; (8006320 <thd1_execute+0xa0>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8006284:	4e27      	ldr	r6, [pc, #156]	; (8006324 <thd1_execute+0xa4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8006286:	693b      	ldr	r3, [r7, #16]
 8006288:	4d27      	ldr	r5, [pc, #156]	; (8006328 <thd1_execute+0xa8>)
 800628a:	689a      	ldr	r2, [r3, #8]
 800628c:	4927      	ldr	r1, [pc, #156]	; (800632c <thd1_execute+0xac>)
static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
}

static void thd1_execute(void) {
 800628e:	b083      	sub	sp, #12

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8006290:	462b      	mov	r3, r5
 8006292:	9100      	str	r1, [sp, #0]
 8006294:	6830      	ldr	r0, [r6, #0]
 8006296:	3a05      	subs	r2, #5
 8006298:	f44f 71a0 	mov.w	r1, #320	; 0x140
 800629c:	f7fb fc08 	bl	8001ab0 <chThdCreateStatic>
 80062a0:	693b      	ldr	r3, [r7, #16]
 80062a2:	4c23      	ldr	r4, [pc, #140]	; (8006330 <thd1_execute+0xb0>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80062a4:	689a      	ldr	r2, [r3, #8]
 80062a6:	4923      	ldr	r1, [pc, #140]	; (8006334 <thd1_execute+0xb4>)
 80062a8:	6873      	ldr	r3, [r6, #4]
  test_emit_token(*(char *)p);
}

static void thd1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80062aa:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80062ac:	9100      	str	r1, [sp, #0]
 80062ae:	3a04      	subs	r2, #4
 80062b0:	4618      	mov	r0, r3
 80062b2:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80062b6:	462b      	mov	r3, r5
 80062b8:	f7fb fbfa 	bl	8001ab0 <chThdCreateStatic>
 80062bc:	693a      	ldr	r2, [r7, #16]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80062be:	68b3      	ldr	r3, [r6, #8]
 80062c0:	6892      	ldr	r2, [r2, #8]
 80062c2:	491d      	ldr	r1, [pc, #116]	; (8006338 <thd1_execute+0xb8>)
}

static void thd1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80062c4:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80062c6:	9100      	str	r1, [sp, #0]
 80062c8:	3a03      	subs	r2, #3
 80062ca:	4618      	mov	r0, r3
 80062cc:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80062d0:	462b      	mov	r3, r5
 80062d2:	f7fb fbed 	bl	8001ab0 <chThdCreateStatic>
 80062d6:	693a      	ldr	r2, [r7, #16]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 80062d8:	68f3      	ldr	r3, [r6, #12]
 80062da:	6892      	ldr	r2, [r2, #8]
 80062dc:	4917      	ldr	r1, [pc, #92]	; (800633c <thd1_execute+0xbc>)

static void thd1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80062de:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 80062e0:	9100      	str	r1, [sp, #0]
 80062e2:	3a02      	subs	r2, #2
 80062e4:	4618      	mov	r0, r3
 80062e6:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80062ea:	462b      	mov	r3, r5
 80062ec:	f7fb fbe0 	bl	8001ab0 <chThdCreateStatic>
 80062f0:	693a      	ldr	r2, [r7, #16]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 80062f2:	6933      	ldr	r3, [r6, #16]
 80062f4:	6892      	ldr	r2, [r2, #8]
 80062f6:	4912      	ldr	r1, [pc, #72]	; (8006340 <thd1_execute+0xc0>)
static void thd1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 80062f8:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 80062fa:	3a01      	subs	r2, #1
 80062fc:	9100      	str	r1, [sp, #0]
 80062fe:	4618      	mov	r0, r3
 8006300:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8006304:	462b      	mov	r3, r5
 8006306:	f7fb fbd3 	bl	8001ab0 <chThdCreateStatic>
 800630a:	6120      	str	r0, [r4, #16]
  test_wait_threads();
 800630c:	f7ff fdd0 	bl	8005eb0 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8006310:	490c      	ldr	r1, [pc, #48]	; (8006344 <thd1_execute+0xc4>)
 8006312:	2001      	movs	r0, #1
}
 8006314:	b003      	add	sp, #12
 8006316:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
 800631a:	f7ff bd69 	b.w	8005df0 <_test_assert_sequence>
 800631e:	bf00      	nop
 8006320:	20001160 	.word	0x20001160
 8006324:	0800d790 	.word	0x0800d790
 8006328:	08006351 	.word	0x08006351
 800632c:	0800da54 	.word	0x0800da54
 8006330:	20001c58 	.word	0x20001c58
 8006334:	0800da40 	.word	0x0800da40
 8006338:	0800da44 	.word	0x0800da44
 800633c:	0800da48 	.word	0x0800da48
 8006340:	0800da4c 	.word	0x0800da4c
 8006344:	0800da50 	.word	0x0800da50
	...

08006350 <thread>:
 * priority order regardless of the initial order.
 */

static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
 8006350:	7800      	ldrb	r0, [r0, #0]
 8006352:	f7ff bd1d 	b.w	8005d90 <test_emit_token>
 8006356:	bf00      	nop
	...

08006360 <thd2_execute>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 8006360:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8006362:	4f2b      	ldr	r7, [pc, #172]	; (8006410 <thd2_execute+0xb0>)

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8006364:	4e2b      	ldr	r6, [pc, #172]	; (8006414 <thd2_execute+0xb4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8006366:	693b      	ldr	r3, [r7, #16]
 8006368:	4d2b      	ldr	r5, [pc, #172]	; (8006418 <thd2_execute+0xb8>)
 800636a:	689a      	ldr	r2, [r3, #8]
 800636c:	492b      	ldr	r1, [pc, #172]	; (800641c <thd2_execute+0xbc>)
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 800636e:	b083      	sub	sp, #12

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8006370:	462b      	mov	r3, r5
 8006372:	9100      	str	r1, [sp, #0]
 8006374:	6870      	ldr	r0, [r6, #4]
 8006376:	3a04      	subs	r2, #4
 8006378:	f44f 71a0 	mov.w	r1, #320	; 0x140
 800637c:	f7fb fb98 	bl	8001ab0 <chThdCreateStatic>
 8006380:	693b      	ldr	r3, [r7, #16]
 8006382:	4c27      	ldr	r4, [pc, #156]	; (8006420 <thd2_execute+0xc0>)
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8006384:	689a      	ldr	r2, [r3, #8]
 8006386:	4927      	ldr	r1, [pc, #156]	; (8006424 <thd2_execute+0xc4>)
 8006388:	6833      	ldr	r3, [r6, #0]
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800638a:	6060      	str	r0, [r4, #4]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800638c:	9100      	str	r1, [sp, #0]
 800638e:	3a05      	subs	r2, #5
 8006390:	4618      	mov	r0, r3
 8006392:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8006396:	462b      	mov	r3, r5
 8006398:	f7fb fb8a 	bl	8001ab0 <chThdCreateStatic>
 800639c:	693a      	ldr	r2, [r7, #16]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800639e:	6933      	ldr	r3, [r6, #16]
 80063a0:	6892      	ldr	r2, [r2, #8]
 80063a2:	4921      	ldr	r1, [pc, #132]	; (8006428 <thd2_execute+0xc8>)
 */

static void thd2_execute(void) {

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80063a4:	6020      	str	r0, [r4, #0]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 80063a6:	9100      	str	r1, [sp, #0]
 80063a8:	3a01      	subs	r2, #1
 80063aa:	4618      	mov	r0, r3
 80063ac:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80063b0:	462b      	mov	r3, r5
 80063b2:	f7fb fb7d 	bl	8001ab0 <chThdCreateStatic>
 80063b6:	693a      	ldr	r2, [r7, #16]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 80063b8:	68f3      	ldr	r3, [r6, #12]
 80063ba:	6892      	ldr	r2, [r2, #8]
 80063bc:	491b      	ldr	r1, [pc, #108]	; (800642c <thd2_execute+0xcc>)

static void thd2_execute(void) {

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 80063be:	6120      	str	r0, [r4, #16]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 80063c0:	9100      	str	r1, [sp, #0]
 80063c2:	3a02      	subs	r2, #2
 80063c4:	4618      	mov	r0, r3
 80063c6:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80063ca:	462b      	mov	r3, r5
 80063cc:	f7fb fb70 	bl	8001ab0 <chThdCreateStatic>
 80063d0:	2320      	movs	r3, #32
 80063d2:	60e0      	str	r0, [r4, #12]
 80063d4:	f383 8811 	msr	BASEPRI, r3
 80063d8:	693b      	ldr	r3, [r7, #16]
  /* Done this way for coverage of chThdCreateI() and chThdStart().*/
  chSysLock();
  threads[2] = chThdCreateI(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80063da:	4915      	ldr	r1, [pc, #84]	; (8006430 <thd2_execute+0xd0>)
 80063dc:	689a      	ldr	r2, [r3, #8]
 80063de:	68b0      	ldr	r0, [r6, #8]
 80063e0:	462b      	mov	r3, r5
 80063e2:	9100      	str	r1, [sp, #0]
 80063e4:	3a03      	subs	r2, #3
 80063e6:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80063ea:	f7fb fb39 	bl	8001a60 <chThdCreateI>
 80063ee:	2300      	movs	r3, #0
 80063f0:	60a0      	str	r0, [r4, #8]
 80063f2:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  chThdStart(threads[2]);
 80063f6:	68a0      	ldr	r0, [r4, #8]
 80063f8:	f7fb fb92 	bl	8001b20 <chThdStart>
  test_wait_threads();
 80063fc:	f7ff fd58 	bl	8005eb0 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8006400:	490c      	ldr	r1, [pc, #48]	; (8006434 <thd2_execute+0xd4>)
 8006402:	2001      	movs	r0, #1
}
 8006404:	b003      	add	sp, #12
 8006406:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  chSysLock();
  threads[2] = chThdCreateI(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
  chSysUnlock();
  chThdStart(threads[2]);
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
 800640a:	f7ff bcf1 	b.w	8005df0 <_test_assert_sequence>
 800640e:	bf00      	nop
 8006410:	20001160 	.word	0x20001160
 8006414:	0800d790 	.word	0x0800d790
 8006418:	08006351 	.word	0x08006351
 800641c:	0800da40 	.word	0x0800da40
 8006420:	20001c58 	.word	0x20001c58
 8006424:	0800da54 	.word	0x0800da54
 8006428:	0800da4c 	.word	0x0800da4c
 800642c:	0800da48 	.word	0x0800da48
 8006430:	0800da44 	.word	0x0800da44
 8006434:	0800da50 	.word	0x0800da50
	...

08006440 <thd3_execute>:
 * to verify that the priority change happens as expected.<br>
 * If the @p CH_CFG_USE_MUTEXES option is enabled then the priority changes are
 * also tested under priority inheritance boosted priority state.
 */

static void thd3_execute(void) {
 8006440:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8006442:	4e49      	ldr	r6, [pc, #292]	; (8006568 <thd3_execute+0x128>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8006444:	6933      	ldr	r3, [r6, #16]
 8006446:	689c      	ldr	r4, [r3, #8]
  tprio_t prio, p1;

  prio = chThdGetPriorityX();
  p1 = chThdSetPriority(prio + 1);
 8006448:	1c65      	adds	r5, r4, #1
 800644a:	4628      	mov	r0, r5
 800644c:	f7fb fb78 	bl	8001b40 <chThdSetPriority>
 8006450:	4607      	mov	r7, r0
  test_assert(1, p1 == prio,
 8006452:	1b39      	subs	r1, r7, r4
 8006454:	fab1 f181 	clz	r1, r1
 8006458:	2001      	movs	r0, #1
 800645a:	0949      	lsrs	r1, r1, #5
 800645c:	f7ff fcb0 	bl	8005dc0 <_test_assert>
 8006460:	b100      	cbz	r0, 8006464 <thd3_execute+0x24>
 8006462:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006464:	6933      	ldr	r3, [r6, #16]
              "unexpected returned priority level");
  test_assert(2, chThdGetPriorityX() == prio + 1,
 8006466:	2002      	movs	r0, #2
 8006468:	6899      	ldr	r1, [r3, #8]
 800646a:	1a69      	subs	r1, r5, r1
 800646c:	fab1 f181 	clz	r1, r1
 8006470:	0949      	lsrs	r1, r1, #5
 8006472:	f7ff fca5 	bl	8005dc0 <_test_assert>
 8006476:	2800      	cmp	r0, #0
 8006478:	d1f3      	bne.n	8006462 <thd3_execute+0x22>
              "unexpected priority level");
  p1 = chThdSetPriority(p1);
 800647a:	4638      	mov	r0, r7
 800647c:	f7fb fb60 	bl	8001b40 <chThdSetPriority>
  test_assert(3, p1 == prio + 1,
 8006480:	1a29      	subs	r1, r5, r0
 8006482:	fab1 f181 	clz	r1, r1
 8006486:	2003      	movs	r0, #3
 8006488:	0949      	lsrs	r1, r1, #5
 800648a:	f7ff fc99 	bl	8005dc0 <_test_assert>
 800648e:	2800      	cmp	r0, #0
 8006490:	d1e7      	bne.n	8006462 <thd3_execute+0x22>
 8006492:	6933      	ldr	r3, [r6, #16]
              "unexpected returned priority level");
  test_assert(4, chThdGetPriorityX() == prio,
 8006494:	2004      	movs	r0, #4
 8006496:	6899      	ldr	r1, [r3, #8]
 8006498:	1a61      	subs	r1, r4, r1
 800649a:	fab1 f181 	clz	r1, r1
 800649e:	0949      	lsrs	r1, r1, #5
 80064a0:	f7ff fc8e 	bl	8005dc0 <_test_assert>
 80064a4:	2800      	cmp	r0, #0
 80064a6:	d1dc      	bne.n	8006462 <thd3_execute+0x22>
 80064a8:	2320      	movs	r3, #32
 80064aa:	f383 8811 	msr	BASEPRI, r3
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80064ae:	6932      	ldr	r2, [r6, #16]
              "unexpected priority level");

#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  /* Simulates a priority boost situation (p_prio > p_realprio).*/
  chSysLock();
  chThdGetSelfX()->p_prio += 2;
 80064b0:	6893      	ldr	r3, [r2, #8]
 80064b2:	3302      	adds	r3, #2
 80064b4:	6093      	str	r3, [r2, #8]
 80064b6:	f380 8811 	msr	BASEPRI, r0
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80064ba:	6933      	ldr	r3, [r6, #16]
  chSysUnlock();
  test_assert(5, chThdGetPriorityX() == prio + 2,
 80064bc:	1ca7      	adds	r7, r4, #2
 80064be:	6899      	ldr	r1, [r3, #8]
 80064c0:	2005      	movs	r0, #5
 80064c2:	1a79      	subs	r1, r7, r1
 80064c4:	fab1 f181 	clz	r1, r1
 80064c8:	0949      	lsrs	r1, r1, #5
 80064ca:	f7ff fc79 	bl	8005dc0 <_test_assert>
 80064ce:	2800      	cmp	r0, #0
 80064d0:	d1c7      	bne.n	8006462 <thd3_execute+0x22>
              "unexpected priority level");

  /* Tries to raise but below the boost level. */
  p1 = chThdSetPriority(prio + 1);
 80064d2:	4628      	mov	r0, r5
 80064d4:	f7fb fb34 	bl	8001b40 <chThdSetPriority>
  test_assert(6, p1 == prio,
 80064d8:	1b01      	subs	r1, r0, r4
 80064da:	fab1 f181 	clz	r1, r1
 80064de:	2006      	movs	r0, #6
 80064e0:	0949      	lsrs	r1, r1, #5
 80064e2:	f7ff fc6d 	bl	8005dc0 <_test_assert>
 80064e6:	2800      	cmp	r0, #0
 80064e8:	d1bb      	bne.n	8006462 <thd3_execute+0x22>
              "unexpected returned priority level");
  test_assert(7, chThdGetSelfX()->p_prio == prio + 2,
 80064ea:	6933      	ldr	r3, [r6, #16]
 80064ec:	2007      	movs	r0, #7
 80064ee:	6899      	ldr	r1, [r3, #8]
 80064f0:	1a79      	subs	r1, r7, r1
 80064f2:	fab1 f181 	clz	r1, r1
 80064f6:	0949      	lsrs	r1, r1, #5
 80064f8:	f7ff fc62 	bl	8005dc0 <_test_assert>
 80064fc:	2800      	cmp	r0, #0
 80064fe:	d1b0      	bne.n	8006462 <thd3_execute+0x22>
              "unexpected priority level");
  test_assert(8, chThdGetSelfX()->p_realprio == prio + 1,
 8006500:	6933      	ldr	r3, [r6, #16]
 8006502:	2008      	movs	r0, #8
 8006504:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8006506:	1a69      	subs	r1, r5, r1
 8006508:	fab1 f181 	clz	r1, r1
 800650c:	0949      	lsrs	r1, r1, #5
 800650e:	f7ff fc57 	bl	8005dc0 <_test_assert>
 8006512:	2800      	cmp	r0, #0
 8006514:	d1a5      	bne.n	8006462 <thd3_execute+0x22>
              "unexpected returned real priority level");

  /* Tries to raise above the boost level. */
  p1 = chThdSetPriority(prio + 3);
 8006516:	1ce7      	adds	r7, r4, #3
 8006518:	4638      	mov	r0, r7
 800651a:	f7fb fb11 	bl	8001b40 <chThdSetPriority>
  test_assert(9, p1 == prio + 1,
 800651e:	1a28      	subs	r0, r5, r0
 8006520:	4241      	negs	r1, r0
 8006522:	4141      	adcs	r1, r0
 8006524:	2009      	movs	r0, #9
 8006526:	f7ff fc4b 	bl	8005dc0 <_test_assert>
 800652a:	2800      	cmp	r0, #0
 800652c:	d199      	bne.n	8006462 <thd3_execute+0x22>
              "unexpected returned priority level");
  test_assert(10, chThdGetSelfX()->p_prio == prio + 3,
 800652e:	6933      	ldr	r3, [r6, #16]
 8006530:	200a      	movs	r0, #10
 8006532:	6899      	ldr	r1, [r3, #8]
 8006534:	1a7a      	subs	r2, r7, r1
 8006536:	4251      	negs	r1, r2
 8006538:	4151      	adcs	r1, r2
 800653a:	f7ff fc41 	bl	8005dc0 <_test_assert>
 800653e:	2800      	cmp	r0, #0
 8006540:	d18f      	bne.n	8006462 <thd3_execute+0x22>
              "unexpected priority level");
  test_assert(11, chThdGetSelfX()->p_realprio == prio + 3,
 8006542:	6933      	ldr	r3, [r6, #16]
 8006544:	200b      	movs	r0, #11
 8006546:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8006548:	1a7b      	subs	r3, r7, r1
 800654a:	4259      	negs	r1, r3
 800654c:	4159      	adcs	r1, r3
 800654e:	f7ff fc37 	bl	8005dc0 <_test_assert>
 8006552:	2800      	cmp	r0, #0
 8006554:	d185      	bne.n	8006462 <thd3_execute+0x22>
 8006556:	2320      	movs	r3, #32
 8006558:	f383 8811 	msr	BASEPRI, r3
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800655c:	6933      	ldr	r3, [r6, #16]
              "unexpected real priority level");

  chSysLock();
  chThdGetSelfX()->p_prio = prio;
 800655e:	609c      	str	r4, [r3, #8]
  chThdGetSelfX()->p_realprio = prio;
 8006560:	631c      	str	r4, [r3, #48]	; 0x30
 8006562:	f380 8811 	msr	BASEPRI, r0
 8006566:	e77c      	b.n	8006462 <thd3_execute+0x22>
 8006568:	20001160 	.word	0x20001160
 800656c:	00000000 	.word	0x00000000

08006570 <thd4_execute>:
 * <h2>Description</h2>
 * Delay APIs and associated macros are tested, the invoking thread is verified
 * to wake up at the exact expected time.
 */

static void thd4_execute(void) {
 8006570:	b570      	push	{r4, r5, r6, lr}
  systime_t time;

  test_wait_tick();
 8006572:	f7ff fcb5 	bl	8005ee0 <test_wait_tick>
 8006576:	2620      	movs	r6, #32
 8006578:	f386 8811 	msr	BASEPRI, r6
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 800657c:	4d28      	ldr	r5, [pc, #160]	; (8006620 <thd4_execute+0xb0>)
 800657e:	2300      	movs	r3, #0
 8006580:	8bec      	ldrh	r4, [r5, #30]
 8006582:	b2a4      	uxth	r4, r4
 8006584:	f383 8811 	msr	BASEPRI, r3

  /* Timeouts in microseconds.*/
  time = chVTGetSystemTime();
  chThdSleepMicroseconds(100000);
 8006588:	20c8      	movs	r0, #200	; 0xc8
 800658a:	f7fb fb01 	bl	8001b90 <chThdSleep>
  test_assert_time_window(1,
 800658e:	f104 01c8 	add.w	r1, r4, #200	; 0xc8
 8006592:	f104 02c9 	add.w	r2, r4, #201	; 0xc9
 8006596:	b289      	uxth	r1, r1
 8006598:	b292      	uxth	r2, r2
 800659a:	2001      	movs	r0, #1
 800659c:	f7ff fc50 	bl	8005e40 <_test_assert_time_window>
 80065a0:	b100      	cbz	r0, 80065a4 <thd4_execute+0x34>
 80065a2:	bd70      	pop	{r4, r5, r6, pc}
 80065a4:	f386 8811 	msr	BASEPRI, r6
 80065a8:	8bec      	ldrh	r4, [r5, #30]
 80065aa:	b2a4      	uxth	r4, r4
 80065ac:	f380 8811 	msr	BASEPRI, r0
                          time + US2ST(100000),
                          time + US2ST(100000) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in milliseconds.*/
  time = chVTGetSystemTime();
  chThdSleepMilliseconds(100);
 80065b0:	20c8      	movs	r0, #200	; 0xc8
 80065b2:	f7fb faed 	bl	8001b90 <chThdSleep>
  test_assert_time_window(2,
 80065b6:	f104 01c8 	add.w	r1, r4, #200	; 0xc8
 80065ba:	f104 02c9 	add.w	r2, r4, #201	; 0xc9
 80065be:	b289      	uxth	r1, r1
 80065c0:	b292      	uxth	r2, r2
 80065c2:	2002      	movs	r0, #2
 80065c4:	f7ff fc3c 	bl	8005e40 <_test_assert_time_window>
 80065c8:	2800      	cmp	r0, #0
 80065ca:	d1ea      	bne.n	80065a2 <thd4_execute+0x32>
 80065cc:	f386 8811 	msr	BASEPRI, r6
 80065d0:	8bec      	ldrh	r4, [r5, #30]
 80065d2:	b2a4      	uxth	r4, r4
 80065d4:	f380 8811 	msr	BASEPRI, r0
                          time + MS2ST(100),
                          time + MS2ST(100) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in seconds.*/
  time = chVTGetSystemTime();
  chThdSleepSeconds(1);
 80065d8:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 80065dc:	f7fb fad8 	bl	8001b90 <chThdSleep>
  test_assert_time_window(3,
 80065e0:	f504 61fa 	add.w	r1, r4, #2000	; 0x7d0
 80065e4:	f204 72d1 	addw	r2, r4, #2001	; 0x7d1
 80065e8:	b289      	uxth	r1, r1
 80065ea:	b292      	uxth	r2, r2
 80065ec:	2003      	movs	r0, #3
 80065ee:	f7ff fc27 	bl	8005e40 <_test_assert_time_window>
 80065f2:	2800      	cmp	r0, #0
 80065f4:	d1d5      	bne.n	80065a2 <thd4_execute+0x32>
 80065f6:	f386 8811 	msr	BASEPRI, r6
 80065fa:	8bec      	ldrh	r4, [r5, #30]
 80065fc:	b2a4      	uxth	r4, r4
 80065fe:	f380 8811 	msr	BASEPRI, r0
                          time + S2ST(1),
                          time + S2ST(1) + CH_CFG_ST_TIMEDELTA + 1);

  /* Absolute timelines.*/
  time = chVTGetSystemTime() + MS2ST(100);
 8006602:	f104 05c8 	add.w	r5, r4, #200	; 0xc8
 8006606:	b2ad      	uxth	r5, r5
  chThdSleepUntil(time);
 8006608:	4628      	mov	r0, r5
 800660a:	f7fb fad1 	bl	8001bb0 <chThdSleepUntil>
  test_assert_time_window(4,
 800660e:	f104 02c9 	add.w	r2, r4, #201	; 0xc9
 8006612:	4629      	mov	r1, r5
                          time,
                          time + CH_CFG_ST_TIMEDELTA + 1);
}
 8006614:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
                          time + S2ST(1) + CH_CFG_ST_TIMEDELTA + 1);

  /* Absolute timelines.*/
  time = chVTGetSystemTime() + MS2ST(100);
  chThdSleepUntil(time);
  test_assert_time_window(4,
 8006618:	b292      	uxth	r2, r2
 800661a:	2004      	movs	r0, #4
 800661c:	f7ff bc10 	b.w	8005e40 <_test_assert_time_window>
 8006620:	20001160 	.word	0x20001160
	...

08006630 <sem1_execute>:

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
}

static void sem1_execute(void) {
 8006630:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006634:	4e48      	ldr	r6, [pc, #288]	; (8006758 <sem1_execute+0x128>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8006636:	4c49      	ldr	r4, [pc, #292]	; (800675c <sem1_execute+0x12c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8006638:	6933      	ldr	r3, [r6, #16]
 800663a:	f8d4 9000 	ldr.w	r9, [r4]
 800663e:	689a      	ldr	r2, [r3, #8]
 8006640:	f8df 813c 	ldr.w	r8, [pc, #316]	; 8006780 <sem1_execute+0x150>

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
}

static void sem1_execute(void) {
 8006644:	b083      	sub	sp, #12

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8006646:	3205      	adds	r2, #5
 8006648:	f44f 71a0 	mov.w	r1, #320	; 0x140
 800664c:	4b44      	ldr	r3, [pc, #272]	; (8006760 <sem1_execute+0x130>)
 800664e:	4648      	mov	r0, r9
 8006650:	f8cd 8000 	str.w	r8, [sp]
 8006654:	f7fb fa2c 	bl	8001ab0 <chThdCreateStatic>
 8006658:	6933      	ldr	r3, [r6, #16]
 800665a:	4d42      	ldr	r5, [pc, #264]	; (8006764 <sem1_execute+0x134>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 800665c:	689a      	ldr	r2, [r3, #8]
 800665e:	6861      	ldr	r1, [r4, #4]
 8006660:	4b41      	ldr	r3, [pc, #260]	; (8006768 <sem1_execute+0x138>)
  test_emit_token(*(char *)p);
}

static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8006662:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8006664:	3201      	adds	r2, #1
 8006666:	4608      	mov	r0, r1
 8006668:	9300      	str	r3, [sp, #0]
 800666a:	f44f 71a0 	mov.w	r1, #320	; 0x140
 800666e:	4b3c      	ldr	r3, [pc, #240]	; (8006760 <sem1_execute+0x130>)
 8006670:	f7fb fa1e 	bl	8001ab0 <chThdCreateStatic>
 8006674:	6933      	ldr	r3, [r6, #16]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8006676:	68a1      	ldr	r1, [r4, #8]
 8006678:	689a      	ldr	r2, [r3, #8]
 800667a:	4b3c      	ldr	r3, [pc, #240]	; (800676c <sem1_execute+0x13c>)
}

static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 800667c:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 800667e:	3203      	adds	r2, #3
 8006680:	4608      	mov	r0, r1
 8006682:	9300      	str	r3, [sp, #0]
 8006684:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8006688:	4b35      	ldr	r3, [pc, #212]	; (8006760 <sem1_execute+0x130>)
 800668a:	f7fb fa11 	bl	8001ab0 <chThdCreateStatic>
 800668e:	6933      	ldr	r3, [r6, #16]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8006690:	68e1      	ldr	r1, [r4, #12]
 8006692:	689a      	ldr	r2, [r3, #8]
 8006694:	4b36      	ldr	r3, [pc, #216]	; (8006770 <sem1_execute+0x140>)

static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8006696:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8006698:	3204      	adds	r2, #4
 800669a:	4608      	mov	r0, r1
 800669c:	9300      	str	r3, [sp, #0]
 800669e:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80066a2:	4b2f      	ldr	r3, [pc, #188]	; (8006760 <sem1_execute+0x130>)
 80066a4:	f7fb fa04 	bl	8001ab0 <chThdCreateStatic>
 80066a8:	6933      	ldr	r3, [r6, #16]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 80066aa:	6921      	ldr	r1, [r4, #16]
 80066ac:	689a      	ldr	r2, [r3, #8]
 80066ae:	4b31      	ldr	r3, [pc, #196]	; (8006774 <sem1_execute+0x144>)
 80066b0:	3202      	adds	r2, #2
static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 80066b2:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 80066b4:	9300      	str	r3, [sp, #0]
 80066b6:	4608      	mov	r0, r1
 80066b8:	4b29      	ldr	r3, [pc, #164]	; (8006760 <sem1_execute+0x130>)
 80066ba:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80066be:	f7fb f9f7 	bl	8001ab0 <chThdCreateStatic>
  chSemSignal(&sem1);
 80066c2:	4c2d      	ldr	r4, [pc, #180]	; (8006778 <sem1_execute+0x148>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 80066c4:	6128      	str	r0, [r5, #16]
  chSemSignal(&sem1);
 80066c6:	4620      	mov	r0, r4
 80066c8:	f7fb fc82 	bl	8001fd0 <chSemSignal>
  chSemSignal(&sem1);
 80066cc:	4620      	mov	r0, r4
 80066ce:	f7fb fc7f 	bl	8001fd0 <chSemSignal>
  chSemSignal(&sem1);
 80066d2:	4620      	mov	r0, r4
 80066d4:	f7fb fc7c 	bl	8001fd0 <chSemSignal>
  chSemSignal(&sem1);
 80066d8:	4620      	mov	r0, r4
 80066da:	f7fb fc79 	bl	8001fd0 <chSemSignal>
  chSemSignal(&sem1);
 80066de:	4620      	mov	r0, r4
 80066e0:	f7fb fc76 	bl	8001fd0 <chSemSignal>
  test_wait_threads();
 80066e4:	f7ff fbe4 	bl	8005eb0 <test_wait_threads>
#if CH_CFG_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
 80066e8:	2001      	movs	r0, #1
 80066ea:	4924      	ldr	r1, [pc, #144]	; (800677c <sem1_execute+0x14c>)
 80066ec:	f7ff fb80 	bl	8005df0 <_test_assert_sequence>
 80066f0:	4607      	mov	r7, r0
 80066f2:	b110      	cbz	r0, 80066fa <sem1_execute+0xca>
  chSemAddCounterI(&sem1, 2);
  chSchRescheduleS();
  chSysUnlock();
  test_wait_threads();
  test_assert_lock(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
}
 80066f4:	b003      	add	sp, #12
 80066f6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80066fa:	6933      	ldr	r3, [r6, #16]
#if CH_CFG_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
#endif
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80066fc:	4648      	mov	r0, r9
 80066fe:	689a      	ldr	r2, [r3, #8]
 8006700:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8006704:	3205      	adds	r2, #5
 8006706:	f8cd 8000 	str.w	r8, [sp]
 800670a:	4b15      	ldr	r3, [pc, #84]	; (8006760 <sem1_execute+0x130>)
 800670c:	f7fb f9d0 	bl	8001ab0 <chThdCreateStatic>
 8006710:	2620      	movs	r6, #32
 8006712:	6028      	str	r0, [r5, #0]
 8006714:	f386 8811 	msr	BASEPRI, r6
  chSysLock();
  chSemAddCounterI(&sem1, 2);
 8006718:	2102      	movs	r1, #2
 800671a:	4620      	mov	r0, r4
 800671c:	f7fb fc90 	bl	8002040 <chSemAddCounterI>
  chSchRescheduleS();
 8006720:	f7fb f96e 	bl	8001a00 <chSchRescheduleS>
 8006724:	f387 8811 	msr	BASEPRI, r7
  chSysUnlock();
  test_wait_threads();
 8006728:	f7ff fbc2 	bl	8005eb0 <test_wait_threads>
 800672c:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
 8006730:	68a1      	ldr	r1, [r4, #8]
 8006732:	2002      	movs	r0, #2
 8006734:	f1a1 0101 	sub.w	r1, r1, #1
 8006738:	fab1 f181 	clz	r1, r1
 800673c:	0949      	lsrs	r1, r1, #5
 800673e:	f7ff fb3f 	bl	8005dc0 <_test_assert>
 8006742:	b920      	cbnz	r0, 800674e <sem1_execute+0x11e>
 8006744:	f380 8811 	msr	BASEPRI, r0
}
 8006748:	b003      	add	sp, #12
 800674a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800674e:	f387 8811 	msr	BASEPRI, r7
 8006752:	b003      	add	sp, #12
 8006754:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8006758:	20001160 	.word	0x20001160
 800675c:	0800d790 	.word	0x0800d790
 8006760:	080067b1 	.word	0x080067b1
 8006764:	20001c58 	.word	0x20001c58
 8006768:	0800da48 	.word	0x0800da48
 800676c:	0800da44 	.word	0x0800da44
 8006770:	0800da40 	.word	0x0800da40
 8006774:	0800da54 	.word	0x0800da54
 8006778:	2000082c 	.word	0x2000082c
 800677c:	0800da50 	.word	0x0800da50
 8006780:	0800da4c 	.word	0x0800da4c
	...

08006790 <thread3>:
static void sem3_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static THD_FUNCTION(thread3, p) {
 8006790:	b510      	push	{r4, lr}

  (void)p;
  chSemWait(&sem1);
 8006792:	4c04      	ldr	r4, [pc, #16]	; (80067a4 <thread3+0x14>)
 8006794:	4620      	mov	r0, r4
 8006796:	f7fb fbc3 	bl	8001f20 <chSemWait>
  chSemSignal(&sem1);
 800679a:	4620      	mov	r0, r4
}
 800679c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

static THD_FUNCTION(thread3, p) {

  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
 80067a0:	f7fb bc16 	b.w	8001fd0 <chSemSignal>
 80067a4:	2000082c 	.word	0x2000082c
	...

080067b0 <thread1>:
static void sem1_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static THD_FUNCTION(thread1, p) {
 80067b0:	b510      	push	{r4, lr}
 80067b2:	4604      	mov	r4, r0

  chSemWait(&sem1);
 80067b4:	4803      	ldr	r0, [pc, #12]	; (80067c4 <thread1+0x14>)
 80067b6:	f7fb fbb3 	bl	8001f20 <chSemWait>
  test_emit_token(*(char *)p);
 80067ba:	7820      	ldrb	r0, [r4, #0]
}
 80067bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
}

static THD_FUNCTION(thread1, p) {

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
 80067c0:	f7ff bae6 	b.w	8005d90 <test_emit_token>
 80067c4:	2000082c 	.word	0x2000082c
	...

080067d0 <sem1_setup>:
 * setting.
 */

static void sem1_setup(void) {

  chSemObjectInit(&sem1, 0);
 80067d0:	4801      	ldr	r0, [pc, #4]	; (80067d8 <sem1_setup+0x8>)
 80067d2:	2100      	movs	r1, #0
 80067d4:	f7fb bb74 	b.w	8001ec0 <chSemObjectInit>
 80067d8:	2000082c 	.word	0x2000082c
 80067dc:	00000000 	.word	0x00000000

080067e0 <sem2_setup>:
 * correct after each operation.
 */

static void sem2_setup(void) {

  chSemObjectInit(&sem1, 0);
 80067e0:	4801      	ldr	r0, [pc, #4]	; (80067e8 <sem2_setup+0x8>)
 80067e2:	2100      	movs	r1, #0
 80067e4:	f7fb bb6c 	b.w	8001ec0 <chSemObjectInit>
 80067e8:	2000082c 	.word	0x2000082c
 80067ec:	00000000 	.word	0x00000000

080067f0 <sem3_setup>:
 * correct after each operation.
 */

static void sem3_setup(void) {

  chSemObjectInit(&sem1, 0);
 80067f0:	4801      	ldr	r0, [pc, #4]	; (80067f8 <sem3_setup+0x8>)
 80067f2:	2100      	movs	r1, #0
 80067f4:	f7fb bb64 	b.w	8001ec0 <chSemObjectInit>
 80067f8:	2000082c 	.word	0x2000082c
 80067fc:	00000000 	.word	0x00000000

08006800 <thread2>:
static void sem2_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static THD_FUNCTION(thread2, p) {
 8006800:	b508      	push	{r3, lr}

  (void)p;
  chThdSleepMilliseconds(50);
 8006802:	2064      	movs	r0, #100	; 0x64
 8006804:	f7fb f9c4 	bl	8001b90 <chThdSleep>
 8006808:	2320      	movs	r3, #32
 800680a:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chSemSignalI(&sem1); /* For coverage reasons */
 800680e:	4804      	ldr	r0, [pc, #16]	; (8006820 <thread2+0x20>)
 8006810:	f7fb fbfe 	bl	8002010 <chSemSignalI>
  chSchRescheduleS();
 8006814:	f7fb f8f4 	bl	8001a00 <chSchRescheduleS>
 8006818:	2300      	movs	r3, #0
 800681a:	f383 8811 	msr	BASEPRI, r3
 800681e:	bd08      	pop	{r3, pc}
 8006820:	2000082c 	.word	0x2000082c
	...

08006830 <sem2_execute>:
  chSysUnlock();
}

static void sem2_execute(void) {
 8006830:	b5f0      	push	{r4, r5, r6, r7, lr}
  msg_t msg;

  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
 8006832:	4c4e      	ldr	r4, [pc, #312]	; (800696c <sem2_execute+0x13c>)
  chSemSignalI(&sem1); /* For coverage reasons */
  chSchRescheduleS();
  chSysUnlock();
}

static void sem2_execute(void) {
 8006834:	b083      	sub	sp, #12
  msg_t msg;

  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
 8006836:	2100      	movs	r1, #0
 8006838:	4620      	mov	r0, r4
 800683a:	f7fb fbb9 	bl	8001fb0 <chSemWaitTimeout>
  test_assert(1, msg == MSG_TIMEOUT, "wrong wake-up message");
 800683e:	f1a0 31ff 	sub.w	r1, r0, #4294967295
 8006842:	fab1 f181 	clz	r1, r1
 8006846:	2001      	movs	r0, #1
 8006848:	0949      	lsrs	r1, r1, #5
 800684a:	f7ff fab9 	bl	8005dc0 <_test_assert>
 800684e:	b108      	cbz	r0, 8006854 <sem2_execute+0x24>
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
}
 8006850:	b003      	add	sp, #12
 8006852:	bdf0      	pop	{r4, r5, r6, r7, pc}
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 8006854:	6821      	ldr	r1, [r4, #0]
  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
  test_assert(1, msg == MSG_TIMEOUT, "wrong wake-up message");
  test_assert(2, queue_isempty(&sem1.s_queue), "queue not empty");
 8006856:	2002      	movs	r0, #2
 8006858:	1b09      	subs	r1, r1, r4
 800685a:	fab1 f181 	clz	r1, r1
 800685e:	0949      	lsrs	r1, r1, #5
 8006860:	f7ff faae 	bl	8005dc0 <_test_assert>
 8006864:	2800      	cmp	r0, #0
 8006866:	d1f3      	bne.n	8006850 <sem2_execute+0x20>
  test_assert(3, sem1.s_cnt == 0, "counter not zero");
 8006868:	68a1      	ldr	r1, [r4, #8]
 800686a:	2003      	movs	r0, #3
 800686c:	fab1 f181 	clz	r1, r1
 8006870:	0949      	lsrs	r1, r1, #5
 8006872:	f7ff faa5 	bl	8005dc0 <_test_assert>
 8006876:	4603      	mov	r3, r0
 8006878:	2800      	cmp	r0, #0
 800687a:	d1e9      	bne.n	8006850 <sem2_execute+0x20>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800687c:	4d3c      	ldr	r5, [pc, #240]	; (8006970 <sem2_execute+0x140>)

  /*
   * Testing not timeout condition.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800687e:	493d      	ldr	r1, [pc, #244]	; (8006974 <sem2_execute+0x144>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8006880:	692a      	ldr	r2, [r5, #16]
 8006882:	6808      	ldr	r0, [r1, #0]
 8006884:	6892      	ldr	r2, [r2, #8]
 8006886:	f44f 71a0 	mov.w	r1, #320	; 0x140
 800688a:	3a01      	subs	r2, #1
 800688c:	9300      	str	r3, [sp, #0]
 800688e:	4b3a      	ldr	r3, [pc, #232]	; (8006978 <sem2_execute+0x148>)
 8006890:	f7fb f90e 	bl	8001ab0 <chThdCreateStatic>
 8006894:	4b39      	ldr	r3, [pc, #228]	; (800697c <sem2_execute+0x14c>)
                                 thread2, 0);
  msg = chSemWaitTimeout(&sem1, MS2ST(500));
 8006896:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  test_assert(3, sem1.s_cnt == 0, "counter not zero");

  /*
   * Testing not timeout condition.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800689a:	6018      	str	r0, [r3, #0]
                                 thread2, 0);
  msg = chSemWaitTimeout(&sem1, MS2ST(500));
 800689c:	4620      	mov	r0, r4
 800689e:	f7fb fb87 	bl	8001fb0 <chSemWaitTimeout>
 80068a2:	4606      	mov	r6, r0
  test_wait_threads();
 80068a4:	f7ff fb04 	bl	8005eb0 <test_wait_threads>
  test_assert(4, msg == MSG_OK, "wrong wake-up message");
 80068a8:	fab6 f186 	clz	r1, r6
 80068ac:	2004      	movs	r0, #4
 80068ae:	0949      	lsrs	r1, r1, #5
 80068b0:	f7ff fa86 	bl	8005dc0 <_test_assert>
 80068b4:	2800      	cmp	r0, #0
 80068b6:	d1cb      	bne.n	8006850 <sem2_execute+0x20>
 80068b8:	6821      	ldr	r1, [r4, #0]
  test_assert(5, queue_isempty(&sem1.s_queue), "queue not empty");
 80068ba:	2005      	movs	r0, #5
 80068bc:	1b09      	subs	r1, r1, r4
 80068be:	fab1 f181 	clz	r1, r1
 80068c2:	0949      	lsrs	r1, r1, #5
 80068c4:	f7ff fa7c 	bl	8005dc0 <_test_assert>
 80068c8:	2800      	cmp	r0, #0
 80068ca:	d1c1      	bne.n	8006850 <sem2_execute+0x20>
  test_assert(6, sem1.s_cnt == 0, "counter not zero");
 80068cc:	68a1      	ldr	r1, [r4, #8]
 80068ce:	2006      	movs	r0, #6
 80068d0:	fab1 f181 	clz	r1, r1
 80068d4:	0949      	lsrs	r1, r1, #5
 80068d6:	f7ff fa73 	bl	8005dc0 <_test_assert>
 80068da:	4607      	mov	r7, r0
 80068dc:	2800      	cmp	r0, #0
 80068de:	d1b7      	bne.n	8006850 <sem2_execute+0x20>

  /*
   * Testing timeout condition.
   */
  test_wait_tick();
 80068e0:	f7ff fafe 	bl	8005ee0 <test_wait_tick>
 80068e4:	2320      	movs	r3, #32
 80068e6:	f383 8811 	msr	BASEPRI, r3
 80068ea:	8bee      	ldrh	r6, [r5, #30]
 80068ec:	b2b6      	uxth	r6, r6
 80068ee:	f387 8811 	msr	BASEPRI, r7
 80068f2:	2541      	movs	r5, #65	; 0x41
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
    test_emit_token('A' + i);
 80068f4:	4628      	mov	r0, r5
 80068f6:	f7ff fa4b 	bl	8005d90 <test_emit_token>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
 80068fa:	2164      	movs	r1, #100	; 0x64
 80068fc:	481b      	ldr	r0, [pc, #108]	; (800696c <sem2_execute+0x13c>)
 80068fe:	f7fb fb57 	bl	8001fb0 <chSemWaitTimeout>
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
 8006902:	f1a0 31ff 	sub.w	r1, r0, #4294967295
 8006906:	fab1 f181 	clz	r1, r1
 800690a:	2007      	movs	r0, #7
 800690c:	0949      	lsrs	r1, r1, #5
 800690e:	f7ff fa57 	bl	8005dc0 <_test_assert>
 8006912:	2800      	cmp	r0, #0
 8006914:	d19c      	bne.n	8006850 <sem2_execute+0x20>
 8006916:	6821      	ldr	r1, [r4, #0]
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
 8006918:	2008      	movs	r0, #8
 800691a:	1b09      	subs	r1, r1, r4
 800691c:	fab1 f181 	clz	r1, r1
 8006920:	0949      	lsrs	r1, r1, #5
 8006922:	f7ff fa4d 	bl	8005dc0 <_test_assert>
 8006926:	2800      	cmp	r0, #0
 8006928:	d192      	bne.n	8006850 <sem2_execute+0x20>
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
 800692a:	68a1      	ldr	r1, [r4, #8]
 800692c:	2009      	movs	r0, #9
 800692e:	fab1 f181 	clz	r1, r1
 8006932:	0949      	lsrs	r1, r1, #5
 8006934:	f7ff fa44 	bl	8005dc0 <_test_assert>
 8006938:	3501      	adds	r5, #1
 800693a:	b2ed      	uxtb	r5, r5
 800693c:	2800      	cmp	r0, #0
 800693e:	d187      	bne.n	8006850 <sem2_execute+0x20>
  /*
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
 8006940:	2d46      	cmp	r5, #70	; 0x46
 8006942:	d1d7      	bne.n	80068f4 <sem2_execute+0xc4>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
 8006944:	200a      	movs	r0, #10
 8006946:	490e      	ldr	r1, [pc, #56]	; (8006980 <sem2_execute+0x150>)
 8006948:	f7ff fa52 	bl	8005df0 <_test_assert_sequence>
 800694c:	2800      	cmp	r0, #0
 800694e:	f47f af7f 	bne.w	8006850 <sem2_execute+0x20>

  /*
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
 8006952:	f506 71fa 	add.w	r1, r6, #500	; 0x1f4
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
 8006956:	f506 72fc 	add.w	r2, r6, #504	; 0x1f8
 800695a:	b289      	uxth	r1, r1
 800695c:	b292      	uxth	r2, r2
 800695e:	200b      	movs	r0, #11
}
 8006960:	b003      	add	sp, #12
 8006962:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
 8006966:	f7ff ba6b 	b.w	8005e40 <_test_assert_time_window>
 800696a:	bf00      	nop
 800696c:	2000082c 	.word	0x2000082c
 8006970:	20001160 	.word	0x20001160
 8006974:	0800d790 	.word	0x0800d790
 8006978:	08006801 	.word	0x08006801
 800697c:	20001c58 	.word	0x20001c58
 8006980:	0800da50 	.word	0x0800da50
	...

08006990 <sem3_execute>:
  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
}

static void sem3_execute(void) {
 8006990:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8006992:	4b20      	ldr	r3, [pc, #128]	; (8006a14 <sem3_execute+0x84>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8006994:	4a20      	ldr	r2, [pc, #128]	; (8006a18 <sem3_execute+0x88>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8006996:	691b      	ldr	r3, [r3, #16]
 8006998:	6810      	ldr	r0, [r2, #0]
 800699a:	689a      	ldr	r2, [r3, #8]
  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
}

static void sem3_execute(void) {
 800699c:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 800699e:	2300      	movs	r3, #0
 80069a0:	3201      	adds	r2, #1
 80069a2:	9300      	str	r3, [sp, #0]
 80069a4:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80069a8:	4b1c      	ldr	r3, [pc, #112]	; (8006a1c <sem3_execute+0x8c>)
 80069aa:	f7fb f881 	bl	8001ab0 <chThdCreateStatic>
  chSemSignalWait(&sem1, &sem1);
 80069ae:	4c1c      	ldr	r4, [pc, #112]	; (8006a20 <sem3_execute+0x90>)
  chSemSignal(&sem1);
}

static void sem3_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 80069b0:	4b1c      	ldr	r3, [pc, #112]	; (8006a24 <sem3_execute+0x94>)
  chSemSignalWait(&sem1, &sem1);
 80069b2:	4621      	mov	r1, r4
  chSemSignal(&sem1);
}

static void sem3_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 80069b4:	6018      	str	r0, [r3, #0]
  chSemSignalWait(&sem1, &sem1);
 80069b6:	4620      	mov	r0, r4
 80069b8:	f7fb fb5a 	bl	8002070 <chSemSignalWait>
 80069bc:	6821      	ldr	r1, [r4, #0]
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
 80069be:	2001      	movs	r0, #1
 80069c0:	1b09      	subs	r1, r1, r4
 80069c2:	fab1 f181 	clz	r1, r1
 80069c6:	0949      	lsrs	r1, r1, #5
 80069c8:	f7ff f9fa 	bl	8005dc0 <_test_assert>
 80069cc:	b108      	cbz	r0, 80069d2 <sem3_execute+0x42>
  test_assert(2, sem1.s_cnt == 0, "counter not zero");

  chSemSignalWait(&sem1, &sem1);
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
}
 80069ce:	b002      	add	sp, #8
 80069d0:	bd10      	pop	{r4, pc}
static void sem3_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
  chSemSignalWait(&sem1, &sem1);
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(2, sem1.s_cnt == 0, "counter not zero");
 80069d2:	68a1      	ldr	r1, [r4, #8]
 80069d4:	2002      	movs	r0, #2
 80069d6:	fab1 f181 	clz	r1, r1
 80069da:	0949      	lsrs	r1, r1, #5
 80069dc:	f7ff f9f0 	bl	8005dc0 <_test_assert>
 80069e0:	2800      	cmp	r0, #0
 80069e2:	d1f4      	bne.n	80069ce <sem3_execute+0x3e>

  chSemSignalWait(&sem1, &sem1);
 80069e4:	4621      	mov	r1, r4
 80069e6:	4620      	mov	r0, r4
 80069e8:	f7fb fb42 	bl	8002070 <chSemSignalWait>
 80069ec:	6821      	ldr	r1, [r4, #0]
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
 80069ee:	2003      	movs	r0, #3
 80069f0:	1b09      	subs	r1, r1, r4
 80069f2:	fab1 f181 	clz	r1, r1
 80069f6:	0949      	lsrs	r1, r1, #5
 80069f8:	f7ff f9e2 	bl	8005dc0 <_test_assert>
 80069fc:	2800      	cmp	r0, #0
 80069fe:	d1e6      	bne.n	80069ce <sem3_execute+0x3e>
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
 8006a00:	68a1      	ldr	r1, [r4, #8]
 8006a02:	2004      	movs	r0, #4
 8006a04:	fab1 f181 	clz	r1, r1
 8006a08:	0949      	lsrs	r1, r1, #5
}
 8006a0a:	b002      	add	sp, #8
 8006a0c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(2, sem1.s_cnt == 0, "counter not zero");

  chSemSignalWait(&sem1, &sem1);
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
 8006a10:	f7ff b9d6 	b.w	8005dc0 <_test_assert>
 8006a14:	20001160 	.word	0x20001160
 8006a18:	0800d790 	.word	0x0800d790
 8006a1c:	08006791 	.word	0x08006791
 8006a20:	2000082c 	.word	0x2000082c
 8006a24:	20001c58 	.word	0x20001c58
	...

08006a30 <thread4>:
 * <h2>Description</h2>
 * This test case tests the binary semaphores functionality. The test both
 * checks the binary semaphore status and the expected status of the underlying
 * counting semaphore.
 */
static THD_FUNCTION(thread4, p) {
 8006a30:	b508      	push	{r3, lr}
 8006a32:	2220      	movs	r2, #32
 8006a34:	f382 8811 	msr	BASEPRI, r2
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 8006a38:	6883      	ldr	r3, [r0, #8]
 8006a3a:	2b00      	cmp	r3, #0
 8006a3c:	dd05      	ble.n	8006a4a <thread4+0x1a>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8006a3e:	f7fa ffdf 	bl	8001a00 <chSchRescheduleS>
 8006a42:	2300      	movs	r3, #0
 8006a44:	f383 8811 	msr	BASEPRI, r3
 8006a48:	bd08      	pop	{r3, pc}
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
    chSemSignalI(&bsp->bs_sem);
 8006a4a:	f7fb fae1 	bl	8002010 <chSemSignalI>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8006a4e:	f7fa ffd7 	bl	8001a00 <chSchRescheduleS>
 8006a52:	2300      	movs	r3, #0
 8006a54:	f383 8811 	msr	BASEPRI, r3
 8006a58:	bd08      	pop	{r3, pc}
 8006a5a:	bf00      	nop
 8006a5c:	0000      	movs	r0, r0
	...

08006a60 <sem4_execute>:

  chBSemSignal((binary_semaphore_t *)p);
}

static void sem4_execute(void) {
 8006a60:	b570      	push	{r4, r5, r6, lr}
 8006a62:	b086      	sub	sp, #24
 *
 * @init
 */
static inline void chBSemObjectInit(binary_semaphore_t *bsp, bool taken) {

  chSemObjectInit(&bsp->bs_sem, taken ? (cnt_t)0 : (cnt_t)1);
 8006a64:	a803      	add	r0, sp, #12
 8006a66:	2100      	movs	r1, #0
 8006a68:	f7fb fa2a 	bl	8001ec0 <chSemObjectInit>
 *
 * @api
 */
static inline void chBSemReset(binary_semaphore_t *bsp, bool taken) {

  chSemReset(&bsp->bs_sem, taken ? (cnt_t)0 : (cnt_t)1);
 8006a6c:	a803      	add	r0, sp, #12
 8006a6e:	2100      	movs	r1, #0
 8006a70:	f7fb fa46 	bl	8001f00 <chSemReset>
 8006a74:	2520      	movs	r5, #32
 8006a76:	f385 8811 	msr	BASEPRI, r5
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->bs_sem.s_cnt > (cnt_t)0) ? false : true;
 8006a7a:	9905      	ldr	r1, [sp, #20]
  binary_semaphore_t bsem;
  
  /* Creates a taken binary semaphore.*/
  chBSemObjectInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");
 8006a7c:	2001      	movs	r0, #1
 8006a7e:	2900      	cmp	r1, #0
 8006a80:	bfcc      	ite	gt
 8006a82:	2100      	movgt	r1, #0
 8006a84:	2101      	movle	r1, #1
 8006a86:	f7ff f99b 	bl	8005dc0 <_test_assert>
 8006a8a:	4604      	mov	r4, r0
 8006a8c:	b120      	cbz	r0, 8006a98 <sem4_execute+0x38>
 8006a8e:	2300      	movs	r3, #0
 8006a90:	f383 8811 	msr	BASEPRI, r3

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
}
 8006a94:	b006      	add	sp, #24
 8006a96:	bd70      	pop	{r4, r5, r6, pc}
 8006a98:	f380 8811 	msr	BASEPRI, r0
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8006a9c:	4b3f      	ldr	r3, [pc, #252]	; (8006b9c <sem4_execute+0x13c>)
  chBSemObjectInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8006a9e:	4a40      	ldr	r2, [pc, #256]	; (8006ba0 <sem4_execute+0x140>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8006aa0:	691b      	ldr	r3, [r3, #16]
 8006aa2:	6810      	ldr	r0, [r2, #0]
 8006aa4:	689a      	ldr	r2, [r3, #8]
 8006aa6:	ab03      	add	r3, sp, #12
 8006aa8:	3a01      	subs	r2, #1
 8006aaa:	9300      	str	r3, [sp, #0]
 8006aac:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8006ab0:	4b3c      	ldr	r3, [pc, #240]	; (8006ba4 <sem4_execute+0x144>)
 8006ab2:	f7fa fffd 	bl	8001ab0 <chThdCreateStatic>
 8006ab6:	4b3c      	ldr	r3, [pc, #240]	; (8006ba8 <sem4_execute+0x148>)
 8006ab8:	6018      	str	r0, [r3, #0]
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {

  return chSemWait(&bsp->bs_sem);
 8006aba:	a803      	add	r0, sp, #12
 8006abc:	f7fb fa30 	bl	8001f20 <chSemWait>
 8006ac0:	f385 8811 	msr	BASEPRI, r5
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->bs_sem.s_cnt > (cnt_t)0) ? false : true;
 8006ac4:	9905      	ldr	r1, [sp, #20]
                                 
  /* Waits to be signaled.*/
  chBSemWait(&bsem);
  
  /* The binary semaphore is expected to be taken.*/
  test_assert_lock(2, chBSemGetStateI(&bsem) == TRUE, "not taken");
 8006ac6:	2002      	movs	r0, #2
 8006ac8:	2900      	cmp	r1, #0
 8006aca:	bfcc      	ite	gt
 8006acc:	2100      	movgt	r1, #0
 8006ace:	2101      	movle	r1, #1
 8006ad0:	f7ff f976 	bl	8005dc0 <_test_assert>
 8006ad4:	b118      	cbz	r0, 8006ade <sem4_execute+0x7e>
 8006ad6:	f384 8811 	msr	BASEPRI, r4

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
}
 8006ada:	b006      	add	sp, #24
 8006adc:	bd70      	pop	{r4, r5, r6, pc}
 8006ade:	f380 8811 	msr	BASEPRI, r0
 8006ae2:	f385 8811 	msr	BASEPRI, r5
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 8006ae6:	9b05      	ldr	r3, [sp, #20]
 8006ae8:	2b00      	cmp	r3, #0
 8006aea:	dd23      	ble.n	8006b34 <sem4_execute+0xd4>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8006aec:	f7fa ff88 	bl	8001a00 <chSchRescheduleS>
 8006af0:	2400      	movs	r4, #0
 8006af2:	f384 8811 	msr	BASEPRI, r4
 8006af6:	2620      	movs	r6, #32
 8006af8:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(2, chBSemGetStateI(&bsem) == TRUE, "not taken");

  /* Releasing it, check both the binary semaphore state and the underlying
     counter semaphore state..*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "still taken");
 8006afc:	9905      	ldr	r1, [sp, #20]
 8006afe:	2003      	movs	r0, #3
 8006b00:	42a1      	cmp	r1, r4
 8006b02:	bfd4      	ite	le
 8006b04:	2100      	movle	r1, #0
 8006b06:	2101      	movgt	r1, #1
 8006b08:	f7ff f95a 	bl	8005dc0 <_test_assert>
 8006b0c:	4605      	mov	r5, r0
 8006b0e:	2800      	cmp	r0, #0
 8006b10:	d1e1      	bne.n	8006ad6 <sem4_execute+0x76>
 8006b12:	f380 8811 	msr	BASEPRI, r0
 8006b16:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(4, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 8006b1a:	9905      	ldr	r1, [sp, #20]
 8006b1c:	2004      	movs	r0, #4
 8006b1e:	f1a1 0101 	sub.w	r1, r1, #1
 8006b22:	fab1 f181 	clz	r1, r1
 8006b26:	0949      	lsrs	r1, r1, #5
 8006b28:	f7ff f94a 	bl	8005dc0 <_test_assert>
 8006b2c:	b130      	cbz	r0, 8006b3c <sem4_execute+0xdc>
 8006b2e:	f385 8811 	msr	BASEPRI, r5
 8006b32:	e7af      	b.n	8006a94 <sem4_execute+0x34>
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
    chSemSignalI(&bsp->bs_sem);
 8006b34:	a803      	add	r0, sp, #12
 8006b36:	f7fb fa6b 	bl	8002010 <chSemSignalI>
 8006b3a:	e7d7      	b.n	8006aec <sem4_execute+0x8c>
 8006b3c:	f380 8811 	msr	BASEPRI, r0
 8006b40:	f386 8811 	msr	BASEPRI, r6
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 8006b44:	9b05      	ldr	r3, [sp, #20]
 8006b46:	2b00      	cmp	r3, #0
 8006b48:	dd24      	ble.n	8006b94 <sem4_execute+0x134>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8006b4a:	f7fa ff59 	bl	8001a00 <chSchRescheduleS>
 8006b4e:	2400      	movs	r4, #0
 8006b50:	f384 8811 	msr	BASEPRI, r4
 8006b54:	2620      	movs	r6, #32
 8006b56:	f386 8811 	msr	BASEPRI, r6

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
 8006b5a:	9905      	ldr	r1, [sp, #20]
 8006b5c:	2003      	movs	r0, #3
 8006b5e:	42a1      	cmp	r1, r4
 8006b60:	bfd4      	ite	le
 8006b62:	2100      	movle	r1, #0
 8006b64:	2101      	movgt	r1, #1
 8006b66:	f7ff f92b 	bl	8005dc0 <_test_assert>
 8006b6a:	4605      	mov	r5, r0
 8006b6c:	2800      	cmp	r0, #0
 8006b6e:	d1b2      	bne.n	8006ad6 <sem4_execute+0x76>
 8006b70:	f380 8811 	msr	BASEPRI, r0
 8006b74:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 8006b78:	9905      	ldr	r1, [sp, #20]
 8006b7a:	2005      	movs	r0, #5
 8006b7c:	f1a1 0101 	sub.w	r1, r1, #1
 8006b80:	fab1 f181 	clz	r1, r1
 8006b84:	0949      	lsrs	r1, r1, #5
 8006b86:	f7ff f91b 	bl	8005dc0 <_test_assert>
 8006b8a:	2800      	cmp	r0, #0
 8006b8c:	d1cf      	bne.n	8006b2e <sem4_execute+0xce>
 8006b8e:	f380 8811 	msr	BASEPRI, r0
 8006b92:	e77f      	b.n	8006a94 <sem4_execute+0x34>
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
    chSemSignalI(&bsp->bs_sem);
 8006b94:	a803      	add	r0, sp, #12
 8006b96:	f7fb fa3b 	bl	8002010 <chSemSignalI>
 8006b9a:	e7d6      	b.n	8006b4a <sem4_execute+0xea>
 8006b9c:	20001160 	.word	0x20001160
 8006ba0:	0800d790 	.word	0x0800d790
 8006ba4:	08006a31 	.word	0x08006a31
 8006ba8:	20001c58 	.word	0x20001c58
 8006bac:	00000000 	.word	0x00000000

08006bb0 <mtx1_execute>:
  chMtxLock(&m1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx1_execute(void) {
 8006bb0:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8006bb2:	4f2b      	ldr	r7, [pc, #172]	; (8006c60 <mtx1_execute+0xb0>)
 8006bb4:	b083      	sub	sp, #12
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8006bb6:	693b      	ldr	r3, [r7, #16]

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
 8006bb8:	482a      	ldr	r0, [pc, #168]	; (8006c64 <mtx1_execute+0xb4>)
 8006bba:	689c      	ldr	r4, [r3, #8]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 8006bbc:	4e2a      	ldr	r6, [pc, #168]	; (8006c68 <mtx1_execute+0xb8>)
}

static void mtx1_execute(void) {

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
 8006bbe:	f7fb faff 	bl	80021c0 <chMtxLock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 8006bc2:	4b2a      	ldr	r3, [pc, #168]	; (8006c6c <mtx1_execute+0xbc>)
 8006bc4:	1c62      	adds	r2, r4, #1
 8006bc6:	9300      	str	r3, [sp, #0]
 8006bc8:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8006bcc:	4b28      	ldr	r3, [pc, #160]	; (8006c70 <mtx1_execute+0xc0>)
 8006bce:	6830      	ldr	r0, [r6, #0]
 8006bd0:	f7fa ff6e 	bl	8001ab0 <chThdCreateStatic>
 8006bd4:	4d27      	ldr	r5, [pc, #156]	; (8006c74 <mtx1_execute+0xc4>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 8006bd6:	6871      	ldr	r1, [r6, #4]
 8006bd8:	4b27      	ldr	r3, [pc, #156]	; (8006c78 <mtx1_execute+0xc8>)

static void mtx1_execute(void) {

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 8006bda:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 8006bdc:	1ca2      	adds	r2, r4, #2
 8006bde:	4608      	mov	r0, r1
 8006be0:	9300      	str	r3, [sp, #0]
 8006be2:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8006be6:	4b22      	ldr	r3, [pc, #136]	; (8006c70 <mtx1_execute+0xc0>)
 8006be8:	f7fa ff62 	bl	8001ab0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8006bec:	68b1      	ldr	r1, [r6, #8]
 8006bee:	4b23      	ldr	r3, [pc, #140]	; (8006c7c <mtx1_execute+0xcc>)
static void mtx1_execute(void) {

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 8006bf0:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8006bf2:	1ce2      	adds	r2, r4, #3
 8006bf4:	4608      	mov	r0, r1
 8006bf6:	9300      	str	r3, [sp, #0]
 8006bf8:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8006bfc:	4b1c      	ldr	r3, [pc, #112]	; (8006c70 <mtx1_execute+0xc0>)
 8006bfe:	f7fa ff57 	bl	8001ab0 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8006c02:	68f1      	ldr	r1, [r6, #12]
 8006c04:	4b1e      	ldr	r3, [pc, #120]	; (8006c80 <mtx1_execute+0xd0>)

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8006c06:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8006c08:	1d22      	adds	r2, r4, #4
 8006c0a:	4608      	mov	r0, r1
 8006c0c:	9300      	str	r3, [sp, #0]
 8006c0e:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8006c12:	4b17      	ldr	r3, [pc, #92]	; (8006c70 <mtx1_execute+0xc0>)
 8006c14:	f7fa ff4c 	bl	8001ab0 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8006c18:	6931      	ldr	r1, [r6, #16]
 8006c1a:	4b1a      	ldr	r3, [pc, #104]	; (8006c84 <mtx1_execute+0xd4>)
 8006c1c:	1d62      	adds	r2, r4, #5
  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8006c1e:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8006c20:	9300      	str	r3, [sp, #0]
 8006c22:	4608      	mov	r0, r1
 8006c24:	4b12      	ldr	r3, [pc, #72]	; (8006c70 <mtx1_execute+0xc0>)
 8006c26:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8006c2a:	f7fa ff41 	bl	8001ab0 <chThdCreateStatic>
 8006c2e:	6128      	str	r0, [r5, #16]
  chMtxUnlock(&m1);
 8006c30:	480c      	ldr	r0, [pc, #48]	; (8006c64 <mtx1_execute+0xb4>)
 8006c32:	f7fb faed 	bl	8002210 <chMtxUnlock>
  test_wait_threads();
 8006c36:	f7ff f93b 	bl	8005eb0 <test_wait_threads>
 8006c3a:	693b      	ldr	r3, [r7, #16]
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
 8006c3c:	2001      	movs	r0, #1
 8006c3e:	6899      	ldr	r1, [r3, #8]
 8006c40:	1a61      	subs	r1, r4, r1
 8006c42:	fab1 f181 	clz	r1, r1
 8006c46:	0949      	lsrs	r1, r1, #5
 8006c48:	f7ff f8ba 	bl	8005dc0 <_test_assert>
 8006c4c:	b108      	cbz	r0, 8006c52 <mtx1_execute+0xa2>
  test_assert_sequence(2, "ABCDE");
}
 8006c4e:	b003      	add	sp, #12
 8006c50:	bdf0      	pop	{r4, r5, r6, r7, pc}
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
  chMtxUnlock(&m1);
  test_wait_threads();
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
  test_assert_sequence(2, "ABCDE");
 8006c52:	490d      	ldr	r1, [pc, #52]	; (8006c88 <mtx1_execute+0xd8>)
 8006c54:	2002      	movs	r0, #2
}
 8006c56:	b003      	add	sp, #12
 8006c58:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
  chMtxUnlock(&m1);
  test_wait_threads();
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
  test_assert_sequence(2, "ABCDE");
 8006c5c:	f7ff b8c8 	b.w	8005df0 <_test_assert_sequence>
 8006c60:	20001160 	.word	0x20001160
 8006c64:	20000838 	.word	0x20000838
 8006c68:	0800d790 	.word	0x0800d790
 8006c6c:	0800da54 	.word	0x0800da54
 8006c70:	08006c91 	.word	0x08006c91
 8006c74:	20001c58 	.word	0x20001c58
 8006c78:	0800da40 	.word	0x0800da40
 8006c7c:	0800da44 	.word	0x0800da44
 8006c80:	0800da48 	.word	0x0800da48
 8006c84:	0800da4c 	.word	0x0800da4c
 8006c88:	0800da50 	.word	0x0800da50
 8006c8c:	00000000 	.word	0x00000000

08006c90 <thread1>:
static void mtx1_setup(void) {

  chMtxObjectInit(&m1);
}

static THD_FUNCTION(thread1, p) {
 8006c90:	b538      	push	{r3, r4, r5, lr}
 8006c92:	4605      	mov	r5, r0

  chMtxLock(&m1);
 8006c94:	4c05      	ldr	r4, [pc, #20]	; (8006cac <thread1+0x1c>)
 8006c96:	4620      	mov	r0, r4
 8006c98:	f7fb fa92 	bl	80021c0 <chMtxLock>
  test_emit_token(*(char *)p);
 8006c9c:	7828      	ldrb	r0, [r5, #0]
 8006c9e:	f7ff f877 	bl	8005d90 <test_emit_token>
  chMtxUnlock(&m1);
 8006ca2:	4620      	mov	r0, r4
}
 8006ca4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

static THD_FUNCTION(thread1, p) {

  chMtxLock(&m1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
 8006ca8:	f7fb bab2 	b.w	8002210 <chMtxUnlock>
 8006cac:	20000838 	.word	0x20000838

08006cb0 <thread12>:
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread12, p) {
 8006cb0:	b538      	push	{r3, r4, r5, lr}
 8006cb2:	4605      	mov	r5, r0

  chMtxLock(&m2);
 8006cb4:	4c05      	ldr	r4, [pc, #20]	; (8006ccc <thread12+0x1c>)
 8006cb6:	4620      	mov	r0, r4
 8006cb8:	f7fb fa82 	bl	80021c0 <chMtxLock>
  test_emit_token(*(char *)p);
 8006cbc:	7828      	ldrb	r0, [r5, #0]
 8006cbe:	f7ff f867 	bl	8005d90 <test_emit_token>
  chMtxUnlock(&m2);
 8006cc2:	4620      	mov	r0, r4
}
 8006cc4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

static THD_FUNCTION(thread12, p) {

  chMtxLock(&m2);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m2);
 8006cc8:	f7fb baa2 	b.w	8002210 <chMtxUnlock>
 8006ccc:	20000848 	.word	0x20000848

08006cd0 <mtx1_setup>:
 * priority order regardless of the initial order.
 */

static void mtx1_setup(void) {

  chMtxObjectInit(&m1);
 8006cd0:	4801      	ldr	r0, [pc, #4]	; (8006cd8 <mtx1_setup+0x8>)
 8006cd2:	f7fb ba05 	b.w	80020e0 <chMtxObjectInit>
 8006cd6:	bf00      	nop
 8006cd8:	20000838 	.word	0x20000838
 8006cdc:	00000000 	.word	0x00000000

08006ce0 <mtx4_setup>:
 * thread with precise timing.<br>
 * The test expects that the priority changes caused by the priority
 * inheritance algorithm happen at the right moment and with the right values.
 */

static void mtx4_setup(void) {
 8006ce0:	b508      	push	{r3, lr}

  chMtxObjectInit(&m1);
 8006ce2:	4804      	ldr	r0, [pc, #16]	; (8006cf4 <mtx4_setup+0x14>)
 8006ce4:	f7fb f9fc 	bl	80020e0 <chMtxObjectInit>
  chMtxObjectInit(&m2);
}
 8006ce8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 */

static void mtx4_setup(void) {

  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
 8006cec:	4802      	ldr	r0, [pc, #8]	; (8006cf8 <mtx4_setup+0x18>)
 8006cee:	f7fb b9f7 	b.w	80020e0 <chMtxObjectInit>
 8006cf2:	bf00      	nop
 8006cf4:	20000838 	.word	0x20000838
 8006cf8:	20000848 	.word	0x20000848
 8006cfc:	00000000 	.word	0x00000000

08006d00 <mtx5_setup>:
 * operation.
 */

static void mtx5_setup(void) {

  chMtxObjectInit(&m1);
 8006d00:	4801      	ldr	r0, [pc, #4]	; (8006d08 <mtx5_setup+0x8>)
 8006d02:	f7fb b9ed 	b.w	80020e0 <chMtxObjectInit>
 8006d06:	bf00      	nop
 8006d08:	20000838 	.word	0x20000838
 8006d0c:	00000000 	.word	0x00000000

08006d10 <thread4b>:
  chThdSleepMilliseconds(50);
  chMtxLock(&m2);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread4b, p) {
 8006d10:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(150);
  chMtxLock(&m1);
 8006d12:	4c06      	ldr	r4, [pc, #24]	; (8006d2c <thread4b+0x1c>)
}

static THD_FUNCTION(thread4b, p) {

  (void)p;
  chThdSleepMilliseconds(150);
 8006d14:	f44f 7096 	mov.w	r0, #300	; 0x12c
 8006d18:	f7fa ff3a 	bl	8001b90 <chThdSleep>
  chMtxLock(&m1);
 8006d1c:	4620      	mov	r0, r4
 8006d1e:	f7fb fa4f 	bl	80021c0 <chMtxLock>
  chMtxUnlock(&m1);
 8006d22:	4620      	mov	r0, r4
}
 8006d24:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static THD_FUNCTION(thread4b, p) {

  (void)p;
  chThdSleepMilliseconds(150);
  chMtxLock(&m1);
  chMtxUnlock(&m1);
 8006d28:	f7fb ba72 	b.w	8002210 <chMtxUnlock>
 8006d2c:	20000838 	.word	0x20000838

08006d30 <thread4a>:

  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static THD_FUNCTION(thread4a, p) {
 8006d30:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(50);
  chMtxLock(&m2);
 8006d32:	4c06      	ldr	r4, [pc, #24]	; (8006d4c <thread4a+0x1c>)
}

static THD_FUNCTION(thread4a, p) {

  (void)p;
  chThdSleepMilliseconds(50);
 8006d34:	2064      	movs	r0, #100	; 0x64
 8006d36:	f7fa ff2b 	bl	8001b90 <chThdSleep>
  chMtxLock(&m2);
 8006d3a:	4620      	mov	r0, r4
 8006d3c:	f7fb fa40 	bl	80021c0 <chMtxLock>
  chMtxUnlock(&m2);
 8006d40:	4620      	mov	r0, r4
}
 8006d42:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static THD_FUNCTION(thread4a, p) {

  (void)p;
  chThdSleepMilliseconds(50);
  chMtxLock(&m2);
  chMtxUnlock(&m2);
 8006d46:	f7fb ba63 	b.w	8002210 <chMtxUnlock>
 8006d4a:	bf00      	nop
 8006d4c:	20000848 	.word	0x20000848

08006d50 <mtx4_execute>:
  chThdSleepMilliseconds(150);
  chMtxLock(&m1);
  chMtxUnlock(&m1);
}

static void mtx4_execute(void) {
 8006d50:	e92d 46f0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8006d54:	4d8a      	ldr	r5, [pc, #552]	; (8006f80 <mtx4_execute+0x230>)
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 8006d56:	4e8b      	ldr	r6, [pc, #556]	; (8006f84 <mtx4_execute+0x234>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8006d58:	692b      	ldr	r3, [r5, #16]
 8006d5a:	6832      	ldr	r2, [r6, #0]
 8006d5c:	689c      	ldr	r4, [r3, #8]
 8006d5e:	4b8a      	ldr	r3, [pc, #552]	; (8006f88 <mtx4_execute+0x238>)
  chThdSleepMilliseconds(150);
  chMtxLock(&m1);
  chMtxUnlock(&m1);
}

static void mtx4_execute(void) {
 8006d60:	b085      	sub	sp, #20
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
 8006d62:	f104 0901 	add.w	r9, r4, #1
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 8006d66:	4610      	mov	r0, r2
 8006d68:	9203      	str	r2, [sp, #12]
 8006d6a:	9300      	str	r3, [sp, #0]
 8006d6c:	464a      	mov	r2, r9
 8006d6e:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8006d72:	4b86      	ldr	r3, [pc, #536]	; (8006f8c <mtx4_execute+0x23c>)
 8006d74:	f7fa fe9c 	bl	8001ab0 <chThdCreateStatic>
 8006d78:	4f85      	ldr	r7, [pc, #532]	; (8006f90 <mtx4_execute+0x240>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 8006d7a:	6876      	ldr	r6, [r6, #4]
 8006d7c:	4b85      	ldr	r3, [pc, #532]	; (8006f94 <mtx4_execute+0x244>)
static void mtx4_execute(void) {
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
  p2 = p + 2;
 8006d7e:	f104 0a02 	add.w	sl, r4, #2
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 8006d82:	6038      	str	r0, [r7, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 8006d84:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8006d88:	4652      	mov	r2, sl
 8006d8a:	9300      	str	r3, [sp, #0]
 8006d8c:	4630      	mov	r0, r6
 8006d8e:	4b82      	ldr	r3, [pc, #520]	; (8006f98 <mtx4_execute+0x248>)
 8006d90:	f7fa fe8e 	bl	8001ab0 <chThdCreateStatic>
 8006d94:	6078      	str	r0, [r7, #4]
  chMtxLock(&m2);
 8006d96:	4881      	ldr	r0, [pc, #516]	; (8006f9c <mtx4_execute+0x24c>)
 8006d98:	f7fb fa12 	bl	80021c0 <chMtxLock>
 8006d9c:	692b      	ldr	r3, [r5, #16]
  test_assert(1, chThdGetPriorityX() == p, "wrong priority level");
 8006d9e:	2001      	movs	r0, #1
 8006da0:	6899      	ldr	r1, [r3, #8]
 8006da2:	1a61      	subs	r1, r4, r1
 8006da4:	fab1 f181 	clz	r1, r1
 8006da8:	0949      	lsrs	r1, r1, #5
 8006daa:	f7ff f809 	bl	8005dc0 <_test_assert>
 8006dae:	b110      	cbz	r0, 8006db6 <mtx4_execute+0x66>
  chThdSleepMilliseconds(100);
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
  chMtxUnlockAll();
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
  test_wait_threads();
}
 8006db0:	b005      	add	sp, #20
 8006db2:	e8bd 86f0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, pc}
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
  chMtxLock(&m2);
  test_assert(1, chThdGetPriorityX() == p, "wrong priority level");
  chThdSleepMilliseconds(100);
 8006db6:	20c8      	movs	r0, #200	; 0xc8
 8006db8:	f7fa feea 	bl	8001b90 <chThdSleep>
 8006dbc:	692b      	ldr	r3, [r5, #16]
  test_assert(2, chThdGetPriorityX() == p1, "wrong priority level");
 8006dbe:	2002      	movs	r0, #2
 8006dc0:	6899      	ldr	r1, [r3, #8]
 8006dc2:	ebc1 0109 	rsb	r1, r1, r9
 8006dc6:	fab1 f181 	clz	r1, r1
 8006dca:	0949      	lsrs	r1, r1, #5
 8006dcc:	f7fe fff8 	bl	8005dc0 <_test_assert>
 8006dd0:	2800      	cmp	r0, #0
 8006dd2:	d1ed      	bne.n	8006db0 <mtx4_execute+0x60>
  chMtxLock(&m1);
 8006dd4:	4872      	ldr	r0, [pc, #456]	; (8006fa0 <mtx4_execute+0x250>)
 8006dd6:	f7fb f9f3 	bl	80021c0 <chMtxLock>
 8006dda:	692b      	ldr	r3, [r5, #16]
  test_assert(3, chThdGetPriorityX() == p1, "wrong priority level");
 8006ddc:	2003      	movs	r0, #3
 8006dde:	6899      	ldr	r1, [r3, #8]
 8006de0:	ebc1 0109 	rsb	r1, r1, r9
 8006de4:	fab1 f181 	clz	r1, r1
 8006de8:	0949      	lsrs	r1, r1, #5
 8006dea:	f7fe ffe9 	bl	8005dc0 <_test_assert>
 8006dee:	2800      	cmp	r0, #0
 8006df0:	d1de      	bne.n	8006db0 <mtx4_execute+0x60>
  chThdSleepMilliseconds(100);
 8006df2:	20c8      	movs	r0, #200	; 0xc8
 8006df4:	f7fa fecc 	bl	8001b90 <chThdSleep>
 8006df8:	692b      	ldr	r3, [r5, #16]
  test_assert(4, chThdGetPriorityX() == p2, "wrong priority level");
 8006dfa:	2004      	movs	r0, #4
 8006dfc:	6899      	ldr	r1, [r3, #8]
 8006dfe:	ebc1 010a 	rsb	r1, r1, sl
 8006e02:	fab1 f181 	clz	r1, r1
 8006e06:	0949      	lsrs	r1, r1, #5
 8006e08:	f7fe ffda 	bl	8005dc0 <_test_assert>
 8006e0c:	2800      	cmp	r0, #0
 8006e0e:	d1cf      	bne.n	8006db0 <mtx4_execute+0x60>
  chMtxUnlock(&m1);
 8006e10:	4863      	ldr	r0, [pc, #396]	; (8006fa0 <mtx4_execute+0x250>)
 8006e12:	f7fb f9fd 	bl	8002210 <chMtxUnlock>
 8006e16:	692b      	ldr	r3, [r5, #16]
  test_assert(5, chThdGetPriorityX() == p1, "wrong priority level");
 8006e18:	2005      	movs	r0, #5
 8006e1a:	6899      	ldr	r1, [r3, #8]
 8006e1c:	ebc1 0109 	rsb	r1, r1, r9
 8006e20:	fab1 f181 	clz	r1, r1
 8006e24:	0949      	lsrs	r1, r1, #5
 8006e26:	f7fe ffcb 	bl	8005dc0 <_test_assert>
 8006e2a:	2800      	cmp	r0, #0
 8006e2c:	d1c0      	bne.n	8006db0 <mtx4_execute+0x60>
  chThdSleepMilliseconds(100);
 8006e2e:	20c8      	movs	r0, #200	; 0xc8
 8006e30:	f7fa feae 	bl	8001b90 <chThdSleep>
 8006e34:	692b      	ldr	r3, [r5, #16]
  test_assert(6, chThdGetPriorityX() == p1, "wrong priority level");
 8006e36:	2006      	movs	r0, #6
 8006e38:	6899      	ldr	r1, [r3, #8]
 8006e3a:	ebc1 0109 	rsb	r1, r1, r9
 8006e3e:	fab1 f181 	clz	r1, r1
 8006e42:	0949      	lsrs	r1, r1, #5
 8006e44:	f7fe ffbc 	bl	8005dc0 <_test_assert>
 8006e48:	2800      	cmp	r0, #0
 8006e4a:	d1b1      	bne.n	8006db0 <mtx4_execute+0x60>
  chMtxUnlockAll();
 8006e4c:	f7fb fa40 	bl	80022d0 <chMtxUnlockAll>
 8006e50:	692b      	ldr	r3, [r5, #16]
  test_assert(7, chThdGetPriorityX() == p, "wrong priority level");
 8006e52:	2007      	movs	r0, #7
 8006e54:	6899      	ldr	r1, [r3, #8]
 8006e56:	1a61      	subs	r1, r4, r1
 8006e58:	fab1 f181 	clz	r1, r1
 8006e5c:	0949      	lsrs	r1, r1, #5
 8006e5e:	f7fe ffaf 	bl	8005dc0 <_test_assert>
 8006e62:	2800      	cmp	r0, #0
 8006e64:	d1a4      	bne.n	8006db0 <mtx4_execute+0x60>
  test_wait_threads();
 8006e66:	f7ff f823 	bl	8005eb0 <test_wait_threads>

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
 8006e6a:	4b4e      	ldr	r3, [pc, #312]	; (8006fa4 <mtx4_execute+0x254>)
 8006e6c:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8006e70:	9300      	str	r3, [sp, #0]
 8006e72:	464a      	mov	r2, r9
 8006e74:	4b45      	ldr	r3, [pc, #276]	; (8006f8c <mtx4_execute+0x23c>)
 8006e76:	9803      	ldr	r0, [sp, #12]
 8006e78:	f7fa fe1a 	bl	8001ab0 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
 8006e7c:	4b4a      	ldr	r3, [pc, #296]	; (8006fa8 <mtx4_execute+0x258>)
  chMtxUnlockAll();
  test_assert(7, chThdGetPriorityX() == p, "wrong priority level");
  test_wait_threads();

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
 8006e7e:	6038      	str	r0, [r7, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
 8006e80:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8006e84:	9300      	str	r3, [sp, #0]
 8006e86:	4652      	mov	r2, sl
 8006e88:	4b43      	ldr	r3, [pc, #268]	; (8006f98 <mtx4_execute+0x248>)
 8006e8a:	4630      	mov	r0, r6
 8006e8c:	f7fa fe10 	bl	8001ab0 <chThdCreateStatic>
 8006e90:	6078      	str	r0, [r7, #4]
  chMtxLock(&m2);
 8006e92:	4842      	ldr	r0, [pc, #264]	; (8006f9c <mtx4_execute+0x24c>)
 8006e94:	f7fb f994 	bl	80021c0 <chMtxLock>
 8006e98:	692b      	ldr	r3, [r5, #16]
  test_assert(8, chThdGetPriorityX() == p, "wrong priority level");
 8006e9a:	2008      	movs	r0, #8
 8006e9c:	6899      	ldr	r1, [r3, #8]
 8006e9e:	1a61      	subs	r1, r4, r1
 8006ea0:	fab1 f181 	clz	r1, r1
 8006ea4:	0949      	lsrs	r1, r1, #5
 8006ea6:	f7fe ff8b 	bl	8005dc0 <_test_assert>
 8006eaa:	2800      	cmp	r0, #0
 8006eac:	d180      	bne.n	8006db0 <mtx4_execute+0x60>
  chThdSleepMilliseconds(100);
 8006eae:	20c8      	movs	r0, #200	; 0xc8
 8006eb0:	f7fa fe6e 	bl	8001b90 <chThdSleep>
 8006eb4:	692b      	ldr	r3, [r5, #16]
  test_assert(9, chThdGetPriorityX() == p1, "wrong priority level");
 8006eb6:	2009      	movs	r0, #9
 8006eb8:	6899      	ldr	r1, [r3, #8]
 8006eba:	ebc1 0c09 	rsb	ip, r1, r9
 8006ebe:	f1dc 0100 	rsbs	r1, ip, #0
 8006ec2:	eb41 010c 	adc.w	r1, r1, ip
 8006ec6:	f7fe ff7b 	bl	8005dc0 <_test_assert>
 8006eca:	2800      	cmp	r0, #0
 8006ecc:	f47f af70 	bne.w	8006db0 <mtx4_execute+0x60>
  chMtxLock(&m1);
 8006ed0:	4833      	ldr	r0, [pc, #204]	; (8006fa0 <mtx4_execute+0x250>)
 8006ed2:	f7fb f975 	bl	80021c0 <chMtxLock>
 8006ed6:	692b      	ldr	r3, [r5, #16]
  test_assert(10, chThdGetPriorityX() == p1, "wrong priority level");
 8006ed8:	200a      	movs	r0, #10
 8006eda:	6899      	ldr	r1, [r3, #8]
 8006edc:	ebc1 0e09 	rsb	lr, r1, r9
 8006ee0:	f1de 0100 	rsbs	r1, lr, #0
 8006ee4:	eb41 010e 	adc.w	r1, r1, lr
 8006ee8:	f7fe ff6a 	bl	8005dc0 <_test_assert>
 8006eec:	2800      	cmp	r0, #0
 8006eee:	f47f af5f 	bne.w	8006db0 <mtx4_execute+0x60>
  chThdSleepMilliseconds(100);
 8006ef2:	20c8      	movs	r0, #200	; 0xc8
 8006ef4:	f7fa fe4c 	bl	8001b90 <chThdSleep>
 8006ef8:	692b      	ldr	r3, [r5, #16]
  test_assert(11, chThdGetPriorityX() == p2, "wrong priority level");
 8006efa:	200b      	movs	r0, #11
 8006efc:	6899      	ldr	r1, [r3, #8]
 8006efe:	ebc1 070a 	rsb	r7, r1, sl
 8006f02:	4279      	negs	r1, r7
 8006f04:	4179      	adcs	r1, r7
 8006f06:	f7fe ff5b 	bl	8005dc0 <_test_assert>
 8006f0a:	4606      	mov	r6, r0
 8006f0c:	2800      	cmp	r0, #0
 8006f0e:	f47f af4f 	bne.w	8006db0 <mtx4_execute+0x60>
 8006f12:	2320      	movs	r3, #32
 8006f14:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chMtxUnlockS(&m1);
 8006f18:	4821      	ldr	r0, [pc, #132]	; (8006fa0 <mtx4_execute+0x250>)
 8006f1a:	f7fb f9b1 	bl	8002280 <chMtxUnlockS>
  chSchRescheduleS();
 8006f1e:	f7fa fd6f 	bl	8001a00 <chSchRescheduleS>
 8006f22:	f386 8811 	msr	BASEPRI, r6
 8006f26:	692b      	ldr	r3, [r5, #16]
  chSysUnlock();
  test_assert(12, chThdGetPriorityX() == p1, "wrong priority level");
 8006f28:	200c      	movs	r0, #12
 8006f2a:	6899      	ldr	r1, [r3, #8]
 8006f2c:	ebc1 0609 	rsb	r6, r1, r9
 8006f30:	4271      	negs	r1, r6
 8006f32:	4171      	adcs	r1, r6
 8006f34:	f7fe ff44 	bl	8005dc0 <_test_assert>
 8006f38:	2800      	cmp	r0, #0
 8006f3a:	f47f af39 	bne.w	8006db0 <mtx4_execute+0x60>
  chThdSleepMilliseconds(100);
 8006f3e:	20c8      	movs	r0, #200	; 0xc8
 8006f40:	f7fa fe26 	bl	8001b90 <chThdSleep>
 8006f44:	692b      	ldr	r3, [r5, #16]
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
 8006f46:	200d      	movs	r0, #13
 8006f48:	6899      	ldr	r1, [r3, #8]
 8006f4a:	ebc1 0209 	rsb	r2, r1, r9
 8006f4e:	4251      	negs	r1, r2
 8006f50:	4151      	adcs	r1, r2
 8006f52:	f7fe ff35 	bl	8005dc0 <_test_assert>
 8006f56:	2800      	cmp	r0, #0
 8006f58:	f47f af2a 	bne.w	8006db0 <mtx4_execute+0x60>
  chMtxUnlockAll();
 8006f5c:	f7fb f9b8 	bl	80022d0 <chMtxUnlockAll>
 8006f60:	692b      	ldr	r3, [r5, #16]
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
 8006f62:	200e      	movs	r0, #14
 8006f64:	6899      	ldr	r1, [r3, #8]
 8006f66:	1a63      	subs	r3, r4, r1
 8006f68:	4259      	negs	r1, r3
 8006f6a:	4159      	adcs	r1, r3
 8006f6c:	f7fe ff28 	bl	8005dc0 <_test_assert>
 8006f70:	2800      	cmp	r0, #0
 8006f72:	f47f af1d 	bne.w	8006db0 <mtx4_execute+0x60>
  test_wait_threads();
}
 8006f76:	b005      	add	sp, #20
 8006f78:	e8bd 46f0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, lr}
  test_assert(12, chThdGetPriorityX() == p1, "wrong priority level");
  chThdSleepMilliseconds(100);
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
  chMtxUnlockAll();
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
  test_wait_threads();
 8006f7c:	f7fe bf98 	b.w	8005eb0 <test_wait_threads>
 8006f80:	20001160 	.word	0x20001160
 8006f84:	0800d790 	.word	0x0800d790
 8006f88:	0800da48 	.word	0x0800da48
 8006f8c:	08006d31 	.word	0x08006d31
 8006f90:	20001c58 	.word	0x20001c58
 8006f94:	0800da4c 	.word	0x0800da4c
 8006f98:	08006d11 	.word	0x08006d11
 8006f9c:	20000848 	.word	0x20000848
 8006fa0:	20000838 	.word	0x20000838
 8006fa4:	0800da40 	.word	0x0800da40
 8006fa8:	0800da44 	.word	0x0800da44
 8006fac:	00000000 	.word	0x00000000

08006fb0 <mtx5_execute>:
static void mtx5_setup(void) {

  chMtxObjectInit(&m1);
}

static void mtx5_execute(void) {
 8006fb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8006fb2:	4d2b      	ldr	r5, [pc, #172]	; (8007060 <mtx5_execute+0xb0>)

#if !CH_CFG_USE_MUTEXES_RECURSIVE
  bool b;
  tprio_t prio = chThdGetPriorityX();

  b = chMtxTryLock(&m1);
 8006fb4:	4c2b      	ldr	r4, [pc, #172]	; (8007064 <mtx5_execute+0xb4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8006fb6:	692b      	ldr	r3, [r5, #16]
 8006fb8:	4620      	mov	r0, r4
 8006fba:	689e      	ldr	r6, [r3, #8]
 8006fbc:	f7fb f910 	bl	80021e0 <chMtxTryLock>
 8006fc0:	4601      	mov	r1, r0
  test_assert(1, b, "already locked");
 8006fc2:	2001      	movs	r0, #1
 8006fc4:	f7fe fefc 	bl	8005dc0 <_test_assert>
 8006fc8:	b100      	cbz	r0, 8006fcc <mtx5_execute+0x1c>
 8006fca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  b = chMtxTryLock(&m1);
 8006fcc:	4620      	mov	r0, r4
 8006fce:	f7fb f907 	bl	80021e0 <chMtxTryLock>
  test_assert(2, !b, "not locked");
 8006fd2:	f080 0101 	eor.w	r1, r0, #1
 8006fd6:	b2c9      	uxtb	r1, r1
 8006fd8:	2002      	movs	r0, #2
 8006fda:	f7fe fef1 	bl	8005dc0 <_test_assert>
 8006fde:	4607      	mov	r7, r0
 8006fe0:	2800      	cmp	r0, #0
 8006fe2:	d1f2      	bne.n	8006fca <mtx5_execute+0x1a>
 8006fe4:	2320      	movs	r3, #32
 8006fe6:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chMtxUnlockS(&m1);
 8006fea:	4620      	mov	r0, r4
 8006fec:	f7fb f948 	bl	8002280 <chMtxUnlockS>
 8006ff0:	f387 8811 	msr	BASEPRI, r7
 8006ff4:	6821      	ldr	r1, [r4, #0]
  chSysUnlock();

  test_assert(3, queue_isempty(&m1.m_queue), "queue not empty");
 8006ff6:	2003      	movs	r0, #3
 8006ff8:	1b09      	subs	r1, r1, r4
 8006ffa:	fab1 f181 	clz	r1, r1
 8006ffe:	0949      	lsrs	r1, r1, #5
 8007000:	f7fe fede 	bl	8005dc0 <_test_assert>
 8007004:	2800      	cmp	r0, #0
 8007006:	d1e0      	bne.n	8006fca <mtx5_execute+0x1a>
  test_assert(4, m1.m_owner == NULL, "still owned");
 8007008:	68a1      	ldr	r1, [r4, #8]
 800700a:	2004      	movs	r0, #4
 800700c:	fab1 f181 	clz	r1, r1
 8007010:	0949      	lsrs	r1, r1, #5
 8007012:	f7fe fed5 	bl	8005dc0 <_test_assert>
 8007016:	2800      	cmp	r0, #0
 8007018:	d1d7      	bne.n	8006fca <mtx5_execute+0x1a>
 800701a:	692b      	ldr	r3, [r5, #16]
  test_assert(5, chThdGetPriorityX() == prio, "wrong priority level");
 800701c:	2005      	movs	r0, #5
 800701e:	6899      	ldr	r1, [r3, #8]
 8007020:	1a71      	subs	r1, r6, r1
 8007022:	fab1 f181 	clz	r1, r1
 8007026:	0949      	lsrs	r1, r1, #5
 8007028:	f7fe feca 	bl	8005dc0 <_test_assert>
 800702c:	2800      	cmp	r0, #0
 800702e:	d1cc      	bne.n	8006fca <mtx5_execute+0x1a>
#endif /* !CH_CFG_USE_MUTEXES_RECURSIVE */
  
  chMtxLock(&m1);
 8007030:	4620      	mov	r0, r4
 8007032:	f7fb f8c5 	bl	80021c0 <chMtxLock>
  chMtxUnlockAll();
 8007036:	f7fb f94b 	bl	80022d0 <chMtxUnlockAll>
 800703a:	6821      	ldr	r1, [r4, #0]
  test_assert(6, queue_isempty(&m1.m_queue), "queue not empty");
 800703c:	2006      	movs	r0, #6
 800703e:	1b09      	subs	r1, r1, r4
 8007040:	fab1 f181 	clz	r1, r1
 8007044:	0949      	lsrs	r1, r1, #5
 8007046:	f7fe febb 	bl	8005dc0 <_test_assert>
 800704a:	2800      	cmp	r0, #0
 800704c:	d1bd      	bne.n	8006fca <mtx5_execute+0x1a>
  test_assert(7, m1.m_owner == NULL, "still owned");
 800704e:	68a1      	ldr	r1, [r4, #8]
 8007050:	2007      	movs	r0, #7
 8007052:	fab1 f181 	clz	r1, r1
}
 8007056:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
#endif /* !CH_CFG_USE_MUTEXES_RECURSIVE */
  
  chMtxLock(&m1);
  chMtxUnlockAll();
  test_assert(6, queue_isempty(&m1.m_queue), "queue not empty");
  test_assert(7, m1.m_owner == NULL, "still owned");
 800705a:	0949      	lsrs	r1, r1, #5
 800705c:	f7fe beb0 	b.w	8005dc0 <_test_assert>
 8007060:	20001160 	.word	0x20001160
 8007064:	20000838 	.word	0x20000838
	...

08007070 <mtx6_execute>:
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx6_execute(void) {
 8007070:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8007072:	4b2f      	ldr	r3, [pc, #188]	; (8007130 <mtx6_execute+0xc0>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8007074:	4f2f      	ldr	r7, [pc, #188]	; (8007134 <mtx6_execute+0xc4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8007076:	691b      	ldr	r3, [r3, #16]
 8007078:	4d2f      	ldr	r5, [pc, #188]	; (8007138 <mtx6_execute+0xc8>)
 800707a:	689e      	ldr	r6, [r3, #8]
 800707c:	492f      	ldr	r1, [pc, #188]	; (800713c <mtx6_execute+0xcc>)
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx6_execute(void) {
 800707e:	b083      	sub	sp, #12

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8007080:	1c72      	adds	r2, r6, #1
 8007082:	462b      	mov	r3, r5
 8007084:	9100      	str	r1, [sp, #0]
 8007086:	6838      	ldr	r0, [r7, #0]
 8007088:	f44f 71a0 	mov.w	r1, #320	; 0x140
 800708c:	f7fa fd10 	bl	8001ab0 <chThdCreateStatic>
 8007090:	4c2b      	ldr	r4, [pc, #172]	; (8007140 <mtx6_execute+0xd0>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8007092:	687b      	ldr	r3, [r7, #4]
 8007094:	492b      	ldr	r1, [pc, #172]	; (8007144 <mtx6_execute+0xd4>)
}

static void mtx6_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8007096:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8007098:	1cb2      	adds	r2, r6, #2
 800709a:	9100      	str	r1, [sp, #0]
 800709c:	4618      	mov	r0, r3
 800709e:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80070a2:	462b      	mov	r3, r5
 80070a4:	f7fa fd04 	bl	8001ab0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 80070a8:	68bb      	ldr	r3, [r7, #8]
 80070aa:	4927      	ldr	r1, [pc, #156]	; (8007148 <mtx6_execute+0xd8>)

static void mtx6_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 80070ac:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 80070ae:	1cf2      	adds	r2, r6, #3
 80070b0:	9100      	str	r1, [sp, #0]
 80070b2:	4618      	mov	r0, r3
 80070b4:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80070b8:	462b      	mov	r3, r5
 80070ba:	f7fa fcf9 	bl	8001ab0 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 80070be:	68fb      	ldr	r3, [r7, #12]
 80070c0:	4922      	ldr	r1, [pc, #136]	; (800714c <mtx6_execute+0xdc>)
static void mtx6_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 80070c2:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 80070c4:	1d32      	adds	r2, r6, #4
 80070c6:	9100      	str	r1, [sp, #0]
 80070c8:	4618      	mov	r0, r3
 80070ca:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80070ce:	462b      	mov	r3, r5
 80070d0:	f7fa fcee 	bl	8001ab0 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 80070d4:	693b      	ldr	r3, [r7, #16]
 80070d6:	491e      	ldr	r1, [pc, #120]	; (8007150 <mtx6_execute+0xe0>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 80070d8:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 80070da:	1d72      	adds	r2, r6, #5
 80070dc:	9100      	str	r1, [sp, #0]
 80070de:	4618      	mov	r0, r3
 80070e0:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80070e4:	462b      	mov	r3, r5
 80070e6:	f7fa fce3 	bl	8001ab0 <chThdCreateStatic>
 80070ea:	2320      	movs	r3, #32
 80070ec:	6120      	str	r0, [r4, #16]
 80070ee:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chCondSignalI(&c1);
 80070f2:	4c18      	ldr	r4, [pc, #96]	; (8007154 <mtx6_execute+0xe4>)
 80070f4:	4620      	mov	r0, r4
 80070f6:	f7fb f93b 	bl	8002370 <chCondSignalI>
  chCondSignalI(&c1);
 80070fa:	4620      	mov	r0, r4
 80070fc:	f7fb f938 	bl	8002370 <chCondSignalI>
  chCondSignalI(&c1);
 8007100:	4620      	mov	r0, r4
 8007102:	f7fb f935 	bl	8002370 <chCondSignalI>
  chCondSignalI(&c1);
 8007106:	4620      	mov	r0, r4
 8007108:	f7fb f932 	bl	8002370 <chCondSignalI>
  chCondSignalI(&c1);
 800710c:	4620      	mov	r0, r4
 800710e:	f7fb f92f 	bl	8002370 <chCondSignalI>
  chSchRescheduleS();
 8007112:	f7fa fc75 	bl	8001a00 <chSchRescheduleS>
 8007116:	2300      	movs	r3, #0
 8007118:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  test_wait_threads();
 800711c:	f7fe fec8 	bl	8005eb0 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8007120:	490d      	ldr	r1, [pc, #52]	; (8007158 <mtx6_execute+0xe8>)
 8007122:	2001      	movs	r0, #1
}
 8007124:	b003      	add	sp, #12
 8007126:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  chCondSignalI(&c1);
  chCondSignalI(&c1);
  chSchRescheduleS();
  chSysUnlock();
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
 800712a:	f7fe be61 	b.w	8005df0 <_test_assert_sequence>
 800712e:	bf00      	nop
 8007130:	20001160 	.word	0x20001160
 8007134:	0800d790 	.word	0x0800d790
 8007138:	08007161 	.word	0x08007161
 800713c:	0800da54 	.word	0x0800da54
 8007140:	20001c58 	.word	0x20001c58
 8007144:	0800da40 	.word	0x0800da40
 8007148:	0800da44 	.word	0x0800da44
 800714c:	0800da48 	.word	0x0800da48
 8007150:	0800da4c 	.word	0x0800da4c
 8007154:	20000858 	.word	0x20000858
 8007158:	0800da50 	.word	0x0800da50
 800715c:	00000000 	.word	0x00000000

08007160 <thread10>:

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static THD_FUNCTION(thread10, p) {
 8007160:	b538      	push	{r3, r4, r5, lr}
 8007162:	4605      	mov	r5, r0

  chMtxLock(&m1);
 8007164:	4c07      	ldr	r4, [pc, #28]	; (8007184 <thread10+0x24>)
 8007166:	4620      	mov	r0, r4
 8007168:	f7fb f82a 	bl	80021c0 <chMtxLock>
  chCondWait(&c1);
 800716c:	4806      	ldr	r0, [pc, #24]	; (8007188 <thread10+0x28>)
 800716e:	f7fb f95f 	bl	8002430 <chCondWait>
  test_emit_token(*(char *)p);
 8007172:	7828      	ldrb	r0, [r5, #0]
 8007174:	f7fe fe0c 	bl	8005d90 <test_emit_token>
  chMtxUnlock(&m1);
 8007178:	4620      	mov	r0, r4
}
 800717a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
static THD_FUNCTION(thread10, p) {

  chMtxLock(&m1);
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
 800717e:	f7fb b847 	b.w	8002210 <chMtxUnlock>
 8007182:	bf00      	nop
 8007184:	20000838 	.word	0x20000838
 8007188:	20000858 	.word	0x20000858
 800718c:	00000000 	.word	0x00000000

08007190 <mtx6_setup>:
 * atomically.<br>
 * The test expects the threads to reach their goal in increasing priority
 * order regardless of the initial order.
 */

static void mtx6_setup(void) {
 8007190:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 8007192:	4804      	ldr	r0, [pc, #16]	; (80071a4 <mtx6_setup+0x14>)
 8007194:	f7fb f8cc 	bl	8002330 <chCondObjectInit>
  chMtxObjectInit(&m1);
}
 8007198:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 */

static void mtx6_setup(void) {

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
 800719c:	4802      	ldr	r0, [pc, #8]	; (80071a8 <mtx6_setup+0x18>)
 800719e:	f7fa bf9f 	b.w	80020e0 <chMtxObjectInit>
 80071a2:	bf00      	nop
 80071a4:	20000858 	.word	0x20000858
 80071a8:	20000838 	.word	0x20000838
 80071ac:	00000000 	.word	0x00000000

080071b0 <mtx7_setup>:
 * tester thread then proceeds to broadcast the conditional variable.<br>
 * The test expects the threads to reach their goal in increasing priority
 * order regardless of the initial order.
 */

static void mtx7_setup(void) {
 80071b0:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 80071b2:	4804      	ldr	r0, [pc, #16]	; (80071c4 <mtx7_setup+0x14>)
 80071b4:	f7fb f8bc 	bl	8002330 <chCondObjectInit>
  chMtxObjectInit(&m1);
}
 80071b8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 */

static void mtx7_setup(void) {

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
 80071bc:	4802      	ldr	r0, [pc, #8]	; (80071c8 <mtx7_setup+0x18>)
 80071be:	f7fa bf8f 	b.w	80020e0 <chMtxObjectInit>
 80071c2:	bf00      	nop
 80071c4:	20000858 	.word	0x20000858
 80071c8:	20000838 	.word	0x20000838
 80071cc:	00000000 	.word	0x00000000

080071d0 <mtx8_setup>:
 * This test case verifies the priority boost of a thread waiting on a
 * conditional variable queue. It tests this very specific situation in order
 * to complete the code coverage.
 */

static void mtx8_setup(void) {
 80071d0:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 80071d2:	4805      	ldr	r0, [pc, #20]	; (80071e8 <mtx8_setup+0x18>)
 80071d4:	f7fb f8ac 	bl	8002330 <chCondObjectInit>
  chMtxObjectInit(&m1);
 80071d8:	4804      	ldr	r0, [pc, #16]	; (80071ec <mtx8_setup+0x1c>)
 80071da:	f7fa ff81 	bl	80020e0 <chMtxObjectInit>
  chMtxObjectInit(&m2);
}
 80071de:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

static void mtx8_setup(void) {

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
 80071e2:	4803      	ldr	r0, [pc, #12]	; (80071f0 <mtx8_setup+0x20>)
 80071e4:	f7fa bf7c 	b.w	80020e0 <chMtxObjectInit>
 80071e8:	20000858 	.word	0x20000858
 80071ec:	20000838 	.word	0x20000838
 80071f0:	20000848 	.word	0x20000848
	...

08007200 <mtx7_execute>:

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void mtx7_execute(void) {
 8007200:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8007202:	4b24      	ldr	r3, [pc, #144]	; (8007294 <mtx7_execute+0x94>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8007204:	4f24      	ldr	r7, [pc, #144]	; (8007298 <mtx7_execute+0x98>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8007206:	691b      	ldr	r3, [r3, #16]
 8007208:	4d24      	ldr	r5, [pc, #144]	; (800729c <mtx7_execute+0x9c>)
 800720a:	689e      	ldr	r6, [r3, #8]
 800720c:	4924      	ldr	r1, [pc, #144]	; (80072a0 <mtx7_execute+0xa0>)

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void mtx7_execute(void) {
 800720e:	b083      	sub	sp, #12

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8007210:	1c72      	adds	r2, r6, #1
 8007212:	462b      	mov	r3, r5
 8007214:	9100      	str	r1, [sp, #0]
 8007216:	6838      	ldr	r0, [r7, #0]
 8007218:	f44f 71a0 	mov.w	r1, #320	; 0x140
 800721c:	f7fa fc48 	bl	8001ab0 <chThdCreateStatic>
 8007220:	4c20      	ldr	r4, [pc, #128]	; (80072a4 <mtx7_execute+0xa4>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8007222:	687b      	ldr	r3, [r7, #4]
 8007224:	4920      	ldr	r1, [pc, #128]	; (80072a8 <mtx7_execute+0xa8>)
}

static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8007226:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8007228:	1cb2      	adds	r2, r6, #2
 800722a:	9100      	str	r1, [sp, #0]
 800722c:	4618      	mov	r0, r3
 800722e:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8007232:	462b      	mov	r3, r5
 8007234:	f7fa fc3c 	bl	8001ab0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8007238:	68bb      	ldr	r3, [r7, #8]
 800723a:	491c      	ldr	r1, [pc, #112]	; (80072ac <mtx7_execute+0xac>)

static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 800723c:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 800723e:	1cf2      	adds	r2, r6, #3
 8007240:	9100      	str	r1, [sp, #0]
 8007242:	4618      	mov	r0, r3
 8007244:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8007248:	462b      	mov	r3, r5
 800724a:	f7fa fc31 	bl	8001ab0 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 800724e:	68fb      	ldr	r3, [r7, #12]
 8007250:	4917      	ldr	r1, [pc, #92]	; (80072b0 <mtx7_execute+0xb0>)
static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8007252:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8007254:	1d32      	adds	r2, r6, #4
 8007256:	9100      	str	r1, [sp, #0]
 8007258:	4618      	mov	r0, r3
 800725a:	f44f 71a0 	mov.w	r1, #320	; 0x140
 800725e:	462b      	mov	r3, r5
 8007260:	f7fa fc26 	bl	8001ab0 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 8007264:	693b      	ldr	r3, [r7, #16]
 8007266:	4913      	ldr	r1, [pc, #76]	; (80072b4 <mtx7_execute+0xb4>)
 8007268:	1d72      	adds	r2, r6, #5

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 800726a:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 800726c:	9100      	str	r1, [sp, #0]
 800726e:	4618      	mov	r0, r3
 8007270:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8007274:	462b      	mov	r3, r5
 8007276:	f7fa fc1b 	bl	8001ab0 <chThdCreateStatic>
 800727a:	6120      	str	r0, [r4, #16]
  chCondBroadcast(&c1);
 800727c:	480e      	ldr	r0, [pc, #56]	; (80072b8 <mtx7_execute+0xb8>)
 800727e:	f7fb f89f 	bl	80023c0 <chCondBroadcast>
  test_wait_threads();
 8007282:	f7fe fe15 	bl	8005eb0 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8007286:	490d      	ldr	r1, [pc, #52]	; (80072bc <mtx7_execute+0xbc>)
 8007288:	2001      	movs	r0, #1
}
 800728a:	b003      	add	sp, #12
 800728c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
  chCondBroadcast(&c1);
  test_wait_threads();
  test_assert_sequence(1, "ABCDE");
 8007290:	f7fe bdae 	b.w	8005df0 <_test_assert_sequence>
 8007294:	20001160 	.word	0x20001160
 8007298:	0800d790 	.word	0x0800d790
 800729c:	08007161 	.word	0x08007161
 80072a0:	0800da54 	.word	0x0800da54
 80072a4:	20001c58 	.word	0x20001c58
 80072a8:	0800da40 	.word	0x0800da40
 80072ac:	0800da44 	.word	0x0800da44
 80072b0:	0800da48 	.word	0x0800da48
 80072b4:	0800da4c 	.word	0x0800da4c
 80072b8:	20000858 	.word	0x20000858
 80072bc:	0800da50 	.word	0x0800da50

080072c0 <mtx8_execute>:
  chMtxLock(&m2);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m2);
}

static void mtx8_execute(void) {
 80072c0:	b570      	push	{r4, r5, r6, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80072c2:	4b1b      	ldr	r3, [pc, #108]	; (8007330 <mtx8_execute+0x70>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 80072c4:	4e1b      	ldr	r6, [pc, #108]	; (8007334 <mtx8_execute+0x74>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80072c6:	691b      	ldr	r3, [r3, #16]
  chMtxLock(&m2);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m2);
}

static void mtx8_execute(void) {
 80072c8:	b082      	sub	sp, #8
 80072ca:	689d      	ldr	r5, [r3, #8]

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 80072cc:	4b1a      	ldr	r3, [pc, #104]	; (8007338 <mtx8_execute+0x78>)
 80072ce:	1c6a      	adds	r2, r5, #1
 80072d0:	9300      	str	r3, [sp, #0]
 80072d2:	6830      	ldr	r0, [r6, #0]
 80072d4:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80072d8:	4b18      	ldr	r3, [pc, #96]	; (800733c <mtx8_execute+0x7c>)
 80072da:	f7fa fbe9 	bl	8001ab0 <chThdCreateStatic>
 80072de:	4c18      	ldr	r4, [pc, #96]	; (8007340 <mtx8_execute+0x80>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 80072e0:	6871      	ldr	r1, [r6, #4]
 80072e2:	4b18      	ldr	r3, [pc, #96]	; (8007344 <mtx8_execute+0x84>)
}

static void mtx8_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 80072e4:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 80072e6:	1caa      	adds	r2, r5, #2
 80072e8:	9300      	str	r3, [sp, #0]
 80072ea:	4608      	mov	r0, r1
 80072ec:	4b16      	ldr	r3, [pc, #88]	; (8007348 <mtx8_execute+0x88>)
 80072ee:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80072f2:	f7fa fbdd 	bl	8001ab0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
 80072f6:	68b1      	ldr	r1, [r6, #8]
 80072f8:	4b14      	ldr	r3, [pc, #80]	; (800734c <mtx8_execute+0x8c>)
 80072fa:	1cea      	adds	r2, r5, #3

static void mtx8_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 80072fc:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
 80072fe:	9300      	str	r3, [sp, #0]
 8007300:	4608      	mov	r0, r1
 8007302:	4b13      	ldr	r3, [pc, #76]	; (8007350 <mtx8_execute+0x90>)
 8007304:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8007308:	f7fa fbd2 	bl	8001ab0 <chThdCreateStatic>
  chCondSignal(&c1);
 800730c:	4d11      	ldr	r5, [pc, #68]	; (8007354 <mtx8_execute+0x94>)
static void mtx8_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
 800730e:	60a0      	str	r0, [r4, #8]
  chCondSignal(&c1);
 8007310:	4628      	mov	r0, r5
 8007312:	f7fb f815 	bl	8002340 <chCondSignal>
  chCondSignal(&c1);
 8007316:	4628      	mov	r0, r5
 8007318:	f7fb f812 	bl	8002340 <chCondSignal>
  test_wait_threads();
 800731c:	f7fe fdc8 	bl	8005eb0 <test_wait_threads>
  test_assert_sequence(1, "ABC");
 8007320:	490d      	ldr	r1, [pc, #52]	; (8007358 <mtx8_execute+0x98>)
 8007322:	2001      	movs	r0, #1
}
 8007324:	b002      	add	sp, #8
 8007326:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
  chCondSignal(&c1);
  chCondSignal(&c1);
  test_wait_threads();
  test_assert_sequence(1, "ABC");
 800732a:	f7fe bd61 	b.w	8005df0 <_test_assert_sequence>
 800732e:	bf00      	nop
 8007330:	20001160 	.word	0x20001160
 8007334:	0800d790 	.word	0x0800d790
 8007338:	0800da4c 	.word	0x0800da4c
 800733c:	08007361 	.word	0x08007361
 8007340:	20001c58 	.word	0x20001c58
 8007344:	0800da44 	.word	0x0800da44
 8007348:	08007161 	.word	0x08007161
 800734c:	0800da48 	.word	0x0800da48
 8007350:	08006cb1 	.word	0x08006cb1
 8007354:	20000858 	.word	0x20000858
 8007358:	0800dbd0 	.word	0x0800dbd0
 800735c:	00000000 	.word	0x00000000

08007360 <thread11>:
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static THD_FUNCTION(thread11, p) {
 8007360:	b570      	push	{r4, r5, r6, lr}
 8007362:	4606      	mov	r6, r0

  chMtxLock(&m2);
 8007364:	4c0b      	ldr	r4, [pc, #44]	; (8007394 <thread11+0x34>)
  chMtxLock(&m1);
 8007366:	4d0c      	ldr	r5, [pc, #48]	; (8007398 <thread11+0x38>)
  chMtxObjectInit(&m2);
}

static THD_FUNCTION(thread11, p) {

  chMtxLock(&m2);
 8007368:	4620      	mov	r0, r4
 800736a:	f7fa ff29 	bl	80021c0 <chMtxLock>
  chMtxLock(&m1);
 800736e:	4628      	mov	r0, r5
 8007370:	f7fa ff26 	bl	80021c0 <chMtxLock>
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
 8007374:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8007378:	4808      	ldr	r0, [pc, #32]	; (800739c <thread11+0x3c>)
 800737a:	f7fb f891 	bl	80024a0 <chCondWaitTimeout>
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
 800737e:	7830      	ldrb	r0, [r6, #0]
 8007380:	f7fe fd06 	bl	8005d90 <test_emit_token>
  chMtxUnlock(&m1);
 8007384:	4628      	mov	r0, r5
 8007386:	f7fa ff43 	bl	8002210 <chMtxUnlock>
  chMtxUnlock(&m2);
 800738a:	4620      	mov	r0, r4
}
 800738c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
 8007390:	f7fa bf3e 	b.w	8002210 <chMtxUnlock>
 8007394:	20000848 	.word	0x20000848
 8007398:	20000838 	.word	0x20000838
 800739c:	20000858 	.word	0x20000858

080073a0 <msg1_execute>:
  chMsgSend(p, 'A');
  chMsgSend(p, 'B');
  chMsgSend(p, 'C');
}

static void msg1_execute(void) {
 80073a0:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80073a2:	4b18      	ldr	r3, [pc, #96]	; (8007404 <msg1_execute+0x64>)
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 80073a4:	4a18      	ldr	r2, [pc, #96]	; (8007408 <msg1_execute+0x68>)
 80073a6:	691b      	ldr	r3, [r3, #16]
 80073a8:	6810      	ldr	r0, [r2, #0]
 80073aa:	689a      	ldr	r2, [r3, #8]
  chMsgSend(p, 'A');
  chMsgSend(p, 'B');
  chMsgSend(p, 'C');
}

static void msg1_execute(void) {
 80073ac:	b082      	sub	sp, #8
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 80073ae:	3201      	adds	r2, #1
 80073b0:	9300      	str	r3, [sp, #0]
 80073b2:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80073b6:	4b15      	ldr	r3, [pc, #84]	; (800740c <msg1_execute+0x6c>)
 80073b8:	f7fa fb7a 	bl	8001ab0 <chThdCreateStatic>
 80073bc:	4b14      	ldr	r3, [pc, #80]	; (8007410 <msg1_execute+0x70>)
 80073be:	6018      	str	r0, [r3, #0]
                                 thread, chThdGetSelfX());
  tp = chMsgWait();
 80073c0:	f7fb fa3e 	bl	8002840 <chMsgWait>
 80073c4:	6a44      	ldr	r4, [r0, #36]	; 0x24
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
 80073c6:	4621      	mov	r1, r4
 80073c8:	f7fb fa5a 	bl	8002880 <chMsgRelease>
  test_emit_token(msg);
 80073cc:	b2e0      	uxtb	r0, r4
 80073ce:	f7fe fcdf 	bl	8005d90 <test_emit_token>
  tp = chMsgWait();
 80073d2:	f7fb fa35 	bl	8002840 <chMsgWait>
 80073d6:	6a44      	ldr	r4, [r0, #36]	; 0x24
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
 80073d8:	4621      	mov	r1, r4
 80073da:	f7fb fa51 	bl	8002880 <chMsgRelease>
  test_emit_token(msg);
 80073de:	b2e0      	uxtb	r0, r4
 80073e0:	f7fe fcd6 	bl	8005d90 <test_emit_token>
  tp = chMsgWait();
 80073e4:	f7fb fa2c 	bl	8002840 <chMsgWait>
 80073e8:	6a44      	ldr	r4, [r0, #36]	; 0x24
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
 80073ea:	4621      	mov	r1, r4
 80073ec:	f7fb fa48 	bl	8002880 <chMsgRelease>
  test_emit_token(msg);
 80073f0:	b2e0      	uxtb	r0, r4
 80073f2:	f7fe fccd 	bl	8005d90 <test_emit_token>
  test_assert_sequence(1, "ABC");
 80073f6:	4907      	ldr	r1, [pc, #28]	; (8007414 <msg1_execute+0x74>)
 80073f8:	2001      	movs	r0, #1
}
 80073fa:	b002      	add	sp, #8
 80073fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_emit_token(msg);
  tp = chMsgWait();
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
  test_emit_token(msg);
  test_assert_sequence(1, "ABC");
 8007400:	f7fe bcf6 	b.w	8005df0 <_test_assert_sequence>
 8007404:	20001160 	.word	0x20001160
 8007408:	0800d790 	.word	0x0800d790
 800740c:	08007421 	.word	0x08007421
 8007410:	20001c58 	.word	0x20001c58
 8007414:	0800dbd0 	.word	0x0800dbd0
	...

08007420 <thread>:
 * A thread is spawned that sends four messages back to the tester thread.<br>
 * The test expect to receive the messages in the correct sequence and to
 * not find a fifth message waiting.
 */

static THD_FUNCTION(thread, p) {
 8007420:	b510      	push	{r4, lr}
 8007422:	4604      	mov	r4, r0

  chMsgSend(p, 'A');
 8007424:	2141      	movs	r1, #65	; 0x41
 8007426:	f7fb f9eb 	bl	8002800 <chMsgSend>
  chMsgSend(p, 'B');
 800742a:	4620      	mov	r0, r4
 800742c:	2142      	movs	r1, #66	; 0x42
 800742e:	f7fb f9e7 	bl	8002800 <chMsgSend>
  chMsgSend(p, 'C');
 8007432:	4620      	mov	r0, r4
}
 8007434:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

static THD_FUNCTION(thread, p) {

  chMsgSend(p, 'A');
  chMsgSend(p, 'B');
  chMsgSend(p, 'C');
 8007438:	2143      	movs	r1, #67	; 0x43
 800743a:	f7fb b9e1 	b.w	8002800 <chMsgSend>
 800743e:	bf00      	nop

08007440 <mbox1_execute>:
static void mbox1_setup(void) {

  chMBObjectInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
}

static void mbox1_execute(void) {
 8007440:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007444:	2320      	movs	r3, #32
 8007446:	b082      	sub	sp, #8
 8007448:	f383 8811 	msr	BASEPRI, r3
 800744c:	4eca      	ldr	r6, [pc, #808]	; (8007778 <mbox1_execute+0x338>)
  unsigned i;

  /*
   * Testing initial space.
   */
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 800744e:	2001      	movs	r0, #1
 8007450:	6a71      	ldr	r1, [r6, #36]	; 0x24
 8007452:	f1a1 0105 	sub.w	r1, r1, #5
 8007456:	fab1 f181 	clz	r1, r1
 800745a:	0949      	lsrs	r1, r1, #5
 800745c:	f7fe fcb0 	bl	8005dc0 <_test_assert>
 8007460:	2800      	cmp	r0, #0
 8007462:	f040 8117 	bne.w	8007694 <mbox1_execute+0x254>
 8007466:	f380 8811 	msr	BASEPRI, r0
 800746a:	2442      	movs	r4, #66	; 0x42

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800746c:	4dc2      	ldr	r5, [pc, #776]	; (8007778 <mbox1_execute+0x338>)
 800746e:	4621      	mov	r1, r4
 8007470:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8007474:	4628      	mov	r0, r5
 8007476:	f7fb fa73 	bl	8002960 <chMBPost>
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
 800747a:	fab0 f180 	clz	r1, r0
 800747e:	2002      	movs	r0, #2
 8007480:	0949      	lsrs	r1, r1, #5
 8007482:	f7fe fc9d 	bl	8005dc0 <_test_assert>
 8007486:	3401      	adds	r4, #1
 8007488:	b980      	cbnz	r0, 80074ac <mbox1_execute+0x6c>
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
 800748a:	2c46      	cmp	r4, #70	; 0x46
 800748c:	d1ee      	bne.n	800746c <mbox1_execute+0x2c>
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
  }
  msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
 800748e:	2141      	movs	r1, #65	; 0x41
 8007490:	4628      	mov	r0, r5
 8007492:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8007496:	f7fb fab3 	bl	8002a00 <chMBPostAhead>
  test_assert(3, msg1 == MSG_OK, "wrong wake-up message");
 800749a:	fab0 f180 	clz	r1, r0
 800749e:	2003      	movs	r0, #3
 80074a0:	0949      	lsrs	r1, r1, #5
 80074a2:	f7fe fc8d 	bl	8005dc0 <_test_assert>
 80074a6:	2800      	cmp	r0, #0
 80074a8:	f000 80fa 	beq.w	80076a0 <mbox1_execute+0x260>
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
}
 80074ac:	b002      	add	sp, #8
 80074ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80074b2:	f385 8811 	msr	BASEPRI, r5
 80074b6:	f387 8811 	msr	BASEPRI, r7
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(29, "ABCDE");
  test_assert_lock(30, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  test_assert_lock(31, chMBGetUsedCountI(&mb1) == 0, "still full");
 80074ba:	69a1      	ldr	r1, [r4, #24]
 80074bc:	201f      	movs	r0, #31
 80074be:	fab1 f181 	clz	r1, r1
 80074c2:	0949      	lsrs	r1, r1, #5
 80074c4:	f7fe fc7c 	bl	8005dc0 <_test_assert>
 80074c8:	2800      	cmp	r0, #0
 80074ca:	f040 8299 	bne.w	8007a00 <mbox1_execute+0x5c0>
 80074ce:	f385 8811 	msr	BASEPRI, r5
  test_assert(32, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 80074d2:	68e1      	ldr	r1, [r4, #12]
 80074d4:	68a3      	ldr	r3, [r4, #8]
 80074d6:	4638      	mov	r0, r7
 80074d8:	1acb      	subs	r3, r1, r3
 80074da:	4259      	negs	r1, r3
 80074dc:	4159      	adcs	r1, r3
 80074de:	f7fe fc6f 	bl	8005dc0 <_test_assert>
 80074e2:	2800      	cmp	r0, #0
 80074e4:	d1e2      	bne.n	80074ac <mbox1_execute+0x6c>
 80074e6:	f387 8811 	msr	BASEPRI, r7

  chSysLock();
  msg1 = chMBPostAheadI(&mb1, 'E');
 80074ea:	2145      	movs	r1, #69	; 0x45
 80074ec:	4620      	mov	r0, r4
 80074ee:	f7fb fa97 	bl	8002a20 <chMBPostAheadI>
  test_assert(33, msg1 == MSG_OK, "wrong wake-up message");
 80074f2:	fab0 f180 	clz	r1, r0
 80074f6:	2021      	movs	r0, #33	; 0x21
 80074f8:	0949      	lsrs	r1, r1, #5
 80074fa:	f7fe fc61 	bl	8005dc0 <_test_assert>
 80074fe:	2800      	cmp	r0, #0
 8007500:	d1d4      	bne.n	80074ac <mbox1_execute+0x6c>
  msg1 = chMBPostAheadI(&mb1, 'D');
 8007502:	2144      	movs	r1, #68	; 0x44
 8007504:	4620      	mov	r0, r4
 8007506:	f7fb fa8b 	bl	8002a20 <chMBPostAheadI>
  test_assert(34, msg1 == MSG_OK, "wrong wake-up message");
 800750a:	fab0 f180 	clz	r1, r0
 800750e:	2022      	movs	r0, #34	; 0x22
 8007510:	0949      	lsrs	r1, r1, #5
 8007512:	f7fe fc55 	bl	8005dc0 <_test_assert>
 8007516:	2800      	cmp	r0, #0
 8007518:	d1c8      	bne.n	80074ac <mbox1_execute+0x6c>
  msg1 = chMBPostAheadI(&mb1, 'C');
 800751a:	2143      	movs	r1, #67	; 0x43
 800751c:	4620      	mov	r0, r4
 800751e:	f7fb fa7f 	bl	8002a20 <chMBPostAheadI>
  test_assert(35, msg1 == MSG_OK, "wrong wake-up message");
 8007522:	fab0 f180 	clz	r1, r0
 8007526:	2023      	movs	r0, #35	; 0x23
 8007528:	0949      	lsrs	r1, r1, #5
 800752a:	f7fe fc49 	bl	8005dc0 <_test_assert>
 800752e:	2800      	cmp	r0, #0
 8007530:	d1bc      	bne.n	80074ac <mbox1_execute+0x6c>
  msg1 = chMBPostAheadI(&mb1, 'B');
 8007532:	2142      	movs	r1, #66	; 0x42
 8007534:	4620      	mov	r0, r4
 8007536:	f7fb fa73 	bl	8002a20 <chMBPostAheadI>
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
 800753a:	fab0 f180 	clz	r1, r0
 800753e:	2024      	movs	r0, #36	; 0x24
 8007540:	0949      	lsrs	r1, r1, #5
 8007542:	f7fe fc3d 	bl	8005dc0 <_test_assert>
 8007546:	2800      	cmp	r0, #0
 8007548:	d1b0      	bne.n	80074ac <mbox1_execute+0x6c>
  msg1 = chMBPostAheadI(&mb1, 'A');
 800754a:	4c8b      	ldr	r4, [pc, #556]	; (8007778 <mbox1_execute+0x338>)
 800754c:	2141      	movs	r1, #65	; 0x41
 800754e:	4620      	mov	r0, r4
 8007550:	f7fb fa66 	bl	8002a20 <chMBPostAheadI>
 8007554:	2300      	movs	r3, #0
 8007556:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
 800755a:	fab0 f180 	clz	r1, r0
 800755e:	2025      	movs	r0, #37	; 0x25
 8007560:	0949      	lsrs	r1, r1, #5
 8007562:	f7fe fc2d 	bl	8005dc0 <_test_assert>
 8007566:	2800      	cmp	r0, #0
 8007568:	d1a0      	bne.n	80074ac <mbox1_execute+0x6c>
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800756a:	68e1      	ldr	r1, [r4, #12]
 800756c:	68a3      	ldr	r3, [r4, #8]
 800756e:	2026      	movs	r0, #38	; 0x26
 8007570:	ebc3 0801 	rsb	r8, r3, r1
 8007574:	f1d8 0100 	rsbs	r1, r8, #0
 8007578:	eb41 0108 	adc.w	r1, r1, r8
 800757c:	f7fe fc20 	bl	8005dc0 <_test_assert>
 8007580:	2800      	cmp	r0, #0
 8007582:	d193      	bne.n	80074ac <mbox1_execute+0x6c>
 8007584:	4607      	mov	r7, r0
 8007586:	2405      	movs	r4, #5
 8007588:	f04f 0820 	mov.w	r8, #32
 800758c:	2620      	movs	r6, #32
 800758e:	f388 8811 	msr	BASEPRI, r8
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
 8007592:	4d79      	ldr	r5, [pc, #484]	; (8007778 <mbox1_execute+0x338>)
 8007594:	a901      	add	r1, sp, #4
 8007596:	4628      	mov	r0, r5
 8007598:	f7fb fa8a 	bl	8002ab0 <chMBFetchI>
 800759c:	f387 8811 	msr	BASEPRI, r7
    chSysUnlock();
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
 80075a0:	fab0 f180 	clz	r1, r0
 80075a4:	2027      	movs	r0, #39	; 0x27
 80075a6:	0949      	lsrs	r1, r1, #5
 80075a8:	f7fe fc0a 	bl	8005dc0 <_test_assert>
 80075ac:	2800      	cmp	r0, #0
 80075ae:	f47f af7d 	bne.w	80074ac <mbox1_execute+0x6c>
    test_emit_token(msg2);
 80075b2:	f89d 0004 	ldrb.w	r0, [sp, #4]
 80075b6:	f7fe fbeb 	bl	8005d90 <test_emit_token>
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostAheadI(&mb1, 'A');
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 80075ba:	3c01      	subs	r4, #1
 80075bc:	d1e6      	bne.n	800758c <mbox1_execute+0x14c>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(40, "ABCDE");
 80075be:	2028      	movs	r0, #40	; 0x28
 80075c0:	496e      	ldr	r1, [pc, #440]	; (800777c <mbox1_execute+0x33c>)
 80075c2:	f7fe fc15 	bl	8005df0 <_test_assert_sequence>
 80075c6:	2800      	cmp	r0, #0
 80075c8:	f47f af70 	bne.w	80074ac <mbox1_execute+0x6c>
 80075cc:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(41, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 80075d0:	6a69      	ldr	r1, [r5, #36]	; 0x24
 80075d2:	2029      	movs	r0, #41	; 0x29
 80075d4:	f1a1 0c05 	sub.w	ip, r1, #5
 80075d8:	f1dc 0100 	rsbs	r1, ip, #0
 80075dc:	eb41 010c 	adc.w	r1, r1, ip
 80075e0:	f7fe fbee 	bl	8005dc0 <_test_assert>
 80075e4:	2800      	cmp	r0, #0
 80075e6:	f040 80c4 	bne.w	8007772 <mbox1_execute+0x332>
 80075ea:	f384 8811 	msr	BASEPRI, r4
 80075ee:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(42, chMBGetUsedCountI(&mb1) == 0, "still full");
 80075f2:	69a9      	ldr	r1, [r5, #24]
 80075f4:	202a      	movs	r0, #42	; 0x2a
 80075f6:	fab1 f181 	clz	r1, r1
 80075fa:	0949      	lsrs	r1, r1, #5
 80075fc:	f7fe fbe0 	bl	8005dc0 <_test_assert>
 8007600:	2800      	cmp	r0, #0
 8007602:	f040 80b6 	bne.w	8007772 <mbox1_execute+0x332>
 8007606:	f384 8811 	msr	BASEPRI, r4
  test_assert(43, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800760a:	68e9      	ldr	r1, [r5, #12]
 800760c:	68ab      	ldr	r3, [r5, #8]
 800760e:	202b      	movs	r0, #43	; 0x2b
 8007610:	ebc3 0e01 	rsb	lr, r3, r1
 8007614:	f1de 0100 	rsbs	r1, lr, #0
 8007618:	eb41 010e 	adc.w	r1, r1, lr
 800761c:	f7fe fbd0 	bl	8005dc0 <_test_assert>
 8007620:	2800      	cmp	r0, #0
 8007622:	f47f af43 	bne.w	80074ac <mbox1_execute+0x6c>

  /*
   * Testing reset.
   */
  chMBReset(&mb1);
 8007626:	4628      	mov	r0, r5
 8007628:	f7fb f96a 	bl	8002900 <chMBReset>
 800762c:	f386 8811 	msr	BASEPRI, r6

  /*
   * Re-testing final conditions.
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8007630:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8007632:	202c      	movs	r0, #44	; 0x2c
 8007634:	1f4f      	subs	r7, r1, #5
 8007636:	4279      	negs	r1, r7
 8007638:	4179      	adcs	r1, r7
 800763a:	f7fe fbc1 	bl	8005dc0 <_test_assert>
 800763e:	2800      	cmp	r0, #0
 8007640:	f040 8097 	bne.w	8007772 <mbox1_execute+0x332>
 8007644:	f384 8811 	msr	BASEPRI, r4
 8007648:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
 800764c:	69a9      	ldr	r1, [r5, #24]
 800764e:	202d      	movs	r0, #45	; 0x2d
 8007650:	fab1 f181 	clz	r1, r1
 8007654:	0949      	lsrs	r1, r1, #5
 8007656:	f7fe fbb3 	bl	8005dc0 <_test_assert>
 800765a:	2800      	cmp	r0, #0
 800765c:	f040 8089 	bne.w	8007772 <mbox1_execute+0x332>
 8007660:	f384 8811 	msr	BASEPRI, r4
 8007664:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 8007668:	6829      	ldr	r1, [r5, #0]
 800766a:	68ab      	ldr	r3, [r5, #8]
 800766c:	202e      	movs	r0, #46	; 0x2e
 800766e:	1aca      	subs	r2, r1, r3
 8007670:	4251      	negs	r1, r2
 8007672:	4151      	adcs	r1, r2
 8007674:	f7fe fba4 	bl	8005dc0 <_test_assert>
 8007678:	2800      	cmp	r0, #0
 800767a:	d17a      	bne.n	8007772 <mbox1_execute+0x332>
 800767c:	f384 8811 	msr	BASEPRI, r4
 8007680:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 8007684:	6829      	ldr	r1, [r5, #0]
 8007686:	68eb      	ldr	r3, [r5, #12]
 8007688:	202f      	movs	r0, #47	; 0x2f
 800768a:	1acb      	subs	r3, r1, r3
 800768c:	4259      	negs	r1, r3
 800768e:	4159      	adcs	r1, r3
 8007690:	f7fe fb96 	bl	8005dc0 <_test_assert>
 8007694:	2300      	movs	r3, #0
 8007696:	f383 8811 	msr	BASEPRI, r3
}
 800769a:	b002      	add	sp, #8
 800769c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  test_assert(3, msg1 == MSG_OK, "wrong wake-up message");

  /*
   * Testing post timeout.
   */
  msg1 = chMBPost(&mb1, 'X', 1);
 80076a0:	2158      	movs	r1, #88	; 0x58
 80076a2:	2201      	movs	r2, #1
 80076a4:	4628      	mov	r0, r5
 80076a6:	f7fb f95b 	bl	8002960 <chMBPost>
  test_assert(4, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80076aa:	f1a0 31ff 	sub.w	r1, r0, #4294967295
 80076ae:	fab1 f181 	clz	r1, r1
 80076b2:	2004      	movs	r0, #4
 80076b4:	0949      	lsrs	r1, r1, #5
 80076b6:	f7fe fb83 	bl	8005dc0 <_test_assert>
 80076ba:	4604      	mov	r4, r0
 80076bc:	2800      	cmp	r0, #0
 80076be:	f47f aef5 	bne.w	80074ac <mbox1_execute+0x6c>
 80076c2:	2720      	movs	r7, #32
 80076c4:	f387 8811 	msr	BASEPRI, r7
  chSysLock();
  msg1 = chMBPostI(&mb1, 'X');
 80076c8:	2158      	movs	r1, #88	; 0x58
 80076ca:	4628      	mov	r0, r5
 80076cc:	f7fb f958 	bl	8002980 <chMBPostI>
 80076d0:	4601      	mov	r1, r0
 80076d2:	f384 8811 	msr	BASEPRI, r4
  chSysUnlock();
  test_assert(5, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80076d6:	f1a1 31ff 	sub.w	r1, r1, #4294967295
 80076da:	fab1 f181 	clz	r1, r1
 80076de:	2005      	movs	r0, #5
 80076e0:	0949      	lsrs	r1, r1, #5
 80076e2:	f7fe fb6d 	bl	8005dc0 <_test_assert>
 80076e6:	2800      	cmp	r0, #0
 80076e8:	f47f aee0 	bne.w	80074ac <mbox1_execute+0x6c>
  msg1 = chMBPostAhead(&mb1, 'X', 1);
 80076ec:	2158      	movs	r1, #88	; 0x58
 80076ee:	2201      	movs	r2, #1
 80076f0:	4628      	mov	r0, r5
 80076f2:	f7fb f985 	bl	8002a00 <chMBPostAhead>
  test_assert(6, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80076f6:	f1a0 31ff 	sub.w	r1, r0, #4294967295
 80076fa:	fab1 f181 	clz	r1, r1
 80076fe:	2006      	movs	r0, #6
 8007700:	0949      	lsrs	r1, r1, #5
 8007702:	f7fe fb5d 	bl	8005dc0 <_test_assert>
 8007706:	4604      	mov	r4, r0
 8007708:	2800      	cmp	r0, #0
 800770a:	f47f aecf 	bne.w	80074ac <mbox1_execute+0x6c>
 800770e:	f387 8811 	msr	BASEPRI, r7
  chSysLock();
  msg1 = chMBPostAheadI(&mb1, 'X');
 8007712:	2158      	movs	r1, #88	; 0x58
 8007714:	4628      	mov	r0, r5
 8007716:	f7fb f983 	bl	8002a20 <chMBPostAheadI>
 800771a:	4601      	mov	r1, r0
 800771c:	f384 8811 	msr	BASEPRI, r4
  chSysUnlock();
  test_assert(7, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8007720:	f1a1 31ff 	sub.w	r1, r1, #4294967295
 8007724:	fab1 f181 	clz	r1, r1
 8007728:	2007      	movs	r0, #7
 800772a:	0949      	lsrs	r1, r1, #5
 800772c:	f7fe fb48 	bl	8005dc0 <_test_assert>
 8007730:	4680      	mov	r8, r0
 8007732:	2800      	cmp	r0, #0
 8007734:	f47f aeba 	bne.w	80074ac <mbox1_execute+0x6c>
 8007738:	f387 8811 	msr	BASEPRI, r7

  /*
   * Testing final conditions.
   */
  test_assert_lock(8, chMBGetFreeCountI(&mb1) == 0, "still empty");
 800773c:	6a69      	ldr	r1, [r5, #36]	; 0x24
 800773e:	2008      	movs	r0, #8
 8007740:	fab1 f181 	clz	r1, r1
 8007744:	0949      	lsrs	r1, r1, #5
 8007746:	f7fe fb3b 	bl	8005dc0 <_test_assert>
 800774a:	4604      	mov	r4, r0
 800774c:	b110      	cbz	r0, 8007754 <mbox1_execute+0x314>
 800774e:	f388 8811 	msr	BASEPRI, r8
 8007752:	e6ab      	b.n	80074ac <mbox1_execute+0x6c>
 8007754:	f380 8811 	msr	BASEPRI, r0
 8007758:	f387 8811 	msr	BASEPRI, r7
  test_assert_lock(9, chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 800775c:	69a9      	ldr	r1, [r5, #24]
 800775e:	2009      	movs	r0, #9
 8007760:	f1a1 0e05 	sub.w	lr, r1, #5
 8007764:	f1de 0100 	rsbs	r1, lr, #0
 8007768:	eb41 010e 	adc.w	r1, r1, lr
 800776c:	f7fe fb28 	bl	8005dc0 <_test_assert>
 8007770:	b130      	cbz	r0, 8007780 <mbox1_execute+0x340>
 8007772:	f384 8811 	msr	BASEPRI, r4
 8007776:	e699      	b.n	80074ac <mbox1_execute+0x6c>
 8007778:	20000860 	.word	0x20000860
 800777c:	0800da50 	.word	0x0800da50
 8007780:	f380 8811 	msr	BASEPRI, r0
 8007784:	f387 8811 	msr	BASEPRI, r7
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8007788:	68e9      	ldr	r1, [r5, #12]
 800778a:	68ab      	ldr	r3, [r5, #8]
 800778c:	200a      	movs	r0, #10
 800778e:	1acc      	subs	r4, r1, r3
 8007790:	4261      	negs	r1, r4
 8007792:	4161      	adcs	r1, r4
 8007794:	f7fe fb14 	bl	8005dc0 <_test_assert>
 8007798:	2300      	movs	r3, #0
 800779a:	2800      	cmp	r0, #0
 800779c:	f47f af7b 	bne.w	8007696 <mbox1_execute+0x256>
 80077a0:	f383 8811 	msr	BASEPRI, r3
 80077a4:	2505      	movs	r5, #5
 80077a6:	e005      	b.n	80077b4 <mbox1_execute+0x374>
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
 80077a8:	f89d 0004 	ldrb.w	r0, [sp, #4]
 80077ac:	f7fe faf0 	bl	8005d90 <test_emit_token>
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
 80077b0:	3d01      	subs	r5, #1
 80077b2:	d00f      	beq.n	80077d4 <mbox1_execute+0x394>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 80077b4:	4c94      	ldr	r4, [pc, #592]	; (8007a08 <mbox1_execute+0x5c8>)
 80077b6:	a901      	add	r1, sp, #4
 80077b8:	4620      	mov	r0, r4
 80077ba:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80077be:	f7fb f967 	bl	8002a90 <chMBFetch>
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
 80077c2:	fab0 f180 	clz	r1, r0
 80077c6:	200b      	movs	r0, #11
 80077c8:	0949      	lsrs	r1, r1, #5
 80077ca:	f7fe faf9 	bl	8005dc0 <_test_assert>
 80077ce:	2800      	cmp	r0, #0
 80077d0:	d0ea      	beq.n	80077a8 <mbox1_execute+0x368>
 80077d2:	e66b      	b.n	80074ac <mbox1_execute+0x6c>
    test_emit_token(msg2);
  }
  test_assert_sequence(12, "ABCDE");
 80077d4:	200c      	movs	r0, #12
 80077d6:	498d      	ldr	r1, [pc, #564]	; (8007a0c <mbox1_execute+0x5cc>)
 80077d8:	f7fe fb0a 	bl	8005df0 <_test_assert_sequence>
 80077dc:	2800      	cmp	r0, #0
 80077de:	f47f ae65 	bne.w	80074ac <mbox1_execute+0x6c>

  /*
   * Testing buffer circularity.
   */
  msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 80077e2:	2147      	movs	r1, #71	; 0x47
 80077e4:	4620      	mov	r0, r4
 80077e6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80077ea:	f7fb f8b9 	bl	8002960 <chMBPost>
  test_assert(13, msg1 == MSG_OK, "wrong wake-up message");
 80077ee:	fab0 f180 	clz	r1, r0
 80077f2:	200d      	movs	r0, #13
 80077f4:	0949      	lsrs	r1, r1, #5
 80077f6:	f7fe fae3 	bl	8005dc0 <_test_assert>
 80077fa:	2800      	cmp	r0, #0
 80077fc:	f47f ae56 	bne.w	80074ac <mbox1_execute+0x6c>
  msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 8007800:	a901      	add	r1, sp, #4
 8007802:	4620      	mov	r0, r4
 8007804:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8007808:	f7fb f942 	bl	8002a90 <chMBFetch>
  test_assert(14, msg1 == MSG_OK, "wrong wake-up message");
 800780c:	fab0 f180 	clz	r1, r0
 8007810:	200e      	movs	r0, #14
 8007812:	0949      	lsrs	r1, r1, #5
 8007814:	f7fe fad4 	bl	8005dc0 <_test_assert>
 8007818:	2800      	cmp	r0, #0
 800781a:	f47f ae47 	bne.w	80074ac <mbox1_execute+0x6c>
  test_assert(15, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 800781e:	6821      	ldr	r1, [r4, #0]
 8007820:	68a3      	ldr	r3, [r4, #8]
 8007822:	200f      	movs	r0, #15
 8007824:	1aca      	subs	r2, r1, r3
 8007826:	4251      	negs	r1, r2
 8007828:	4151      	adcs	r1, r2
 800782a:	f7fe fac9 	bl	8005dc0 <_test_assert>
 800782e:	2800      	cmp	r0, #0
 8007830:	f47f ae3c 	bne.w	80074ac <mbox1_execute+0x6c>
  test_assert(16, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 8007834:	6821      	ldr	r1, [r4, #0]
 8007836:	68e3      	ldr	r3, [r4, #12]
 8007838:	2010      	movs	r0, #16
 800783a:	1acb      	subs	r3, r1, r3
 800783c:	4259      	negs	r1, r3
 800783e:	4159      	adcs	r1, r3
 8007840:	f7fe fabe 	bl	8005dc0 <_test_assert>
 8007844:	2800      	cmp	r0, #0
 8007846:	f47f ae31 	bne.w	80074ac <mbox1_execute+0x6c>

  /*
   * Testing fetch timeout.
   */
  msg1 = chMBFetch(&mb1, &msg2, 1);
 800784a:	a901      	add	r1, sp, #4
 800784c:	4620      	mov	r0, r4
 800784e:	2201      	movs	r2, #1
 8007850:	f7fb f91e 	bl	8002a90 <chMBFetch>
  test_assert(17, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8007854:	f100 0801 	add.w	r8, r0, #1
 8007858:	f1d8 0100 	rsbs	r1, r8, #0
 800785c:	eb41 0108 	adc.w	r1, r1, r8
 8007860:	2011      	movs	r0, #17
 8007862:	f7fe faad 	bl	8005dc0 <_test_assert>
 8007866:	2800      	cmp	r0, #0
 8007868:	f47f ae20 	bne.w	80074ac <mbox1_execute+0x6c>
 800786c:	2720      	movs	r7, #32
 800786e:	f387 8811 	msr	BASEPRI, r7
  chSysLock();
  msg1 = chMBFetchI(&mb1, &msg2);
 8007872:	a901      	add	r1, sp, #4
 8007874:	4620      	mov	r0, r4
 8007876:	f7fb f91b 	bl	8002ab0 <chMBFetchI>
 800787a:	4601      	mov	r1, r0
 800787c:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();
  test_assert(18, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8007880:	f101 0c01 	add.w	ip, r1, #1
 8007884:	f1dc 0100 	rsbs	r1, ip, #0
 8007888:	eb41 010c 	adc.w	r1, r1, ip
 800788c:	2012      	movs	r0, #18
 800788e:	f7fe fa97 	bl	8005dc0 <_test_assert>
 8007892:	2800      	cmp	r0, #0
 8007894:	f47f ae0a 	bne.w	80074ac <mbox1_execute+0x6c>
 8007898:	f387 8811 	msr	BASEPRI, r7

  /*
   * Testing final conditions.
   */
  test_assert_lock(19, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800789c:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800789e:	2013      	movs	r0, #19
 80078a0:	f1a1 0e05 	sub.w	lr, r1, #5
 80078a4:	f1de 0100 	rsbs	r1, lr, #0
 80078a8:	eb41 010e 	adc.w	r1, r1, lr
 80078ac:	f7fe fa88 	bl	8005dc0 <_test_assert>
 80078b0:	2800      	cmp	r0, #0
 80078b2:	f47f aeef 	bne.w	8007694 <mbox1_execute+0x254>
 80078b6:	2700      	movs	r7, #0
 80078b8:	f387 8811 	msr	BASEPRI, r7
 80078bc:	2520      	movs	r5, #32
 80078be:	f385 8811 	msr	BASEPRI, r5
  test_assert_lock(20, chMBGetUsedCountI(&mb1) == 0, "still full");
 80078c2:	69b1      	ldr	r1, [r6, #24]
 80078c4:	2014      	movs	r0, #20
 80078c6:	fab1 f181 	clz	r1, r1
 80078ca:	0949      	lsrs	r1, r1, #5
 80078cc:	f7fe fa78 	bl	8005dc0 <_test_assert>
 80078d0:	4c4d      	ldr	r4, [pc, #308]	; (8007a08 <mbox1_execute+0x5c8>)
 80078d2:	4606      	mov	r6, r0
 80078d4:	b110      	cbz	r0, 80078dc <mbox1_execute+0x49c>
 80078d6:	f387 8811 	msr	BASEPRI, r7
 80078da:	e5e7      	b.n	80074ac <mbox1_execute+0x6c>
 80078dc:	f380 8811 	msr	BASEPRI, r0
 80078e0:	f385 8811 	msr	BASEPRI, r5
  test_assert_lock(21, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 80078e4:	68e1      	ldr	r1, [r4, #12]
 80078e6:	68a3      	ldr	r3, [r4, #8]
 80078e8:	2015      	movs	r0, #21
 80078ea:	1acf      	subs	r7, r1, r3
 80078ec:	4279      	negs	r1, r7
 80078ee:	4179      	adcs	r1, r7
 80078f0:	f7fe fa66 	bl	8005dc0 <_test_assert>
 80078f4:	b110      	cbz	r0, 80078fc <mbox1_execute+0x4bc>
 80078f6:	f386 8811 	msr	BASEPRI, r6
 80078fa:	e5d7      	b.n	80074ac <mbox1_execute+0x6c>
 80078fc:	f380 8811 	msr	BASEPRI, r0
 8007900:	f385 8811 	msr	BASEPRI, r5

  /*
   * Testing I-Class.
   */
  chSysLock();
  msg1 = chMBPostI(&mb1, 'A');
 8007904:	2141      	movs	r1, #65	; 0x41
 8007906:	4620      	mov	r0, r4
 8007908:	f7fb f83a 	bl	8002980 <chMBPostI>
  test_assert(22, msg1 == MSG_OK, "wrong wake-up message");
 800790c:	fab0 f180 	clz	r1, r0
 8007910:	2016      	movs	r0, #22
 8007912:	0949      	lsrs	r1, r1, #5
 8007914:	f7fe fa54 	bl	8005dc0 <_test_assert>
 8007918:	2800      	cmp	r0, #0
 800791a:	f47f adc7 	bne.w	80074ac <mbox1_execute+0x6c>
  msg1 = chMBPostI(&mb1, 'B');
 800791e:	2142      	movs	r1, #66	; 0x42
 8007920:	4620      	mov	r0, r4
 8007922:	f7fb f82d 	bl	8002980 <chMBPostI>
  test_assert(23, msg1 == MSG_OK, "wrong wake-up message");
 8007926:	fab0 f180 	clz	r1, r0
 800792a:	2017      	movs	r0, #23
 800792c:	0949      	lsrs	r1, r1, #5
 800792e:	f7fe fa47 	bl	8005dc0 <_test_assert>
 8007932:	2800      	cmp	r0, #0
 8007934:	f47f adba 	bne.w	80074ac <mbox1_execute+0x6c>
  msg1 = chMBPostI(&mb1, 'C');
 8007938:	2143      	movs	r1, #67	; 0x43
 800793a:	4620      	mov	r0, r4
 800793c:	f7fb f820 	bl	8002980 <chMBPostI>
  test_assert(24, msg1 == MSG_OK, "wrong wake-up message");
 8007940:	fab0 f180 	clz	r1, r0
 8007944:	2018      	movs	r0, #24
 8007946:	0949      	lsrs	r1, r1, #5
 8007948:	f7fe fa3a 	bl	8005dc0 <_test_assert>
 800794c:	2800      	cmp	r0, #0
 800794e:	f47f adad 	bne.w	80074ac <mbox1_execute+0x6c>
  msg1 = chMBPostI(&mb1, 'D');
 8007952:	2144      	movs	r1, #68	; 0x44
 8007954:	4620      	mov	r0, r4
 8007956:	f7fb f813 	bl	8002980 <chMBPostI>
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
 800795a:	fab0 f180 	clz	r1, r0
 800795e:	2019      	movs	r0, #25
 8007960:	0949      	lsrs	r1, r1, #5
 8007962:	f7fe fa2d 	bl	8005dc0 <_test_assert>
 8007966:	4606      	mov	r6, r0
 8007968:	2800      	cmp	r0, #0
 800796a:	f47f ad9f 	bne.w	80074ac <mbox1_execute+0x6c>
  msg1 = chMBPostI(&mb1, 'E');
 800796e:	4620      	mov	r0, r4
 8007970:	2145      	movs	r1, #69	; 0x45
 8007972:	f7fb f805 	bl	8002980 <chMBPostI>
 8007976:	f386 8811 	msr	BASEPRI, r6
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
 800797a:	fab0 f180 	clz	r1, r0
 800797e:	201a      	movs	r0, #26
 8007980:	0949      	lsrs	r1, r1, #5
 8007982:	f7fe fa1d 	bl	8005dc0 <_test_assert>
 8007986:	2800      	cmp	r0, #0
 8007988:	f47f ad90 	bne.w	80074ac <mbox1_execute+0x6c>
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800798c:	68e1      	ldr	r1, [r4, #12]
 800798e:	68a3      	ldr	r3, [r4, #8]
 8007990:	201b      	movs	r0, #27
 8007992:	1acc      	subs	r4, r1, r3
 8007994:	4261      	negs	r1, r4
 8007996:	4161      	adcs	r1, r4
 8007998:	f7fe fa12 	bl	8005dc0 <_test_assert>
 800799c:	2800      	cmp	r0, #0
 800799e:	f47f ad85 	bne.w	80074ac <mbox1_execute+0x6c>
 80079a2:	4680      	mov	r8, r0
 80079a4:	462e      	mov	r6, r5
 80079a6:	2505      	movs	r5, #5
 80079a8:	2720      	movs	r7, #32
 80079aa:	f386 8811 	msr	BASEPRI, r6
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
 80079ae:	4c16      	ldr	r4, [pc, #88]	; (8007a08 <mbox1_execute+0x5c8>)
 80079b0:	a901      	add	r1, sp, #4
 80079b2:	4620      	mov	r0, r4
 80079b4:	f7fb f87c 	bl	8002ab0 <chMBFetchI>
 80079b8:	f388 8811 	msr	BASEPRI, r8
    chSysUnlock();
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
 80079bc:	fab0 f180 	clz	r1, r0
 80079c0:	201c      	movs	r0, #28
 80079c2:	0949      	lsrs	r1, r1, #5
 80079c4:	f7fe f9fc 	bl	8005dc0 <_test_assert>
 80079c8:	2800      	cmp	r0, #0
 80079ca:	f47f ad6f 	bne.w	80074ac <mbox1_execute+0x6c>
    test_emit_token(msg2);
 80079ce:	f89d 0004 	ldrb.w	r0, [sp, #4]
 80079d2:	f7fe f9dd 	bl	8005d90 <test_emit_token>
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostI(&mb1, 'E');
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 80079d6:	3d01      	subs	r5, #1
 80079d8:	d1e6      	bne.n	80079a8 <mbox1_execute+0x568>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(29, "ABCDE");
 80079da:	201d      	movs	r0, #29
 80079dc:	490b      	ldr	r1, [pc, #44]	; (8007a0c <mbox1_execute+0x5cc>)
 80079de:	f7fe fa07 	bl	8005df0 <_test_assert_sequence>
 80079e2:	2800      	cmp	r0, #0
 80079e4:	f47f ad62 	bne.w	80074ac <mbox1_execute+0x6c>
 80079e8:	f387 8811 	msr	BASEPRI, r7
  test_assert_lock(30, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 80079ec:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80079ee:	201e      	movs	r0, #30
 80079f0:	1f4a      	subs	r2, r1, #5
 80079f2:	4251      	negs	r1, r2
 80079f4:	4151      	adcs	r1, r2
 80079f6:	f7fe f9e3 	bl	8005dc0 <_test_assert>
 80079fa:	2800      	cmp	r0, #0
 80079fc:	f43f ad59 	beq.w	80074b2 <mbox1_execute+0x72>
 8007a00:	f385 8811 	msr	BASEPRI, r5
 8007a04:	e552      	b.n	80074ac <mbox1_execute+0x6c>
 8007a06:	bf00      	nop
 8007a08:	20000860 	.word	0x20000860
 8007a0c:	0800da50 	.word	0x0800da50

08007a10 <mbox1_setup>:
 * The test expects to find a consistent mailbox status after each operation.
 */

static void mbox1_setup(void) {

  chMBObjectInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
 8007a10:	4802      	ldr	r0, [pc, #8]	; (8007a1c <mbox1_setup+0xc>)
 8007a12:	4903      	ldr	r1, [pc, #12]	; (8007a20 <mbox1_setup+0x10>)
 8007a14:	2205      	movs	r2, #5
 8007a16:	f7fa bf43 	b.w	80028a0 <chMBObjectInit>
 8007a1a:	bf00      	nop
 8007a1c:	20000860 	.word	0x20000860
 8007a20:	200015f8 	.word	0x200015f8
	...

08007a30 <h3>:
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 8007a30:	2043      	movs	r0, #67	; 0x43
 8007a32:	f7fe b9ad 	b.w	8005d90 <test_emit_token>
 8007a36:	bf00      	nop
	...

08007a40 <h2>:

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 8007a40:	2042      	movs	r0, #66	; 0x42
 8007a42:	f7fe b9a5 	b.w	8005d90 <test_emit_token>
 8007a46:	bf00      	nop
	...

08007a50 <h1>:
static void evt1_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 8007a50:	2041      	movs	r0, #65	; 0x41
 8007a52:	f7fe b99d 	b.w	8005d90 <test_emit_token>
 8007a56:	bf00      	nop
	...

08007a60 <evt1_execute>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static void evt1_execute(void) {
 8007a60:	b510      	push	{r4, lr}
 8007a62:	4c1f      	ldr	r4, [pc, #124]	; (8007ae0 <evt1_execute+0x80>)
 8007a64:	b08a      	sub	sp, #40	; 0x28
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 8007a66:	4620      	mov	r0, r4
 8007a68:	4669      	mov	r1, sp
 8007a6a:	2201      	movs	r2, #1
 8007a6c:	f04f 33ff 	mov.w	r3, #4294967295
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 8007a70:	6024      	str	r4, [r4, #0]
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 8007a72:	f7fa fd25 	bl	80024c0 <chEvtRegisterMaskWithFlags>
 8007a76:	4620      	mov	r0, r4
 8007a78:	a905      	add	r1, sp, #20
 8007a7a:	2202      	movs	r2, #2
 8007a7c:	f04f 33ff 	mov.w	r3, #4294967295
 8007a80:	f7fa fd1e 	bl	80024c0 <chEvtRegisterMaskWithFlags>
 *
 * @iclass
 */
static inline bool chEvtIsListeningI(event_source_t *esp) {

  return (bool)(esp != (event_source_t *)esp->es_next);
 8007a84:	6821      	ldr	r1, [r4, #0]
   * Testing chEvtRegisterMask() and chEvtUnregister().
   */
  chEvtObjectInit(&es1);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es1, &el2, 2);
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
 8007a86:	2001      	movs	r0, #1
 8007a88:	1b09      	subs	r1, r1, r4
 8007a8a:	bf18      	it	ne
 8007a8c:	2101      	movne	r1, #1
 8007a8e:	f7fe f997 	bl	8005dc0 <_test_assert>
 8007a92:	b108      	cbz	r0, 8007a98 <evt1_execute+0x38>
  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
  test_assert_sequence(4, "ABC");
}
 8007a94:	b00a      	add	sp, #40	; 0x28
 8007a96:	bd10      	pop	{r4, pc}
   */
  chEvtObjectInit(&es1);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es1, &el2, 2);
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
  chEvtUnregister(&es1, &el1);
 8007a98:	4669      	mov	r1, sp
 8007a9a:	4620      	mov	r0, r4
 8007a9c:	f7fa fd28 	bl	80024f0 <chEvtUnregister>
 8007aa0:	6821      	ldr	r1, [r4, #0]
  test_assert(2, chEvtIsListeningI(&es1), "no listener");
 8007aa2:	2002      	movs	r0, #2
 8007aa4:	1b09      	subs	r1, r1, r4
 8007aa6:	bf18      	it	ne
 8007aa8:	2101      	movne	r1, #1
 8007aaa:	f7fe f989 	bl	8005dc0 <_test_assert>
 8007aae:	2800      	cmp	r0, #0
 8007ab0:	d1f0      	bne.n	8007a94 <evt1_execute+0x34>
  chEvtUnregister(&es1, &el2);
 8007ab2:	a905      	add	r1, sp, #20
 8007ab4:	4620      	mov	r0, r4
 8007ab6:	f7fa fd1b 	bl	80024f0 <chEvtUnregister>
  test_assert(3, !chEvtIsListeningI(&es1), "stuck listener");
 8007aba:	6821      	ldr	r1, [r4, #0]
 8007abc:	2003      	movs	r0, #3
 8007abe:	1b09      	subs	r1, r1, r4
 8007ac0:	fab1 f181 	clz	r1, r1
 8007ac4:	0949      	lsrs	r1, r1, #5
 8007ac6:	f7fe f97b 	bl	8005dc0 <_test_assert>
 8007aca:	2800      	cmp	r0, #0
 8007acc:	d1e2      	bne.n	8007a94 <evt1_execute+0x34>

  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
 8007ace:	4805      	ldr	r0, [pc, #20]	; (8007ae4 <evt1_execute+0x84>)
 8007ad0:	2107      	movs	r1, #7
 8007ad2:	f7fa fd9d 	bl	8002610 <chEvtDispatch>
  test_assert_sequence(4, "ABC");
 8007ad6:	4904      	ldr	r1, [pc, #16]	; (8007ae8 <evt1_execute+0x88>)
 8007ad8:	2004      	movs	r0, #4
 8007ada:	f7fe f989 	bl	8005df0 <_test_assert_sequence>
 8007ade:	e7d9      	b.n	8007a94 <evt1_execute+0x34>
 8007ae0:	20000888 	.word	0x20000888
 8007ae4:	0800ddb0 	.word	0x0800ddb0
 8007ae8:	0800dbd0 	.word	0x0800dbd0
 8007aec:	00000000 	.word	0x00000000

08007af0 <evt1_setup>:
 * the associated event handlers are invoked in LSb-first order.
 */

static void evt1_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
 8007af0:	f04f 30ff 	mov.w	r0, #4294967295
 8007af4:	f7fa bd14 	b.w	8002520 <chEvtGetAndClearEvents>
	...

08007b00 <evt2_setup>:
 * the expected time and that there are no stuck event flags.
 */

static void evt2_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
 8007b00:	f04f 30ff 	mov.w	r0, #4294967295
 8007b04:	f7fa bd0c 	b.w	8002520 <chEvtGetAndClearEvents>
	...

08007b10 <evt3_setup>:
 * After each test phase the test verifies that there are no stuck event flags.
 */

static void evt3_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
 8007b10:	f04f 30ff 	mov.w	r0, #4294967295
 8007b14:	f7fa bd04 	b.w	8002520 <chEvtGetAndClearEvents>
	...

08007b20 <evt2_execute>:
  chEvtBroadcast(&es1);
  chThdSleepMilliseconds(50);
  chEvtBroadcast(&es2);
}

static void evt2_execute(void) {
 8007b20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  systime_t target_time;

  /*
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
 8007b24:	2007      	movs	r0, #7
  chEvtBroadcast(&es1);
  chThdSleepMilliseconds(50);
  chEvtBroadcast(&es2);
}

static void evt2_execute(void) {
 8007b26:	b08c      	sub	sp, #48	; 0x30
  systime_t target_time;

  /*
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
 8007b28:	f7fa fd12 	bl	8002550 <chEvtAddEvents>
  m = chEvtWaitOne(ALL_EVENTS);
 8007b2c:	f04f 30ff 	mov.w	r0, #4294967295
 8007b30:	f7fa fd8e 	bl	8002650 <chEvtWaitOne>
  test_assert(1, m == 1, "single event error");
 8007b34:	f1a0 0101 	sub.w	r1, r0, #1
 8007b38:	fab1 f181 	clz	r1, r1
 8007b3c:	2001      	movs	r0, #1
 8007b3e:	0949      	lsrs	r1, r1, #5
 8007b40:	f7fe f93e 	bl	8005dc0 <_test_assert>
 8007b44:	b110      	cbz	r0, 8007b4c <evt2_execute+0x2c>
  test_wait_threads();
  chEvtUnregister(&es1, &el1);
  chEvtUnregister(&es2, &el2);
  test_assert(15, !chEvtIsListeningI(&es1), "stuck listener");
  test_assert(16, !chEvtIsListeningI(&es2), "stuck listener");
}
 8007b46:	b00c      	add	sp, #48	; 0x30
 8007b48:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
  m = chEvtWaitOne(ALL_EVENTS);
  test_assert(1, m == 1, "single event error");
  m = chEvtWaitOne(ALL_EVENTS);
 8007b4c:	f04f 30ff 	mov.w	r0, #4294967295
 8007b50:	f7fa fd7e 	bl	8002650 <chEvtWaitOne>
  test_assert(2, m == 2, "single event error");
 8007b54:	f1a0 0102 	sub.w	r1, r0, #2
 8007b58:	fab1 f181 	clz	r1, r1
 8007b5c:	2002      	movs	r0, #2
 8007b5e:	0949      	lsrs	r1, r1, #5
 8007b60:	f7fe f92e 	bl	8005dc0 <_test_assert>
 8007b64:	2800      	cmp	r0, #0
 8007b66:	d1ee      	bne.n	8007b46 <evt2_execute+0x26>
  m = chEvtWaitOne(ALL_EVENTS);
 8007b68:	f04f 30ff 	mov.w	r0, #4294967295
 8007b6c:	f7fa fd70 	bl	8002650 <chEvtWaitOne>
  test_assert(3, m == 4, "single event error");
 8007b70:	f1a0 0104 	sub.w	r1, r0, #4
 8007b74:	fab1 f181 	clz	r1, r1
 8007b78:	2003      	movs	r0, #3
 8007b7a:	0949      	lsrs	r1, r1, #5
 8007b7c:	f7fe f920 	bl	8005dc0 <_test_assert>
 8007b80:	2800      	cmp	r0, #0
 8007b82:	d1e0      	bne.n	8007b46 <evt2_execute+0x26>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8007b84:	f04f 30ff 	mov.w	r0, #4294967295
 8007b88:	f7fa fcca 	bl	8002520 <chEvtGetAndClearEvents>
  test_assert(4, m == 0, "stuck event");
 8007b8c:	fab0 f180 	clz	r1, r0
 8007b90:	2004      	movs	r0, #4
 8007b92:	0949      	lsrs	r1, r1, #5
 8007b94:	f7fe f914 	bl	8005dc0 <_test_assert>
 8007b98:	4604      	mov	r4, r0
 8007b9a:	2800      	cmp	r0, #0
 8007b9c:	d1d3      	bne.n	8007b46 <evt2_execute+0x26>

  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
 8007b9e:	f7fe f99f 	bl	8005ee0 <test_wait_tick>
 8007ba2:	f04f 0820 	mov.w	r8, #32
 8007ba6:	f388 8811 	msr	BASEPRI, r8
 8007baa:	4e7c      	ldr	r6, [pc, #496]	; (8007d9c <evt2_execute+0x27c>)
 8007bac:	8bf5      	ldrh	r5, [r6, #30]
 8007bae:	b2ad      	uxth	r5, r5
 8007bb0:	f384 8811 	msr	BASEPRI, r4
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8007bb4:	f8df 9200 	ldr.w	r9, [pc, #512]	; 8007db8 <evt2_execute+0x298>
 8007bb8:	6933      	ldr	r3, [r6, #16]
 8007bba:	f8d9 4000 	ldr.w	r4, [r9]
 8007bbe:	689a      	ldr	r2, [r3, #8]
 8007bc0:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8007bc4:	3a01      	subs	r2, #1
 8007bc6:	9300      	str	r3, [sp, #0]
 8007bc8:	4620      	mov	r0, r4
 8007bca:	4b75      	ldr	r3, [pc, #468]	; (8007da0 <evt2_execute+0x280>)
 8007bcc:	f7f9 ff70 	bl	8001ab0 <chThdCreateStatic>
 8007bd0:	4f74      	ldr	r7, [pc, #464]	; (8007da4 <evt2_execute+0x284>)
 8007bd2:	6038      	str	r0, [r7, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
 8007bd4:	f04f 30ff 	mov.w	r0, #4294967295
 8007bd8:	f7fa fd3a 	bl	8002650 <chEvtWaitOne>

  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
 8007bdc:	f105 0164 	add.w	r1, r5, #100	; 0x64
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
 8007be0:	f105 026e 	add.w	r2, r5, #110	; 0x6e
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
 8007be4:	4682      	mov	sl, r0
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
 8007be6:	b289      	uxth	r1, r1
 8007be8:	b292      	uxth	r2, r2
 8007bea:	2005      	movs	r0, #5
 8007bec:	f7fe f928 	bl	8005e40 <_test_assert_time_window>
 8007bf0:	2800      	cmp	r0, #0
 8007bf2:	d1a8      	bne.n	8007b46 <evt2_execute+0x26>
  test_assert(6, m == 1, "single event error");
 8007bf4:	f1aa 0101 	sub.w	r1, sl, #1
 8007bf8:	fab1 f181 	clz	r1, r1
 8007bfc:	2006      	movs	r0, #6
 8007bfe:	0949      	lsrs	r1, r1, #5
 8007c00:	f7fe f8de 	bl	8005dc0 <_test_assert>
 8007c04:	2800      	cmp	r0, #0
 8007c06:	d19e      	bne.n	8007b46 <evt2_execute+0x26>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8007c08:	f04f 30ff 	mov.w	r0, #4294967295
 8007c0c:	f7fa fc88 	bl	8002520 <chEvtGetAndClearEvents>
  test_assert(7, m == 0, "stuck event");
 8007c10:	fab0 f180 	clz	r1, r0
 8007c14:	2007      	movs	r0, #7
 8007c16:	0949      	lsrs	r1, r1, #5
 8007c18:	f7fe f8d2 	bl	8005dc0 <_test_assert>
 8007c1c:	2800      	cmp	r0, #0
 8007c1e:	d192      	bne.n	8007b46 <evt2_execute+0x26>
  test_wait_threads();
 8007c20:	f7fe f946 	bl	8005eb0 <test_wait_threads>

  /*
   * Test on chEvtWaitAny() without wait.
   */
  chEvtAddEvents(5);
 8007c24:	2005      	movs	r0, #5
 8007c26:	f7fa fc93 	bl	8002550 <chEvtAddEvents>
  m = chEvtWaitAny(ALL_EVENTS);
 8007c2a:	f04f 30ff 	mov.w	r0, #4294967295
 8007c2e:	f7fa fd2f 	bl	8002690 <chEvtWaitAny>
  test_assert(8, m == 5, "unexpected pending bit");
 8007c32:	1f45      	subs	r5, r0, #5
 8007c34:	4269      	negs	r1, r5
 8007c36:	4169      	adcs	r1, r5
 8007c38:	2008      	movs	r0, #8
 8007c3a:	f7fe f8c1 	bl	8005dc0 <_test_assert>
 8007c3e:	2800      	cmp	r0, #0
 8007c40:	d181      	bne.n	8007b46 <evt2_execute+0x26>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8007c42:	f04f 30ff 	mov.w	r0, #4294967295
 8007c46:	f7fa fc6b 	bl	8002520 <chEvtGetAndClearEvents>
  test_assert(9, m == 0, "stuck event");
 8007c4a:	fab0 f180 	clz	r1, r0
 8007c4e:	2009      	movs	r0, #9
 8007c50:	0949      	lsrs	r1, r1, #5
 8007c52:	f7fe f8b5 	bl	8005dc0 <_test_assert>
 8007c56:	4682      	mov	sl, r0
 8007c58:	2800      	cmp	r0, #0
 8007c5a:	f47f af74 	bne.w	8007b46 <evt2_execute+0x26>

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
 8007c5e:	f7fe f93f 	bl	8005ee0 <test_wait_tick>
 8007c62:	f388 8811 	msr	BASEPRI, r8
 8007c66:	8bf5      	ldrh	r5, [r6, #30]
 8007c68:	b2ad      	uxth	r5, r5
 8007c6a:	f38a 8811 	msr	BASEPRI, sl
 8007c6e:	6933      	ldr	r3, [r6, #16]
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8007c70:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8007c74:	689a      	ldr	r2, [r3, #8]
 8007c76:	4620      	mov	r0, r4
 8007c78:	3a01      	subs	r2, #1
 8007c7a:	9300      	str	r3, [sp, #0]
 8007c7c:	4b48      	ldr	r3, [pc, #288]	; (8007da0 <evt2_execute+0x280>)
 8007c7e:	f7f9 ff17 	bl	8001ab0 <chThdCreateStatic>
 8007c82:	6038      	str	r0, [r7, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
 8007c84:	f04f 30ff 	mov.w	r0, #4294967295
 8007c88:	f7fa fd02 	bl	8002690 <chEvtWaitAny>

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
 8007c8c:	f105 0164 	add.w	r1, r5, #100	; 0x64
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
 8007c90:	f105 026e 	add.w	r2, r5, #110	; 0x6e
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
 8007c94:	4604      	mov	r4, r0
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
 8007c96:	b289      	uxth	r1, r1
 8007c98:	b292      	uxth	r2, r2
 8007c9a:	200a      	movs	r0, #10
 8007c9c:	f7fe f8d0 	bl	8005e40 <_test_assert_time_window>
 8007ca0:	2800      	cmp	r0, #0
 8007ca2:	f47f af50 	bne.w	8007b46 <evt2_execute+0x26>
  test_assert(11, m == 1, "single event error");
 8007ca6:	1e60      	subs	r0, r4, #1
 8007ca8:	4241      	negs	r1, r0
 8007caa:	4141      	adcs	r1, r0
 8007cac:	200b      	movs	r0, #11
 8007cae:	f7fe f887 	bl	8005dc0 <_test_assert>
 8007cb2:	2800      	cmp	r0, #0
 8007cb4:	f47f af47 	bne.w	8007b46 <evt2_execute+0x26>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8007cb8:	f04f 30ff 	mov.w	r0, #4294967295
 8007cbc:	f7fa fc30 	bl	8002520 <chEvtGetAndClearEvents>
  test_assert(12, m == 0, "stuck event");
 8007cc0:	fab0 f180 	clz	r1, r0
 8007cc4:	200c      	movs	r0, #12
 8007cc6:	0949      	lsrs	r1, r1, #5
 8007cc8:	f7fe f87a 	bl	8005dc0 <_test_assert>
 8007ccc:	4682      	mov	sl, r0
 8007cce:	2800      	cmp	r0, #0
 8007cd0:	f47f af39 	bne.w	8007b46 <evt2_execute+0x26>
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 8007cd4:	4d34      	ldr	r5, [pc, #208]	; (8007da8 <evt2_execute+0x288>)
 8007cd6:	4c35      	ldr	r4, [pc, #212]	; (8007dac <evt2_execute+0x28c>)
  test_wait_threads();
 8007cd8:	f7fe f8ea 	bl	8005eb0 <test_wait_threads>
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 8007cdc:	4628      	mov	r0, r5
 8007cde:	a902      	add	r1, sp, #8
 8007ce0:	2201      	movs	r2, #1
 8007ce2:	f04f 33ff 	mov.w	r3, #4294967295
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 8007ce6:	602d      	str	r5, [r5, #0]
 8007ce8:	6024      	str	r4, [r4, #0]
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 8007cea:	f7fa fbe9 	bl	80024c0 <chEvtRegisterMaskWithFlags>
 8007cee:	4620      	mov	r0, r4
 8007cf0:	a907      	add	r1, sp, #28
 8007cf2:	2204      	movs	r2, #4
 8007cf4:	f04f 33ff 	mov.w	r3, #4294967295
 8007cf8:	f7fa fbe2 	bl	80024c0 <chEvtRegisterMaskWithFlags>
   */
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es2, &el2, 4);
  test_wait_tick();
 8007cfc:	f7fe f8f0 	bl	8005ee0 <test_wait_tick>
 8007d00:	f388 8811 	msr	BASEPRI, r8
 8007d04:	f8b6 801e 	ldrh.w	r8, [r6, #30]
 8007d08:	fa1f f888 	uxth.w	r8, r8
 8007d0c:	f38a 8811 	msr	BASEPRI, sl
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8007d10:	6932      	ldr	r2, [r6, #16]
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8007d12:	4b27      	ldr	r3, [pc, #156]	; (8007db0 <evt2_execute+0x290>)
 8007d14:	6892      	ldr	r2, [r2, #8]
 8007d16:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8007d1a:	3a01      	subs	r2, #1
 8007d1c:	9300      	str	r3, [sp, #0]
 8007d1e:	f8d9 0000 	ldr.w	r0, [r9]
 8007d22:	4b24      	ldr	r3, [pc, #144]	; (8007db4 <evt2_execute+0x294>)
 8007d24:	f7f9 fec4 	bl	8001ab0 <chThdCreateStatic>
 8007d28:	6038      	str	r0, [r7, #0]
                                 thread2, "A");
  m = chEvtWaitAll(5);
 8007d2a:	2005      	movs	r0, #5
 8007d2c:	f7fa fcd0 	bl	80026d0 <chEvtWaitAll>
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es2, &el2, 4);
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
 8007d30:	f108 0164 	add.w	r1, r8, #100	; 0x64
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread2, "A");
  m = chEvtWaitAll(5);
  test_assert_time_window(13, target_time, target_time + ALLOWED_DELAY);
 8007d34:	f108 026e 	add.w	r2, r8, #110	; 0x6e
 8007d38:	b289      	uxth	r1, r1
 8007d3a:	b292      	uxth	r2, r2
 8007d3c:	200d      	movs	r0, #13
 8007d3e:	f7fe f87f 	bl	8005e40 <_test_assert_time_window>
 8007d42:	2800      	cmp	r0, #0
 8007d44:	f47f aeff 	bne.w	8007b46 <evt2_execute+0x26>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8007d48:	f04f 30ff 	mov.w	r0, #4294967295
 8007d4c:	f7fa fbe8 	bl	8002520 <chEvtGetAndClearEvents>
  test_assert(14, m == 0, "stuck event");
 8007d50:	fab0 f180 	clz	r1, r0
 8007d54:	200e      	movs	r0, #14
 8007d56:	0949      	lsrs	r1, r1, #5
 8007d58:	f7fe f832 	bl	8005dc0 <_test_assert>
 8007d5c:	2800      	cmp	r0, #0
 8007d5e:	f47f aef2 	bne.w	8007b46 <evt2_execute+0x26>
  test_wait_threads();
 8007d62:	f7fe f8a5 	bl	8005eb0 <test_wait_threads>
  chEvtUnregister(&es1, &el1);
 8007d66:	4628      	mov	r0, r5
 8007d68:	a902      	add	r1, sp, #8
 8007d6a:	f7fa fbc1 	bl	80024f0 <chEvtUnregister>
  chEvtUnregister(&es2, &el2);
 8007d6e:	4620      	mov	r0, r4
 8007d70:	a907      	add	r1, sp, #28
 8007d72:	f7fa fbbd 	bl	80024f0 <chEvtUnregister>
  test_assert(15, !chEvtIsListeningI(&es1), "stuck listener");
 8007d76:	6829      	ldr	r1, [r5, #0]
 8007d78:	200f      	movs	r0, #15
 8007d7a:	1b4a      	subs	r2, r1, r5
 8007d7c:	4251      	negs	r1, r2
 8007d7e:	4151      	adcs	r1, r2
 8007d80:	f7fe f81e 	bl	8005dc0 <_test_assert>
 8007d84:	2800      	cmp	r0, #0
 8007d86:	f47f aede 	bne.w	8007b46 <evt2_execute+0x26>
  test_assert(16, !chEvtIsListeningI(&es2), "stuck listener");
 8007d8a:	6821      	ldr	r1, [r4, #0]
 8007d8c:	2010      	movs	r0, #16
 8007d8e:	1b0b      	subs	r3, r1, r4
 8007d90:	4259      	negs	r1, r3
 8007d92:	4159      	adcs	r1, r3
 8007d94:	f7fe f814 	bl	8005dc0 <_test_assert>
 8007d98:	e6d5      	b.n	8007b46 <evt2_execute+0x26>
 8007d9a:	bf00      	nop
 8007d9c:	20001160 	.word	0x20001160
 8007da0:	08007df1 	.word	0x08007df1
 8007da4:	20001c58 	.word	0x20001c58
 8007da8:	20000888 	.word	0x20000888
 8007dac:	2000088c 	.word	0x2000088c
 8007db0:	0800da4c 	.word	0x0800da4c
 8007db4:	08007dc1 	.word	0x08007dc1
 8007db8:	0800d790 	.word	0x0800d790
 8007dbc:	00000000 	.word	0x00000000

08007dc0 <thread2>:

  chThdSleepMilliseconds(50);
  chEvtSignal((thread_t *)p, 1);
}

static THD_FUNCTION(thread2, p) {
 8007dc0:	b508      	push	{r3, lr}
 *
 * @api
 */
static inline void chEvtBroadcast(event_source_t *esp) {

  chEvtBroadcastFlags(esp, (eventflags_t)0);
 8007dc2:	2100      	movs	r1, #0
 8007dc4:	4805      	ldr	r0, [pc, #20]	; (8007ddc <thread2+0x1c>)
 8007dc6:	f7fa fc13 	bl	80025f0 <chEvtBroadcastFlags>

  (void)p;
  chEvtBroadcast(&es1);
  chThdSleepMilliseconds(50);
 8007dca:	2064      	movs	r0, #100	; 0x64
 8007dcc:	f7f9 fee0 	bl	8001b90 <chThdSleep>
  chEvtBroadcast(&es2);
}
 8007dd0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8007dd4:	4802      	ldr	r0, [pc, #8]	; (8007de0 <thread2+0x20>)
 8007dd6:	2100      	movs	r1, #0
 8007dd8:	f7fa bc0a 	b.w	80025f0 <chEvtBroadcastFlags>
 8007ddc:	20000888 	.word	0x20000888
 8007de0:	2000088c 	.word	0x2000088c
	...

08007df0 <thread1>:
static void evt2_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static THD_FUNCTION(thread1, p) {
 8007df0:	b510      	push	{r4, lr}
 8007df2:	4604      	mov	r4, r0

  chThdSleepMilliseconds(50);
 8007df4:	2064      	movs	r0, #100	; 0x64
 8007df6:	f7f9 fecb 	bl	8001b90 <chThdSleep>
  chEvtSignal((thread_t *)p, 1);
 8007dfa:	4620      	mov	r0, r4
}
 8007dfc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
}

static THD_FUNCTION(thread1, p) {

  chThdSleepMilliseconds(50);
  chEvtSignal((thread_t *)p, 1);
 8007e00:	2101      	movs	r1, #1
 8007e02:	f7fa bbe5 	b.w	80025d0 <chEvtSignal>
 8007e06:	bf00      	nop
	...

08007e10 <evt3_execute>:
static void evt3_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void evt3_execute(void) {
 8007e10:	b508      	push	{r3, lr}
  eventmask_t m;

  /*
   * Tests various timeout situations.
   */
  m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8007e12:	2100      	movs	r1, #0
 8007e14:	f04f 30ff 	mov.w	r0, #4294967295
 8007e18:	f7fa fc7a 	bl	8002710 <chEvtWaitOneTimeout>
  test_assert(1, m == 0, "spurious event");
 8007e1c:	fab0 f180 	clz	r1, r0
 8007e20:	2001      	movs	r0, #1
 8007e22:	0949      	lsrs	r1, r1, #5
 8007e24:	f7fd ffcc 	bl	8005dc0 <_test_assert>
 8007e28:	b100      	cbz	r0, 8007e2c <evt3_execute+0x1c>
 8007e2a:	bd08      	pop	{r3, pc}
  m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8007e2c:	4601      	mov	r1, r0
 8007e2e:	f04f 30ff 	mov.w	r0, #4294967295
 8007e32:	f7fa fc95 	bl	8002760 <chEvtWaitAnyTimeout>
  test_assert(2, m == 0, "spurious event");
 8007e36:	fab0 f180 	clz	r1, r0
 8007e3a:	2002      	movs	r0, #2
 8007e3c:	0949      	lsrs	r1, r1, #5
 8007e3e:	f7fd ffbf 	bl	8005dc0 <_test_assert>
 8007e42:	2800      	cmp	r0, #0
 8007e44:	d1f1      	bne.n	8007e2a <evt3_execute+0x1a>
  m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8007e46:	4601      	mov	r1, r0
 8007e48:	f04f 30ff 	mov.w	r0, #4294967295
 8007e4c:	f7fa fcb0 	bl	80027b0 <chEvtWaitAllTimeout>
  test_assert(3, m == 0, "spurious event");
 8007e50:	fab0 f180 	clz	r1, r0
 8007e54:	2003      	movs	r0, #3
 8007e56:	0949      	lsrs	r1, r1, #5
 8007e58:	f7fd ffb2 	bl	8005dc0 <_test_assert>
 8007e5c:	2800      	cmp	r0, #0
 8007e5e:	d1e4      	bne.n	8007e2a <evt3_execute+0x1a>
  m = chEvtWaitOneTimeout(ALL_EVENTS, 10);
 8007e60:	210a      	movs	r1, #10
 8007e62:	f04f 30ff 	mov.w	r0, #4294967295
 8007e66:	f7fa fc53 	bl	8002710 <chEvtWaitOneTimeout>
  test_assert(4, m == 0, "spurious event");
 8007e6a:	fab0 f180 	clz	r1, r0
 8007e6e:	2004      	movs	r0, #4
 8007e70:	0949      	lsrs	r1, r1, #5
 8007e72:	f7fd ffa5 	bl	8005dc0 <_test_assert>
 8007e76:	2800      	cmp	r0, #0
 8007e78:	d1d7      	bne.n	8007e2a <evt3_execute+0x1a>
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
 8007e7a:	210a      	movs	r1, #10
 8007e7c:	f04f 30ff 	mov.w	r0, #4294967295
 8007e80:	f7fa fc6e 	bl	8002760 <chEvtWaitAnyTimeout>
  test_assert(5, m == 0, "spurious event");
 8007e84:	fab0 f180 	clz	r1, r0
 8007e88:	2005      	movs	r0, #5
 8007e8a:	0949      	lsrs	r1, r1, #5
 8007e8c:	f7fd ff98 	bl	8005dc0 <_test_assert>
 8007e90:	2800      	cmp	r0, #0
 8007e92:	d1ca      	bne.n	8007e2a <evt3_execute+0x1a>
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
 8007e94:	210a      	movs	r1, #10
 8007e96:	f04f 30ff 	mov.w	r0, #4294967295
 8007e9a:	f7fa fc89 	bl	80027b0 <chEvtWaitAllTimeout>
  test_assert(6, m == 0, "spurious event");
}
 8007e9e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  m = chEvtWaitOneTimeout(ALL_EVENTS, 10);
  test_assert(4, m == 0, "spurious event");
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
  test_assert(5, m == 0, "spurious event");
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
  test_assert(6, m == 0, "spurious event");
 8007ea2:	fab0 f180 	clz	r1, r0
 8007ea6:	2006      	movs	r0, #6
 8007ea8:	0949      	lsrs	r1, r1, #5
 8007eaa:	f7fd bf89 	b.w	8005dc0 <_test_assert>
 8007eae:	bf00      	nop

08007eb0 <heap1_execute>:
static void heap1_setup(void) {

  chHeapObjectInit(&test_heap, test.buffer, sizeof(union test_buffers));
}

static void heap1_execute(void) {
 8007eb0:	b570      	push	{r4, r5, r6, lr}
 8007eb2:	b082      	sub	sp, #8
  void *p1, *p2, *p3;
  size_t n, sz;

  /* Unrelated, for coverage only.*/
  (void)chCoreGetStatusX();
 8007eb4:	f7fa ffac 	bl	8002e10 <chCoreGetStatusX>

  /*
   * Test on the default heap in order to cover the core allocator at
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
 8007eb8:	a901      	add	r1, sp, #4
 8007eba:	2000      	movs	r0, #0
 8007ebc:	f7fb f868 	bl	8002f90 <chHeapStatus>
  p1 = chHeapAlloc(NULL, SIZE);
 8007ec0:	2110      	movs	r1, #16
 8007ec2:	2000      	movs	r0, #0
 8007ec4:	f7fa ffd4 	bl	8002e70 <chHeapAlloc>
  test_assert(1, p1 != NULL, "allocation failed");
 8007ec8:	1c01      	adds	r1, r0, #0
 8007eca:	4605      	mov	r5, r0
 8007ecc:	bf18      	it	ne
 8007ece:	2101      	movne	r1, #1
 8007ed0:	2001      	movs	r0, #1
 8007ed2:	f7fd ff75 	bl	8005dc0 <_test_assert>
 8007ed6:	4604      	mov	r4, r0
 8007ed8:	b108      	cbz	r0, 8007ede <heap1_execute+0x2e>
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
  chHeapFree(p1);

  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
  test_assert(12, n == sz, "size changed");
}
 8007eda:	b002      	add	sp, #8
 8007edc:	bd70      	pop	{r4, r5, r6, pc}
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
  p1 = chHeapAlloc(NULL, SIZE);
  test_assert(1, p1 != NULL, "allocation failed");
  chHeapFree(p1);
 8007ede:	4628      	mov	r0, r5
 8007ee0:	f7fb f80e 	bl	8002f00 <chHeapFree>
  p1 = chHeapAlloc(NULL, (size_t)-256);
 8007ee4:	f06f 01ff 	mvn.w	r1, #255	; 0xff
 8007ee8:	4620      	mov	r0, r4
 8007eea:	f7fa ffc1 	bl	8002e70 <chHeapAlloc>
  test_assert(2, p1 == NULL, "allocation not failed");
 8007eee:	fab0 f180 	clz	r1, r0
 8007ef2:	2002      	movs	r0, #2
 8007ef4:	0949      	lsrs	r1, r1, #5
 8007ef6:	f7fd ff63 	bl	8005dc0 <_test_assert>
 8007efa:	2800      	cmp	r0, #0
 8007efc:	d1ed      	bne.n	8007eda <heap1_execute+0x2a>

  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);
 8007efe:	a901      	add	r1, sp, #4
 8007f00:	487b      	ldr	r0, [pc, #492]	; (80080f0 <heap1_execute+0x240>)
 8007f02:	f7fb f845 	bl	8002f90 <chHeapStatus>

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8007f06:	2110      	movs	r1, #16
 8007f08:	4879      	ldr	r0, [pc, #484]	; (80080f0 <heap1_execute+0x240>)
 8007f0a:	f7fa ffb1 	bl	8002e70 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8007f0e:	2110      	movs	r1, #16

  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8007f10:	4606      	mov	r6, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8007f12:	4877      	ldr	r0, [pc, #476]	; (80080f0 <heap1_execute+0x240>)
 8007f14:	f7fa ffac 	bl	8002e70 <chHeapAlloc>
  p3 = chHeapAlloc(&test_heap, SIZE);
 8007f18:	2110      	movs	r1, #16
  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
  p2 = chHeapAlloc(&test_heap, SIZE);
 8007f1a:	4605      	mov	r5, r0
  p3 = chHeapAlloc(&test_heap, SIZE);
 8007f1c:	4874      	ldr	r0, [pc, #464]	; (80080f0 <heap1_execute+0x240>)
 8007f1e:	f7fa ffa7 	bl	8002e70 <chHeapAlloc>
 8007f22:	4604      	mov	r4, r0
  chHeapFree(p1);                               /* Does not merge.*/
 8007f24:	4630      	mov	r0, r6
 8007f26:	f7fa ffeb 	bl	8002f00 <chHeapFree>
  chHeapFree(p2);                               /* Merges backward.*/
 8007f2a:	4628      	mov	r0, r5
 8007f2c:	f7fa ffe8 	bl	8002f00 <chHeapFree>
  chHeapFree(p3);                               /* Merges both sides.*/
 8007f30:	4620      	mov	r0, r4
 8007f32:	f7fa ffe5 	bl	8002f00 <chHeapFree>
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8007f36:	4669      	mov	r1, sp
 8007f38:	486d      	ldr	r0, [pc, #436]	; (80080f0 <heap1_execute+0x240>)
 8007f3a:	f7fb f829 	bl	8002f90 <chHeapStatus>
 8007f3e:	f1a0 0101 	sub.w	r1, r0, #1
 8007f42:	fab1 f181 	clz	r1, r1
 8007f46:	2003      	movs	r0, #3
 8007f48:	0949      	lsrs	r1, r1, #5
 8007f4a:	f7fd ff39 	bl	8005dc0 <_test_assert>
 8007f4e:	2800      	cmp	r0, #0
 8007f50:	d1c3      	bne.n	8007eda <heap1_execute+0x2a>

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8007f52:	2110      	movs	r1, #16
 8007f54:	4866      	ldr	r0, [pc, #408]	; (80080f0 <heap1_execute+0x240>)
 8007f56:	f7fa ff8b 	bl	8002e70 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8007f5a:	2110      	movs	r1, #16
  chHeapFree(p2);                               /* Merges backward.*/
  chHeapFree(p3);                               /* Merges both sides.*/
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8007f5c:	4604      	mov	r4, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8007f5e:	4864      	ldr	r0, [pc, #400]	; (80080f0 <heap1_execute+0x240>)
 8007f60:	f7fa ff86 	bl	8002e70 <chHeapAlloc>
 8007f64:	4605      	mov	r5, r0
  p3 = chHeapAlloc(&test_heap, SIZE);
 8007f66:	2110      	movs	r1, #16
 8007f68:	4861      	ldr	r0, [pc, #388]	; (80080f0 <heap1_execute+0x240>)
 8007f6a:	f7fa ff81 	bl	8002e70 <chHeapAlloc>
  chHeapFree(p3);                               /* Merges forward.*/
 8007f6e:	f7fa ffc7 	bl	8002f00 <chHeapFree>
  chHeapFree(p2);                               /* Merges forward.*/
 8007f72:	4628      	mov	r0, r5
 8007f74:	f7fa ffc4 	bl	8002f00 <chHeapFree>
  chHeapFree(p1);                               /* Merges forward.*/
 8007f78:	4620      	mov	r0, r4
 8007f7a:	f7fa ffc1 	bl	8002f00 <chHeapFree>
  test_assert(4, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8007f7e:	4669      	mov	r1, sp
 8007f80:	485b      	ldr	r0, [pc, #364]	; (80080f0 <heap1_execute+0x240>)
 8007f82:	f7fb f805 	bl	8002f90 <chHeapStatus>
 8007f86:	f1a0 0101 	sub.w	r1, r0, #1
 8007f8a:	fab1 f181 	clz	r1, r1
 8007f8e:	2004      	movs	r0, #4
 8007f90:	0949      	lsrs	r1, r1, #5
 8007f92:	f7fd ff15 	bl	8005dc0 <_test_assert>
 8007f96:	2800      	cmp	r0, #0
 8007f98:	d19f      	bne.n	8007eda <heap1_execute+0x2a>

  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
 8007f9a:	2111      	movs	r1, #17
 8007f9c:	4854      	ldr	r0, [pc, #336]	; (80080f0 <heap1_execute+0x240>)
 8007f9e:	f7fa ff67 	bl	8002e70 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8007fa2:	2110      	movs	r1, #16
  chHeapFree(p2);                               /* Merges forward.*/
  chHeapFree(p1);                               /* Merges forward.*/
  test_assert(4, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
 8007fa4:	4604      	mov	r4, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8007fa6:	4852      	ldr	r0, [pc, #328]	; (80080f0 <heap1_execute+0x240>)
 8007fa8:	f7fa ff62 	bl	8002e70 <chHeapAlloc>
 8007fac:	4605      	mov	r5, r0
  chHeapFree(p1);
 8007fae:	4620      	mov	r0, r4
 8007fb0:	f7fa ffa6 	bl	8002f00 <chHeapFree>
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 8007fb4:	4669      	mov	r1, sp
 8007fb6:	484e      	ldr	r0, [pc, #312]	; (80080f0 <heap1_execute+0x240>)
 8007fb8:	f7fa ffea 	bl	8002f90 <chHeapStatus>
 8007fbc:	f1a0 0102 	sub.w	r1, r0, #2
 8007fc0:	fab1 f181 	clz	r1, r1
 8007fc4:	2005      	movs	r0, #5
 8007fc6:	0949      	lsrs	r1, r1, #5
 8007fc8:	f7fd fefa 	bl	8005dc0 <_test_assert>
 8007fcc:	2800      	cmp	r0, #0
 8007fce:	d184      	bne.n	8007eda <heap1_execute+0x2a>
  p1 = chHeapAlloc(&test_heap, SIZE);
 8007fd0:	2110      	movs	r1, #16
 8007fd2:	4847      	ldr	r0, [pc, #284]	; (80080f0 <heap1_execute+0x240>)
 8007fd4:	f7fa ff4c 	bl	8002e70 <chHeapAlloc>
  /* Note, the first situation happens when the alignment size is smaller
     than the header size, the second in the other cases.*/
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
 8007fd8:	4669      	mov	r1, sp
  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
  p2 = chHeapAlloc(&test_heap, SIZE);
  chHeapFree(p1);
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
  p1 = chHeapAlloc(&test_heap, SIZE);
 8007fda:	4604      	mov	r4, r0
  /* Note, the first situation happens when the alignment size is smaller
     than the header size, the second in the other cases.*/
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
 8007fdc:	4844      	ldr	r0, [pc, #272]	; (80080f0 <heap1_execute+0x240>)
 8007fde:	f7fa ffd7 	bl	8002f90 <chHeapStatus>
 8007fe2:	2801      	cmp	r0, #1
 8007fe4:	f000 8081 	beq.w	80080ea <heap1_execute+0x23a>
 8007fe8:	4669      	mov	r1, sp
 8007fea:	4841      	ldr	r0, [pc, #260]	; (80080f0 <heap1_execute+0x240>)
 8007fec:	f7fa ffd0 	bl	8002f90 <chHeapStatus>
 8007ff0:	f1a0 0102 	sub.w	r1, r0, #2
 8007ff4:	fab1 f181 	clz	r1, r1
 8007ff8:	0949      	lsrs	r1, r1, #5
 8007ffa:	2006      	movs	r0, #6
 8007ffc:	f7fd fee0 	bl	8005dc0 <_test_assert>
 8008000:	2800      	cmp	r0, #0
 8008002:	f47f af6a 	bne.w	8007eda <heap1_execute+0x2a>
                 (chHeapStatus(&test_heap, &n) == 2), "heap fragmented");
  chHeapFree(p2);
 8008006:	4628      	mov	r0, r5
 8008008:	f7fa ff7a 	bl	8002f00 <chHeapFree>
  chHeapFree(p1);
 800800c:	4620      	mov	r0, r4
 800800e:	f7fa ff77 	bl	8002f00 <chHeapFree>
  test_assert(7, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8008012:	4669      	mov	r1, sp
 8008014:	4836      	ldr	r0, [pc, #216]	; (80080f0 <heap1_execute+0x240>)
 8008016:	f7fa ffbb 	bl	8002f90 <chHeapStatus>
 800801a:	1e46      	subs	r6, r0, #1
 800801c:	4271      	negs	r1, r6
 800801e:	4171      	adcs	r1, r6
 8008020:	2007      	movs	r0, #7
 8008022:	f7fd fecd 	bl	8005dc0 <_test_assert>
 8008026:	2800      	cmp	r0, #0
 8008028:	f47f af57 	bne.w	8007eda <heap1_execute+0x2a>

  /* Skip fragment handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 800802c:	2110      	movs	r1, #16
 800802e:	4830      	ldr	r0, [pc, #192]	; (80080f0 <heap1_execute+0x240>)
 8008030:	f7fa ff1e 	bl	8002e70 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8008034:	2110      	movs	r1, #16
  chHeapFree(p2);
  chHeapFree(p1);
  test_assert(7, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Skip fragment handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8008036:	4605      	mov	r5, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8008038:	482d      	ldr	r0, [pc, #180]	; (80080f0 <heap1_execute+0x240>)
 800803a:	f7fa ff19 	bl	8002e70 <chHeapAlloc>
 800803e:	4604      	mov	r4, r0
  chHeapFree(p1);
 8008040:	4628      	mov	r0, r5
 8008042:	f7fa ff5d 	bl	8002f00 <chHeapFree>
  test_assert(8, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 8008046:	4669      	mov	r1, sp
 8008048:	4829      	ldr	r0, [pc, #164]	; (80080f0 <heap1_execute+0x240>)
 800804a:	f7fa ffa1 	bl	8002f90 <chHeapStatus>
 800804e:	1e85      	subs	r5, r0, #2
 8008050:	4269      	negs	r1, r5
 8008052:	4169      	adcs	r1, r5
 8008054:	2008      	movs	r0, #8
 8008056:	f7fd feb3 	bl	8005dc0 <_test_assert>
 800805a:	2800      	cmp	r0, #0
 800805c:	f47f af3d 	bne.w	8007eda <heap1_execute+0x2a>
  p1 = chHeapAlloc(&test_heap, SIZE * 2);       /* Skips first fragment.*/
 8008060:	2120      	movs	r1, #32
 8008062:	4823      	ldr	r0, [pc, #140]	; (80080f0 <heap1_execute+0x240>)
 8008064:	f7fa ff04 	bl	8002e70 <chHeapAlloc>
  chHeapFree(p1);
 8008068:	f7fa ff4a 	bl	8002f00 <chHeapFree>
  chHeapFree(p2);
 800806c:	4620      	mov	r0, r4
 800806e:	f7fa ff47 	bl	8002f00 <chHeapFree>
  test_assert(9, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8008072:	4669      	mov	r1, sp
 8008074:	481e      	ldr	r0, [pc, #120]	; (80080f0 <heap1_execute+0x240>)
 8008076:	f7fa ff8b 	bl	8002f90 <chHeapStatus>
 800807a:	3801      	subs	r0, #1
 800807c:	4241      	negs	r1, r0
 800807e:	4141      	adcs	r1, r0
 8008080:	2009      	movs	r0, #9
 8008082:	f7fd fe9d 	bl	8005dc0 <_test_assert>
 8008086:	2800      	cmp	r0, #0
 8008088:	f47f af27 	bne.w	8007eda <heap1_execute+0x2a>

  /* Allocate all handling.*/
  (void)chHeapStatus(&test_heap, &n);
 800808c:	4669      	mov	r1, sp
 800808e:	4818      	ldr	r0, [pc, #96]	; (80080f0 <heap1_execute+0x240>)
 8008090:	f7fa ff7e 	bl	8002f90 <chHeapStatus>
  p1 = chHeapAlloc(&test_heap, n);
 8008094:	9900      	ldr	r1, [sp, #0]
 8008096:	4816      	ldr	r0, [pc, #88]	; (80080f0 <heap1_execute+0x240>)
 8008098:	f7fa feea 	bl	8002e70 <chHeapAlloc>
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
 800809c:	4669      	mov	r1, sp
  chHeapFree(p2);
  test_assert(9, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Allocate all handling.*/
  (void)chHeapStatus(&test_heap, &n);
  p1 = chHeapAlloc(&test_heap, n);
 800809e:	4604      	mov	r4, r0
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
 80080a0:	4813      	ldr	r0, [pc, #76]	; (80080f0 <heap1_execute+0x240>)
 80080a2:	f7fa ff75 	bl	8002f90 <chHeapStatus>
 80080a6:	fab0 f180 	clz	r1, r0
 80080aa:	200a      	movs	r0, #10
 80080ac:	0949      	lsrs	r1, r1, #5
 80080ae:	f7fd fe87 	bl	8005dc0 <_test_assert>
 80080b2:	2800      	cmp	r0, #0
 80080b4:	f47f af11 	bne.w	8007eda <heap1_execute+0x2a>
  chHeapFree(p1);
 80080b8:	4620      	mov	r0, r4
 80080ba:	f7fa ff21 	bl	8002f00 <chHeapFree>

  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 80080be:	4669      	mov	r1, sp
 80080c0:	480b      	ldr	r0, [pc, #44]	; (80080f0 <heap1_execute+0x240>)
 80080c2:	f7fa ff65 	bl	8002f90 <chHeapStatus>
 80080c6:	1e42      	subs	r2, r0, #1
 80080c8:	4251      	negs	r1, r2
 80080ca:	4151      	adcs	r1, r2
 80080cc:	200b      	movs	r0, #11
 80080ce:	f7fd fe77 	bl	8005dc0 <_test_assert>
 80080d2:	2800      	cmp	r0, #0
 80080d4:	f47f af01 	bne.w	8007eda <heap1_execute+0x2a>
  test_assert(12, n == sz, "size changed");
 80080d8:	e89d 000a 	ldmia.w	sp, {r1, r3}
 80080dc:	1acb      	subs	r3, r1, r3
 80080de:	4259      	negs	r1, r3
 80080e0:	4159      	adcs	r1, r3
 80080e2:	200c      	movs	r0, #12
 80080e4:	f7fd fe6c 	bl	8005dc0 <_test_assert>
 80080e8:	e6f7      	b.n	8007eda <heap1_execute+0x2a>
 80080ea:	4601      	mov	r1, r0
 80080ec:	e785      	b.n	8007ffa <heap1_execute+0x14a>
 80080ee:	bf00      	nop
 80080f0:	20001c88 	.word	0x20001c88
	...

08008100 <heap1_setup>:
 * sequence.
 */

static void heap1_setup(void) {

  chHeapObjectInit(&test_heap, test.buffer, sizeof(union test_buffers));
 8008100:	4802      	ldr	r0, [pc, #8]	; (800810c <heap1_setup+0xc>)
 8008102:	4903      	ldr	r1, [pc, #12]	; (8008110 <heap1_setup+0x10>)
 8008104:	f44f 62c8 	mov.w	r2, #1600	; 0x640
 8008108:	f7fa bea2 	b.w	8002e50 <chHeapObjectInit>
 800810c:	20001c88 	.word	0x20001c88
 8008110:	200015f8 	.word	0x200015f8
	...

08008120 <null_provider>:

static void *null_provider(size_t size) {

  (void)size;
  return NULL;
}
 8008120:	2000      	movs	r0, #0
 8008122:	4770      	bx	lr
	...

08008130 <pools1_setup>:

static void pools1_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
 8008130:	4802      	ldr	r0, [pc, #8]	; (800813c <pools1_setup+0xc>)
 8008132:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8008136:	2200      	movs	r2, #0
 8008138:	f7fa bf52 	b.w	8002fe0 <chPoolObjectInit>
 800813c:	20000890 	.word	0x20000890

08008140 <pools1_execute>:
}

static void pools1_execute(void) {
 8008140:	b538      	push	{r3, r4, r5, lr}
  int i;

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);
 8008142:	4b2b      	ldr	r3, [pc, #172]	; (80081f0 <pools1_execute+0xb0>)
 8008144:	482b      	ldr	r0, [pc, #172]	; (80081f4 <pools1_execute+0xb4>)
 8008146:	681d      	ldr	r5, [r3, #0]
 8008148:	2205      	movs	r2, #5
 800814a:	4629      	mov	r1, r5
 800814c:	f7fa ff50 	bl	8002ff0 <chPoolLoadArray>
 8008150:	2405      	movs	r4, #5

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");
 8008152:	4828      	ldr	r0, [pc, #160]	; (80081f4 <pools1_execute+0xb4>)
 8008154:	f7fa ff64 	bl	8003020 <chPoolAlloc>
 8008158:	1c01      	adds	r1, r0, #0
 800815a:	bf18      	it	ne
 800815c:	2101      	movne	r1, #1
 800815e:	2001      	movs	r0, #1
 8008160:	f7fd fe2e 	bl	8005dc0 <_test_assert>
 8008164:	bb90      	cbnz	r0, 80081cc <pools1_execute+0x8c>

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
 8008166:	3c01      	subs	r4, #1
 8008168:	d1f3      	bne.n	8008152 <pools1_execute+0x12>
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");
 800816a:	4822      	ldr	r0, [pc, #136]	; (80081f4 <pools1_execute+0xb4>)
 800816c:	f7fa ff58 	bl	8003020 <chPoolAlloc>
 8008170:	fab0 f180 	clz	r1, r0
 8008174:	2002      	movs	r0, #2
 8008176:	0949      	lsrs	r1, r1, #5
 8008178:	f7fd fe22 	bl	8005dc0 <_test_assert>
 800817c:	bb30      	cbnz	r0, 80081cc <pools1_execute+0x8c>
 800817e:	4c1c      	ldr	r4, [pc, #112]	; (80081f0 <pools1_execute+0xb0>)
 8008180:	4629      	mov	r1, r5

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
    chPoolFree(&mp1, wa[i]);
 8008182:	481c      	ldr	r0, [pc, #112]	; (80081f4 <pools1_execute+0xb4>)
 8008184:	f104 0510 	add.w	r5, r4, #16
 8008188:	f7fa ff62 	bl	8003050 <chPoolFree>

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
 800818c:	42ac      	cmp	r4, r5
 800818e:	d006      	beq.n	800819e <pools1_execute+0x5e>
 8008190:	f854 1f04 	ldr.w	r1, [r4, #4]!
    chPoolFree(&mp1, wa[i]);
 8008194:	4817      	ldr	r0, [pc, #92]	; (80081f4 <pools1_execute+0xb4>)
 8008196:	f7fa ff5b 	bl	8003050 <chPoolFree>

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
 800819a:	42ac      	cmp	r4, r5
 800819c:	d1f8      	bne.n	8008190 <pools1_execute+0x50>
 800819e:	2405      	movs	r4, #5
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");
 80081a0:	4814      	ldr	r0, [pc, #80]	; (80081f4 <pools1_execute+0xb4>)
 80081a2:	f7fa ff3d 	bl	8003020 <chPoolAlloc>
 80081a6:	1c01      	adds	r1, r0, #0
 80081a8:	bf18      	it	ne
 80081aa:	2101      	movne	r1, #1
 80081ac:	2003      	movs	r0, #3
 80081ae:	f7fd fe07 	bl	8005dc0 <_test_assert>
 80081b2:	b958      	cbnz	r0, 80081cc <pools1_execute+0x8c>
  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
 80081b4:	3c01      	subs	r4, #1
 80081b6:	d1f3      	bne.n	80081a0 <pools1_execute+0x60>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty again.*/
  test_assert(4, chPoolAlloc(&mp1) == NULL, "list not empty");
 80081b8:	480e      	ldr	r0, [pc, #56]	; (80081f4 <pools1_execute+0xb4>)
 80081ba:	f7fa ff31 	bl	8003020 <chPoolAlloc>
 80081be:	fab0 f180 	clz	r1, r0
 80081c2:	2004      	movs	r0, #4
 80081c4:	0949      	lsrs	r1, r1, #5
 80081c6:	f7fd fdfb 	bl	8005dc0 <_test_assert>
 80081ca:	b100      	cbz	r0, 80081ce <pools1_execute+0x8e>
 80081cc:	bd38      	pop	{r3, r4, r5, pc}

  /* Covering the case where a provider is unable to return more memory.*/
  chPoolObjectInit(&mp1, 16, null_provider);
 80081ce:	2110      	movs	r1, #16
 80081d0:	4808      	ldr	r0, [pc, #32]	; (80081f4 <pools1_execute+0xb4>)
 80081d2:	4a09      	ldr	r2, [pc, #36]	; (80081f8 <pools1_execute+0xb8>)
 80081d4:	f7fa ff04 	bl	8002fe0 <chPoolObjectInit>
  test_assert(5, chPoolAlloc(&mp1) == NULL, "provider returned memory");
 80081d8:	4806      	ldr	r0, [pc, #24]	; (80081f4 <pools1_execute+0xb4>)
 80081da:	f7fa ff21 	bl	8003020 <chPoolAlloc>
}
 80081de:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  /* Now must be empty again.*/
  test_assert(4, chPoolAlloc(&mp1) == NULL, "list not empty");

  /* Covering the case where a provider is unable to return more memory.*/
  chPoolObjectInit(&mp1, 16, null_provider);
  test_assert(5, chPoolAlloc(&mp1) == NULL, "provider returned memory");
 80081e2:	fab0 f180 	clz	r1, r0
 80081e6:	2005      	movs	r0, #5
 80081e8:	0949      	lsrs	r1, r1, #5
 80081ea:	f7fd bde9 	b.w	8005dc0 <_test_assert>
 80081ee:	bf00      	nop
 80081f0:	0800d790 	.word	0x0800d790
 80081f4:	20000890 	.word	0x20000890
 80081f8:	08008121 	.word	0x08008121
 80081fc:	00000000 	.word	0x00000000

08008200 <dyn1_execute>:
static void dyn1_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}

static void dyn1_execute(void) {
 8008200:	b570      	push	{r4, r5, r6, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8008202:	4b34      	ldr	r3, [pc, #208]	; (80082d4 <dyn1_execute+0xd4>)
 8008204:	b084      	sub	sp, #16
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8008206:	691b      	ldr	r3, [r3, #16]
  size_t n, sz;
  void *p1;
  tprio_t prio = chThdGetPriorityX();

  (void)chHeapStatus(&heap1, &sz);
 8008208:	a903      	add	r1, sp, #12
 800820a:	4833      	ldr	r0, [pc, #204]	; (80082d8 <dyn1_execute+0xd8>)
 800820c:	689d      	ldr	r5, [r3, #8]
 800820e:	f7fa febf 	bl	8002f90 <chHeapStatus>
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 8008212:	4b32      	ldr	r3, [pc, #200]	; (80082dc <dyn1_execute+0xdc>)
 8008214:	1e6a      	subs	r2, r5, #1
 8008216:	9300      	str	r3, [sp, #0]
 8008218:	f44f 71a0 	mov.w	r1, #320	; 0x140
 800821c:	4b30      	ldr	r3, [pc, #192]	; (80082e0 <dyn1_execute+0xe0>)
 800821e:	482e      	ldr	r0, [pc, #184]	; (80082d8 <dyn1_execute+0xd8>)
 8008220:	f7f9 fe06 	bl	8001e30 <chThdCreateFromHeap>
 8008224:	4c2f      	ldr	r4, [pc, #188]	; (80082e4 <dyn1_execute+0xe4>)
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 8008226:	4b30      	ldr	r3, [pc, #192]	; (80082e8 <dyn1_execute+0xe8>)
 8008228:	1eaa      	subs	r2, r5, #2
  void *p1;
  tprio_t prio = chThdGetPriorityX();

  (void)chHeapStatus(&heap1, &sz);
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 800822a:	6020      	str	r0, [r4, #0]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 800822c:	9300      	str	r3, [sp, #0]
 800822e:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8008232:	4b2b      	ldr	r3, [pc, #172]	; (80082e0 <dyn1_execute+0xe0>)
 8008234:	4828      	ldr	r0, [pc, #160]	; (80082d8 <dyn1_execute+0xd8>)
 8008236:	f7f9 fdfb 	bl	8001e30 <chThdCreateFromHeap>
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
 800823a:	a902      	add	r1, sp, #8
  (void)chHeapStatus(&heap1, &sz);
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 800823c:	6060      	str	r0, [r4, #4]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
 800823e:	4826      	ldr	r0, [pc, #152]	; (80082d8 <dyn1_execute+0xd8>)
 8008240:	f7fa fea6 	bl	8002f90 <chHeapStatus>
  p1 = chHeapAlloc(&heap1, n);
 8008244:	9902      	ldr	r1, [sp, #8]
 8008246:	4824      	ldr	r0, [pc, #144]	; (80082d8 <dyn1_execute+0xd8>)
 8008248:	f7fa fe12 	bl	8002e70 <chHeapAlloc>
  threads[2] = chThdCreateFromHeap(&heap1,
 800824c:	4b27      	ldr	r3, [pc, #156]	; (80082ec <dyn1_execute+0xec>)
 800824e:	f44f 71a0 	mov.w	r1, #320	; 0x140
  threads[1] = chThdCreateFromHeap(&heap1,
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
  p1 = chHeapAlloc(&heap1, n);
 8008252:	4606      	mov	r6, r0
  threads[2] = chThdCreateFromHeap(&heap1,
 8008254:	1eea      	subs	r2, r5, #3
 8008256:	9300      	str	r3, [sp, #0]
 8008258:	481f      	ldr	r0, [pc, #124]	; (80082d8 <dyn1_execute+0xd8>)
 800825a:	4b21      	ldr	r3, [pc, #132]	; (80082e0 <dyn1_execute+0xe0>)
 800825c:	f7f9 fde8 	bl	8001e30 <chThdCreateFromHeap>
 8008260:	60a0      	str	r0, [r4, #8]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-3, thread, "C");
  chHeapFree(p1);
 8008262:	4630      	mov	r0, r6
 8008264:	f7fa fe4c 	bl	8002f00 <chHeapFree>

  test_assert(1, (threads[0] != NULL) &&
 8008268:	6821      	ldr	r1, [r4, #0]
 800826a:	b121      	cbz	r1, 8008276 <dyn1_execute+0x76>
 800826c:	6861      	ldr	r1, [r4, #4]
 800826e:	b111      	cbz	r1, 8008276 <dyn1_execute+0x76>
 8008270:	68a1      	ldr	r1, [r4, #8]
 8008272:	b331      	cbz	r1, 80082c2 <dyn1_execute+0xc2>
 8008274:	2100      	movs	r1, #0
 8008276:	2001      	movs	r0, #1
 8008278:	f7fd fda2 	bl	8005dc0 <_test_assert>
 800827c:	b108      	cbz	r0, 8008282 <dyn1_execute+0x82>
  test_assert_sequence(2, "AB");

  /* Heap status checked again.*/
  test_assert(3, chHeapStatus(&heap1, &n) == 1, "heap fragmented");
  test_assert(4, n == sz, "heap size changed");
}
 800827e:	b004      	add	sp, #16
 8008280:	bd70      	pop	{r4, r5, r6, pc}
                 (threads[3] == NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 8008282:	f7fd fe15 	bl	8005eb0 <test_wait_threads>
  test_assert_sequence(2, "AB");
 8008286:	2002      	movs	r0, #2
 8008288:	4919      	ldr	r1, [pc, #100]	; (80082f0 <dyn1_execute+0xf0>)
 800828a:	f7fd fdb1 	bl	8005df0 <_test_assert_sequence>
 800828e:	2800      	cmp	r0, #0
 8008290:	d1f5      	bne.n	800827e <dyn1_execute+0x7e>

  /* Heap status checked again.*/
  test_assert(3, chHeapStatus(&heap1, &n) == 1, "heap fragmented");
 8008292:	a902      	add	r1, sp, #8
 8008294:	4810      	ldr	r0, [pc, #64]	; (80082d8 <dyn1_execute+0xd8>)
 8008296:	f7fa fe7b 	bl	8002f90 <chHeapStatus>
 800829a:	f1a0 0101 	sub.w	r1, r0, #1
 800829e:	fab1 f181 	clz	r1, r1
 80082a2:	2003      	movs	r0, #3
 80082a4:	0949      	lsrs	r1, r1, #5
 80082a6:	f7fd fd8b 	bl	8005dc0 <_test_assert>
 80082aa:	2800      	cmp	r0, #0
 80082ac:	d1e7      	bne.n	800827e <dyn1_execute+0x7e>
  test_assert(4, n == sz, "heap size changed");
 80082ae:	9902      	ldr	r1, [sp, #8]
 80082b0:	9b03      	ldr	r3, [sp, #12]
 80082b2:	2004      	movs	r0, #4
 80082b4:	1ac9      	subs	r1, r1, r3
 80082b6:	fab1 f181 	clz	r1, r1
 80082ba:	0949      	lsrs	r1, r1, #5
 80082bc:	f7fd fd80 	bl	8005dc0 <_test_assert>
 80082c0:	e7dd      	b.n	800827e <dyn1_execute+0x7e>
  threads[2] = chThdCreateFromHeap(&heap1,
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-3, thread, "C");
  chHeapFree(p1);

  test_assert(1, (threads[0] != NULL) &&
 80082c2:	68e3      	ldr	r3, [r4, #12]
 80082c4:	2b00      	cmp	r3, #0
 80082c6:	d1d6      	bne.n	8008276 <dyn1_execute+0x76>
 80082c8:	6921      	ldr	r1, [r4, #16]
 80082ca:	fab1 f181 	clz	r1, r1
 80082ce:	0949      	lsrs	r1, r1, #5
 80082d0:	e7d1      	b.n	8008276 <dyn1_execute+0x76>
 80082d2:	bf00      	nop
 80082d4:	20001160 	.word	0x20001160
 80082d8:	20001cb8 	.word	0x20001cb8
 80082dc:	0800da4c 	.word	0x0800da4c
 80082e0:	08008301 	.word	0x08008301
 80082e4:	20001c58 	.word	0x20001c58
 80082e8:	0800da48 	.word	0x0800da48
 80082ec:	0800da44 	.word	0x0800da44
 80082f0:	0800de80 	.word	0x0800de80
	...

08008300 <thread>:
 * one to fail.
 */

static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
 8008300:	7800      	ldrb	r0, [r0, #0]
 8008302:	f7fd bd45 	b.w	8005d90 <test_emit_token>
 8008306:	bf00      	nop
	...

08008310 <dyn1_setup>:
}

#if CH_CFG_USE_HEAP || defined(__DOXYGEN__)
static void dyn1_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
 8008310:	4802      	ldr	r0, [pc, #8]	; (800831c <dyn1_setup+0xc>)
 8008312:	4903      	ldr	r1, [pc, #12]	; (8008320 <dyn1_setup+0x10>)
 8008314:	f44f 62c8 	mov.w	r2, #1600	; 0x640
 8008318:	f7fa bd9a 	b.w	8002e50 <chHeapObjectInit>
 800831c:	20001cb8 	.word	0x20001cb8
 8008320:	200015f8 	.word	0x200015f8
	...

08008330 <dyn2_execute>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8008330:	4b31      	ldr	r3, [pc, #196]	; (80083f8 <dyn2_execute+0xc8>)
static void dyn2_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}

static void dyn2_execute(void) {
 8008332:	b570      	push	{r4, r5, r6, lr}
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8008334:	691b      	ldr	r3, [r3, #16]
 8008336:	4c31      	ldr	r4, [pc, #196]	; (80083fc <dyn2_execute+0xcc>)
 8008338:	689d      	ldr	r5, [r3, #8]
 800833a:	f104 0610 	add.w	r6, r4, #16
  int i;
  tprio_t prio = chThdGetPriorityX();

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
    chPoolFree(&mp1, wa[i]);
 800833e:	f854 1b04 	ldr.w	r1, [r4], #4
 8008342:	482f      	ldr	r0, [pc, #188]	; (8008400 <dyn2_execute+0xd0>)
 8008344:	f7fa fe84 	bl	8003050 <chPoolFree>
static void dyn2_execute(void) {
  int i;
  tprio_t prio = chThdGetPriorityX();

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
 8008348:	42b4      	cmp	r4, r6
 800834a:	d1f8      	bne.n	800833e <dyn2_execute+0xe>
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
 800834c:	1e69      	subs	r1, r5, #1
 800834e:	4a2d      	ldr	r2, [pc, #180]	; (8008404 <dyn2_execute+0xd4>)
 8008350:	4b2d      	ldr	r3, [pc, #180]	; (8008408 <dyn2_execute+0xd8>)
 8008352:	482b      	ldr	r0, [pc, #172]	; (8008400 <dyn2_execute+0xd0>)
 8008354:	f7f9 fd8c 	bl	8001e70 <chThdCreateFromMemoryPool>
 8008358:	4c2c      	ldr	r4, [pc, #176]	; (800840c <dyn2_execute+0xdc>)
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 800835a:	1ea9      	subs	r1, r5, #2
  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
 800835c:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 800835e:	4a29      	ldr	r2, [pc, #164]	; (8008404 <dyn2_execute+0xd4>)
 8008360:	4b2b      	ldr	r3, [pc, #172]	; (8008410 <dyn2_execute+0xe0>)
 8008362:	4827      	ldr	r0, [pc, #156]	; (8008400 <dyn2_execute+0xd0>)
 8008364:	f7f9 fd84 	bl	8001e70 <chThdCreateFromMemoryPool>
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 8008368:	1ee9      	subs	r1, r5, #3
  for (i = 0; i < 4; i++)
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 800836a:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 800836c:	4a25      	ldr	r2, [pc, #148]	; (8008404 <dyn2_execute+0xd4>)
 800836e:	4b29      	ldr	r3, [pc, #164]	; (8008414 <dyn2_execute+0xe4>)
 8008370:	4823      	ldr	r0, [pc, #140]	; (8008400 <dyn2_execute+0xd0>)
 8008372:	f7f9 fd7d 	bl	8001e70 <chThdCreateFromMemoryPool>
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 8008376:	1f29      	subs	r1, r5, #4
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 8008378:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 800837a:	4a22      	ldr	r2, [pc, #136]	; (8008404 <dyn2_execute+0xd4>)
 800837c:	4b26      	ldr	r3, [pc, #152]	; (8008418 <dyn2_execute+0xe8>)
 800837e:	4820      	ldr	r0, [pc, #128]	; (8008400 <dyn2_execute+0xd0>)
 8008380:	f7f9 fd76 	bl	8001e70 <chThdCreateFromMemoryPool>
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8008384:	1f69      	subs	r1, r5, #5

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 8008386:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8008388:	4a1e      	ldr	r2, [pc, #120]	; (8008404 <dyn2_execute+0xd4>)
 800838a:	481d      	ldr	r0, [pc, #116]	; (8008400 <dyn2_execute+0xd0>)
 800838c:	4b23      	ldr	r3, [pc, #140]	; (800841c <dyn2_execute+0xec>)
 800838e:	f7f9 fd6f 	bl	8001e70 <chThdCreateFromMemoryPool>

  test_assert(1, (threads[0] != NULL) &&
 8008392:	6821      	ldr	r1, [r4, #0]
  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8008394:	6120      	str	r0, [r4, #16]

  test_assert(1, (threads[0] != NULL) &&
 8008396:	b141      	cbz	r1, 80083aa <dyn2_execute+0x7a>
 8008398:	6861      	ldr	r1, [r4, #4]
 800839a:	b131      	cbz	r1, 80083aa <dyn2_execute+0x7a>
 800839c:	68a1      	ldr	r1, [r4, #8]
 800839e:	b121      	cbz	r1, 80083aa <dyn2_execute+0x7a>
 80083a0:	68e1      	ldr	r1, [r4, #12]
 80083a2:	b111      	cbz	r1, 80083aa <dyn2_execute+0x7a>
 80083a4:	fab0 f180 	clz	r1, r0
 80083a8:	0949      	lsrs	r1, r1, #5
 80083aa:	2001      	movs	r0, #1
 80083ac:	f7fd fd08 	bl	8005dc0 <_test_assert>
 80083b0:	b100      	cbz	r0, 80083b4 <dyn2_execute+0x84>
 80083b2:	bd70      	pop	{r4, r5, r6, pc}
                 (threads[3] != NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 80083b4:	f7fd fd7c 	bl	8005eb0 <test_wait_threads>
  test_assert_sequence(2, "ABCD");
 80083b8:	2002      	movs	r0, #2
 80083ba:	4919      	ldr	r1, [pc, #100]	; (8008420 <dyn2_execute+0xf0>)
 80083bc:	f7fd fd18 	bl	8005df0 <_test_assert_sequence>
 80083c0:	2800      	cmp	r0, #0
 80083c2:	d1f6      	bne.n	80083b2 <dyn2_execute+0x82>
 80083c4:	2404      	movs	r4, #4

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
 80083c6:	480e      	ldr	r0, [pc, #56]	; (8008400 <dyn2_execute+0xd0>)
 80083c8:	f7fa fe2a 	bl	8003020 <chPoolAlloc>
 80083cc:	1c01      	adds	r1, r0, #0
 80083ce:	bf18      	it	ne
 80083d0:	2101      	movne	r1, #1
 80083d2:	2003      	movs	r0, #3
 80083d4:	f7fd fcf4 	bl	8005dc0 <_test_assert>
 80083d8:	2800      	cmp	r0, #0
 80083da:	d1ea      	bne.n	80083b2 <dyn2_execute+0x82>
  /* Claiming the memory from terminated threads. */
  test_wait_threads();
  test_assert_sequence(2, "ABCD");

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
 80083dc:	3c01      	subs	r4, #1
 80083de:	d1f2      	bne.n	80083c6 <dyn2_execute+0x96>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
 80083e0:	4807      	ldr	r0, [pc, #28]	; (8008400 <dyn2_execute+0xd0>)
 80083e2:	f7fa fe1d 	bl	8003020 <chPoolAlloc>
}
 80083e6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  test_assert_sequence(2, "ABCD");

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
 80083ea:	fab0 f180 	clz	r1, r0
 80083ee:	2004      	movs	r0, #4
 80083f0:	0949      	lsrs	r1, r1, #5
 80083f2:	f7fd bce5 	b.w	8005dc0 <_test_assert>
 80083f6:	bf00      	nop
 80083f8:	20001160 	.word	0x20001160
 80083fc:	0800d790 	.word	0x0800d790
 8008400:	20001ca8 	.word	0x20001ca8
 8008404:	08008301 	.word	0x08008301
 8008408:	0800da4c 	.word	0x0800da4c
 800840c:	20001c58 	.word	0x20001c58
 8008410:	0800da48 	.word	0x0800da48
 8008414:	0800da44 	.word	0x0800da44
 8008418:	0800da40 	.word	0x0800da40
 800841c:	0800da54 	.word	0x0800da54
 8008420:	0800de84 	.word	0x0800de84
	...

08008430 <dyn2_setup>:
 * one to fail.
 */

static void dyn2_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
 8008430:	4802      	ldr	r0, [pc, #8]	; (800843c <dyn2_setup+0xc>)
 8008432:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8008436:	2200      	movs	r2, #0
 8008438:	f7fa bdd2 	b.w	8002fe0 <chPoolObjectInit>
 800843c:	20001ca8 	.word	0x20001ca8

08008440 <notify>:

#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)

#define TEST_QUEUES_SIZE 4

static void notify(io_queue_t *qp) {
 8008440:	4770      	bx	lr
 8008442:	bf00      	nop
	...

08008450 <thread1>:
}

static THD_FUNCTION(thread1, p) {

  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
 8008450:	4802      	ldr	r0, [pc, #8]	; (800845c <thread1+0xc>)
 8008452:	f44f 71c8 	mov.w	r1, #400	; 0x190
 8008456:	f7fa bb8b 	b.w	8002b70 <chIQGetTimeout>
 800845a:	bf00      	nop
 800845c:	200008c0 	.word	0x200008c0

08008460 <queues1_setup>:
 * This test case tests synchronous and asynchronous operations on an
 * @p InputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues1_setup(void) {
 8008460:	b500      	push	{lr}

  chIQObjectInit(&iq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 8008462:	4a06      	ldr	r2, [pc, #24]	; (800847c <queues1_setup+0x1c>)
 * This test case tests synchronous and asynchronous operations on an
 * @p InputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues1_setup(void) {
 8008464:	b083      	sub	sp, #12

  chIQObjectInit(&iq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 8008466:	2300      	movs	r3, #0
 8008468:	6811      	ldr	r1, [r2, #0]
 800846a:	9300      	str	r3, [sp, #0]
 800846c:	4804      	ldr	r0, [pc, #16]	; (8008480 <queues1_setup+0x20>)
 800846e:	2204      	movs	r2, #4
 8008470:	4b04      	ldr	r3, [pc, #16]	; (8008484 <queues1_setup+0x24>)
 8008472:	f7fa fb3d 	bl	8002af0 <chIQObjectInit>
}
 8008476:	b003      	add	sp, #12
 8008478:	f85d fb04 	ldr.w	pc, [sp], #4
 800847c:	0800d790 	.word	0x0800d790
 8008480:	200008c0 	.word	0x200008c0
 8008484:	08008441 	.word	0x08008441
	...

08008490 <thread2>:
}

static THD_FUNCTION(thread2, p) {

  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
 8008490:	4802      	ldr	r0, [pc, #8]	; (800849c <thread2+0xc>)
 8008492:	2100      	movs	r1, #0
 8008494:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8008498:	f7fa bbf2 	b.w	8002c80 <chOQPutTimeout>
 800849c:	2000089c 	.word	0x2000089c

080084a0 <queues2_setup>:
 * This test case tests synchronous and asynchronous operations on an
 * @p OutputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues2_setup(void) {
 80084a0:	b500      	push	{lr}

  chOQObjectInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 80084a2:	4a06      	ldr	r2, [pc, #24]	; (80084bc <queues2_setup+0x1c>)
 * This test case tests synchronous and asynchronous operations on an
 * @p OutputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues2_setup(void) {
 80084a4:	b083      	sub	sp, #12

  chOQObjectInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 80084a6:	2300      	movs	r3, #0
 80084a8:	6811      	ldr	r1, [r2, #0]
 80084aa:	9300      	str	r3, [sp, #0]
 80084ac:	4804      	ldr	r0, [pc, #16]	; (80084c0 <queues2_setup+0x20>)
 80084ae:	2204      	movs	r2, #4
 80084b0:	4b04      	ldr	r3, [pc, #16]	; (80084c4 <queues2_setup+0x24>)
 80084b2:	f7fa fbc5 	bl	8002c40 <chOQObjectInit>
}
 80084b6:	b003      	add	sp, #12
 80084b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80084bc:	0800d790 	.word	0x0800d790
 80084c0:	2000089c 	.word	0x2000089c
 80084c4:	08008441 	.word	0x08008441
	...

080084d0 <queues1_execute>:

  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
}

static void queues1_execute(void) {
 80084d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80084d4:	2420      	movs	r4, #32
 80084d6:	b082      	sub	sp, #8
 80084d8:	f384 8811 	msr	BASEPRI, r4
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 80084dc:	4b90      	ldr	r3, [pc, #576]	; (8008720 <queues1_execute+0x250>)
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");
 80084de:	2001      	movs	r0, #1
 80084e0:	6899      	ldr	r1, [r3, #8]
 80084e2:	fab1 f181 	clz	r1, r1
 80084e6:	0949      	lsrs	r1, r1, #5
 80084e8:	f7fd fc6a 	bl	8005dc0 <_test_assert>
 80084ec:	4606      	mov	r6, r0
 80084ee:	b9e8      	cbnz	r0, 800852c <queues1_execute+0x5c>
 80084f0:	f380 8811 	msr	BASEPRI, r0
 80084f4:	f384 8811 	msr	BASEPRI, r4
 80084f8:	2441      	movs	r4, #65	; 0x41

  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
 80084fa:	4d89      	ldr	r5, [pc, #548]	; (8008720 <queues1_execute+0x250>)
 80084fc:	4621      	mov	r1, r4
 80084fe:	3401      	adds	r4, #1
 8008500:	4628      	mov	r0, r5
 8008502:	b2e4      	uxtb	r4, r4
 8008504:	f7fa fb14 	bl	8002b30 <chIQPutI>
  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");

  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8008508:	2c45      	cmp	r4, #69	; 0x45
 800850a:	d1f6      	bne.n	80084fa <queues1_execute+0x2a>
 800850c:	2300      	movs	r3, #0
 800850e:	f383 8811 	msr	BASEPRI, r3
 8008512:	2320      	movs	r3, #32
 8008514:	f383 8811 	msr	BASEPRI, r3
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8008518:	69aa      	ldr	r2, [r5, #24]
 800851a:	696b      	ldr	r3, [r5, #20]
 800851c:	429a      	cmp	r2, r3
 800851e:	d03a      	beq.n	8008596 <queues1_execute+0xc6>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
 8008520:	4631      	mov	r1, r6
 8008522:	2002      	movs	r0, #2
 8008524:	f7fd fc4c 	bl	8005dc0 <_test_assert>
 8008528:	4604      	mov	r4, r0
 800852a:	b128      	cbz	r0, 8008538 <queues1_execute+0x68>
 800852c:	2300      	movs	r3, #0
 800852e:	f383 8811 	msr	BASEPRI, r3
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
  test_wait_threads();

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
}
 8008532:	b002      	add	sp, #8
 8008534:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008538:	f380 8811 	msr	BASEPRI, r0
 800853c:	2320      	movs	r3, #32
 800853e:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");
 8008542:	4877      	ldr	r0, [pc, #476]	; (8008720 <queues1_execute+0x250>)
 8008544:	4621      	mov	r1, r4
 8008546:	f7fa faf3 	bl	8002b30 <chIQPutI>
 800854a:	3004      	adds	r0, #4
 800854c:	bf14      	ite	ne
 800854e:	2100      	movne	r1, #0
 8008550:	2101      	moveq	r1, #1
 8008552:	2003      	movs	r0, #3
 8008554:	f7fd fc34 	bl	8005dc0 <_test_assert>
 8008558:	b9c0      	cbnz	r0, 800858c <queues1_execute+0xbc>
 800855a:	f380 8811 	msr	BASEPRI, r0
 800855e:	2404      	movs	r4, #4
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {

  return chIQGetTimeout(iqp, TIME_INFINITE);
 8008560:	4d6f      	ldr	r5, [pc, #444]	; (8008720 <queues1_execute+0x250>)
 8008562:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8008566:	4628      	mov	r0, r5
 8008568:	f7fa fb02 	bl	8002b70 <chIQGetTimeout>

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    test_emit_token(chIQGet(&iq));
 800856c:	b2c0      	uxtb	r0, r0
 800856e:	f7fd fc0f 	bl	8005d90 <test_emit_token>
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8008572:	3c01      	subs	r4, #1
 8008574:	d1f4      	bne.n	8008560 <queues1_execute+0x90>
 8008576:	2620      	movs	r6, #32
 8008578:	f386 8811 	msr	BASEPRI, r6
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 800857c:	68a9      	ldr	r1, [r5, #8]
    test_emit_token(chIQGet(&iq));
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
 800857e:	2004      	movs	r0, #4
 8008580:	fab1 f181 	clz	r1, r1
 8008584:	0949      	lsrs	r1, r1, #5
 8008586:	f7fd fc1b 	bl	8005dc0 <_test_assert>
 800858a:	b148      	cbz	r0, 80085a0 <queues1_execute+0xd0>
 800858c:	f384 8811 	msr	BASEPRI, r4
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
  test_wait_threads();

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
}
 8008590:	b002      	add	sp, #8
 8008592:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8008596:	68ae      	ldr	r6, [r5, #8]
 8008598:	3600      	adds	r6, #0
 800859a:	bf18      	it	ne
 800859c:	2601      	movne	r6, #1
 800859e:	e7bf      	b.n	8008520 <queues1_execute+0x50>
 80085a0:	f384 8811 	msr	BASEPRI, r4

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    test_emit_token(chIQGet(&iq));
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
  test_assert_sequence(5, "ABCD");
 80085a4:	2005      	movs	r0, #5
 80085a6:	495f      	ldr	r1, [pc, #380]	; (8008724 <queues1_execute+0x254>)
 80085a8:	f7fd fc22 	bl	8005df0 <_test_assert_sequence>
 80085ac:	2800      	cmp	r0, #0
 80085ae:	d1c0      	bne.n	8008532 <queues1_execute+0x62>
 80085b0:	f386 8811 	msr	BASEPRI, r6
 80085b4:	2441      	movs	r4, #65	; 0x41

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
 80085b6:	4d5a      	ldr	r5, [pc, #360]	; (8008720 <queues1_execute+0x250>)
 80085b8:	4621      	mov	r1, r4
 80085ba:	3401      	adds	r4, #1
 80085bc:	4628      	mov	r0, r5
 80085be:	b2e4      	uxtb	r4, r4
 80085c0:	f7fa fab6 	bl	8002b30 <chIQPutI>
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
  test_assert_sequence(5, "ABCD");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 80085c4:	2c45      	cmp	r4, #69	; 0x45
 80085c6:	d1f6      	bne.n	80085b6 <queues1_execute+0xe6>
 80085c8:	2300      	movs	r3, #0
 80085ca:	f383 8811 	msr	BASEPRI, r3
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();

  /* Reading the whole thing */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 80085ce:	4e56      	ldr	r6, [pc, #344]	; (8008728 <queues1_execute+0x258>)
 80085d0:	2208      	movs	r2, #8
 80085d2:	6871      	ldr	r1, [r6, #4]
 80085d4:	4628      	mov	r0, r5
 80085d6:	f7fa faf3 	bl	8002bc0 <chIQReadTimeout>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 80085da:	f1a0 0104 	sub.w	r1, r0, #4
 80085de:	fab1 f181 	clz	r1, r1
 80085e2:	2006      	movs	r0, #6
 80085e4:	0949      	lsrs	r1, r1, #5
 80085e6:	f7fd fbeb 	bl	8005dc0 <_test_assert>
 80085ea:	4604      	mov	r4, r0
 80085ec:	2800      	cmp	r0, #0
 80085ee:	d1a0      	bne.n	8008532 <queues1_execute+0x62>
 80085f0:	2720      	movs	r7, #32
 80085f2:	f387 8811 	msr	BASEPRI, r7
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 80085f6:	68a9      	ldr	r1, [r5, #8]
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");
 80085f8:	2007      	movs	r0, #7
 80085fa:	fab1 f181 	clz	r1, r1
 80085fe:	0949      	lsrs	r1, r1, #5
 8008600:	f7fd fbde 	bl	8005dc0 <_test_assert>
 8008604:	2800      	cmp	r0, #0
 8008606:	d1c1      	bne.n	800858c <queues1_execute+0xbc>
 8008608:	f380 8811 	msr	BASEPRI, r0
 800860c:	f387 8811 	msr	BASEPRI, r7
 8008610:	2441      	movs	r4, #65	; 0x41

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
 8008612:	4d43      	ldr	r5, [pc, #268]	; (8008720 <queues1_execute+0x250>)
 8008614:	4621      	mov	r1, r4
 8008616:	3401      	adds	r4, #1
 8008618:	4628      	mov	r0, r5
 800861a:	b2e4      	uxtb	r4, r4
 800861c:	f7fa fa88 	bl	8002b30 <chIQPutI>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8008620:	2c45      	cmp	r4, #69	; 0x45
 8008622:	d1f6      	bne.n	8008612 <queues1_execute+0x142>
 8008624:	2300      	movs	r3, #0
 8008626:	f383 8811 	msr	BASEPRI, r3
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();

  /* Partial reads */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800862a:	6874      	ldr	r4, [r6, #4]
 800862c:	2202      	movs	r2, #2
 800862e:	4621      	mov	r1, r4
 8008630:	4628      	mov	r0, r5
 8008632:	f7fa fac5 	bl	8002bc0 <chIQReadTimeout>
  test_assert(8, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 8008636:	f1a0 0102 	sub.w	r1, r0, #2
 800863a:	fab1 f181 	clz	r1, r1
 800863e:	2008      	movs	r0, #8
 8008640:	0949      	lsrs	r1, r1, #5
 8008642:	f7fd fbbd 	bl	8005dc0 <_test_assert>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();

  /* Partial reads */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8008646:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 8008728 <queues1_execute+0x258>
  test_assert(8, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800864a:	2800      	cmp	r0, #0
 800864c:	f47f af71 	bne.w	8008532 <queues1_execute+0x62>
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8008650:	4603      	mov	r3, r0
 8008652:	4621      	mov	r1, r4
 8008654:	2202      	movs	r2, #2
 8008656:	4628      	mov	r0, r5
 8008658:	f7fa fab2 	bl	8002bc0 <chIQReadTimeout>
  test_assert(9, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800865c:	f1a0 0102 	sub.w	r1, r0, #2
 8008660:	fab1 f181 	clz	r1, r1
 8008664:	2009      	movs	r0, #9
 8008666:	0949      	lsrs	r1, r1, #5
 8008668:	f7fd fbaa 	bl	8005dc0 <_test_assert>
 800866c:	4606      	mov	r6, r0
 800866e:	2800      	cmp	r0, #0
 8008670:	f47f af5f 	bne.w	8008532 <queues1_execute+0x62>
 8008674:	2720      	movs	r7, #32
 8008676:	f387 8811 	msr	BASEPRI, r7
 800867a:	68a9      	ldr	r1, [r5, #8]
  test_assert_lock(10, chIQIsEmptyI(&iq), "still full");
 800867c:	200a      	movs	r0, #10
 800867e:	fab1 f181 	clz	r1, r1
 8008682:	0949      	lsrs	r1, r1, #5
 8008684:	f7fd fb9c 	bl	8005dc0 <_test_assert>
 8008688:	4604      	mov	r4, r0
 800868a:	b110      	cbz	r0, 8008692 <queues1_execute+0x1c2>
 800868c:	f386 8811 	msr	BASEPRI, r6
 8008690:	e74f      	b.n	8008532 <queues1_execute+0x62>
 8008692:	f380 8811 	msr	BASEPRI, r0
 8008696:	f387 8811 	msr	BASEPRI, r7

  /* Testing reset */
  chSysLock();
  chIQPutI(&iq, 0);
 800869a:	4621      	mov	r1, r4
 800869c:	4628      	mov	r0, r5
 800869e:	f7fa fa47 	bl	8002b30 <chIQPutI>
  chIQResetI(&iq);
 80086a2:	4628      	mov	r0, r5
 80086a4:	f7fa fa34 	bl	8002b10 <chIQResetI>
 80086a8:	f384 8811 	msr	BASEPRI, r4
 80086ac:	f387 8811 	msr	BASEPRI, r7
 */
static inline size_t chIQGetFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (size_t)chQSpaceI(iqp);
 80086b0:	68a9      	ldr	r1, [r5, #8]
  chSysUnlock();
  test_assert_lock(11, chIQGetFullI(&iq) == 0, "still full");
 80086b2:	200b      	movs	r0, #11
 80086b4:	fab1 f181 	clz	r1, r1
 80086b8:	0949      	lsrs	r1, r1, #5
 80086ba:	f7fd fb81 	bl	8005dc0 <_test_assert>
 80086be:	4606      	mov	r6, r0
 80086c0:	2800      	cmp	r0, #0
 80086c2:	f47f af63 	bne.w	800858c <queues1_execute+0xbc>
 80086c6:	f380 8811 	msr	BASEPRI, r0
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80086ca:	4b18      	ldr	r3, [pc, #96]	; (800872c <queues1_execute+0x25c>)
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, NULL);
 80086cc:	f8d8 0000 	ldr.w	r0, [r8]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80086d0:	691b      	ldr	r3, [r3, #16]
 80086d2:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80086d6:	689a      	ldr	r2, [r3, #8]
 80086d8:	4b15      	ldr	r3, [pc, #84]	; (8008730 <queues1_execute+0x260>)
 80086da:	3201      	adds	r2, #1
 80086dc:	9600      	str	r6, [sp, #0]
 80086de:	f7f9 f9e7 	bl	8001ab0 <chThdCreateStatic>
 80086e2:	4b14      	ldr	r3, [pc, #80]	; (8008734 <queues1_execute+0x264>)
 80086e4:	6018      	str	r0, [r3, #0]
 80086e6:	f387 8811 	msr	BASEPRI, r7
 80086ea:	68a9      	ldr	r1, [r5, #8]
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
 80086ec:	200c      	movs	r0, #12
 80086ee:	fab1 f181 	clz	r1, r1
 80086f2:	0949      	lsrs	r1, r1, #5
 80086f4:	f7fd fb64 	bl	8005dc0 <_test_assert>
 80086f8:	2800      	cmp	r0, #0
 80086fa:	d1c7      	bne.n	800868c <queues1_execute+0x1bc>
 80086fc:	f380 8811 	msr	BASEPRI, r0
  test_wait_threads();
 8008700:	f7fd fbd6 	bl	8005eb0 <test_wait_threads>

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
 8008704:	4628      	mov	r0, r5
 8008706:	210a      	movs	r1, #10
 8008708:	f7fa fa32 	bl	8002b70 <chIQGetTimeout>
 800870c:	1c43      	adds	r3, r0, #1
 800870e:	4259      	negs	r1, r3
 8008710:	4159      	adcs	r1, r3
 8008712:	200d      	movs	r0, #13
}
 8008714:	b002      	add	sp, #8
 8008716:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, NULL);
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
  test_wait_threads();

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
 800871a:	f7fd bb51 	b.w	8005dc0 <_test_assert>
 800871e:	bf00      	nop
 8008720:	200008c0 	.word	0x200008c0
 8008724:	0800de84 	.word	0x0800de84
 8008728:	0800d790 	.word	0x0800d790
 800872c:	20001160 	.word	0x20001160
 8008730:	08008451 	.word	0x08008451
 8008734:	20001c58 	.word	0x20001c58
	...

08008740 <queues2_execute>:

  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
}

static void queues2_execute(void) {
 8008740:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8008744:	2320      	movs	r3, #32
 8008746:	b083      	sub	sp, #12
 8008748:	f383 8811 	msr	BASEPRI, r3
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 800874c:	4b85      	ldr	r3, [pc, #532]	; (8008964 <queues2_execute+0x224>)
 800874e:	6959      	ldr	r1, [r3, #20]
 8008750:	699a      	ldr	r2, [r3, #24]
 8008752:	4291      	cmp	r1, r2
 8008754:	d05d      	beq.n	8008812 <queues2_execute+0xd2>
 8008756:	2100      	movs	r1, #0
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");
 8008758:	2001      	movs	r0, #1
 800875a:	f7fd fb31 	bl	8005dc0 <_test_assert>
 800875e:	bbb8      	cbnz	r0, 80087d0 <queues2_execute+0x90>
 8008760:	f380 8811 	msr	BASEPRI, r0
 8008764:	2441      	movs	r4, #65	; 0x41
 *
 * @api
 */
static inline msg_t chOQPut(output_queue_t *oqp, uint8_t b) {

  return chOQPutTimeout(oqp, b, TIME_INFINITE);
 8008766:	4d7f      	ldr	r5, [pc, #508]	; (8008964 <queues2_execute+0x224>)
 8008768:	4621      	mov	r1, r4
 800876a:	3401      	adds	r4, #1
 800876c:	4628      	mov	r0, r5
 800876e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8008772:	b2e4      	uxtb	r4, r4
 8008774:	f7fa fa84 	bl	8002c80 <chOQPutTimeout>

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8008778:	2c45      	cmp	r4, #69	; 0x45
 800877a:	d1f4      	bne.n	8008766 <queues2_execute+0x26>
 800877c:	2620      	movs	r6, #32
 800877e:	f386 8811 	msr	BASEPRI, r6
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8008782:	68a9      	ldr	r1, [r5, #8]
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");
 8008784:	2002      	movs	r0, #2
 8008786:	fab1 f181 	clz	r1, r1
 800878a:	0949      	lsrs	r1, r1, #5
 800878c:	f7fd fb18 	bl	8005dc0 <_test_assert>
 8008790:	4607      	mov	r7, r0
 8008792:	b9e8      	cbnz	r0, 80087d0 <queues2_execute+0x90>
 8008794:	f380 8811 	msr	BASEPRI, r0
 8008798:	4681      	mov	r9, r0
 800879a:	2404      	movs	r4, #4
 800879c:	f04f 0820 	mov.w	r8, #32
 80087a0:	f386 8811 	msr	BASEPRI, r6
  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
    char c;

    chSysLock();
    c = chOQGetI(&oq);
 80087a4:	4d6f      	ldr	r5, [pc, #444]	; (8008964 <queues2_execute+0x224>)
 80087a6:	4628      	mov	r0, r5
 80087a8:	f7fa fa9a 	bl	8002ce0 <chOQGetI>
 80087ac:	f389 8811 	msr	BASEPRI, r9
    chSysUnlock();
    test_emit_token(c);
 80087b0:	b2c0      	uxtb	r0, r0
 80087b2:	f7fd faed 	bl	8005d90 <test_emit_token>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
 80087b6:	3c01      	subs	r4, #1
 80087b8:	d1f0      	bne.n	800879c <queues2_execute+0x5c>
 80087ba:	f388 8811 	msr	BASEPRI, r8
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 80087be:	696a      	ldr	r2, [r5, #20]
 80087c0:	69ab      	ldr	r3, [r5, #24]
 80087c2:	429a      	cmp	r2, r3
 80087c4:	d02a      	beq.n	800881c <queues2_execute+0xdc>
    chSysLock();
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
 80087c6:	4639      	mov	r1, r7
 80087c8:	2003      	movs	r0, #3
 80087ca:	f7fd faf9 	bl	8005dc0 <_test_assert>
 80087ce:	b128      	cbz	r0, 80087dc <queues2_execute+0x9c>
 80087d0:	2300      	movs	r3, #0
 80087d2:	f383 8811 	msr	BASEPRI, r3
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
  test_assert_lock(12, chOQIsFullI(&oq), "not full");

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
}
 80087d6:	b003      	add	sp, #12
 80087d8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80087dc:	f380 8811 	msr	BASEPRI, r0
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
  test_assert_sequence(4, "ABCD");
 80087e0:	2004      	movs	r0, #4
 80087e2:	4961      	ldr	r1, [pc, #388]	; (8008968 <queues2_execute+0x228>)
 80087e4:	f7fd fb04 	bl	8005df0 <_test_assert_sequence>
 80087e8:	4604      	mov	r4, r0
 80087ea:	2800      	cmp	r0, #0
 80087ec:	d1f3      	bne.n	80087d6 <queues2_execute+0x96>
 80087ee:	2620      	movs	r6, #32
 80087f0:	f386 8811 	msr	BASEPRI, r6
  test_assert_lock(5, chOQGetI(&oq) == Q_EMPTY, "failed to report Q_EMPTY");
 80087f4:	4d5b      	ldr	r5, [pc, #364]	; (8008964 <queues2_execute+0x224>)
 80087f6:	4628      	mov	r0, r5
 80087f8:	f7fa fa72 	bl	8002ce0 <chOQGetI>
 80087fc:	3003      	adds	r0, #3
 80087fe:	bf14      	ite	ne
 8008800:	2100      	movne	r1, #0
 8008802:	2101      	moveq	r1, #1
 8008804:	2005      	movs	r0, #5
 8008806:	f7fd fadb 	bl	8005dc0 <_test_assert>
 800880a:	b160      	cbz	r0, 8008826 <queues2_execute+0xe6>
 800880c:	f384 8811 	msr	BASEPRI, r4
 8008810:	e7e1      	b.n	80087d6 <queues2_execute+0x96>
 8008812:	6899      	ldr	r1, [r3, #8]
 8008814:	3100      	adds	r1, #0
 8008816:	bf18      	it	ne
 8008818:	2101      	movne	r1, #1
 800881a:	e79d      	b.n	8008758 <queues2_execute+0x18>
 800881c:	68af      	ldr	r7, [r5, #8]
 800881e:	3700      	adds	r7, #0
 8008820:	bf18      	it	ne
 8008822:	2701      	movne	r7, #1
 8008824:	e7cf      	b.n	80087c6 <queues2_execute+0x86>
 8008826:	f380 8811 	msr	BASEPRI, r0

  /* Writing the whole thing */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 800882a:	4f50      	ldr	r7, [pc, #320]	; (800896c <queues2_execute+0x22c>)
 800882c:	4603      	mov	r3, r0
 800882e:	687c      	ldr	r4, [r7, #4]
 8008830:	2208      	movs	r2, #8
 8008832:	4621      	mov	r1, r4
 8008834:	4628      	mov	r0, r5
 8008836:	f7fa fa73 	bl	8002d20 <chOQWriteTimeout>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 800883a:	f1a0 0104 	sub.w	r1, r0, #4
 800883e:	fab1 f181 	clz	r1, r1
 8008842:	2006      	movs	r0, #6
 8008844:	0949      	lsrs	r1, r1, #5
 8008846:	f7fd fabb 	bl	8005dc0 <_test_assert>
 800884a:	4680      	mov	r8, r0
 800884c:	2800      	cmp	r0, #0
 800884e:	d1c2      	bne.n	80087d6 <queues2_execute+0x96>
 8008850:	f386 8811 	msr	BASEPRI, r6
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8008854:	68a9      	ldr	r1, [r5, #8]
  test_assert_lock(7, chOQIsFullI(&oq), "not full");
 8008856:	2007      	movs	r0, #7
 8008858:	fab1 f181 	clz	r1, r1
 800885c:	0949      	lsrs	r1, r1, #5
 800885e:	f7fd faaf 	bl	8005dc0 <_test_assert>
 8008862:	4681      	mov	r9, r0
 8008864:	b110      	cbz	r0, 800886c <queues2_execute+0x12c>
 8008866:	f388 8811 	msr	BASEPRI, r8
 800886a:	e7b4      	b.n	80087d6 <queues2_execute+0x96>
 800886c:	f380 8811 	msr	BASEPRI, r0
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8008870:	4b3f      	ldr	r3, [pc, #252]	; (8008970 <queues2_execute+0x230>)
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8008872:	6838      	ldr	r0, [r7, #0]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8008874:	691b      	ldr	r3, [r3, #16]
 8008876:	f44f 71a0 	mov.w	r1, #320	; 0x140
 800887a:	689a      	ldr	r2, [r3, #8]
 800887c:	f8cd 9000 	str.w	r9, [sp]
 8008880:	3201      	adds	r2, #1
 8008882:	4b3c      	ldr	r3, [pc, #240]	; (8008974 <queues2_execute+0x234>)
 8008884:	f7f9 f914 	bl	8001ab0 <chThdCreateStatic>
 8008888:	4b3b      	ldr	r3, [pc, #236]	; (8008978 <queues2_execute+0x238>)
 800888a:	6018      	str	r0, [r3, #0]
 800888c:	f386 8811 	msr	BASEPRI, r6
 */
static inline size_t chOQGetFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
 8008890:	68e9      	ldr	r1, [r5, #12]
 8008892:	692b      	ldr	r3, [r5, #16]
 8008894:	68aa      	ldr	r2, [r5, #8]
 8008896:	1a5b      	subs	r3, r3, r1
 8008898:	1a99      	subs	r1, r3, r2
  test_assert_lock(8, chOQGetFullI(&oq) == TEST_QUEUES_SIZE, "not empty");
 800889a:	f1a1 0104 	sub.w	r1, r1, #4
 800889e:	fab1 f181 	clz	r1, r1
 80088a2:	2008      	movs	r0, #8
 80088a4:	0949      	lsrs	r1, r1, #5
 80088a6:	f7fd fa8b 	bl	8005dc0 <_test_assert>
 80088aa:	4607      	mov	r7, r0
 80088ac:	b110      	cbz	r0, 80088b4 <queues2_execute+0x174>
 80088ae:	f389 8811 	msr	BASEPRI, r9
 80088b2:	e790      	b.n	80087d6 <queues2_execute+0x96>
 80088b4:	f380 8811 	msr	BASEPRI, r0
  test_wait_threads();
 80088b8:	f7fd fafa 	bl	8005eb0 <test_wait_threads>
 80088bc:	f386 8811 	msr	BASEPRI, r6

  /* Testing reset */
  chSysLock();
  chOQResetI(&oq);
 80088c0:	4628      	mov	r0, r5
 80088c2:	f7fa f9cd 	bl	8002c60 <chOQResetI>
 80088c6:	f387 8811 	msr	BASEPRI, r7
 80088ca:	f386 8811 	msr	BASEPRI, r6
 80088ce:	692b      	ldr	r3, [r5, #16]
 80088d0:	68ea      	ldr	r2, [r5, #12]
 80088d2:	68a9      	ldr	r1, [r5, #8]
 80088d4:	1a9b      	subs	r3, r3, r2
  chSysUnlock();
  test_assert_lock(9, chOQGetFullI(&oq) == 0, "still full");
 80088d6:	1a59      	subs	r1, r3, r1
 80088d8:	fab1 f181 	clz	r1, r1
 80088dc:	2009      	movs	r0, #9
 80088de:	0949      	lsrs	r1, r1, #5
 80088e0:	f7fd fa6e 	bl	8005dc0 <_test_assert>
 80088e4:	4603      	mov	r3, r0
 80088e6:	b110      	cbz	r0, 80088ee <queues2_execute+0x1ae>
 80088e8:	f387 8811 	msr	BASEPRI, r7
 80088ec:	e773      	b.n	80087d6 <queues2_execute+0x96>
 80088ee:	f380 8811 	msr	BASEPRI, r0

  /* Partial writes */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 80088f2:	2202      	movs	r2, #2
 80088f4:	4621      	mov	r1, r4
 80088f6:	4628      	mov	r0, r5
 80088f8:	f7fa fa12 	bl	8002d20 <chOQWriteTimeout>
  test_assert(10, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 80088fc:	3802      	subs	r0, #2
 80088fe:	4241      	negs	r1, r0
 8008900:	4141      	adcs	r1, r0
 8008902:	200a      	movs	r0, #10
 8008904:	f7fd fa5c 	bl	8005dc0 <_test_assert>
 8008908:	4603      	mov	r3, r0
 800890a:	2800      	cmp	r0, #0
 800890c:	f47f af63 	bne.w	80087d6 <queues2_execute+0x96>
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8008910:	4621      	mov	r1, r4
 8008912:	2202      	movs	r2, #2
 8008914:	4628      	mov	r0, r5
 8008916:	f7fa fa03 	bl	8002d20 <chOQWriteTimeout>
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800891a:	1e82      	subs	r2, r0, #2
 800891c:	4251      	negs	r1, r2
 800891e:	4151      	adcs	r1, r2
 8008920:	200b      	movs	r0, #11
 8008922:	f7fd fa4d 	bl	8005dc0 <_test_assert>
 8008926:	2800      	cmp	r0, #0
 8008928:	f47f af55 	bne.w	80087d6 <queues2_execute+0x96>
 800892c:	f386 8811 	msr	BASEPRI, r6
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8008930:	68a9      	ldr	r1, [r5, #8]
  test_assert_lock(12, chOQIsFullI(&oq), "not full");
 8008932:	200c      	movs	r0, #12
 8008934:	fab1 f181 	clz	r1, r1
 8008938:	0949      	lsrs	r1, r1, #5
 800893a:	f7fd fa41 	bl	8005dc0 <_test_assert>
 800893e:	2800      	cmp	r0, #0
 8008940:	f47f af46 	bne.w	80087d0 <queues2_execute+0x90>
 8008944:	2100      	movs	r1, #0
 8008946:	f381 8811 	msr	BASEPRI, r1

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
 800894a:	220a      	movs	r2, #10
 800894c:	4805      	ldr	r0, [pc, #20]	; (8008964 <queues2_execute+0x224>)
 800894e:	f7fa f997 	bl	8002c80 <chOQPutTimeout>
 8008952:	1c43      	adds	r3, r0, #1
 8008954:	4259      	negs	r1, r3
 8008956:	4159      	adcs	r1, r3
 8008958:	200d      	movs	r0, #13
}
 800895a:	b003      	add	sp, #12
 800895c:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
  test_assert_lock(12, chOQIsFullI(&oq), "not full");

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
 8008960:	f7fd ba2e 	b.w	8005dc0 <_test_assert>
 8008964:	2000089c 	.word	0x2000089c
 8008968:	0800de84 	.word	0x0800de84
 800896c:	0800d790 	.word	0x0800d790
 8008970:	20001160 	.word	0x20001160
 8008974:	08008491 	.word	0x08008491
 8008978:	20001c58 	.word	0x20001c58
 800897c:	00000000 	.word	0x00000000

08008980 <sys2_execute>:
 8008980:	2320      	movs	r3, #32
 8008982:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8008986:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8008988:	b672      	cpsid	i

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800898a:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800898e:	b662      	cpsie	i

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8008990:	2300      	movs	r3, #0
 8008992:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8008996:	b662      	cpsie	i
 8008998:	4770      	bx	lr
 800899a:	bf00      	nop
 800899c:	0000      	movs	r0, r0
	...

080089a0 <vtcb>:
 *
 * <h2>Description</h2>
 * The critical zones API is invoked for coverage.
 */

static void vtcb(void *p) {
 80089a0:	b510      	push	{r4, lr}

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80089a2:	2320      	movs	r3, #32
 80089a4:	f383 8811 	msr	BASEPRI, r3
 80089a8:	2400      	movs	r4, #0
 80089aa:	f384 8811 	msr	BASEPRI, r4
 80089ae:	f383 8811 	msr	BASEPRI, r3
  chSysLockFromISR();
  chSysUnlockFromISR();

  /* Reentrant case.*/
  chSysLockFromISR();
  sts = chSysGetStatusAndLockX();
 80089b2:	f7f8 fea5 	bl	8001700 <chSysGetStatusAndLockX>
  chSysRestoreStatusX(sts);
 80089b6:	f7f8 feb3 	bl	8001720 <chSysRestoreStatusX>
 80089ba:	f384 8811 	msr	BASEPRI, r4
 80089be:	bd10      	pop	{r4, pc}

080089c0 <sys3_execute>:
 * <h2>Description</h2>
 * The chSysIntegrityCheckI() API is invoked in order to asses the state of the
 * system data structures.
 */

static void sys3_execute(void) {
 80089c0:	b538      	push	{r3, r4, r5, lr}
 80089c2:	2420      	movs	r4, #32
 80089c4:	f384 8811 	msr	BASEPRI, r4
  bool result;

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 80089c8:	2001      	movs	r0, #1
 80089ca:	f7f8 fe31 	bl	8001630 <chSysIntegrityCheckI>
 80089ce:	2300      	movs	r3, #0
 80089d0:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  test_assert(1, result == false, "ready list check failed");
 80089d4:	f080 0101 	eor.w	r1, r0, #1
 80089d8:	b2c9      	uxtb	r1, r1
 80089da:	2001      	movs	r0, #1
 80089dc:	f7fd f9f0 	bl	8005dc0 <_test_assert>
 80089e0:	4605      	mov	r5, r0
 80089e2:	b100      	cbz	r0, 80089e6 <sys3_execute+0x26>
 80089e4:	bd38      	pop	{r3, r4, r5, pc}
 80089e6:	f384 8811 	msr	BASEPRI, r4

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 80089ea:	2002      	movs	r0, #2
 80089ec:	f7f8 fe20 	bl	8001630 <chSysIntegrityCheckI>
 80089f0:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();
  test_assert(2, result == false, "virtual timers list check failed");
 80089f4:	f080 0101 	eor.w	r1, r0, #1
 80089f8:	b2c9      	uxtb	r1, r1
 80089fa:	2002      	movs	r0, #2
 80089fc:	f7fd f9e0 	bl	8005dc0 <_test_assert>
 8008a00:	4605      	mov	r5, r0
 8008a02:	2800      	cmp	r0, #0
 8008a04:	d1ee      	bne.n	80089e4 <sys3_execute+0x24>
 8008a06:	f384 8811 	msr	BASEPRI, r4

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 8008a0a:	2004      	movs	r0, #4
 8008a0c:	f7f8 fe10 	bl	8001630 <chSysIntegrityCheckI>
 8008a10:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();
  test_assert(3, result == false, "registry list check failed");
 8008a14:	f080 0101 	eor.w	r1, r0, #1
 8008a18:	b2c9      	uxtb	r1, r1
 8008a1a:	2003      	movs	r0, #3
 8008a1c:	f7fd f9d0 	bl	8005dc0 <_test_assert>
 8008a20:	4605      	mov	r5, r0
 8008a22:	2800      	cmp	r0, #0
 8008a24:	d1de      	bne.n	80089e4 <sys3_execute+0x24>
 8008a26:	f384 8811 	msr	BASEPRI, r4

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 8008a2a:	2008      	movs	r0, #8
 8008a2c:	f7f8 fe00 	bl	8001630 <chSysIntegrityCheckI>
 8008a30:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();
  test_assert(4, result == false, "port layer check failed");
}
 8008a34:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  test_assert(3, result == false, "registry list check failed");

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
  chSysUnlock();
  test_assert(4, result == false, "port layer check failed");
 8008a38:	f080 0101 	eor.w	r1, r0, #1
 8008a3c:	b2c9      	uxtb	r1, r1
 8008a3e:	2004      	movs	r0, #4
 8008a40:	f7fd b9be 	b.w	8005dc0 <_test_assert>
	...

08008a50 <sys1_execute>:
  sts = chSysGetStatusAndLockX();
  chSysRestoreStatusX(sts);
  chSysUnlockFromISR();
}

static void sys1_execute(void) {
 8008a50:	b510      	push	{r4, lr}
 8008a52:	b086      	sub	sp, #24
  syssts_t sts;
  virtual_timer_t vt;

  /* Testing normal case.*/
  sts = chSysGetStatusAndLockX();
 8008a54:	f7f8 fe54 	bl	8001700 <chSysGetStatusAndLockX>
  chSysRestoreStatusX(sts);
 8008a58:	f7f8 fe62 	bl	8001720 <chSysRestoreStatusX>
 8008a5c:	2420      	movs	r4, #32
 8008a5e:	f384 8811 	msr	BASEPRI, r4

  /* Reentrant case.*/
  chSysLock();
  sts = chSysGetStatusAndLockX();
 8008a62:	f7f8 fe4d 	bl	8001700 <chSysGetStatusAndLockX>
  chSysRestoreStatusX(sts);
 8008a66:	f7f8 fe5b 	bl	8001720 <chSysRestoreStatusX>
 8008a6a:	2300      	movs	r3, #0
 8008a6c:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8008a70:	f3ef 8311 	mrs	r3, BASEPRI
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {

  if (port_irq_enabled(port_get_irq_status())) {
 8008a74:	b90b      	cbnz	r3, 8008a7a <sys1_execute+0x2a>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8008a76:	f384 8811 	msr	BASEPRI, r4
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8008a7a:	f3ef 8311 	mrs	r3, BASEPRI
 8008a7e:	b913      	cbnz	r3, 8008a86 <sys1_execute+0x36>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8008a80:	2320      	movs	r3, #32
 8008a82:	f383 8811 	msr	BASEPRI, r3
 8008a86:	2300      	movs	r3, #0
 8008a88:	f383 8811 	msr	BASEPRI, r3
 8008a8c:	2220      	movs	r2, #32
 8008a8e:	f382 8811 	msr	BASEPRI, r2
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8008a92:	f3ef 8211 	mrs	r2, BASEPRI
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {

  if (!port_irq_enabled(port_get_irq_status())) {
 8008a96:	b10a      	cbz	r2, 8008a9c <sys1_execute+0x4c>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8008a98:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8008a9c:	f3ef 8311 	mrs	r3, BASEPRI
 8008aa0:	b113      	cbz	r3, 8008aa8 <sys1_execute+0x58>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8008aa2:	2300      	movs	r3, #0
 8008aa4:	f383 8811 	msr	BASEPRI, r3
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {

  vtp->vt_func = NULL;
 8008aa8:	2300      	movs	r3, #0
 8008aaa:	9304      	str	r3, [sp, #16]
 8008aac:	2320      	movs	r3, #32
 8008aae:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8008ab2:	9b04      	ldr	r3, [sp, #16]
    chVTDoResetI(vtp);
 8008ab4:	ac01      	add	r4, sp, #4
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8008ab6:	b113      	cbz	r3, 8008abe <sys1_execute+0x6e>
    chVTDoResetI(vtp);
 8008ab8:	4620      	mov	r0, r4
 8008aba:	f7f8 fe71 	bl	80017a0 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8008abe:	4620      	mov	r0, r4
 8008ac0:	2101      	movs	r1, #1
 8008ac2:	4a0c      	ldr	r2, [pc, #48]	; (8008af4 <sys1_execute+0xa4>)
 8008ac4:	2300      	movs	r3, #0
 8008ac6:	f7f8 fe4b 	bl	8001760 <chVTDoSetI>
 8008aca:	2400      	movs	r4, #0
 8008acc:	f384 8811 	msr	BASEPRI, r4
  chSysUnconditionalUnlock();

  /*/Testing from ISR context using a virtual timer.*/
  chVTObjectInit(&vt);
  chVTSet(&vt, 1, vtcb, NULL);
  chThdSleep(10);
 8008ad0:	200a      	movs	r0, #10
 8008ad2:	f7f9 f85d 	bl	8001b90 <chThdSleep>
 8008ad6:	2320      	movs	r3, #32
 8008ad8:	f383 8811 	msr	BASEPRI, r3
 8008adc:	9904      	ldr	r1, [sp, #16]
 8008ade:	f384 8811 	msr	BASEPRI, r4

  test_assert(1, chVTIsArmed(&vt) == false, "timer still armed");
 8008ae2:	fab1 f181 	clz	r1, r1
 8008ae6:	2001      	movs	r0, #1
 8008ae8:	0949      	lsrs	r1, r1, #5
 8008aea:	f7fd f969 	bl	8005dc0 <_test_assert>
}
 8008aee:	b006      	add	sp, #24
 8008af0:	bd10      	pop	{r4, pc}
 8008af2:	bf00      	nop
 8008af4:	080089a1 	.word	0x080089a1
	...

08008b00 <tmo>:
 * A virtual timer is set and immediately reset into a continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}
 8008b00:	4770      	bx	lr
 8008b02:	bf00      	nop
	...

08008b10 <bmk13_execute>:
 *
 * <h2>Description</h2>
 * The memory size of the various kernel objects is printed.
 */

static void bmk13_execute(void) {
 8008b10:	b510      	push	{r4, lr}

  test_print("--- System: ");
 8008b12:	482f      	ldr	r0, [pc, #188]	; (8008bd0 <bmk13_execute+0xc0>)
  test_printn(sizeof(ch_system_t));
  test_println(" bytes");
 8008b14:	4c2f      	ldr	r4, [pc, #188]	; (8008bd4 <bmk13_execute+0xc4>)
 * The memory size of the various kernel objects is printed.
 */

static void bmk13_execute(void) {

  test_print("--- System: ");
 8008b16:	f7fd f90b 	bl	8005d30 <test_print>
  test_printn(sizeof(ch_system_t));
 8008b1a:	f44f 7098 	mov.w	r0, #304	; 0x130
 8008b1e:	f7fd f8d7 	bl	8005cd0 <test_printn>
  test_println(" bytes");
 8008b22:	4620      	mov	r0, r4
 8008b24:	f7fd f914 	bl	8005d50 <test_println>
  test_print("--- Thread: ");
 8008b28:	482b      	ldr	r0, [pc, #172]	; (8008bd8 <bmk13_execute+0xc8>)
 8008b2a:	f7fd f901 	bl	8005d30 <test_print>
  test_printn(sizeof(thread_t));
 8008b2e:	2038      	movs	r0, #56	; 0x38
 8008b30:	f7fd f8ce 	bl	8005cd0 <test_printn>
  test_println(" bytes");
 8008b34:	4620      	mov	r0, r4
 8008b36:	f7fd f90b 	bl	8005d50 <test_println>
  test_print("--- Timer : ");
 8008b3a:	4828      	ldr	r0, [pc, #160]	; (8008bdc <bmk13_execute+0xcc>)
 8008b3c:	f7fd f8f8 	bl	8005d30 <test_print>
  test_printn(sizeof(virtual_timer_t));
 8008b40:	2014      	movs	r0, #20
 8008b42:	f7fd f8c5 	bl	8005cd0 <test_printn>
  test_println(" bytes");
 8008b46:	4620      	mov	r0, r4
 8008b48:	f7fd f902 	bl	8005d50 <test_println>
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
  test_print("--- Semaph: ");
 8008b4c:	4824      	ldr	r0, [pc, #144]	; (8008be0 <bmk13_execute+0xd0>)
 8008b4e:	f7fd f8ef 	bl	8005d30 <test_print>
  test_printn(sizeof(semaphore_t));
 8008b52:	200c      	movs	r0, #12
 8008b54:	f7fd f8bc 	bl	8005cd0 <test_printn>
  test_println(" bytes");
 8008b58:	4620      	mov	r0, r4
 8008b5a:	f7fd f8f9 	bl	8005d50 <test_println>
#endif
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
  test_print("--- EventS: ");
 8008b5e:	4821      	ldr	r0, [pc, #132]	; (8008be4 <bmk13_execute+0xd4>)
 8008b60:	f7fd f8e6 	bl	8005d30 <test_print>
  test_printn(sizeof(event_source_t));
 8008b64:	2004      	movs	r0, #4
 8008b66:	f7fd f8b3 	bl	8005cd0 <test_printn>
  test_println(" bytes");
 8008b6a:	4620      	mov	r0, r4
 8008b6c:	f7fd f8f0 	bl	8005d50 <test_println>
  test_print("--- EventL: ");
 8008b70:	481d      	ldr	r0, [pc, #116]	; (8008be8 <bmk13_execute+0xd8>)
 8008b72:	f7fd f8dd 	bl	8005d30 <test_print>
  test_printn(sizeof(event_listener_t));
 8008b76:	2014      	movs	r0, #20
 8008b78:	f7fd f8aa 	bl	8005cd0 <test_printn>
  test_println(" bytes");
 8008b7c:	4620      	mov	r0, r4
 8008b7e:	f7fd f8e7 	bl	8005d50 <test_println>
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  test_print("--- Mutex : ");
 8008b82:	481a      	ldr	r0, [pc, #104]	; (8008bec <bmk13_execute+0xdc>)
 8008b84:	f7fd f8d4 	bl	8005d30 <test_print>
  test_printn(sizeof(mutex_t));
 8008b88:	2010      	movs	r0, #16
 8008b8a:	f7fd f8a1 	bl	8005cd0 <test_printn>
  test_println(" bytes");
 8008b8e:	4620      	mov	r0, r4
 8008b90:	f7fd f8de 	bl	8005d50 <test_println>
#endif
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
  test_print("--- CondV.: ");
 8008b94:	4816      	ldr	r0, [pc, #88]	; (8008bf0 <bmk13_execute+0xe0>)
 8008b96:	f7fd f8cb 	bl	8005d30 <test_print>
  test_printn(sizeof(condition_variable_t));
 8008b9a:	2008      	movs	r0, #8
 8008b9c:	f7fd f898 	bl	8005cd0 <test_printn>
  test_println(" bytes");
 8008ba0:	4620      	mov	r0, r4
 8008ba2:	f7fd f8d5 	bl	8005d50 <test_println>
#endif
#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)
  test_print("--- Queue : ");
 8008ba6:	4813      	ldr	r0, [pc, #76]	; (8008bf4 <bmk13_execute+0xe4>)
 8008ba8:	f7fd f8c2 	bl	8005d30 <test_print>
  test_printn(sizeof(io_queue_t));
 8008bac:	2024      	movs	r0, #36	; 0x24
 8008bae:	f7fd f88f 	bl	8005cd0 <test_printn>
  test_println(" bytes");
 8008bb2:	4620      	mov	r0, r4
 8008bb4:	f7fd f8cc 	bl	8005d50 <test_println>
#endif
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
  test_print("--- MailB.: ");
 8008bb8:	480f      	ldr	r0, [pc, #60]	; (8008bf8 <bmk13_execute+0xe8>)
 8008bba:	f7fd f8b9 	bl	8005d30 <test_print>
  test_printn(sizeof(mailbox_t));
 8008bbe:	2028      	movs	r0, #40	; 0x28
 8008bc0:	f7fd f886 	bl	8005cd0 <test_printn>
  test_println(" bytes");
 8008bc4:	4620      	mov	r0, r4
#endif
}
 8008bc6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_println(" bytes");
#endif
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
  test_print("--- MailB.: ");
  test_printn(sizeof(mailbox_t));
  test_println(" bytes");
 8008bca:	f7fd b8c1 	b.w	8005d50 <test_println>
 8008bce:	bf00      	nop
 8008bd0:	0800e080 	.word	0x0800e080
 8008bd4:	0800e090 	.word	0x0800e090
 8008bd8:	0800e098 	.word	0x0800e098
 8008bdc:	0800e0a8 	.word	0x0800e0a8
 8008be0:	0800e0b8 	.word	0x0800e0b8
 8008be4:	0800e0c8 	.word	0x0800e0c8
 8008be8:	0800e0d8 	.word	0x0800e0d8
 8008bec:	0800e0e8 	.word	0x0800e0e8
 8008bf0:	0800e0f8 	.word	0x0800e0f8
 8008bf4:	0800e108 	.word	0x0800e108
 8008bf8:	0800e118 	.word	0x0800e118
 8008bfc:	00000000 	.word	0x00000000

08008c00 <thread2>:

  chThdExit((msg_t)p);
}

#if CH_CFG_USE_MESSAGES || defined(__DOXYGEN__)
static THD_FUNCTION(thread2, p) {
 8008c00:	b510      	push	{r4, lr}
  thread_t *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
 8008c02:	f7f9 fe1d 	bl	8002840 <chMsgWait>
 8008c06:	6a44      	ldr	r4, [r0, #36]	; 0x24
    msg = chMsgGet(tp);
    chMsgRelease(tp, msg);
 8008c08:	4621      	mov	r1, r4
 8008c0a:	f7f9 fe39 	bl	8002880 <chMsgRelease>
  } while (msg);
 8008c0e:	2c00      	cmp	r4, #0
 8008c10:	d1f7      	bne.n	8008c02 <thread2+0x2>
}
 8008c12:	bd10      	pop	{r4, pc}
	...

08008c20 <bmk6_execute>:
 * terminate.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk6_execute(void) {
 8008c20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8008c24:	4b14      	ldr	r3, [pc, #80]	; (8008c78 <bmk6_execute+0x58>)

  uint32_t n = 0;
  void *wap = wa[0];
 8008c26:	4a15      	ldr	r2, [pc, #84]	; (8008c7c <bmk6_execute+0x5c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8008c28:	691b      	ldr	r3, [r3, #16]
 * terminate.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk6_execute(void) {
 8008c2a:	b082      	sub	sp, #8

  uint32_t n = 0;
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() + 1;
 8008c2c:	689d      	ldr	r5, [r3, #8]
 */

static void bmk6_execute(void) {

  uint32_t n = 0;
  void *wap = wa[0];
 8008c2e:	f8d2 8000 	ldr.w	r8, [r2]
 * a second of continuous operations.
 */

static void bmk6_execute(void) {

  uint32_t n = 0;
 8008c32:	2400      	movs	r4, #0
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() + 1;
  test_wait_tick();
 8008c34:	f7fd f954 	bl	8005ee0 <test_wait_tick>
  test_start_timer(1000);
 8008c38:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008c3c:	f7fd f960 	bl	8005f00 <test_start_timer>
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
 8008c40:	4627      	mov	r7, r4
 8008c42:	4e0f      	ldr	r6, [pc, #60]	; (8008c80 <bmk6_execute+0x60>)

static void bmk6_execute(void) {

  uint32_t n = 0;
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() + 1;
 8008c44:	3501      	adds	r5, #1
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
 8008c46:	4b0f      	ldr	r3, [pc, #60]	; (8008c84 <bmk6_execute+0x64>)
 8008c48:	9700      	str	r7, [sp, #0]
 8008c4a:	4640      	mov	r0, r8
 8008c4c:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8008c50:	462a      	mov	r2, r5
 8008c52:	f7f8 ff2d 	bl	8001ab0 <chThdCreateStatic>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8008c56:	7833      	ldrb	r3, [r6, #0]
  tprio_t prio = chThdGetPriorityX() + 1;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
    n++;
 8008c58:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8008c5a:	2b00      	cmp	r3, #0
 8008c5c:	d0f3      	beq.n	8008c46 <bmk6_execute+0x26>
  test_print("--- Score : ");
 8008c5e:	480a      	ldr	r0, [pc, #40]	; (8008c88 <bmk6_execute+0x68>)
 8008c60:	f7fd f866 	bl	8005d30 <test_print>
  test_printn(n);
 8008c64:	4620      	mov	r0, r4
 8008c66:	f7fd f833 	bl	8005cd0 <test_printn>
  test_println(" threads/S");
 8008c6a:	4808      	ldr	r0, [pc, #32]	; (8008c8c <bmk6_execute+0x6c>)
}
 8008c6c:	b002      	add	sp, #8
 8008c6e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n);
  test_println(" threads/S");
 8008c72:	f7fd b86d 	b.w	8005d50 <test_println>
 8008c76:	bf00      	nop
 8008c78:	20001160 	.word	0x20001160
 8008c7c:	0800d790 	.word	0x0800d790
 8008c80:	20001c3d 	.word	0x20001c3d
 8008c84:	08008e91 	.word	0x08008e91
 8008c88:	0800e128 	.word	0x0800e128
 8008c8c:	0800e138 	.word	0x0800e138

08008c90 <msg_loop_test>:
}

#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(thread_t *tp) {
 8008c90:	b570      	push	{r4, r5, r6, lr}
 8008c92:	4605      	mov	r5, r0

  uint32_t n = 0;
  test_wait_tick();
 8008c94:	f7fd f924 	bl	8005ee0 <test_wait_tick>
  test_start_timer(1000);
 8008c98:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008c9c:	f7fd f930 	bl	8005f00 <test_start_timer>
 8008ca0:	4e07      	ldr	r6, [pc, #28]	; (8008cc0 <msg_loop_test+0x30>)
#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(thread_t *tp) {

  uint32_t n = 0;
 8008ca2:	2400      	movs	r4, #0
  test_wait_tick();
  test_start_timer(1000);
  do {
    (void)chMsgSend(tp, 1);
 8008ca4:	4628      	mov	r0, r5
 8008ca6:	2101      	movs	r1, #1
 8008ca8:	f7f9 fdaa 	bl	8002800 <chMsgSend>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8008cac:	7833      	ldrb	r3, [r6, #0]
  uint32_t n = 0;
  test_wait_tick();
  test_start_timer(1000);
  do {
    (void)chMsgSend(tp, 1);
    n++;
 8008cae:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8008cb0:	2b00      	cmp	r3, #0
 8008cb2:	d0f7      	beq.n	8008ca4 <msg_loop_test+0x14>
  (void)chMsgSend(tp, 0);
 8008cb4:	4628      	mov	r0, r5
 8008cb6:	2100      	movs	r1, #0
 8008cb8:	f7f9 fda2 	bl	8002800 <chMsgSend>
  return n;
}
 8008cbc:	4620      	mov	r0, r4
 8008cbe:	bd70      	pop	{r4, r5, r6, pc}
 8008cc0:	20001c3d 	.word	0x20001c3d
	...

08008cd0 <bmk1_execute>:
 * A message server thread is created with a lower priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk1_execute(void) {
 8008cd0:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8008cd2:	4b13      	ldr	r3, [pc, #76]	; (8008d20 <bmk1_execute+0x50>)
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
 8008cd4:	4a13      	ldr	r2, [pc, #76]	; (8008d24 <bmk1_execute+0x54>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8008cd6:	691b      	ldr	r3, [r3, #16]
 8008cd8:	6810      	ldr	r0, [r2, #0]
 8008cda:	689a      	ldr	r2, [r3, #8]
 * A message server thread is created with a lower priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk1_execute(void) {
 8008cdc:	b082      	sub	sp, #8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
 8008cde:	2300      	movs	r3, #0
 8008ce0:	3a01      	subs	r2, #1
 8008ce2:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8008ce6:	9300      	str	r3, [sp, #0]
 8008ce8:	4b0f      	ldr	r3, [pc, #60]	; (8008d28 <bmk1_execute+0x58>)
 8008cea:	f7f8 fee1 	bl	8001ab0 <chThdCreateStatic>
 8008cee:	4b0f      	ldr	r3, [pc, #60]	; (8008d2c <bmk1_execute+0x5c>)
 8008cf0:	6018      	str	r0, [r3, #0]
  n = msg_loop_test(threads[0]);
 8008cf2:	f7ff ffcd 	bl	8008c90 <msg_loop_test>
 8008cf6:	4604      	mov	r4, r0
  test_wait_threads();
 8008cf8:	f7fd f8da 	bl	8005eb0 <test_wait_threads>
  test_print("--- Score : ");
 8008cfc:	480c      	ldr	r0, [pc, #48]	; (8008d30 <bmk1_execute+0x60>)
 8008cfe:	f7fd f817 	bl	8005d30 <test_print>
  test_printn(n);
 8008d02:	4620      	mov	r0, r4
 8008d04:	f7fc ffe4 	bl	8005cd0 <test_printn>
  test_print(" msgs/S, ");
 8008d08:	480a      	ldr	r0, [pc, #40]	; (8008d34 <bmk1_execute+0x64>)
 8008d0a:	f7fd f811 	bl	8005d30 <test_print>
  test_printn(n << 1);
 8008d0e:	0060      	lsls	r0, r4, #1
 8008d10:	f7fc ffde 	bl	8005cd0 <test_printn>
  test_println(" ctxswc/S");
 8008d14:	4808      	ldr	r0, [pc, #32]	; (8008d38 <bmk1_execute+0x68>)
}
 8008d16:	b002      	add	sp, #8
 8008d18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_wait_threads();
  test_print("--- Score : ");
  test_printn(n);
  test_print(" msgs/S, ");
  test_printn(n << 1);
  test_println(" ctxswc/S");
 8008d1c:	f7fd b818 	b.w	8005d50 <test_println>
 8008d20:	20001160 	.word	0x20001160
 8008d24:	0800d790 	.word	0x0800d790
 8008d28:	08008c01 	.word	0x08008c01
 8008d2c:	20001c58 	.word	0x20001c58
 8008d30:	0800e128 	.word	0x0800e128
 8008d34:	0800e144 	.word	0x0800e144
 8008d38:	0800e150 	.word	0x0800e150
 8008d3c:	00000000 	.word	0x00000000

08008d40 <bmk2_execute>:
 * A message server thread is created with an higher priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk2_execute(void) {
 8008d40:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8008d42:	4b13      	ldr	r3, [pc, #76]	; (8008d90 <bmk2_execute+0x50>)
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8008d44:	4a13      	ldr	r2, [pc, #76]	; (8008d94 <bmk2_execute+0x54>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8008d46:	691b      	ldr	r3, [r3, #16]
 8008d48:	6810      	ldr	r0, [r2, #0]
 8008d4a:	689a      	ldr	r2, [r3, #8]
 * A message server thread is created with an higher priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk2_execute(void) {
 8008d4c:	b082      	sub	sp, #8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8008d4e:	2300      	movs	r3, #0
 8008d50:	3201      	adds	r2, #1
 8008d52:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8008d56:	9300      	str	r3, [sp, #0]
 8008d58:	4b0f      	ldr	r3, [pc, #60]	; (8008d98 <bmk2_execute+0x58>)
 8008d5a:	f7f8 fea9 	bl	8001ab0 <chThdCreateStatic>
 8008d5e:	4b0f      	ldr	r3, [pc, #60]	; (8008d9c <bmk2_execute+0x5c>)
 8008d60:	6018      	str	r0, [r3, #0]
  n = msg_loop_test(threads[0]);
 8008d62:	f7ff ff95 	bl	8008c90 <msg_loop_test>
 8008d66:	4604      	mov	r4, r0
  test_wait_threads();
 8008d68:	f7fd f8a2 	bl	8005eb0 <test_wait_threads>
  test_print("--- Score : ");
 8008d6c:	480c      	ldr	r0, [pc, #48]	; (8008da0 <bmk2_execute+0x60>)
 8008d6e:	f7fc ffdf 	bl	8005d30 <test_print>
  test_printn(n);
 8008d72:	4620      	mov	r0, r4
 8008d74:	f7fc ffac 	bl	8005cd0 <test_printn>
  test_print(" msgs/S, ");
 8008d78:	480a      	ldr	r0, [pc, #40]	; (8008da4 <bmk2_execute+0x64>)
 8008d7a:	f7fc ffd9 	bl	8005d30 <test_print>
  test_printn(n << 1);
 8008d7e:	0060      	lsls	r0, r4, #1
 8008d80:	f7fc ffa6 	bl	8005cd0 <test_printn>
  test_println(" ctxswc/S");
 8008d84:	4808      	ldr	r0, [pc, #32]	; (8008da8 <bmk2_execute+0x68>)
}
 8008d86:	b002      	add	sp, #8
 8008d88:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_wait_threads();
  test_print("--- Score : ");
  test_printn(n);
  test_print(" msgs/S, ");
  test_printn(n << 1);
  test_println(" ctxswc/S");
 8008d8c:	f7fc bfe0 	b.w	8005d50 <test_println>
 8008d90:	20001160 	.word	0x20001160
 8008d94:	0800d790 	.word	0x0800d790
 8008d98:	08008c01 	.word	0x08008c01
 8008d9c:	20001c58 	.word	0x20001c58
 8008da0:	0800e128 	.word	0x0800e128
 8008da4:	0800e144 	.word	0x0800e144
 8008da8:	0800e150 	.word	0x0800e150
 8008dac:	00000000 	.word	0x00000000

08008db0 <bmk3_execute>:
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
 8008db0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8008db4:	4f2c      	ldr	r7, [pc, #176]	; (8008e68 <bmk3_execute+0xb8>)
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8008db6:	4e2d      	ldr	r6, [pc, #180]	; (8008e6c <bmk3_execute+0xbc>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8008db8:	693b      	ldr	r3, [r7, #16]
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
 8008dba:	b082      	sub	sp, #8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8008dbc:	689a      	ldr	r2, [r3, #8]
 8008dbe:	2500      	movs	r5, #0
 8008dc0:	6830      	ldr	r0, [r6, #0]
 8008dc2:	3201      	adds	r2, #1
 8008dc4:	9500      	str	r5, [sp, #0]
 8008dc6:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8008dca:	4b29      	ldr	r3, [pc, #164]	; (8008e70 <bmk3_execute+0xc0>)
 8008dcc:	f7f8 fe70 	bl	8001ab0 <chThdCreateStatic>
 8008dd0:	693b      	ldr	r3, [r7, #16]
 8008dd2:	4c28      	ldr	r4, [pc, #160]	; (8008e74 <bmk3_execute+0xc4>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 8008dd4:	689a      	ldr	r2, [r3, #8]
 8008dd6:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 8008e84 <bmk3_execute+0xd4>
 8008dda:	6873      	ldr	r3, [r6, #4]
 */

static void bmk3_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8008ddc:	6020      	str	r0, [r4, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 8008dde:	3a02      	subs	r2, #2
 8008de0:	9500      	str	r5, [sp, #0]
 8008de2:	4618      	mov	r0, r3
 8008de4:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8008de8:	4643      	mov	r3, r8
 8008dea:	f7f8 fe61 	bl	8001ab0 <chThdCreateStatic>
 8008dee:	693a      	ldr	r2, [r7, #16]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 8008df0:	68b3      	ldr	r3, [r6, #8]
 8008df2:	6892      	ldr	r2, [r2, #8]
 8008df4:	f44f 71a0 	mov.w	r1, #320	; 0x140

static void bmk3_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 8008df8:	6060      	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 8008dfa:	3a03      	subs	r2, #3
 8008dfc:	9500      	str	r5, [sp, #0]
 8008dfe:	4618      	mov	r0, r3
 8008e00:	4643      	mov	r3, r8
 8008e02:	f7f8 fe55 	bl	8001ab0 <chThdCreateStatic>
 8008e06:	693a      	ldr	r2, [r7, #16]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 8008e08:	68f3      	ldr	r3, [r6, #12]
 8008e0a:	6892      	ldr	r2, [r2, #8]
 8008e0c:	f44f 71a0 	mov.w	r1, #320	; 0x140
static void bmk3_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 8008e10:	60a0      	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 8008e12:	3a04      	subs	r2, #4
 8008e14:	9500      	str	r5, [sp, #0]
 8008e16:	4618      	mov	r0, r3
 8008e18:	4643      	mov	r3, r8
 8008e1a:	f7f8 fe49 	bl	8001ab0 <chThdCreateStatic>
 8008e1e:	693a      	ldr	r2, [r7, #16]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, thread1, NULL);
 8008e20:	6933      	ldr	r3, [r6, #16]
 8008e22:	6892      	ldr	r2, [r2, #8]
 8008e24:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8008e28:	3a05      	subs	r2, #5
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 8008e2a:	60e0      	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, thread1, NULL);
 8008e2c:	4618      	mov	r0, r3
 8008e2e:	9500      	str	r5, [sp, #0]
 8008e30:	4643      	mov	r3, r8
 8008e32:	f7f8 fe3d 	bl	8001ab0 <chThdCreateStatic>
 8008e36:	6120      	str	r0, [r4, #16]
  n = msg_loop_test(threads[0]);
 8008e38:	6820      	ldr	r0, [r4, #0]
 8008e3a:	f7ff ff29 	bl	8008c90 <msg_loop_test>
 8008e3e:	4604      	mov	r4, r0
  test_wait_threads();
 8008e40:	f7fd f836 	bl	8005eb0 <test_wait_threads>
  test_print("--- Score : ");
 8008e44:	480c      	ldr	r0, [pc, #48]	; (8008e78 <bmk3_execute+0xc8>)
 8008e46:	f7fc ff73 	bl	8005d30 <test_print>
  test_printn(n);
 8008e4a:	4620      	mov	r0, r4
 8008e4c:	f7fc ff40 	bl	8005cd0 <test_printn>
  test_print(" msgs/S, ");
 8008e50:	480a      	ldr	r0, [pc, #40]	; (8008e7c <bmk3_execute+0xcc>)
 8008e52:	f7fc ff6d 	bl	8005d30 <test_print>
  test_printn(n << 1);
 8008e56:	0060      	lsls	r0, r4, #1
 8008e58:	f7fc ff3a 	bl	8005cd0 <test_printn>
  test_println(" ctxswc/S");
 8008e5c:	4808      	ldr	r0, [pc, #32]	; (8008e80 <bmk3_execute+0xd0>)
}
 8008e5e:	b002      	add	sp, #8
 8008e60:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  test_wait_threads();
  test_print("--- Score : ");
  test_printn(n);
  test_print(" msgs/S, ");
  test_printn(n << 1);
  test_println(" ctxswc/S");
 8008e64:	f7fc bf74 	b.w	8005d50 <test_println>
 8008e68:	20001160 	.word	0x20001160
 8008e6c:	0800d790 	.word	0x0800d790
 8008e70:	08008c01 	.word	0x08008c01
 8008e74:	20001c58 	.word	0x20001c58
 8008e78:	0800e128 	.word	0x0800e128
 8008e7c:	0800e144 	.word	0x0800e144
 8008e80:	0800e150 	.word	0x0800e150
 8008e84:	08008e91 	.word	0x08008e91
	...

08008e90 <thread1>:
static mutex_t mtx1;
#endif

static THD_FUNCTION(thread1, p) {

  chThdExit((msg_t)p);
 8008e90:	f7f8 bed6 	b.w	8001c40 <chThdExit>
	...

08008ea0 <bmk4_execute>:
    msg = self->p_u.rdymsg;
  } while (msg == MSG_OK);
  chSysUnlock();
}

static void bmk4_execute(void) {
 8008ea0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8008ea4:	4b26      	ldr	r3, [pc, #152]	; (8008f40 <bmk4_execute+0xa0>)
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8008ea6:	4a27      	ldr	r2, [pc, #156]	; (8008f44 <bmk4_execute+0xa4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8008ea8:	691b      	ldr	r3, [r3, #16]
 8008eaa:	6810      	ldr	r0, [r2, #0]
 8008eac:	689a      	ldr	r2, [r3, #8]
    msg = self->p_u.rdymsg;
  } while (msg == MSG_OK);
  chSysUnlock();
}

static void bmk4_execute(void) {
 8008eae:	b082      	sub	sp, #8
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8008eb0:	2500      	movs	r5, #0
 8008eb2:	3201      	adds	r2, #1
 8008eb4:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8008eb8:	4b23      	ldr	r3, [pc, #140]	; (8008f48 <bmk4_execute+0xa8>)
 8008eba:	9500      	str	r5, [sp, #0]
 8008ebc:	f7f8 fdf8 	bl	8001ab0 <chThdCreateStatic>
 8008ec0:	4b22      	ldr	r3, [pc, #136]	; (8008f4c <bmk4_execute+0xac>)
 8008ec2:	4604      	mov	r4, r0
 8008ec4:	6018      	str	r0, [r3, #0]
                                      thread4, NULL);
  n = 0;
  test_wait_tick();
 8008ec6:	f7fd f80b 	bl	8005ee0 <test_wait_tick>
  test_start_timer(1000);
 8008eca:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  do {
    chSysLock();
    chSchWakeupS(tp, MSG_OK);
 8008ece:	46aa      	mov	sl, r5

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
                                      thread4, NULL);
  n = 0;
  test_wait_tick();
  test_start_timer(1000);
 8008ed0:	f7fd f816 	bl	8005f00 <test_start_timer>
 8008ed4:	f8df 9080 	ldr.w	r9, [pc, #128]	; 8008f58 <bmk4_execute+0xb8>
 8008ed8:	f04f 0820 	mov.w	r8, #32
 8008edc:	2720      	movs	r7, #32
 8008ede:	f388 8811 	msr	BASEPRI, r8
  do {
    chSysLock();
    chSchWakeupS(tp, MSG_OK);
 8008ee2:	2100      	movs	r1, #0
 8008ee4:	4620      	mov	r0, r4
 8008ee6:	f7f8 fd0b 	bl	8001900 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8008eea:	4620      	mov	r0, r4
 8008eec:	2100      	movs	r1, #0
 8008eee:	f7f8 fd07 	bl	8001900 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8008ef2:	4620      	mov	r0, r4
 8008ef4:	2100      	movs	r1, #0
 8008ef6:	f7f8 fd03 	bl	8001900 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8008efa:	4620      	mov	r0, r4
 8008efc:	2100      	movs	r1, #0
 8008efe:	f7f8 fcff 	bl	8001900 <chSchWakeupS>
 8008f02:	2600      	movs	r6, #0
 8008f04:	f38a 8811 	msr	BASEPRI, sl
    chSysUnlock();
    n += 4;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8008f08:	f899 3000 	ldrb.w	r3, [r9]
    chSchWakeupS(tp, MSG_OK);
    chSchWakeupS(tp, MSG_OK);
    chSchWakeupS(tp, MSG_OK);
    chSchWakeupS(tp, MSG_OK);
    chSysUnlock();
    n += 4;
 8008f0c:	3504      	adds	r5, #4
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8008f0e:	2b00      	cmp	r3, #0
 8008f10:	d0e4      	beq.n	8008edc <bmk4_execute+0x3c>
 8008f12:	f387 8811 	msr	BASEPRI, r7
  chSysLock();
  chSchWakeupS(tp, MSG_TIMEOUT);
 8008f16:	f04f 31ff 	mov.w	r1, #4294967295
 8008f1a:	4620      	mov	r0, r4
 8008f1c:	f7f8 fcf0 	bl	8001900 <chSchWakeupS>
 8008f20:	f386 8811 	msr	BASEPRI, r6
  chSysUnlock();

  test_wait_threads();
 8008f24:	f7fc ffc4 	bl	8005eb0 <test_wait_threads>
  test_print("--- Score : ");
 8008f28:	4809      	ldr	r0, [pc, #36]	; (8008f50 <bmk4_execute+0xb0>)
 8008f2a:	f7fc ff01 	bl	8005d30 <test_print>
  test_printn(n * 2);
 8008f2e:	0068      	lsls	r0, r5, #1
 8008f30:	f7fc fece 	bl	8005cd0 <test_printn>
  test_println(" ctxswc/S");
 8008f34:	4807      	ldr	r0, [pc, #28]	; (8008f54 <bmk4_execute+0xb4>)
}
 8008f36:	b002      	add	sp, #8
 8008f38:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  chSysUnlock();

  test_wait_threads();
  test_print("--- Score : ");
  test_printn(n * 2);
  test_println(" ctxswc/S");
 8008f3c:	f7fc bf08 	b.w	8005d50 <test_println>
 8008f40:	20001160 	.word	0x20001160
 8008f44:	0800d790 	.word	0x0800d790
 8008f48:	08008f61 	.word	0x08008f61
 8008f4c:	20001c58 	.word	0x20001c58
 8008f50:	0800e128 	.word	0x0800e128
 8008f54:	0800e150 	.word	0x0800e150
 8008f58:	20001c3d 	.word	0x20001c3d
 8008f5c:	00000000 	.word	0x00000000

08008f60 <thread4>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8008f60:	4a07      	ldr	r2, [pc, #28]	; (8008f80 <thread4+0x20>)
 * the thread is awakened as fast is possible by the tester thread.<br>
 * The Context Switch performance is calculated by measuring the number of
 * iterations after a second of continuous operations.
 */

static THD_FUNCTION(thread4, p) {
 8008f62:	b510      	push	{r4, lr}
 8008f64:	2320      	movs	r3, #32
 8008f66:	6914      	ldr	r4, [r2, #16]
 8008f68:	f383 8811 	msr	BASEPRI, r3
  thread_t *self = chThdGetSelfX();

  (void)p;
  chSysLock();
  do {
    chSchGoSleepS(CH_STATE_SUSPENDED);
 8008f6c:	2003      	movs	r0, #3
 8008f6e:	f7f8 fc87 	bl	8001880 <chSchGoSleepS>
    msg = self->p_u.rdymsg;
  } while (msg == MSG_OK);
 8008f72:	6963      	ldr	r3, [r4, #20]
 8008f74:	2b00      	cmp	r3, #0
 8008f76:	d0f9      	beq.n	8008f6c <thread4+0xc>
 8008f78:	2300      	movs	r3, #0
 8008f7a:	f383 8811 	msr	BASEPRI, r3
 8008f7e:	bd10      	pop	{r4, pc}
 8008f80:	20001160 	.word	0x20001160
	...

08008f90 <bmk5_execute>:
 * in each iteration.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk5_execute(void) {
 8008f90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008f94:	4b15      	ldr	r3, [pc, #84]	; (8008fec <bmk5_execute+0x5c>)

  uint32_t n = 0;
  void *wap = wa[0];
 8008f96:	4a16      	ldr	r2, [pc, #88]	; (8008ff0 <bmk5_execute+0x60>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8008f98:	691b      	ldr	r3, [r3, #16]
 * in each iteration.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk5_execute(void) {
 8008f9a:	b082      	sub	sp, #8

  uint32_t n = 0;
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() - 1;
 8008f9c:	689d      	ldr	r5, [r3, #8]
 */

static void bmk5_execute(void) {

  uint32_t n = 0;
  void *wap = wa[0];
 8008f9e:	f8d2 8000 	ldr.w	r8, [r2]
 * a second of continuous operations.
 */

static void bmk5_execute(void) {

  uint32_t n = 0;
 8008fa2:	2400      	movs	r4, #0
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() - 1;
  test_wait_tick();
 8008fa4:	f7fc ff9c 	bl	8005ee0 <test_wait_tick>
  test_start_timer(1000);
 8008fa8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008fac:	f7fc ffa8 	bl	8005f00 <test_start_timer>
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
 8008fb0:	4627      	mov	r7, r4
 8008fb2:	4e10      	ldr	r6, [pc, #64]	; (8008ff4 <bmk5_execute+0x64>)

static void bmk5_execute(void) {

  uint32_t n = 0;
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() - 1;
 8008fb4:	3d01      	subs	r5, #1
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
 8008fb6:	4b10      	ldr	r3, [pc, #64]	; (8008ff8 <bmk5_execute+0x68>)
 8008fb8:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8008fbc:	462a      	mov	r2, r5
 8008fbe:	9700      	str	r7, [sp, #0]
 8008fc0:	4640      	mov	r0, r8
 8008fc2:	f7f8 fd75 	bl	8001ab0 <chThdCreateStatic>
 8008fc6:	f7f8 fe43 	bl	8001c50 <chThdWait>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8008fca:	7833      	ldrb	r3, [r6, #0]
  tprio_t prio = chThdGetPriorityX() - 1;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
    n++;
 8008fcc:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8008fce:	2b00      	cmp	r3, #0
 8008fd0:	d0f1      	beq.n	8008fb6 <bmk5_execute+0x26>
  test_print("--- Score : ");
 8008fd2:	480a      	ldr	r0, [pc, #40]	; (8008ffc <bmk5_execute+0x6c>)
 8008fd4:	f7fc feac 	bl	8005d30 <test_print>
  test_printn(n);
 8008fd8:	4620      	mov	r0, r4
 8008fda:	f7fc fe79 	bl	8005cd0 <test_printn>
  test_println(" threads/S");
 8008fde:	4808      	ldr	r0, [pc, #32]	; (8009000 <bmk5_execute+0x70>)
}
 8008fe0:	b002      	add	sp, #8
 8008fe2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n);
  test_println(" threads/S");
 8008fe6:	f7fc beb3 	b.w	8005d50 <test_println>
 8008fea:	bf00      	nop
 8008fec:	20001160 	.word	0x20001160
 8008ff0:	0800d790 	.word	0x0800d790
 8008ff4:	20001c3d 	.word	0x20001c3d
 8008ff8:	08008e91 	.word	0x08008e91
 8008ffc:	0800e128 	.word	0x0800e128
 8009000:	0800e138 	.word	0x0800e138
	...

08009010 <bmk7_execute>:
static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static void bmk7_execute(void) {
 8009010:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8009012:	4f35      	ldr	r7, [pc, #212]	; (80090e8 <bmk7_execute+0xd8>)
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8009014:	4e35      	ldr	r6, [pc, #212]	; (80090ec <bmk7_execute+0xdc>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8009016:	693b      	ldr	r3, [r7, #16]
static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static void bmk7_execute(void) {
 8009018:	b083      	sub	sp, #12
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 800901a:	689a      	ldr	r2, [r3, #8]
 800901c:	2400      	movs	r4, #0
 800901e:	3205      	adds	r2, #5
 8009020:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8009024:	4b32      	ldr	r3, [pc, #200]	; (80090f0 <bmk7_execute+0xe0>)
 8009026:	6830      	ldr	r0, [r6, #0]
 8009028:	9400      	str	r4, [sp, #0]
 800902a:	f7f8 fd41 	bl	8001ab0 <chThdCreateStatic>
 800902e:	693b      	ldr	r3, [r7, #16]
 8009030:	4d30      	ldr	r5, [pc, #192]	; (80090f4 <bmk7_execute+0xe4>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 8009032:	689a      	ldr	r2, [r3, #8]
 8009034:	6873      	ldr	r3, [r6, #4]
}

static void bmk7_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8009036:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 8009038:	3204      	adds	r2, #4
 800903a:	4618      	mov	r0, r3
 800903c:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8009040:	4b2b      	ldr	r3, [pc, #172]	; (80090f0 <bmk7_execute+0xe0>)
 8009042:	9400      	str	r4, [sp, #0]
 8009044:	f7f8 fd34 	bl	8001ab0 <chThdCreateStatic>
 8009048:	693a      	ldr	r2, [r7, #16]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 800904a:	68b3      	ldr	r3, [r6, #8]
 800904c:	6892      	ldr	r2, [r2, #8]
 800904e:	f44f 71a0 	mov.w	r1, #320	; 0x140

static void bmk7_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 8009052:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 8009054:	3203      	adds	r2, #3
 8009056:	4618      	mov	r0, r3
 8009058:	9400      	str	r4, [sp, #0]
 800905a:	4b25      	ldr	r3, [pc, #148]	; (80090f0 <bmk7_execute+0xe0>)
 800905c:	f7f8 fd28 	bl	8001ab0 <chThdCreateStatic>
 8009060:	693a      	ldr	r2, [r7, #16]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 8009062:	68f3      	ldr	r3, [r6, #12]
 8009064:	6892      	ldr	r2, [r2, #8]
 8009066:	f44f 71a0 	mov.w	r1, #320	; 0x140
static void bmk7_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 800906a:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 800906c:	3202      	adds	r2, #2
 800906e:	4618      	mov	r0, r3
 8009070:	9400      	str	r4, [sp, #0]
 8009072:	4b1f      	ldr	r3, [pc, #124]	; (80090f0 <bmk7_execute+0xe0>)
 8009074:	f7f8 fd1c 	bl	8001ab0 <chThdCreateStatic>
 8009078:	693a      	ldr	r2, [r7, #16]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
 800907a:	6933      	ldr	r3, [r6, #16]
 800907c:	6892      	ldr	r2, [r2, #8]
 800907e:	f44f 71a0 	mov.w	r1, #320	; 0x140
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 8009082:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
 8009084:	3201      	adds	r2, #1
 8009086:	4618      	mov	r0, r3
 8009088:	9400      	str	r4, [sp, #0]
 800908a:	4b19      	ldr	r3, [pc, #100]	; (80090f0 <bmk7_execute+0xe0>)
 800908c:	f7f8 fd10 	bl	8001ab0 <chThdCreateStatic>
 8009090:	6128      	str	r0, [r5, #16]

  n = 0;
  test_wait_tick();
 8009092:	f7fc ff25 	bl	8005ee0 <test_wait_tick>
  test_start_timer(1000);
 8009096:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800909a:	f7fc ff31 	bl	8005f00 <test_start_timer>
 800909e:	4d16      	ldr	r5, [pc, #88]	; (80090f8 <bmk7_execute+0xe8>)
  do {
    chSemReset(&sem1, 0);
 80090a0:	4816      	ldr	r0, [pc, #88]	; (80090fc <bmk7_execute+0xec>)
 80090a2:	2100      	movs	r1, #0
 80090a4:	f7f8 ff2c 	bl	8001f00 <chSemReset>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80090a8:	782b      	ldrb	r3, [r5, #0]
  n = 0;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chSemReset(&sem1, 0);
    n++;
 80090aa:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80090ac:	2b00      	cmp	r3, #0
 80090ae:	d0f7      	beq.n	80090a0 <bmk7_execute+0x90>
  test_terminate_threads();
 80090b0:	f7fc feee 	bl	8005e90 <test_terminate_threads>
  chSemReset(&sem1, 0);
 80090b4:	2100      	movs	r1, #0
 80090b6:	4811      	ldr	r0, [pc, #68]	; (80090fc <bmk7_execute+0xec>)
 80090b8:	f7f8 ff22 	bl	8001f00 <chSemReset>
  test_wait_threads();
 80090bc:	f7fc fef8 	bl	8005eb0 <test_wait_threads>

  test_print("--- Score : ");
 80090c0:	480f      	ldr	r0, [pc, #60]	; (8009100 <bmk7_execute+0xf0>)
 80090c2:	f7fc fe35 	bl	8005d30 <test_print>
  test_printn(n);
 80090c6:	4620      	mov	r0, r4
 80090c8:	f7fc fe02 	bl	8005cd0 <test_printn>
  test_print(" reschedules/S, ");
 80090cc:	480d      	ldr	r0, [pc, #52]	; (8009104 <bmk7_execute+0xf4>)
 80090ce:	f7fc fe2f 	bl	8005d30 <test_print>
  test_printn(n * 6);
 80090d2:	eb04 0044 	add.w	r0, r4, r4, lsl #1
 80090d6:	0040      	lsls	r0, r0, #1
 80090d8:	f7fc fdfa 	bl	8005cd0 <test_printn>
  test_println(" ctxswc/S");
 80090dc:	480a      	ldr	r0, [pc, #40]	; (8009108 <bmk7_execute+0xf8>)
}
 80090de:	b003      	add	sp, #12
 80090e0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}

  test_print("--- Score : ");
  test_printn(n);
  test_print(" reschedules/S, ");
  test_printn(n * 6);
  test_println(" ctxswc/S");
 80090e4:	f7fc be34 	b.w	8005d50 <test_println>
 80090e8:	20001160 	.word	0x20001160
 80090ec:	0800d790 	.word	0x0800d790
 80090f0:	08009111 	.word	0x08009111
 80090f4:	20001c58 	.word	0x20001c58
 80090f8:	20001c3d 	.word	0x20001c3d
 80090fc:	20001d44 	.word	0x20001d44
 8009100:	0800e128 	.word	0x0800e128
 8009104:	0800e15c 	.word	0x0800e15c
 8009108:	0800e150 	.word	0x0800e150
 800910c:	00000000 	.word	0x00000000

08009110 <thread3>:
 * continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread3, p) {
 8009110:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8009112:	4c06      	ldr	r4, [pc, #24]	; (800912c <thread3+0x1c>)
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8009114:	6923      	ldr	r3, [r4, #16]
 8009116:	7c5b      	ldrb	r3, [r3, #17]

  (void)p;
  while (!chThdShouldTerminateX())
 8009118:	075a      	lsls	r2, r3, #29
 800911a:	d406      	bmi.n	800912a <thread3+0x1a>
    chSemWait(&sem1);
 800911c:	4804      	ldr	r0, [pc, #16]	; (8009130 <thread3+0x20>)
 800911e:	f7f8 feff 	bl	8001f20 <chSemWait>
 8009122:	6923      	ldr	r3, [r4, #16]
 8009124:	7c5b      	ldrb	r3, [r3, #17]
 */

static THD_FUNCTION(thread3, p) {

  (void)p;
  while (!chThdShouldTerminateX())
 8009126:	075b      	lsls	r3, r3, #29
 8009128:	d5f8      	bpl.n	800911c <thread3+0xc>
 800912a:	bd10      	pop	{r4, pc}
 800912c:	20001160 	.word	0x20001160
 8009130:	20001d44 	.word	0x20001d44
	...

08009140 <bmk7_setup>:
    chSemWait(&sem1);
}

static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
 8009140:	4801      	ldr	r0, [pc, #4]	; (8009148 <bmk7_setup+0x8>)
 8009142:	2100      	movs	r1, #0
 8009144:	f7f8 bebc 	b.w	8001ec0 <chSemObjectInit>
 8009148:	20001d44 	.word	0x20001d44
 800914c:	00000000 	.word	0x00000000

08009150 <bmk11_setup>:
 * a second of continuous operations.
 */

static void bmk11_setup(void) {

  chSemObjectInit(&sem1, 1);
 8009150:	4801      	ldr	r0, [pc, #4]	; (8009158 <bmk11_setup+0x8>)
 8009152:	2101      	movs	r1, #1
 8009154:	f7f8 beb4 	b.w	8001ec0 <chSemObjectInit>
 8009158:	20001d44 	.word	0x20001d44
 800915c:	00000000 	.word	0x00000000

08009160 <bmk8_execute>:
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
}

static void bmk8_execute(void) {
 8009160:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8009164:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 8009238 <bmk8_execute+0xd8>
 8009168:	b084      	sub	sp, #16
  uint32_t n;

  n = 0;
 800916a:	ac04      	add	r4, sp, #16
 800916c:	2300      	movs	r3, #0
 800916e:	f844 3d04 	str.w	r3, [r4, #-4]!
  test_wait_tick();
 8009172:	f7fc feb5 	bl	8005ee0 <test_wait_tick>
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8009176:	f8d8 3010 	ldr.w	r3, [r8, #16]

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 800917a:	4f2a      	ldr	r7, [pc, #168]	; (8009224 <bmk8_execute+0xc4>)
 800917c:	4e2a      	ldr	r6, [pc, #168]	; (8009228 <bmk8_execute+0xc8>)
 800917e:	689a      	ldr	r2, [r3, #8]
 8009180:	6838      	ldr	r0, [r7, #0]
 8009182:	4633      	mov	r3, r6
 8009184:	3a01      	subs	r2, #1
 8009186:	9400      	str	r4, [sp, #0]
 8009188:	f44f 71a0 	mov.w	r1, #320	; 0x140
 800918c:	f7f8 fc90 	bl	8001ab0 <chThdCreateStatic>
 8009190:	f8d8 3010 	ldr.w	r3, [r8, #16]
 8009194:	4d25      	ldr	r5, [pc, #148]	; (800922c <bmk8_execute+0xcc>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8009196:	689a      	ldr	r2, [r3, #8]
 8009198:	687b      	ldr	r3, [r7, #4]
  uint32_t n;

  n = 0;
  test_wait_tick();

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 800919a:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 800919c:	3a01      	subs	r2, #1
 800919e:	9400      	str	r4, [sp, #0]
 80091a0:	4618      	mov	r0, r3
 80091a2:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80091a6:	4633      	mov	r3, r6
 80091a8:	f7f8 fc82 	bl	8001ab0 <chThdCreateStatic>
 80091ac:	f8d8 2010 	ldr.w	r2, [r8, #16]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 80091b0:	68bb      	ldr	r3, [r7, #8]
 80091b2:	6892      	ldr	r2, [r2, #8]
 80091b4:	f44f 71a0 	mov.w	r1, #320	; 0x140

  n = 0;
  test_wait_tick();

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 80091b8:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 80091ba:	3a01      	subs	r2, #1
 80091bc:	9400      	str	r4, [sp, #0]
 80091be:	4618      	mov	r0, r3
 80091c0:	4633      	mov	r3, r6
 80091c2:	f7f8 fc75 	bl	8001ab0 <chThdCreateStatic>
 80091c6:	f8d8 2010 	ldr.w	r2, [r8, #16]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 80091ca:	68fb      	ldr	r3, [r7, #12]
 80091cc:	6892      	ldr	r2, [r2, #8]
 80091ce:	f44f 71a0 	mov.w	r1, #320	; 0x140
  n = 0;
  test_wait_tick();

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 80091d2:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 80091d4:	3a01      	subs	r2, #1
 80091d6:	9400      	str	r4, [sp, #0]
 80091d8:	4618      	mov	r0, r3
 80091da:	4633      	mov	r3, r6
 80091dc:	f7f8 fc68 	bl	8001ab0 <chThdCreateStatic>
 80091e0:	f8d8 2010 	ldr.w	r2, [r8, #16]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 80091e4:	693b      	ldr	r3, [r7, #16]
 80091e6:	6892      	ldr	r2, [r2, #8]
 80091e8:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80091ec:	3a01      	subs	r2, #1
  test_wait_tick();

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 80091ee:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 80091f0:	9400      	str	r4, [sp, #0]
 80091f2:	4618      	mov	r0, r3
 80091f4:	4633      	mov	r3, r6
 80091f6:	f7f8 fc5b 	bl	8001ab0 <chThdCreateStatic>
 80091fa:	6128      	str	r0, [r5, #16]

  chThdSleepSeconds(1);
 80091fc:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8009200:	f7f8 fcc6 	bl	8001b90 <chThdSleep>
  test_terminate_threads();
 8009204:	f7fc fe44 	bl	8005e90 <test_terminate_threads>
  test_wait_threads();
 8009208:	f7fc fe52 	bl	8005eb0 <test_wait_threads>

  test_print("--- Score : ");
 800920c:	4808      	ldr	r0, [pc, #32]	; (8009230 <bmk8_execute+0xd0>)
 800920e:	f7fc fd8f 	bl	8005d30 <test_print>
  test_printn(n);
 8009212:	9803      	ldr	r0, [sp, #12]
 8009214:	f7fc fd5c 	bl	8005cd0 <test_printn>
  test_println(" ctxswc/S");
 8009218:	4806      	ldr	r0, [pc, #24]	; (8009234 <bmk8_execute+0xd4>)
 800921a:	f7fc fd99 	bl	8005d50 <test_println>
}
 800921e:	b004      	add	sp, #16
 8009220:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009224:	0800d790 	.word	0x0800d790
 8009228:	08009241 	.word	0x08009241
 800922c:	20001c58 	.word	0x20001c58
 8009230:	0800e128 	.word	0x0800e128
 8009234:	0800e150 	.word	0x0800e150
 8009238:	20001160 	.word	0x20001160
 800923c:	00000000 	.word	0x00000000

08009240 <thread8>:
 * variable and yields.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread8, p) {
 8009240:	b538      	push	{r3, r4, r5, lr}
 8009242:	4604      	mov	r4, r0
 8009244:	4d08      	ldr	r5, [pc, #32]	; (8009268 <thread8+0x28>)

  do {
    chThdYield();
 8009246:	f7f8 fccb 	bl	8001be0 <chThdYield>
    chThdYield();
 800924a:	f7f8 fcc9 	bl	8001be0 <chThdYield>
    chThdYield();
 800924e:	f7f8 fcc7 	bl	8001be0 <chThdYield>
    chThdYield();
 8009252:	f7f8 fcc5 	bl	8001be0 <chThdYield>
    (*(uint32_t *)p) += 4;
 8009256:	6823      	ldr	r3, [r4, #0]
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8009258:	692a      	ldr	r2, [r5, #16]
 800925a:	3304      	adds	r3, #4
 800925c:	6023      	str	r3, [r4, #0]
 800925e:	7c53      	ldrb	r3, [r2, #17]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
 8009260:	075b      	lsls	r3, r3, #29
 8009262:	d5f0      	bpl.n	8009246 <thread8+0x6>
}
 8009264:	bd38      	pop	{r3, r4, r5, pc}
 8009266:	bf00      	nop
 8009268:	20001160 	.word	0x20001160
 800926c:	00000000 	.word	0x00000000

08009270 <bmk9_execute>:
static void bmk9_execute(void) {
  uint32_t n;
  static uint8_t ib[16];
  static input_queue_t iq;

  chIQObjectInit(&iq, ib, sizeof(ib), NULL, NULL);
 8009270:	2300      	movs	r3, #0
 * loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk9_execute(void) {
 8009272:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t n;
  static uint8_t ib[16];
  static input_queue_t iq;

  chIQObjectInit(&iq, ib, sizeof(ib), NULL, NULL);
  n = 0;
 8009274:	461c      	mov	r4, r3
 * loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk9_execute(void) {
 8009276:	b083      	sub	sp, #12
  uint32_t n;
  static uint8_t ib[16];
  static input_queue_t iq;

  chIQObjectInit(&iq, ib, sizeof(ib), NULL, NULL);
 8009278:	9300      	str	r3, [sp, #0]
 800927a:	4923      	ldr	r1, [pc, #140]	; (8009308 <bmk9_execute+0x98>)
 800927c:	2210      	movs	r2, #16
 800927e:	4823      	ldr	r0, [pc, #140]	; (800930c <bmk9_execute+0x9c>)
 8009280:	f7f9 fc36 	bl	8002af0 <chIQObjectInit>
  n = 0;
  test_wait_tick();
 8009284:	f7fc fe2c 	bl	8005ee0 <test_wait_tick>
  test_start_timer(1000);
 8009288:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  do {
    chSysLock();
    chIQPutI(&iq, 0);
 800928c:	4627      	mov	r7, r4
  static input_queue_t iq;

  chIQObjectInit(&iq, ib, sizeof(ib), NULL, NULL);
  n = 0;
  test_wait_tick();
  test_start_timer(1000);
 800928e:	f7fc fe37 	bl	8005f00 <test_start_timer>
 8009292:	4e1f      	ldr	r6, [pc, #124]	; (8009310 <bmk9_execute+0xa0>)
 8009294:	2520      	movs	r5, #32
 8009296:	f385 8811 	msr	BASEPRI, r5
  do {
    chSysLock();
    chIQPutI(&iq, 0);
 800929a:	2100      	movs	r1, #0
 800929c:	481b      	ldr	r0, [pc, #108]	; (800930c <bmk9_execute+0x9c>)
 800929e:	f7f9 fc47 	bl	8002b30 <chIQPutI>
    chIQPutI(&iq, 1);
 80092a2:	2101      	movs	r1, #1
 80092a4:	4819      	ldr	r0, [pc, #100]	; (800930c <bmk9_execute+0x9c>)
 80092a6:	f7f9 fc43 	bl	8002b30 <chIQPutI>
    chIQPutI(&iq, 2);
 80092aa:	2102      	movs	r1, #2
 80092ac:	4817      	ldr	r0, [pc, #92]	; (800930c <bmk9_execute+0x9c>)
 80092ae:	f7f9 fc3f 	bl	8002b30 <chIQPutI>
    chIQPutI(&iq, 3);
 80092b2:	2103      	movs	r1, #3
 80092b4:	4815      	ldr	r0, [pc, #84]	; (800930c <bmk9_execute+0x9c>)
 80092b6:	f7f9 fc3b 	bl	8002b30 <chIQPutI>
 80092ba:	f387 8811 	msr	BASEPRI, r7
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {

  return chIQGetTimeout(iqp, TIME_INFINITE);
 80092be:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80092c2:	4812      	ldr	r0, [pc, #72]	; (800930c <bmk9_execute+0x9c>)
 80092c4:	f7f9 fc54 	bl	8002b70 <chIQGetTimeout>
 80092c8:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80092cc:	480f      	ldr	r0, [pc, #60]	; (800930c <bmk9_execute+0x9c>)
 80092ce:	f7f9 fc4f 	bl	8002b70 <chIQGetTimeout>
 80092d2:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80092d6:	480d      	ldr	r0, [pc, #52]	; (800930c <bmk9_execute+0x9c>)
 80092d8:	f7f9 fc4a 	bl	8002b70 <chIQGetTimeout>
 80092dc:	480b      	ldr	r0, [pc, #44]	; (800930c <bmk9_execute+0x9c>)
 80092de:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80092e2:	f7f9 fc45 	bl	8002b70 <chIQGetTimeout>
    (void)chIQGet(&iq);
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80092e6:	7833      	ldrb	r3, [r6, #0]
    chSysUnlock();
    (void)chIQGet(&iq);
    (void)chIQGet(&iq);
    (void)chIQGet(&iq);
    (void)chIQGet(&iq);
    n++;
 80092e8:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80092ea:	2b00      	cmp	r3, #0
 80092ec:	d0d3      	beq.n	8009296 <bmk9_execute+0x26>
  test_print("--- Score : ");
 80092ee:	4809      	ldr	r0, [pc, #36]	; (8009314 <bmk9_execute+0xa4>)
 80092f0:	f7fc fd1e 	bl	8005d30 <test_print>
  test_printn(n * 4);
 80092f4:	00a0      	lsls	r0, r4, #2
 80092f6:	f7fc fceb 	bl	8005cd0 <test_printn>
  test_println(" bytes/S");
 80092fa:	4807      	ldr	r0, [pc, #28]	; (8009318 <bmk9_execute+0xa8>)
}
 80092fc:	b003      	add	sp, #12
 80092fe:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n * 4);
  test_println(" bytes/S");
 8009302:	f7fc bd25 	b.w	8005d50 <test_println>
 8009306:	bf00      	nop
 8009308:	20001cec 	.word	0x20001cec
 800930c:	20001d20 	.word	0x20001d20
 8009310:	20001c3d 	.word	0x20001c3d
 8009314:	0800e128 	.word	0x0800e128
 8009318:	0800e170 	.word	0x0800e170
 800931c:	00000000 	.word	0x00000000

08009320 <bmk10_execute>:
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}

static void bmk10_execute(void) {
 8009320:	b538      	push	{r3, r4, r5, lr}
  static virtual_timer_t vt1, vt2;
  uint32_t n = 0;

  test_wait_tick();
 8009322:	f7fc fddd 	bl	8005ee0 <test_wait_tick>
  test_start_timer(1000);
 8009326:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800932a:	f7fc fde9 	bl	8005f00 <test_start_timer>
 800932e:	4d15      	ldr	r5, [pc, #84]	; (8009384 <bmk10_execute+0x64>)

static void tmo(void *param) {(void)param;}

static void bmk10_execute(void) {
  static virtual_timer_t vt1, vt2;
  uint32_t n = 0;
 8009330:	2400      	movs	r4, #0
 8009332:	2320      	movs	r3, #32
 8009334:	f383 8811 	msr	BASEPRI, r3

  test_wait_tick();
  test_start_timer(1000);
  do {
    chSysLock();
    chVTDoSetI(&vt1, 1, tmo, NULL);
 8009338:	4813      	ldr	r0, [pc, #76]	; (8009388 <bmk10_execute+0x68>)
 800933a:	2101      	movs	r1, #1
 800933c:	4a13      	ldr	r2, [pc, #76]	; (800938c <bmk10_execute+0x6c>)
 800933e:	2300      	movs	r3, #0
 8009340:	f7f8 fa0e 	bl	8001760 <chVTDoSetI>
    chVTDoSetI(&vt2, 10000, tmo, NULL);
 8009344:	f242 7110 	movw	r1, #10000	; 0x2710
 8009348:	4a10      	ldr	r2, [pc, #64]	; (800938c <bmk10_execute+0x6c>)
 800934a:	2300      	movs	r3, #0
 800934c:	4810      	ldr	r0, [pc, #64]	; (8009390 <bmk10_execute+0x70>)
 800934e:	f7f8 fa07 	bl	8001760 <chVTDoSetI>
    chVTDoResetI(&vt1);
 8009352:	480d      	ldr	r0, [pc, #52]	; (8009388 <bmk10_execute+0x68>)
 8009354:	f7f8 fa24 	bl	80017a0 <chVTDoResetI>
    chVTDoResetI(&vt2);
 8009358:	480d      	ldr	r0, [pc, #52]	; (8009390 <bmk10_execute+0x70>)
 800935a:	f7f8 fa21 	bl	80017a0 <chVTDoResetI>
 800935e:	2300      	movs	r3, #0
 8009360:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8009364:	782b      	ldrb	r3, [r5, #0]
    chVTDoSetI(&vt1, 1, tmo, NULL);
    chVTDoSetI(&vt2, 10000, tmo, NULL);
    chVTDoResetI(&vt1);
    chVTDoResetI(&vt2);
    chSysUnlock();
    n++;
 8009366:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8009368:	2b00      	cmp	r3, #0
 800936a:	d0e2      	beq.n	8009332 <bmk10_execute+0x12>
  test_print("--- Score : ");
 800936c:	4809      	ldr	r0, [pc, #36]	; (8009394 <bmk10_execute+0x74>)
 800936e:	f7fc fcdf 	bl	8005d30 <test_print>
  test_printn(n * 2);
 8009372:	0060      	lsls	r0, r4, #1
 8009374:	f7fc fcac 	bl	8005cd0 <test_printn>
  test_println(" timers/S");
}
 8009378:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n * 2);
  test_println(" timers/S");
 800937c:	4806      	ldr	r0, [pc, #24]	; (8009398 <bmk10_execute+0x78>)
 800937e:	f7fc bce7 	b.w	8005d50 <test_println>
 8009382:	bf00      	nop
 8009384:	20001c3d 	.word	0x20001c3d
 8009388:	20001cfc 	.word	0x20001cfc
 800938c:	08008b01 	.word	0x08008b01
 8009390:	20001cd8 	.word	0x20001cd8
 8009394:	0800e128 	.word	0x0800e128
 8009398:	0800e17c 	.word	0x0800e17c
 800939c:	00000000 	.word	0x00000000

080093a0 <bmk11_execute>:
static void bmk11_setup(void) {

  chSemObjectInit(&sem1, 1);
}

static void bmk11_execute(void) {
 80093a0:	b538      	push	{r3, r4, r5, lr}
  uint32_t n = 0;

  test_wait_tick();
 80093a2:	f7fc fd9d 	bl	8005ee0 <test_wait_tick>
  test_start_timer(1000);
 80093a6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80093aa:	f7fc fda9 	bl	8005f00 <test_start_timer>
 80093ae:	4d14      	ldr	r5, [pc, #80]	; (8009400 <bmk11_execute+0x60>)

  chSemObjectInit(&sem1, 1);
}

static void bmk11_execute(void) {
  uint32_t n = 0;
 80093b0:	2400      	movs	r4, #0

  test_wait_tick();
  test_start_timer(1000);
  do {
    chSemWait(&sem1);
 80093b2:	4814      	ldr	r0, [pc, #80]	; (8009404 <bmk11_execute+0x64>)
 80093b4:	f7f8 fdb4 	bl	8001f20 <chSemWait>
    chSemSignal(&sem1);
 80093b8:	4812      	ldr	r0, [pc, #72]	; (8009404 <bmk11_execute+0x64>)
 80093ba:	f7f8 fe09 	bl	8001fd0 <chSemSignal>
    chSemWait(&sem1);
 80093be:	4811      	ldr	r0, [pc, #68]	; (8009404 <bmk11_execute+0x64>)
 80093c0:	f7f8 fdae 	bl	8001f20 <chSemWait>
    chSemSignal(&sem1);
 80093c4:	480f      	ldr	r0, [pc, #60]	; (8009404 <bmk11_execute+0x64>)
 80093c6:	f7f8 fe03 	bl	8001fd0 <chSemSignal>
    chSemWait(&sem1);
 80093ca:	480e      	ldr	r0, [pc, #56]	; (8009404 <bmk11_execute+0x64>)
 80093cc:	f7f8 fda8 	bl	8001f20 <chSemWait>
    chSemSignal(&sem1);
 80093d0:	480c      	ldr	r0, [pc, #48]	; (8009404 <bmk11_execute+0x64>)
 80093d2:	f7f8 fdfd 	bl	8001fd0 <chSemSignal>
    chSemWait(&sem1);
 80093d6:	480b      	ldr	r0, [pc, #44]	; (8009404 <bmk11_execute+0x64>)
 80093d8:	f7f8 fda2 	bl	8001f20 <chSemWait>
    chSemSignal(&sem1);
 80093dc:	4809      	ldr	r0, [pc, #36]	; (8009404 <bmk11_execute+0x64>)
 80093de:	f7f8 fdf7 	bl	8001fd0 <chSemSignal>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80093e2:	782b      	ldrb	r3, [r5, #0]
    chSemSignal(&sem1);
    chSemWait(&sem1);
    chSemSignal(&sem1);
    chSemWait(&sem1);
    chSemSignal(&sem1);
    n++;
 80093e4:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80093e6:	2b00      	cmp	r3, #0
 80093e8:	d0e3      	beq.n	80093b2 <bmk11_execute+0x12>
  test_print("--- Score : ");
 80093ea:	4807      	ldr	r0, [pc, #28]	; (8009408 <bmk11_execute+0x68>)
 80093ec:	f7fc fca0 	bl	8005d30 <test_print>
  test_printn(n * 4);
 80093f0:	00a0      	lsls	r0, r4, #2
 80093f2:	f7fc fc6d 	bl	8005cd0 <test_printn>
  test_println(" wait+signal/S");
}
 80093f6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n * 4);
  test_println(" wait+signal/S");
 80093fa:	4804      	ldr	r0, [pc, #16]	; (800940c <bmk11_execute+0x6c>)
 80093fc:	f7fc bca8 	b.w	8005d50 <test_println>
 8009400:	20001c3d 	.word	0x20001c3d
 8009404:	20001d44 	.word	0x20001d44
 8009408:	0800e128 	.word	0x0800e128
 800940c:	0800e188 	.word	0x0800e188

08009410 <bmk12_execute>:
static void bmk12_setup(void) {

  chMtxObjectInit(&mtx1);
}

static void bmk12_execute(void) {
 8009410:	b538      	push	{r3, r4, r5, lr}
  uint32_t n = 0;

  test_wait_tick();
 8009412:	f7fc fd65 	bl	8005ee0 <test_wait_tick>
  test_start_timer(1000);
 8009416:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800941a:	f7fc fd71 	bl	8005f00 <test_start_timer>
 800941e:	4d14      	ldr	r5, [pc, #80]	; (8009470 <bmk12_execute+0x60>)

  chMtxObjectInit(&mtx1);
}

static void bmk12_execute(void) {
  uint32_t n = 0;
 8009420:	2400      	movs	r4, #0

  test_wait_tick();
  test_start_timer(1000);
  do {
    chMtxLock(&mtx1);
 8009422:	4814      	ldr	r0, [pc, #80]	; (8009474 <bmk12_execute+0x64>)
 8009424:	f7f8 fecc 	bl	80021c0 <chMtxLock>
    chMtxUnlock(&mtx1);
 8009428:	4812      	ldr	r0, [pc, #72]	; (8009474 <bmk12_execute+0x64>)
 800942a:	f7f8 fef1 	bl	8002210 <chMtxUnlock>
    chMtxLock(&mtx1);
 800942e:	4811      	ldr	r0, [pc, #68]	; (8009474 <bmk12_execute+0x64>)
 8009430:	f7f8 fec6 	bl	80021c0 <chMtxLock>
    chMtxUnlock(&mtx1);
 8009434:	480f      	ldr	r0, [pc, #60]	; (8009474 <bmk12_execute+0x64>)
 8009436:	f7f8 feeb 	bl	8002210 <chMtxUnlock>
    chMtxLock(&mtx1);
 800943a:	480e      	ldr	r0, [pc, #56]	; (8009474 <bmk12_execute+0x64>)
 800943c:	f7f8 fec0 	bl	80021c0 <chMtxLock>
    chMtxUnlock(&mtx1);
 8009440:	480c      	ldr	r0, [pc, #48]	; (8009474 <bmk12_execute+0x64>)
 8009442:	f7f8 fee5 	bl	8002210 <chMtxUnlock>
    chMtxLock(&mtx1);
 8009446:	480b      	ldr	r0, [pc, #44]	; (8009474 <bmk12_execute+0x64>)
 8009448:	f7f8 feba 	bl	80021c0 <chMtxLock>
    chMtxUnlock(&mtx1);
 800944c:	4809      	ldr	r0, [pc, #36]	; (8009474 <bmk12_execute+0x64>)
 800944e:	f7f8 fedf 	bl	8002210 <chMtxUnlock>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8009452:	782b      	ldrb	r3, [r5, #0]
    chMtxUnlock(&mtx1);
    chMtxLock(&mtx1);
    chMtxUnlock(&mtx1);
    chMtxLock(&mtx1);
    chMtxUnlock(&mtx1);
    n++;
 8009454:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8009456:	2b00      	cmp	r3, #0
 8009458:	d0e3      	beq.n	8009422 <bmk12_execute+0x12>
  test_print("--- Score : ");
 800945a:	4807      	ldr	r0, [pc, #28]	; (8009478 <bmk12_execute+0x68>)
 800945c:	f7fc fc68 	bl	8005d30 <test_print>
  test_printn(n * 4);
 8009460:	00a0      	lsls	r0, r4, #2
 8009462:	f7fc fc35 	bl	8005cd0 <test_printn>
  test_println(" lock+unlock/S");
}
 8009466:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
  test_print("--- Score : ");
  test_printn(n * 4);
  test_println(" lock+unlock/S");
 800946a:	4804      	ldr	r0, [pc, #16]	; (800947c <bmk12_execute+0x6c>)
 800946c:	f7fc bc70 	b.w	8005d50 <test_println>
 8009470:	20001c3d 	.word	0x20001c3d
 8009474:	20001d10 	.word	0x20001d10
 8009478:	0800e128 	.word	0x0800e128
 800947c:	0800e198 	.word	0x0800e198

08009480 <bmk12_setup>:
 * a second of continuous operations.
 */

static void bmk12_setup(void) {

  chMtxObjectInit(&mtx1);
 8009480:	4801      	ldr	r0, [pc, #4]	; (8009488 <bmk12_setup+0x8>)
 8009482:	f7f8 be2d 	b.w	80020e0 <chMtxObjectInit>
 8009486:	bf00      	nop
 8009488:	20001d10 	.word	0x20001d10
 800948c:	00000000 	.word	0x00000000

08009490 <cmd_systime>:
}

static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 8009490:	2900      	cmp	r1, #0
 8009492:	dd03      	ble.n	800949c <cmd_systime+0xc>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 8009494:	4907      	ldr	r1, [pc, #28]	; (80094b4 <cmd_systime+0x24>)
 8009496:	4a08      	ldr	r2, [pc, #32]	; (80094b8 <cmd_systime+0x28>)
 8009498:	f000 bc12 	b.w	8009cc0 <chprintf>
 800949c:	2320      	movs	r3, #32
 800949e:	f383 8811 	msr	BASEPRI, r3
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 80094a2:	4a06      	ldr	r2, [pc, #24]	; (80094bc <cmd_systime+0x2c>)
 80094a4:	2300      	movs	r3, #0
 80094a6:	8bd2      	ldrh	r2, [r2, #30]
 80094a8:	b292      	uxth	r2, r2
 80094aa:	f383 8811 	msr	BASEPRI, r3
  (void)argv;
  if (argc > 0) {
    usage(chp, "systime");
    return;
  }
  chprintf(chp, "%lu\r\n", (unsigned long)chVTGetSystemTime());
 80094ae:	4904      	ldr	r1, [pc, #16]	; (80094c0 <cmd_systime+0x30>)
 80094b0:	f000 bc06 	b.w	8009cc0 <chprintf>
 80094b4:	0800e3d0 	.word	0x0800e3d0
 80094b8:	0800e3dc 	.word	0x0800e3dc
 80094bc:	20001160 	.word	0x20001160
 80094c0:	0800e3e4 	.word	0x0800e3e4
	...

080094d0 <cmd_info>:
}

static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 80094d0:	2900      	cmp	r1, #0
 80094d2:	dd03      	ble.n	80094dc <cmd_info+0xc>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 80094d4:	4919      	ldr	r1, [pc, #100]	; (800953c <cmd_info+0x6c>)
 80094d6:	4a1a      	ldr	r2, [pc, #104]	; (8009540 <cmd_info+0x70>)
 80094d8:	f000 bbf2 	b.w	8009cc0 <chprintf>
    chprintf(chp, "%s ", scp->sc_name);
    scp++;
  }
}

static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 80094dc:	b510      	push	{r4, lr}
 80094de:	4604      	mov	r4, r0
 80094e0:	b082      	sub	sp, #8
  if (argc > 0) {
    usage(chp, "info");
    return;
  }

  chprintf(chp, "Kernel:       %s\r\n", CH_KERNEL_VERSION);
 80094e2:	4918      	ldr	r1, [pc, #96]	; (8009544 <cmd_info+0x74>)
 80094e4:	4a18      	ldr	r2, [pc, #96]	; (8009548 <cmd_info+0x78>)
 80094e6:	f000 fbeb 	bl	8009cc0 <chprintf>
#ifdef PORT_COMPILER_NAME
  chprintf(chp, "Compiler:     %s\r\n", PORT_COMPILER_NAME);
 80094ea:	4620      	mov	r0, r4
 80094ec:	4917      	ldr	r1, [pc, #92]	; (800954c <cmd_info+0x7c>)
 80094ee:	4a18      	ldr	r2, [pc, #96]	; (8009550 <cmd_info+0x80>)
 80094f0:	f000 fbe6 	bl	8009cc0 <chprintf>
#endif
  chprintf(chp, "Architecture: %s\r\n", PORT_ARCHITECTURE_NAME);
 80094f4:	4620      	mov	r0, r4
 80094f6:	4917      	ldr	r1, [pc, #92]	; (8009554 <cmd_info+0x84>)
 80094f8:	4a17      	ldr	r2, [pc, #92]	; (8009558 <cmd_info+0x88>)
 80094fa:	f000 fbe1 	bl	8009cc0 <chprintf>
#ifdef PORT_CORE_VARIANT_NAME
  chprintf(chp, "Core Variant: %s\r\n", PORT_CORE_VARIANT_NAME);
 80094fe:	4620      	mov	r0, r4
 8009500:	4916      	ldr	r1, [pc, #88]	; (800955c <cmd_info+0x8c>)
 8009502:	4a17      	ldr	r2, [pc, #92]	; (8009560 <cmd_info+0x90>)
 8009504:	f000 fbdc 	bl	8009cc0 <chprintf>
#endif
#ifdef PORT_INFO
  chprintf(chp, "Port Info:    %s\r\n", PORT_INFO);
 8009508:	4620      	mov	r0, r4
 800950a:	4916      	ldr	r1, [pc, #88]	; (8009564 <cmd_info+0x94>)
 800950c:	4a16      	ldr	r2, [pc, #88]	; (8009568 <cmd_info+0x98>)
 800950e:	f000 fbd7 	bl	8009cc0 <chprintf>
#endif
#ifdef PLATFORM_NAME
  chprintf(chp, "Platform:     %s\r\n", PLATFORM_NAME);
 8009512:	4620      	mov	r0, r4
 8009514:	4915      	ldr	r1, [pc, #84]	; (800956c <cmd_info+0x9c>)
 8009516:	4a16      	ldr	r2, [pc, #88]	; (8009570 <cmd_info+0xa0>)
 8009518:	f000 fbd2 	bl	8009cc0 <chprintf>
#endif
#ifdef BOARD_NAME
  chprintf(chp, "Board:        %s\r\n", BOARD_NAME);
 800951c:	4620      	mov	r0, r4
 800951e:	4915      	ldr	r1, [pc, #84]	; (8009574 <cmd_info+0xa4>)
 8009520:	4a15      	ldr	r2, [pc, #84]	; (8009578 <cmd_info+0xa8>)
 8009522:	f000 fbcd 	bl	8009cc0 <chprintf>
#endif
#ifdef __DATE__
#ifdef __TIME__
  chprintf(chp, "Build time:   %s%s%s\r\n", __DATE__, " - ", __TIME__);
 8009526:	4b15      	ldr	r3, [pc, #84]	; (800957c <cmd_info+0xac>)
 8009528:	4620      	mov	r0, r4
 800952a:	9300      	str	r3, [sp, #0]
 800952c:	4914      	ldr	r1, [pc, #80]	; (8009580 <cmd_info+0xb0>)
 800952e:	4a15      	ldr	r2, [pc, #84]	; (8009584 <cmd_info+0xb4>)
 8009530:	4b15      	ldr	r3, [pc, #84]	; (8009588 <cmd_info+0xb8>)
 8009532:	f000 fbc5 	bl	8009cc0 <chprintf>
#endif
#endif
}
 8009536:	b002      	add	sp, #8
 8009538:	bd10      	pop	{r4, pc}
 800953a:	bf00      	nop
 800953c:	0800e3d0 	.word	0x0800e3d0
 8009540:	0800e3ec 	.word	0x0800e3ec
 8009544:	0800e3f4 	.word	0x0800e3f4
 8009548:	0800d914 	.word	0x0800d914
 800954c:	0800e408 	.word	0x0800e408
 8009550:	0800d934 	.word	0x0800d934
 8009554:	0800e41c 	.word	0x0800e41c
 8009558:	0800d97c 	.word	0x0800d97c
 800955c:	0800e430 	.word	0x0800e430
 8009560:	0800d984 	.word	0x0800d984
 8009564:	0800e444 	.word	0x0800e444
 8009568:	0800d990 	.word	0x0800d990
 800956c:	0800e458 	.word	0x0800e458
 8009570:	0800d9a8 	.word	0x0800d9a8
 8009574:	0800e46c 	.word	0x0800e46c
 8009578:	0800d9d0 	.word	0x0800d9d0
 800957c:	0800e4a8 	.word	0x0800e4a8
 8009580:	0800e480 	.word	0x0800e480
 8009584:	0800e498 	.word	0x0800e498
 8009588:	0800e4a4 	.word	0x0800e4a4
 800958c:	00000000 	.word	0x00000000

08009590 <_strtok.constprop.3>:
/**
 * @brief   Shell termination event source.
 */
event_source_t shell_terminated;

static char *_strtok(char *str, const char *delim, char **saveptr) {
 8009590:	b538      	push	{r3, r4, r5, lr}
 8009592:	460d      	mov	r5, r1
  char *token;
  if (str)
 8009594:	4604      	mov	r4, r0
 8009596:	b190      	cbz	r0, 80095be <_strtok.constprop.3+0x2e>
    *saveptr = str;
 8009598:	6028      	str	r0, [r5, #0]
  token = *saveptr;

  if (!token)
    return NULL;

  token += strspn(token, delim);
 800959a:	4620      	mov	r0, r4
 800959c:	490b      	ldr	r1, [pc, #44]	; (80095cc <_strtok.constprop.3+0x3c>)
 800959e:	f003 ff7f 	bl	800d4a0 <strspn>
 80095a2:	4404      	add	r4, r0
  *saveptr = strpbrk(token, delim);
 80095a4:	4620      	mov	r0, r4
 80095a6:	4909      	ldr	r1, [pc, #36]	; (80095cc <_strtok.constprop.3+0x3c>)
 80095a8:	f003 ff52 	bl	800d450 <strpbrk>
  if (*saveptr)
 80095ac:	b160      	cbz	r0, 80095c8 <_strtok.constprop.3+0x38>
    *(*saveptr)++ = '\0';
 80095ae:	1c42      	adds	r2, r0, #1
 80095b0:	2300      	movs	r3, #0
 80095b2:	602a      	str	r2, [r5, #0]
 80095b4:	7003      	strb	r3, [r0, #0]

  return *token ? token : NULL;
 80095b6:	7823      	ldrb	r3, [r4, #0]
 80095b8:	b123      	cbz	r3, 80095c4 <_strtok.constprop.3+0x34>
 80095ba:	4620      	mov	r0, r4
}
 80095bc:	bd38      	pop	{r3, r4, r5, pc}

static char *_strtok(char *str, const char *delim, char **saveptr) {
  char *token;
  if (str)
    *saveptr = str;
  token = *saveptr;
 80095be:	680c      	ldr	r4, [r1, #0]

  if (!token)
 80095c0:	2c00      	cmp	r4, #0
 80095c2:	d1ea      	bne.n	800959a <_strtok.constprop.3+0xa>
    return NULL;
 80095c4:	2000      	movs	r0, #0
 80095c6:	bd38      	pop	{r3, r4, r5, pc}

  token += strspn(token, delim);
  *saveptr = strpbrk(token, delim);
 80095c8:	6028      	str	r0, [r5, #0]
 80095ca:	e7f4      	b.n	80095b6 <_strtok.constprop.3+0x26>
 80095cc:	0800e4b4 	.word	0x0800e4b4

080095d0 <shellInit>:
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 80095d0:	4b01      	ldr	r3, [pc, #4]	; (80095d8 <shellInit+0x8>)
 80095d2:	601b      	str	r3, [r3, #0]
 80095d4:	4770      	bx	lr
 80095d6:	bf00      	nop
 80095d8:	20001d50 	.word	0x20001d50
 80095dc:	00000000 	.word	0x00000000

080095e0 <shellExit>:
 *
 * @param[in] msg       shell exit code
 *
 * @api
 */
void shellExit(msg_t msg) {
 80095e0:	b510      	push	{r4, lr}
 80095e2:	2320      	movs	r3, #32
 80095e4:	4604      	mov	r4, r0
 80095e6:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 80095ea:	4804      	ldr	r0, [pc, #16]	; (80095fc <shellExit+0x1c>)
 80095ec:	2100      	movs	r1, #0
 80095ee:	f7f8 ffd7 	bl	80025a0 <chEvtBroadcastFlagsI>

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
  chEvtBroadcastI(&shell_terminated);
  chThdExitS(msg);
 80095f2:	4620      	mov	r0, r4
}
 80095f4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
  chEvtBroadcastI(&shell_terminated);
  chThdExitS(msg);
 80095f8:	f7f8 bb0a 	b.w	8001c10 <chThdExitS>
 80095fc:	20001d50 	.word	0x20001d50

08009600 <shellCreate>:
 * @retval NULL         thread creation failed because memory allocation.
 *
 * @api
 */
#if CH_CFG_USE_HEAP && CH_CFG_USE_DYNAMIC
thread_t *shellCreate(const ShellConfig *scp, size_t size, tprio_t prio) {
 8009600:	b500      	push	{lr}
 8009602:	b083      	sub	sp, #12

  return chThdCreateFromHeap(NULL, size, prio, shell_thread, (void *)scp);
 8009604:	9000      	str	r0, [sp, #0]
 8009606:	4b03      	ldr	r3, [pc, #12]	; (8009614 <shellCreate+0x14>)
 8009608:	2000      	movs	r0, #0
 800960a:	f7f8 fc11 	bl	8001e30 <chThdCreateFromHeap>
}
 800960e:	b003      	add	sp, #12
 8009610:	f85d fb04 	ldr.w	pc, [sp], #4
 8009614:	080096c1 	.word	0x080096c1
	...

08009620 <shellGetLine>:
 * @retval true         the channel was reset or CTRL-D pressed.
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(BaseSequentialStream *chp, char *line, unsigned size) {
 8009620:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009622:	460e      	mov	r6, r1
 8009624:	4604      	mov	r4, r0
 8009626:	460d      	mov	r5, r1
      *p = 0;
      return false;
    }
    if (c < 0x20)
      continue;
    if (p < line + size - 1) {
 8009628:	3a01      	subs	r2, #1
 * @retval true         the channel was reset or CTRL-D pressed.
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(BaseSequentialStream *chp, char *line, unsigned size) {
 800962a:	b083      	sub	sp, #12
      *p = 0;
      return false;
    }
    if (c < 0x20)
      continue;
    if (p < line + size - 1) {
 800962c:	188f      	adds	r7, r1, r2
  char *p = line;

  while (true) {
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
 800962e:	6823      	ldr	r3, [r4, #0]
 8009630:	4620      	mov	r0, r4
 8009632:	685b      	ldr	r3, [r3, #4]
 8009634:	f10d 0107 	add.w	r1, sp, #7
 8009638:	2201      	movs	r2, #1
 800963a:	4798      	blx	r3
 800963c:	b350      	cbz	r0, 8009694 <shellGetLine+0x74>
      return true;
    if (c == 4) {
 800963e:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8009642:	2904      	cmp	r1, #4
 8009644:	d029      	beq.n	800969a <shellGetLine+0x7a>
      chprintf(chp, "^D");
      return true;
    }
    if ((c == 8) || (c == 127)) {
 8009646:	2908      	cmp	r1, #8
 8009648:	d011      	beq.n	800966e <shellGetLine+0x4e>
 800964a:	297f      	cmp	r1, #127	; 0x7f
 800964c:	d00f      	beq.n	800966e <shellGetLine+0x4e>
        chSequentialStreamPut(chp, c);
        p--;
      }
      continue;
    }
    if (c == '\r') {
 800964e:	290d      	cmp	r1, #13
 8009650:	d02a      	beq.n	80096a8 <shellGetLine+0x88>
      chprintf(chp, "\r\n");
      *p = 0;
      return false;
    }
    if (c < 0x20)
 8009652:	291f      	cmp	r1, #31
 8009654:	d9eb      	bls.n	800962e <shellGetLine+0xe>
      continue;
    if (p < line + size - 1) {
 8009656:	42bd      	cmp	r5, r7
 8009658:	d2e9      	bcs.n	800962e <shellGetLine+0xe>
      chSequentialStreamPut(chp, c);
 800965a:	6823      	ldr	r3, [r4, #0]
 800965c:	4620      	mov	r0, r4
 800965e:	689b      	ldr	r3, [r3, #8]
 8009660:	4798      	blx	r3
      *p++ = (char)c;
 8009662:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8009666:	3501      	adds	r5, #1
 8009668:	f805 3c01 	strb.w	r3, [r5, #-1]
 800966c:	e7df      	b.n	800962e <shellGetLine+0xe>
    if (c == 4) {
      chprintf(chp, "^D");
      return true;
    }
    if ((c == 8) || (c == 127)) {
      if (p != line) {
 800966e:	42b5      	cmp	r5, r6
 8009670:	d0dd      	beq.n	800962e <shellGetLine+0xe>
        chSequentialStreamPut(chp, c);
 8009672:	6823      	ldr	r3, [r4, #0]
 8009674:	4620      	mov	r0, r4
 8009676:	689b      	ldr	r3, [r3, #8]
 8009678:	4798      	blx	r3
        chSequentialStreamPut(chp, 0x20);
 800967a:	6823      	ldr	r3, [r4, #0]
 800967c:	4620      	mov	r0, r4
 800967e:	689b      	ldr	r3, [r3, #8]
 8009680:	2120      	movs	r1, #32
 8009682:	4798      	blx	r3
        chSequentialStreamPut(chp, c);
 8009684:	6823      	ldr	r3, [r4, #0]
 8009686:	4620      	mov	r0, r4
 8009688:	689b      	ldr	r3, [r3, #8]
 800968a:	f89d 1007 	ldrb.w	r1, [sp, #7]
        p--;
 800968e:	3d01      	subs	r5, #1
    }
    if ((c == 8) || (c == 127)) {
      if (p != line) {
        chSequentialStreamPut(chp, c);
        chSequentialStreamPut(chp, 0x20);
        chSequentialStreamPut(chp, c);
 8009690:	4798      	blx	r3
 8009692:	e7cc      	b.n	800962e <shellGetLine+0xe>

  while (true) {
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
      return true;
 8009694:	2001      	movs	r0, #1
    if (p < line + size - 1) {
      chSequentialStreamPut(chp, c);
      *p++ = (char)c;
    }
  }
}
 8009696:	b003      	add	sp, #12
 8009698:	bdf0      	pop	{r4, r5, r6, r7, pc}
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
      return true;
    if (c == 4) {
      chprintf(chp, "^D");
 800969a:	4620      	mov	r0, r4
 800969c:	4906      	ldr	r1, [pc, #24]	; (80096b8 <shellGetLine+0x98>)
 800969e:	f000 fb0f 	bl	8009cc0 <chprintf>
      return true;
 80096a2:	2001      	movs	r0, #1
    if (p < line + size - 1) {
      chSequentialStreamPut(chp, c);
      *p++ = (char)c;
    }
  }
}
 80096a4:	b003      	add	sp, #12
 80096a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
        p--;
      }
      continue;
    }
    if (c == '\r') {
      chprintf(chp, "\r\n");
 80096a8:	4620      	mov	r0, r4
 80096aa:	4904      	ldr	r1, [pc, #16]	; (80096bc <shellGetLine+0x9c>)
 80096ac:	f000 fb08 	bl	8009cc0 <chprintf>
      *p = 0;
 80096b0:	2000      	movs	r0, #0
 80096b2:	7028      	strb	r0, [r5, #0]
    if (p < line + size - 1) {
      chSequentialStreamPut(chp, c);
      *p++ = (char)c;
    }
  }
}
 80096b4:	b003      	add	sp, #12
 80096b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80096b8:	0800e4b8 	.word	0x0800e4b8
 80096bc:	0800e608 	.word	0x0800e608

080096c0 <shell_thread>:
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
static THD_FUNCTION(shell_thread, p) {
 80096c0:	4603      	mov	r3, r0
 80096c2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  int n;
  BaseSequentialStream *chp = ((ShellConfig *)p)->sc_channel;
 80096c6:	6806      	ldr	r6, [r0, #0]
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
static THD_FUNCTION(shell_thread, p) {
 80096c8:	b096      	sub	sp, #88	; 0x58
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
 80096ca:	4953      	ldr	r1, [pc, #332]	; (8009818 <shell_thread+0x158>)
 80096cc:	4630      	mov	r0, r6
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
static THD_FUNCTION(shell_thread, p) {
  int n;
  BaseSequentialStream *chp = ((ShellConfig *)p)->sc_channel;
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
 80096ce:	f8d3 8004 	ldr.w	r8, [r3, #4]
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
 80096d2:	f000 faf5 	bl	8009cc0 <chprintf>
  while (true) {
    chprintf(chp, "ch> ");
 80096d6:	4951      	ldr	r1, [pc, #324]	; (800981c <shell_thread+0x15c>)
 80096d8:	4630      	mov	r0, r6
 80096da:	f000 faf1 	bl	8009cc0 <chprintf>
    if (shellGetLine(chp, line, sizeof(line))) {
 80096de:	4630      	mov	r0, r6
 80096e0:	a906      	add	r1, sp, #24
 80096e2:	2240      	movs	r2, #64	; 0x40
 80096e4:	f7ff ff9c 	bl	8009620 <shellGetLine>
 80096e8:	4604      	mov	r4, r0
 80096ea:	bb78      	cbnz	r0, 800974c <shell_thread+0x8c>
      chprintf(chp, "\r\nlogout");
      break;
    }
    lp = _strtok(line, " \t", &tokp);
 80096ec:	4669      	mov	r1, sp
 80096ee:	a806      	add	r0, sp, #24
 80096f0:	f7ff ff4e 	bl	8009590 <_strtok.constprop.3>
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 80096f4:	4669      	mov	r1, sp
    chprintf(chp, "ch> ");
    if (shellGetLine(chp, line, sizeof(line))) {
      chprintf(chp, "\r\nlogout");
      break;
    }
    lp = _strtok(line, " \t", &tokp);
 80096f6:	4607      	mov	r7, r0
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 80096f8:	2000      	movs	r0, #0
 80096fa:	ad01      	add	r5, sp, #4
 80096fc:	f7ff ff48 	bl	8009590 <_strtok.constprop.3>
 8009700:	b150      	cbz	r0, 8009718 <shell_thread+0x58>
      if (n >= SHELL_MAX_ARGUMENTS) {
 8009702:	2c04      	cmp	r4, #4
 8009704:	d01b      	beq.n	800973e <shell_thread+0x7e>
        chprintf(chp, "too many arguments\r\n");
        cmd = NULL;
        break;
      }
      args[n++] = lp;
 8009706:	f845 0b04 	str.w	r0, [r5], #4
      break;
    }
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 800970a:	4669      	mov	r1, sp
 800970c:	2000      	movs	r0, #0
      if (n >= SHELL_MAX_ARGUMENTS) {
        chprintf(chp, "too many arguments\r\n");
        cmd = NULL;
        break;
      }
      args[n++] = lp;
 800970e:	3401      	adds	r4, #1
      break;
    }
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 8009710:	f7ff ff3e 	bl	8009590 <_strtok.constprop.3>
 8009714:	2800      	cmp	r0, #0
 8009716:	d1f4      	bne.n	8009702 <shell_thread+0x42>
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    }
    args[n] = NULL;
 8009718:	ab16      	add	r3, sp, #88	; 0x58
 800971a:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 800971e:	f843 0c54 	str.w	r0, [r3, #-84]
    if (cmd != NULL) {
 8009722:	2f00      	cmp	r7, #0
 8009724:	d0d7      	beq.n	80096d6 <shell_thread+0x16>
      if (strcmp(cmd, "exit") == 0) {
 8009726:	4638      	mov	r0, r7
 8009728:	493d      	ldr	r1, [pc, #244]	; (8009820 <shell_thread+0x160>)
 800972a:	f7f7 fe01 	bl	8001330 <strcmp>
 800972e:	b9b8      	cbnz	r0, 8009760 <shell_thread+0xa0>
        if (n > 0) {
 8009730:	b184      	cbz	r4, 8009754 <shell_thread+0x94>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 8009732:	4630      	mov	r0, r6
 8009734:	493b      	ldr	r1, [pc, #236]	; (8009824 <shell_thread+0x164>)
 8009736:	4a3a      	ldr	r2, [pc, #232]	; (8009820 <shell_thread+0x160>)
 8009738:	f000 fac2 	bl	8009cc0 <chprintf>
    args[n] = NULL;
    if (cmd != NULL) {
      if (strcmp(cmd, "exit") == 0) {
        if (n > 0) {
          usage(chp, "exit");
          continue;
 800973c:	e7cb      	b.n	80096d6 <shell_thread+0x16>
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
      if (n >= SHELL_MAX_ARGUMENTS) {
        chprintf(chp, "too many arguments\r\n");
 800973e:	4630      	mov	r0, r6
 8009740:	4939      	ldr	r1, [pc, #228]	; (8009828 <shell_thread+0x168>)
 8009742:	f000 fabd 	bl	8009cc0 <chprintf>
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    }
    args[n] = NULL;
 8009746:	2300      	movs	r3, #0
 8009748:	9305      	str	r3, [sp, #20]
 800974a:	e7c4      	b.n	80096d6 <shell_thread+0x16>
  chRegSetThreadName("shell");
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
  while (true) {
    chprintf(chp, "ch> ");
    if (shellGetLine(chp, line, sizeof(line))) {
      chprintf(chp, "\r\nlogout");
 800974c:	4630      	mov	r0, r6
 800974e:	4937      	ldr	r1, [pc, #220]	; (800982c <shell_thread+0x16c>)
 8009750:	f000 fab6 	bl	8009cc0 <chprintf>
        chprintf(chp, "%s", cmd);
        chprintf(chp, " ?\r\n");
      }
    }
  }
  shellExit(MSG_OK);
 8009754:	2000      	movs	r0, #0
 8009756:	f7ff ff43 	bl	80095e0 <shellExit>
}
 800975a:	b016      	add	sp, #88	; 0x58
 800975c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          usage(chp, "exit");
          continue;
        }
        break;
      }
      else if (strcmp(cmd, "help") == 0) {
 8009760:	4638      	mov	r0, r7
 8009762:	4933      	ldr	r1, [pc, #204]	; (8009830 <shell_thread+0x170>)
 8009764:	f7f7 fde4 	bl	8001330 <strcmp>
 8009768:	b930      	cbnz	r0, 8009778 <shell_thread+0xb8>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 800976a:	4630      	mov	r0, r6
          continue;
        }
        break;
      }
      else if (strcmp(cmd, "help") == 0) {
        if (n > 0) {
 800976c:	b1b4      	cbz	r4, 800979c <shell_thread+0xdc>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 800976e:	492d      	ldr	r1, [pc, #180]	; (8009824 <shell_thread+0x164>)
 8009770:	4a2f      	ldr	r2, [pc, #188]	; (8009830 <shell_thread+0x170>)
 8009772:	f000 faa5 	bl	8009cc0 <chprintf>
        break;
      }
      else if (strcmp(cmd, "help") == 0) {
        if (n > 0) {
          usage(chp, "help");
          continue;
 8009776:	e7ae      	b.n	80096d6 <shell_thread+0x16>
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
 8009778:	4d2e      	ldr	r5, [pc, #184]	; (8009834 <shell_thread+0x174>)
 800977a:	6828      	ldr	r0, [r5, #0]
 800977c:	b918      	cbnz	r0, 8009786 <shell_thread+0xc6>
 800977e:	e030      	b.n	80097e2 <shell_thread+0x122>
 8009780:	f855 0f08 	ldr.w	r0, [r5, #8]!
 8009784:	b368      	cbz	r0, 80097e2 <shell_thread+0x122>
    if (strcmp(scp->sc_name, name) == 0) {
 8009786:	4639      	mov	r1, r7
 8009788:	f7f7 fdd2 	bl	8001330 <strcmp>
 800978c:	2800      	cmp	r0, #0
 800978e:	d1f7      	bne.n	8009780 <shell_thread+0xc0>
      scp->sc_function(chp, argc, argv);
 8009790:	686b      	ldr	r3, [r5, #4]
 8009792:	4621      	mov	r1, r4
 8009794:	4630      	mov	r0, r6
 8009796:	aa01      	add	r2, sp, #4
 8009798:	4798      	blx	r3
 800979a:	e79c      	b.n	80096d6 <shell_thread+0x16>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 800979c:	4d25      	ldr	r5, [pc, #148]	; (8009834 <shell_thread+0x174>)
      else if (strcmp(cmd, "help") == 0) {
        if (n > 0) {
          usage(chp, "help");
          continue;
        }
        chprintf(chp, "Commands: help exit ");
 800979e:	4926      	ldr	r1, [pc, #152]	; (8009838 <shell_thread+0x178>)
 80097a0:	f000 fa8e 	bl	8009cc0 <chprintf>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 80097a4:	682a      	ldr	r2, [r5, #0]
 80097a6:	462c      	mov	r4, r5
 80097a8:	b13a      	cbz	r2, 80097ba <shell_thread+0xfa>
    chprintf(chp, "%s ", scp->sc_name);
 80097aa:	4630      	mov	r0, r6
 80097ac:	4923      	ldr	r1, [pc, #140]	; (800983c <shell_thread+0x17c>)
 80097ae:	f000 fa87 	bl	8009cc0 <chprintf>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 80097b2:	f854 2f08 	ldr.w	r2, [r4, #8]!
 80097b6:	2a00      	cmp	r2, #0
 80097b8:	d1f7      	bne.n	80097aa <shell_thread+0xea>
          usage(chp, "help");
          continue;
        }
        chprintf(chp, "Commands: help exit ");
        list_commands(chp, local_commands);
        if (scp != NULL)
 80097ba:	f1b8 0f00 	cmp.w	r8, #0
 80097be:	d00b      	beq.n	80097d8 <shell_thread+0x118>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 80097c0:	f8d8 2000 	ldr.w	r2, [r8]
 80097c4:	b142      	cbz	r2, 80097d8 <shell_thread+0x118>
 80097c6:	4644      	mov	r4, r8
    chprintf(chp, "%s ", scp->sc_name);
 80097c8:	4630      	mov	r0, r6
 80097ca:	491c      	ldr	r1, [pc, #112]	; (800983c <shell_thread+0x17c>)
 80097cc:	f000 fa78 	bl	8009cc0 <chprintf>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 80097d0:	f854 2f08 	ldr.w	r2, [r4, #8]!
 80097d4:	2a00      	cmp	r2, #0
 80097d6:	d1f7      	bne.n	80097c8 <shell_thread+0x108>
        }
        chprintf(chp, "Commands: help exit ");
        list_commands(chp, local_commands);
        if (scp != NULL)
          list_commands(chp, scp);
        chprintf(chp, "\r\n");
 80097d8:	4630      	mov	r0, r6
 80097da:	4919      	ldr	r1, [pc, #100]	; (8009840 <shell_thread+0x180>)
 80097dc:	f000 fa70 	bl	8009cc0 <chprintf>
 80097e0:	e779      	b.n	80096d6 <shell_thread+0x16>
      }
      else if (cmdexec(local_commands, chp, cmd, n, args) &&
 80097e2:	f1b8 0f00 	cmp.w	r8, #0
 80097e6:	d00d      	beq.n	8009804 <shell_thread+0x144>
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
 80097e8:	f8d8 0000 	ldr.w	r0, [r8]
 80097ec:	b150      	cbz	r0, 8009804 <shell_thread+0x144>
 80097ee:	4645      	mov	r5, r8
 80097f0:	e002      	b.n	80097f8 <shell_thread+0x138>
 80097f2:	f855 0f08 	ldr.w	r0, [r5, #8]!
 80097f6:	b128      	cbz	r0, 8009804 <shell_thread+0x144>
    if (strcmp(scp->sc_name, name) == 0) {
 80097f8:	4639      	mov	r1, r7
 80097fa:	f7f7 fd99 	bl	8001330 <strcmp>
 80097fe:	2800      	cmp	r0, #0
 8009800:	d1f7      	bne.n	80097f2 <shell_thread+0x132>
 8009802:	e7c5      	b.n	8009790 <shell_thread+0xd0>
          list_commands(chp, scp);
        chprintf(chp, "\r\n");
      }
      else if (cmdexec(local_commands, chp, cmd, n, args) &&
          ((scp == NULL) || cmdexec(scp, chp, cmd, n, args))) {
        chprintf(chp, "%s", cmd);
 8009804:	463a      	mov	r2, r7
 8009806:	4630      	mov	r0, r6
 8009808:	490e      	ldr	r1, [pc, #56]	; (8009844 <shell_thread+0x184>)
 800980a:	f000 fa59 	bl	8009cc0 <chprintf>
        chprintf(chp, " ?\r\n");
 800980e:	4630      	mov	r0, r6
 8009810:	490d      	ldr	r1, [pc, #52]	; (8009848 <shell_thread+0x188>)
 8009812:	f000 fa55 	bl	8009cc0 <chprintf>
 8009816:	e75e      	b.n	80096d6 <shell_thread+0x16>
 8009818:	0800e4bc 	.word	0x0800e4bc
 800981c:	0800e4d4 	.word	0x0800e4d4
 8009820:	0800e500 	.word	0x0800e500
 8009824:	0800e3d0 	.word	0x0800e3d0
 8009828:	0800e4e8 	.word	0x0800e4e8
 800982c:	0800e4dc 	.word	0x0800e4dc
 8009830:	0800e508 	.word	0x0800e508
 8009834:	200008e4 	.word	0x200008e4
 8009838:	0800e510 	.word	0x0800e510
 800983c:	0800e528 	.word	0x0800e528
 8009840:	0800e608 	.word	0x0800e608
 8009844:	0800e52c 	.word	0x0800e52c
 8009848:	0800e530 	.word	0x0800e530
 800984c:	00000000 	.word	0x00000000

08009850 <long_to_string_with_divisor>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 8009850:	b4f0      	push	{r4, r5, r6, r7}
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8009852:	f100 070b 	add.w	r7, r0, #11
  int i;
  char *q;
  long l, ll;

  l = num;
  if (divisor == 0) {
 8009856:	2b00      	cmp	r3, #0
 8009858:	bf08      	it	eq
 800985a:	460b      	moveq	r3, r1
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 800985c:	463d      	mov	r5, r7
  do {
    i = (int)(l % radix);
 800985e:	fbb1 f6f2 	udiv	r6, r1, r2
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
  } while ((ll /= radix) != 0);
 8009862:	fbb3 f3f2 	udiv	r3, r3, r2
    ll = divisor;
  }

  q = p + MAX_FILLER;
  do {
    i = (int)(l % radix);
 8009866:	fb02 1116 	mls	r1, r2, r6, r1
    i += '0';
 800986a:	f101 0430 	add.w	r4, r1, #48	; 0x30
    if (i > '9')
 800986e:	2c39      	cmp	r4, #57	; 0x39
      i += 'A' - '0' - 10;
 8009870:	bfc8      	it	gt
 8009872:	f101 0437 	addgt.w	r4, r1, #55	; 0x37
    *--q = i;
 8009876:	b2e4      	uxtb	r4, r4
 8009878:	f805 4d01 	strb.w	r4, [r5, #-1]!
    l /= radix;
 800987c:	4631      	mov	r1, r6
  } while ((ll /= radix) != 0);
 800987e:	2b00      	cmp	r3, #0
 8009880:	d1ed      	bne.n	800985e <long_to_string_with_divisor+0xe>

  i = (int)(p + MAX_FILLER - q);
 8009882:	1b7b      	subs	r3, r7, r5
 8009884:	4403      	add	r3, r0
 8009886:	e001      	b.n	800988c <long_to_string_with_divisor+0x3c>
 8009888:	f815 4f01 	ldrb.w	r4, [r5, #1]!
  do
    *p++ = *q++;
 800988c:	f800 4b01 	strb.w	r4, [r0], #1
  while (--i);
 8009890:	4298      	cmp	r0, r3
 8009892:	d1f9      	bne.n	8009888 <long_to_string_with_divisor+0x38>

  return p;
}
 8009894:	bcf0      	pop	{r4, r5, r6, r7}
 8009896:	4770      	bx	lr
	...

080098a0 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 80098a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80098a4:	4681      	mov	r9, r0
 80098a6:	460d      	mov	r5, r1
 80098a8:	4616      	mov	r6, r2
 80098aa:	4682      	mov	sl, r0
 80098ac:	b08d      	sub	sp, #52	; 0x34
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 80098ae:	2300      	movs	r3, #0
 80098b0:	9301      	str	r3, [sp, #4]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 80098b2:	7829      	ldrb	r1, [r5, #0]
 80098b4:	1c6b      	adds	r3, r5, #1
    if (c == 0)
 80098b6:	b171      	cbz	r1, 80098d6 <chvprintf+0x36>
      return n;
    if (c != '%') {
 80098b8:	2925      	cmp	r1, #37	; 0x25
 80098ba:	d010      	beq.n	80098de <chvprintf+0x3e>
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 80098bc:	461d      	mov	r5, r3
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
 80098be:	9c01      	ldr	r4, [sp, #4]
  while (true) {
    c = *fmt++;
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
 80098c0:	f8da 2000 	ldr.w	r2, [sl]
 80098c4:	4650      	mov	r0, sl
 80098c6:	6892      	ldr	r2, [r2, #8]
      n++;
 80098c8:	3401      	adds	r4, #1
 80098ca:	9401      	str	r4, [sp, #4]
  while (true) {
    c = *fmt++;
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
 80098cc:	4790      	blx	r2
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 80098ce:	7829      	ldrb	r1, [r5, #0]
 80098d0:	1c6b      	adds	r3, r5, #1
    if (c == 0)
 80098d2:	2900      	cmp	r1, #0
 80098d4:	d1f0      	bne.n	80098b8 <chvprintf+0x18>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 80098d6:	9801      	ldr	r0, [sp, #4]
 80098d8:	b00d      	add	sp, #52	; 0x34
 80098da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 80098de:	786a      	ldrb	r2, [r5, #1]
    filler = ' ';
    if (*fmt == '0') {
      fmt++;
      filler = '0';
    }
    width = 0;
 80098e0:	2700      	movs	r7, #0
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 80098e2:	2a2d      	cmp	r2, #45	; 0x2d
 80098e4:	bf03      	ittte	eq
 80098e6:	78aa      	ldrbeq	r2, [r5, #2]
      fmt++;
 80098e8:	1cab      	addeq	r3, r5, #2
      left_align = TRUE;
 80098ea:	f04f 0901 	moveq.w	r9, #1
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
 80098ee:	f04f 0900 	movne.w	r9, #0
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
 80098f2:	2a30      	cmp	r2, #48	; 0x30
 80098f4:	bf03      	ittte	eq
 80098f6:	785a      	ldrbeq	r2, [r3, #1]
      fmt++;
 80098f8:	3301      	addeq	r3, #1
      filler = '0';
 80098fa:	f04f 0830 	moveq.w	r8, #48	; 0x30
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
 80098fe:	f04f 0820 	movne.w	r8, #32
 8009902:	1c59      	adds	r1, r3, #1
 8009904:	e005      	b.n	8009912 <chvprintf+0x72>
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
 8009906:	7833      	ldrb	r3, [r6, #0]
 8009908:	3604      	adds	r6, #4
 800990a:	782a      	ldrb	r2, [r5, #0]
      else
        break;
      width = width * 10 + c;
 800990c:	eb03 0740 	add.w	r7, r3, r0, lsl #1
 8009910:	3101      	adds	r1, #1
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 8009912:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8009916:	b2db      	uxtb	r3, r3
 8009918:	2b09      	cmp	r3, #9
      fmt++;
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
 800991a:	460d      	mov	r5, r1
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
 800991c:	eb07 0087 	add.w	r0, r7, r7, lsl #2
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 8009920:	d9f3      	bls.n	800990a <chvprintf+0x6a>
        c -= '0';
      else if (c == '*')
 8009922:	2a2a      	cmp	r2, #42	; 0x2a
 8009924:	d0ef      	beq.n	8009906 <chvprintf+0x66>
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
 8009926:	2a2e      	cmp	r2, #46	; 0x2e
 8009928:	f04f 0b00 	mov.w	fp, #0
 800992c:	d043      	beq.n	80099b6 <chvprintf+0x116>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 800992e:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 8009932:	2b4c      	cmp	r3, #76	; 0x4c
 8009934:	d04e      	beq.n	80099d4 <chvprintf+0x134>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8009936:	f1a2 0144 	sub.w	r1, r2, #68	; 0x44
 800993a:	2934      	cmp	r1, #52	; 0x34
 800993c:	f200 8174 	bhi.w	8009c28 <chvprintf+0x388>
 8009940:	e8df f011 	tbh	[pc, r1, lsl #1]
 8009944:	01720158 	.word	0x01720158
 8009948:	01720172 	.word	0x01720172
 800994c:	01580172 	.word	0x01580172
 8009950:	01720172 	.word	0x01720172
 8009954:	01720172 	.word	0x01720172
 8009958:	012b0172 	.word	0x012b0172
 800995c:	01720172 	.word	0x01720172
 8009960:	01720172 	.word	0x01720172
 8009964:	015f0172 	.word	0x015f0172
 8009968:	01720172 	.word	0x01720172
 800996c:	0172016f 	.word	0x0172016f
 8009970:	01720172 	.word	0x01720172
 8009974:	01720172 	.word	0x01720172
 8009978:	01720172 	.word	0x01720172
 800997c:	01720172 	.word	0x01720172
 8009980:	01610172 	.word	0x01610172
 8009984:	01720158 	.word	0x01720158
 8009988:	017200d5 	.word	0x017200d5
 800998c:	01580172 	.word	0x01580172
 8009990:	01720172 	.word	0x01720172
 8009994:	01720172 	.word	0x01720172
 8009998:	012b0172 	.word	0x012b0172
 800999c:	01720172 	.word	0x01720172
 80099a0:	00890172 	.word	0x00890172
 80099a4:	015f0172 	.word	0x015f0172
 80099a8:	01720172 	.word	0x01720172
 80099ac:	016f      	.short	0x016f
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
 80099ae:	7833      	ldrb	r3, [r6, #0]
 80099b0:	3604      	adds	r6, #4
        else
          break;
        precision *= 10;
        precision += c;
 80099b2:	eb03 0b41 	add.w	fp, r3, r1, lsl #1
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 80099b6:	f815 2b01 	ldrb.w	r2, [r5], #1
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
        else
          break;
        precision *= 10;
 80099ba:	eb0b 018b 	add.w	r1, fp, fp, lsl #2
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
 80099be:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 80099c2:	b2db      	uxtb	r3, r3
 80099c4:	2b09      	cmp	r3, #9
 80099c6:	d9f4      	bls.n	80099b2 <chvprintf+0x112>
          c -= '0';
        else if (c == '*')
 80099c8:	2a2a      	cmp	r2, #42	; 0x2a
 80099ca:	d0f0      	beq.n	80099ae <chvprintf+0x10e>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 80099cc:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 80099d0:	2b4c      	cmp	r3, #76	; 0x4c
 80099d2:	d1b0      	bne.n	8009936 <chvprintf+0x96>
      is_long = TRUE;
      if (*fmt)
 80099d4:	782b      	ldrb	r3, [r5, #0]
 80099d6:	2b00      	cmp	r3, #0
 80099d8:	f000 8126 	beq.w	8009c28 <chvprintf+0x388>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 80099dc:	f1a3 0244 	sub.w	r2, r3, #68	; 0x44
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
 80099e0:	3501      	adds	r5, #1
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 80099e2:	2a34      	cmp	r2, #52	; 0x34
 80099e4:	f200 811f 	bhi.w	8009c26 <chvprintf+0x386>
 80099e8:	e8df f012 	tbh	[pc, r2, lsl #1]
 80099ec:	011d0104 	.word	0x011d0104
 80099f0:	011d011d 	.word	0x011d011d
 80099f4:	0104011d 	.word	0x0104011d
 80099f8:	011d011d 	.word	0x011d011d
 80099fc:	011d011d 	.word	0x011d011d
 8009a00:	00d7011d 	.word	0x00d7011d
 8009a04:	011d011d 	.word	0x011d011d
 8009a08:	011d011d 	.word	0x011d011d
 8009a0c:	010b011d 	.word	0x010b011d
 8009a10:	011d011d 	.word	0x011d011d
 8009a14:	011d011b 	.word	0x011d011b
 8009a18:	011d011d 	.word	0x011d011d
 8009a1c:	011d011d 	.word	0x011d011d
 8009a20:	011d011d 	.word	0x011d011d
 8009a24:	011d011d 	.word	0x011d011d
 8009a28:	010d011d 	.word	0x010d011d
 8009a2c:	011d0104 	.word	0x011d0104
 8009a30:	011d0081 	.word	0x011d0081
 8009a34:	0104011d 	.word	0x0104011d
 8009a38:	011d011d 	.word	0x011d011d
 8009a3c:	011d011d 	.word	0x011d011d
 8009a40:	00d7011d 	.word	0x00d7011d
 8009a44:	011d011d 	.word	0x011d011d
 8009a48:	0035011d 	.word	0x0035011d
 8009a4c:	010b011d 	.word	0x010b011d
 8009a50:	011d011d 	.word	0x011d011d
 8009a54:	011b      	.short	0x011b
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 8009a56:	6834      	ldr	r4, [r6, #0]
        s = "(null)";
 8009a58:	4b93      	ldr	r3, [pc, #588]	; (8009ca8 <chvprintf+0x408>)
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 8009a5a:	3604      	adds	r6, #4
        s = "(null)";
 8009a5c:	2c00      	cmp	r4, #0
 8009a5e:	bf08      	it	eq
 8009a60:	461c      	moveq	r4, r3
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8009a62:	7823      	ldrb	r3, [r4, #0]
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
 8009a64:	f1bb 0f00 	cmp.w	fp, #0
 8009a68:	f000 80fc 	beq.w	8009c64 <chvprintf+0x3c4>
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8009a6c:	2b00      	cmp	r3, #0
 8009a6e:	f000 80fe 	beq.w	8009c6e <chvprintf+0x3ce>
 8009a72:	f10b 3bff 	add.w	fp, fp, #4294967295
 8009a76:	4620      	mov	r0, r4
 8009a78:	e002      	b.n	8009a80 <chvprintf+0x1e0>
 8009a7a:	f1bb 0b01 	subs.w	fp, fp, #1
 8009a7e:	d403      	bmi.n	8009a88 <chvprintf+0x1e8>
 8009a80:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8009a84:	2b00      	cmp	r3, #0
 8009a86:	d1f8      	bne.n	8009a7a <chvprintf+0x1da>
 8009a88:	1b00      	subs	r0, r0, r4
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 8009a8a:	1a3f      	subs	r7, r7, r0
 8009a8c:	f100 3bff 	add.w	fp, r0, #4294967295
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 8009a90:	f04f 0820 	mov.w	r8, #32
 8009a94:	ea27 77e7 	bic.w	r7, r7, r7, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8009a98:	f1b9 0f00 	cmp.w	r9, #0
 8009a9c:	f000 8090 	beq.w	8009bc0 <chvprintf+0x320>
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8009aa0:	f1bb 0f00 	cmp.w	fp, #0
 8009aa4:	db13      	blt.n	8009ace <chvprintf+0x22e>
 8009aa6:	46d9      	mov	r9, fp
      streamPut(chp, (uint8_t)*s++);
 8009aa8:	f8da 3000 	ldr.w	r3, [sl]
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8009aac:	f109 39ff 	add.w	r9, r9, #4294967295
      streamPut(chp, (uint8_t)*s++);
 8009ab0:	689b      	ldr	r3, [r3, #8]
 8009ab2:	4650      	mov	r0, sl
 8009ab4:	f814 1b01 	ldrb.w	r1, [r4], #1
 8009ab8:	4798      	blx	r3
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8009aba:	f1b9 3fff 	cmp.w	r9, #4294967295
 8009abe:	d1f3      	bne.n	8009aa8 <chvprintf+0x208>
 8009ac0:	9b01      	ldr	r3, [sp, #4]
 8009ac2:	3301      	adds	r3, #1
 8009ac4:	f1bb 0f00 	cmp.w	fp, #0
 8009ac8:	bfa8      	it	ge
 8009aca:	445b      	addge	r3, fp
 8009acc:	9301      	str	r3, [sp, #4]
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8009ace:	2f00      	cmp	r7, #0
 8009ad0:	f43f aeef 	beq.w	80098b2 <chvprintf+0x12>
 8009ad4:	463c      	mov	r4, r7
      streamPut(chp, (uint8_t)filler);
 8009ad6:	f8da 3000 	ldr.w	r3, [sl]
 8009ada:	4650      	mov	r0, sl
 8009adc:	689b      	ldr	r3, [r3, #8]
 8009ade:	4641      	mov	r1, r8
 8009ae0:	4798      	blx	r3
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8009ae2:	3c01      	subs	r4, #1
 8009ae4:	d1f7      	bne.n	8009ad6 <chvprintf+0x236>
 8009ae6:	9b01      	ldr	r3, [sp, #4]
 8009ae8:	443b      	add	r3, r7
 8009aea:	9301      	str	r3, [sp, #4]
 8009aec:	e6e1      	b.n	80098b2 <chvprintf+0x12>
      }
      p = ch_ltoa(p, l, 10);
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
 8009aee:	3607      	adds	r6, #7
 8009af0:	f026 0607 	bic.w	r6, r6, #7
 8009af4:	e9d6 0100 	ldrd	r0, r1, [r6]
 8009af8:	f7f7 f832 	bl	8000b60 <__aeabi_d2f>
      if (f < 0) {
 8009afc:	2100      	movs	r1, #0
      }
      p = ch_ltoa(p, l, 10);
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
 8009afe:	3608      	adds	r6, #8
 8009b00:	4604      	mov	r4, r0
      if (f < 0) {
 8009b02:	f7f7 fb2b 	bl	800115c <__aeabi_fcmplt>
 8009b06:	2800      	cmp	r0, #0
 8009b08:	f040 80c2 	bne.w	8009c90 <chvprintf+0x3f0>
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 8009b0c:	ab06      	add	r3, sp, #24
};

static char *ftoa(char *p, double num, unsigned long precision) {
  long l;

  if ((precision == 0) || (precision > FLOAT_PRECISION))
 8009b0e:	f10b 3bff 	add.w	fp, fp, #4294967295
 8009b12:	f1bb 0f08 	cmp.w	fp, #8
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];
 8009b16:	4a65      	ldr	r2, [pc, #404]	; (8009cac <chvprintf+0x40c>)
 8009b18:	bf28      	it	cs
 8009b1a:	f04f 0b08 	movcs.w	fp, #8
 8009b1e:	9302      	str	r3, [sp, #8]
 8009b20:	f852 302b 	ldr.w	r3, [r2, fp, lsl #2]

  l = (long)num;
 8009b24:	4620      	mov	r0, r4
static char *ftoa(char *p, double num, unsigned long precision) {
  long l;

  if ((precision == 0) || (precision > FLOAT_PRECISION))
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];
 8009b26:	9304      	str	r3, [sp, #16]

  l = (long)num;
 8009b28:	f7f7 fb42 	bl	80011b0 <__aeabi_f2iz>
 8009b2c:	4683      	mov	fp, r0
  p = long_to_string_with_divisor(p, l, 10, 0);
 8009b2e:	9b02      	ldr	r3, [sp, #8]
 8009b30:	220a      	movs	r2, #10
 8009b32:	4618      	mov	r0, r3
 8009b34:	4659      	mov	r1, fp
 8009b36:	2300      	movs	r3, #0
 8009b38:	f7ff fe8a 	bl	8009850 <long_to_string_with_divisor>
  *p++ = '.';
 8009b3c:	4684      	mov	ip, r0
 8009b3e:	232e      	movs	r3, #46	; 0x2e
 8009b40:	f80c 3b01 	strb.w	r3, [ip], #1
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
        f = -f;
      }
      p = ftoa(p, f, precision);
 8009b44:	4620      	mov	r0, r4
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];

  l = (long)num;
  p = long_to_string_with_divisor(p, l, 10, 0);
  *p++ = '.';
 8009b46:	f8cd c014 	str.w	ip, [sp, #20]
 8009b4a:	f8cd c008 	str.w	ip, [sp, #8]
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
        f = -f;
      }
      p = ftoa(p, f, precision);
 8009b4e:	f7f6 fceb 	bl	8000528 <__aeabi_f2d>
 8009b52:	e9cd 0102 	strd	r0, r1, [sp, #8]
  precision = pow10[precision - 1];

  l = (long)num;
  p = long_to_string_with_divisor(p, l, 10, 0);
  *p++ = '.';
  l = (long)((num - l) * precision);
 8009b56:	4658      	mov	r0, fp
 8009b58:	f7f6 fcd4 	bl	8000504 <__aeabi_i2d>
 8009b5c:	4602      	mov	r2, r0
 8009b5e:	460b      	mov	r3, r1
 8009b60:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8009b64:	f7f6 fb80 	bl	8000268 <__aeabi_dsub>
 8009b68:	9c04      	ldr	r4, [sp, #16]
 8009b6a:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8009b6e:	4620      	mov	r0, r4
 8009b70:	f7f6 fcb8 	bl	80004e4 <__aeabi_ui2d>
 8009b74:	4602      	mov	r2, r0
 8009b76:	460b      	mov	r3, r1
 8009b78:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8009b7c:	f7f6 fd28 	bl	80005d0 <__aeabi_dmul>
 8009b80:	f7f6 ffc6 	bl	8000b10 <__aeabi_d2iz>
  return long_to_string_with_divisor(p, l, 10, precision / 10);
 8009b84:	4622      	mov	r2, r4
 8009b86:	4b4a      	ldr	r3, [pc, #296]	; (8009cb0 <chvprintf+0x410>)
 8009b88:	f8dd c014 	ldr.w	ip, [sp, #20]
 8009b8c:	fba3 2302 	umull	r2, r3, r3, r2
  precision = pow10[precision - 1];

  l = (long)num;
  p = long_to_string_with_divisor(p, l, 10, 0);
  *p++ = '.';
  l = (long)((num - l) * precision);
 8009b90:	4601      	mov	r1, r0
  return long_to_string_with_divisor(p, l, 10, precision / 10);
 8009b92:	08db      	lsrs	r3, r3, #3
 8009b94:	4660      	mov	r0, ip
 8009b96:	220a      	movs	r2, #10
 8009b98:	e004      	b.n	8009ba4 <chvprintf+0x304>
 8009b9a:	2208      	movs	r2, #8
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 8009b9c:	6831      	ldr	r1, [r6, #0]
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8009b9e:	a806      	add	r0, sp, #24
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 8009ba0:	3604      	adds	r6, #4
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8009ba2:	2300      	movs	r3, #0
 8009ba4:	f7ff fe54 	bl	8009850 <long_to_string_with_divisor>
 8009ba8:	ab06      	add	r3, sp, #24
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8009baa:	461c      	mov	r4, r3
 8009bac:	1ac0      	subs	r0, r0, r3
 8009bae:	f100 3bff 	add.w	fp, r0, #4294967295
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 8009bb2:	1a3f      	subs	r7, r7, r0
 8009bb4:	ea27 77e7 	bic.w	r7, r7, r7, asr #31
      width = 0;
    if (left_align == FALSE)
 8009bb8:	f1b9 0f00 	cmp.w	r9, #0
 8009bbc:	f47f af70 	bne.w	8009aa0 <chvprintf+0x200>
      width = -width;
 8009bc0:	f1c7 0900 	rsb	r9, r7, #0
    if (width < 0) {
 8009bc4:	f1b9 0f00 	cmp.w	r9, #0
 8009bc8:	d037      	beq.n	8009c3a <chvprintf+0x39a>
      if (*s == '-' && filler == '0') {
 8009bca:	7821      	ldrb	r1, [r4, #0]
 8009bcc:	292d      	cmp	r1, #45	; 0x2d
 8009bce:	d03a      	beq.n	8009c46 <chvprintf+0x3a6>
        streamPut(chp, (uint8_t)*s++);
        n++;
 8009bd0:	464f      	mov	r7, r9
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8009bd2:	f8da 3000 	ldr.w	r3, [sl]
 8009bd6:	4650      	mov	r0, sl
 8009bd8:	689b      	ldr	r3, [r3, #8]
 8009bda:	4641      	mov	r1, r8
 8009bdc:	4798      	blx	r3
        n++;
      } while (++width != 0);
 8009bde:	3701      	adds	r7, #1
 8009be0:	d1f7      	bne.n	8009bd2 <chvprintf+0x332>
 8009be2:	9b01      	ldr	r3, [sp, #4]
    }
    while (--i >= 0) {
 8009be4:	f1bb 0f00 	cmp.w	fp, #0
 8009be8:	ebc9 0303 	rsb	r3, r9, r3
 8009bec:	9301      	str	r3, [sp, #4]
 8009bee:	f6bf af5a 	bge.w	8009aa6 <chvprintf+0x206>
 8009bf2:	e65e      	b.n	80098b2 <chvprintf+0x12>
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 8009bf4:	6831      	ldr	r1, [r6, #0]
 8009bf6:	3604      	adds	r6, #4
      if (l < 0) {
 8009bf8:	2900      	cmp	r1, #0
 8009bfa:	db42      	blt.n	8009c82 <chvprintf+0x3e2>
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 8009bfc:	a806      	add	r0, sp, #24
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8009bfe:	220a      	movs	r2, #10
 8009c00:	e7cf      	b.n	8009ba2 <chvprintf+0x302>
      c = 16;
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
      goto unsigned_common;
 8009c02:	220a      	movs	r2, #10
 8009c04:	e7ca      	b.n	8009b9c <chvprintf+0x2fc>

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
 8009c06:	6833      	ldr	r3, [r6, #0]
 8009c08:	aa06      	add	r2, sp, #24
 8009c0a:	f10d 0019 	add.w	r0, sp, #25
 8009c0e:	1a80      	subs	r0, r0, r2
 8009c10:	f100 3bff 	add.w	fp, r0, #4294967295
 8009c14:	f88d 3018 	strb.w	r3, [sp, #24]
 8009c18:	3604      	adds	r6, #4
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
 8009c1a:	f04f 0820 	mov.w	r8, #32
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8009c1e:	4614      	mov	r4, r2
    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
 8009c20:	e7c7      	b.n	8009bb2 <chvprintf+0x312>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8009c22:	2210      	movs	r2, #16
 8009c24:	e7ba      	b.n	8009b9c <chvprintf+0x2fc>
 8009c26:	461a      	mov	r2, r3
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8009c28:	ac06      	add	r4, sp, #24
 8009c2a:	f10d 0019 	add.w	r0, sp, #25
 8009c2e:	1b00      	subs	r0, r0, r4
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 8009c30:	f88d 2018 	strb.w	r2, [sp, #24]
 8009c34:	f100 3bff 	add.w	fp, r0, #4294967295
      break;
 8009c38:	e7bb      	b.n	8009bb2 <chvprintf+0x312>
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8009c3a:	f1bb 0f00 	cmp.w	fp, #0
 8009c3e:	464f      	mov	r7, r9
 8009c40:	f6bf af31 	bge.w	8009aa6 <chvprintf+0x206>
 8009c44:	e635      	b.n	80098b2 <chvprintf+0x12>
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
 8009c46:	f1b8 0f30 	cmp.w	r8, #48	; 0x30
 8009c4a:	d1c1      	bne.n	8009bd0 <chvprintf+0x330>
        streamPut(chp, (uint8_t)*s++);
 8009c4c:	f8da 3000 	ldr.w	r3, [sl]
 8009c50:	4650      	mov	r0, sl
 8009c52:	689b      	ldr	r3, [r3, #8]
 8009c54:	4798      	blx	r3
        n++;
 8009c56:	9b01      	ldr	r3, [sp, #4]
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
        streamPut(chp, (uint8_t)*s++);
 8009c58:	3401      	adds	r4, #1
        n++;
 8009c5a:	3301      	adds	r3, #1
 8009c5c:	9301      	str	r3, [sp, #4]
 8009c5e:	f10b 3bff 	add.w	fp, fp, #4294967295
 8009c62:	e7b5      	b.n	8009bd0 <chvprintf+0x330>
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8009c64:	f647 7bfe 	movw	fp, #32766	; 0x7ffe
 8009c68:	2b00      	cmp	r3, #0
 8009c6a:	f47f af04 	bne.w	8009a76 <chvprintf+0x1d6>
 8009c6e:	ea27 77e7 	bic.w	r7, r7, r7, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8009c72:	f1b9 0f00 	cmp.w	r9, #0
 8009c76:	d113      	bne.n	8009ca0 <chvprintf+0x400>
 8009c78:	f04f 3bff 	mov.w	fp, #4294967295
 8009c7c:	f04f 0820 	mov.w	r8, #32
 8009c80:	e79e      	b.n	8009bc0 <chvprintf+0x320>
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8009c82:	232d      	movs	r3, #45	; 0x2d
        l = -l;
 8009c84:	4249      	negs	r1, r1
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8009c86:	f88d 3018 	strb.w	r3, [sp, #24]
 8009c8a:	f10d 0019 	add.w	r0, sp, #25
 8009c8e:	e7b6      	b.n	8009bfe <chvprintf+0x35e>
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
 8009c90:	232d      	movs	r3, #45	; 0x2d
 8009c92:	f88d 3018 	strb.w	r3, [sp, #24]
        f = -f;
 8009c96:	f104 4400 	add.w	r4, r4, #2147483648	; 0x80000000
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
 8009c9a:	f10d 0319 	add.w	r3, sp, #25
 8009c9e:	e736      	b.n	8009b0e <chvprintf+0x26e>
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8009ca0:	f04f 0820 	mov.w	r8, #32
 8009ca4:	e713      	b.n	8009ace <chvprintf+0x22e>
 8009ca6:	bf00      	nop
 8009ca8:	0800e540 	.word	0x0800e540
 8009cac:	0800e550 	.word	0x0800e550
 8009cb0:	cccccccd 	.word	0xcccccccd
	...

08009cc0 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8009cc0:	b40e      	push	{r1, r2, r3}
 8009cc2:	b500      	push	{lr}
 8009cc4:	b082      	sub	sp, #8
 8009cc6:	ab03      	add	r3, sp, #12
 8009cc8:	f853 1b04 	ldr.w	r1, [r3], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
  formatted_bytes = chvprintf(chp, fmt, ap);
 8009ccc:	461a      	mov	r2, r3
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8009cce:	9301      	str	r3, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8009cd0:	f7ff fde6 	bl	80098a0 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8009cd4:	b002      	add	sp, #8
 8009cd6:	f85d eb04 	ldr.w	lr, [sp], #4
 8009cda:	b003      	add	sp, #12
 8009cdc:	4770      	bx	lr
 8009cde:	bf00      	nop

08009ce0 <flashUnlock.part.0>:
  /* Check if unlock is really needed */
  if (!(FLASH->CR & FLASH_CR_LOCK))
    return CH_SUCCESS;

  /* Write magic unlock sequence */
  FLASH->KEYR = 0x45670123;
 8009ce0:	4b05      	ldr	r3, [pc, #20]	; (8009cf8 <flashUnlock.part.0+0x18>)
 8009ce2:	4906      	ldr	r1, [pc, #24]	; (8009cfc <flashUnlock.part.0+0x1c>)
  FLASH->KEYR = 0xCDEF89AB;
 8009ce4:	4a06      	ldr	r2, [pc, #24]	; (8009d00 <flashUnlock.part.0+0x20>)
  /* Check if unlock is really needed */
  if (!(FLASH->CR & FLASH_CR_LOCK))
    return CH_SUCCESS;

  /* Write magic unlock sequence */
  FLASH->KEYR = 0x45670123;
 8009ce6:	6059      	str	r1, [r3, #4]
  FLASH->KEYR = 0xCDEF89AB;
 8009ce8:	605a      	str	r2, [r3, #4]

  if (FLASH->CR & FLASH_CR_LOCK)
 8009cea:	6918      	ldr	r0, [r3, #16]
 8009cec:	f080 0080 	eor.w	r0, r0, #128	; 0x80
    return CH_FAILED;

  return CH_SUCCESS;
}
 8009cf0:	f3c0 10c0 	ubfx	r0, r0, #7, #1
 8009cf4:	4770      	bx	lr
 8009cf6:	bf00      	nop
 8009cf8:	40022000 	.word	0x40022000
 8009cfc:	45670123 	.word	0x45670123
 8009d00:	cdef89ab 	.word	0xcdef89ab
	...

08009d10 <flashPageErase>:


int flashPageErase(flashpage_t page){

  /* Only write on pages in the user area */
  if (!(FLASH_IS_ADDRESS_USERSPACE(FLASH_ADDRESS_OF_PAGE(page))))
 8009d10:	4b22      	ldr	r3, [pc, #136]	; (8009d9c <flashPageErase+0x8c>)
static void flashLock(void) {
  FLASH->CR |= FLASH_CR_LOCK;
}


int flashPageErase(flashpage_t page){
 8009d12:	b570      	push	{r4, r5, r6, lr}

  /* Only write on pages in the user area */
  if (!(FLASH_IS_ADDRESS_USERSPACE(FLASH_ADDRESS_OF_PAGE(page))))
 8009d14:	4403      	add	r3, r0
 8009d16:	02de      	lsls	r6, r3, #11
 8009d18:	f5b6 5fc0 	cmp.w	r6, #6144	; 0x1800
 8009d1c:	d23b      	bcs.n	8009d96 <flashPageErase+0x86>
 * @return  CH_SUCCESS  Unlock was successful.
 * @return CH_FAILED    Unlock failed.
 */
static bool_t flashUnlock(void){
  /* Check if unlock is really needed */
  if (!(FLASH->CR & FLASH_CR_LOCK))
 8009d1e:	4b20      	ldr	r3, [pc, #128]	; (8009da0 <flashPageErase+0x90>)
 8009d20:	4604      	mov	r4, r0
 8009d22:	691b      	ldr	r3, [r3, #16]
 8009d24:	061a      	lsls	r2, r3, #24
 8009d26:	d432      	bmi.n	8009d8e <flashPageErase+0x7e>
  /* Unlock flash for write access */
  if(flashUnlock() == CH_FAILED)
    return FLASH_RETURN_NO_PERMISSION;

  /* Wait for any busy flags. */
  flashWaitWhileBusy();
 8009d28:	491d      	ldr	r1, [pc, #116]	; (8009da0 <flashPageErase+0x90>)
 8009d2a:	68cb      	ldr	r3, [r1, #12]
 8009d2c:	4a1c      	ldr	r2, [pc, #112]	; (8009da0 <flashPageErase+0x90>)
 8009d2e:	07db      	lsls	r3, r3, #31
 8009d30:	d4fb      	bmi.n	8009d2a <flashPageErase+0x1a>
  FLASH->CR |= FLASH_CR_PER;
  FLASH->AR = FLASH_ADDRESS_OF_PAGE(page);
  FLASH->CR |= FLASH_CR_STRT;

  /* Wait until it's finished. */
  flashWaitWhileBusy();
 8009d32:	4611      	mov	r1, r2

  /* Wait for any busy flags. */
  flashWaitWhileBusy();

  /* Start deletion of page. */
  FLASH->CR |= FLASH_CR_PER;
 8009d34:	6913      	ldr	r3, [r2, #16]
  FLASH->AR = FLASH_ADDRESS_OF_PAGE(page);
 8009d36:	f106 6500 	add.w	r5, r6, #134217728	; 0x8000000

  /* Wait for any busy flags. */
  flashWaitWhileBusy();

  /* Start deletion of page. */
  FLASH->CR |= FLASH_CR_PER;
 8009d3a:	f043 0302 	orr.w	r3, r3, #2
  FLASH->AR = FLASH_ADDRESS_OF_PAGE(page);
 8009d3e:	f505 357a 	add.w	r5, r5, #256000	; 0x3e800

  /* Wait for any busy flags. */
  flashWaitWhileBusy();

  /* Start deletion of page. */
  FLASH->CR |= FLASH_CR_PER;
 8009d42:	6113      	str	r3, [r2, #16]
  FLASH->AR = FLASH_ADDRESS_OF_PAGE(page);
 8009d44:	6155      	str	r5, [r2, #20]
  FLASH->CR |= FLASH_CR_STRT;
 8009d46:	6913      	ldr	r3, [r2, #16]
 8009d48:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009d4c:	6113      	str	r3, [r2, #16]

  /* Wait until it's finished. */
  flashWaitWhileBusy();
 8009d4e:	68cb      	ldr	r3, [r1, #12]
 8009d50:	4a13      	ldr	r2, [pc, #76]	; (8009da0 <flashPageErase+0x90>)
 8009d52:	f013 0301 	ands.w	r3, r3, #1
 8009d56:	d1fa      	bne.n	8009d4e <flashPageErase+0x3e>

  /* Page erase flag does not clear automatically. */
  FLASH->CR &= !FLASH_CR_PER;
 8009d58:	6911      	ldr	r1, [r2, #16]
 8009d5a:	6113      	str	r3, [r2, #16]

/**
 * @brief Lock the flash memory for write access.
 */
static void flashLock(void) {
  FLASH->CR |= FLASH_CR_LOCK;
 8009d5c:	6913      	ldr	r3, [r2, #16]
  return FLASH_RETURN_SUCCESS;
}

bool_t flashPageCheckErased(flashpage_t page){
  uint32_t* const startAddress = (uint32_t*) FLASH_ADDRESS_OF_PAGE(page);
  uint32_t* const stopAddress = (uint32_t*) FLASH_ADDRESS_OF_PAGE(page+1);
 8009d5e:	f104 2008 	add.w	r0, r4, #134219776	; 0x8000800

/**
 * @brief Lock the flash memory for write access.
 */
static void flashLock(void) {
  FLASH->CR |= FLASH_CR_LOCK;
 8009d62:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  uint32_t* const stopAddress = (uint32_t*) FLASH_ADDRESS_OF_PAGE(page+1);

  uint32_t* addr;

  /* Cycle through the whole page and check for default set bits */
  for(addr = startAddress; addr < stopAddress; addr++){
 8009d66:	4285      	cmp	r5, r0

/**
 * @brief Lock the flash memory for write access.
 */
static void flashLock(void) {
  FLASH->CR |= FLASH_CR_LOCK;
 8009d68:	6113      	str	r3, [r2, #16]
  uint32_t* const stopAddress = (uint32_t*) FLASH_ADDRESS_OF_PAGE(page+1);

  uint32_t* addr;

  /* Cycle through the whole page and check for default set bits */
  for(addr = startAddress; addr < stopAddress; addr++){
 8009d6a:	d20b      	bcs.n	8009d84 <flashPageErase+0x74>
    if (*addr != 0xffffffff)
 8009d6c:	682b      	ldr	r3, [r5, #0]
 8009d6e:	3301      	adds	r3, #1
 8009d70:	d10a      	bne.n	8009d88 <flashPageErase+0x78>
 8009d72:	4b0c      	ldr	r3, [pc, #48]	; (8009da4 <flashPageErase+0x94>)
 8009d74:	4433      	add	r3, r6
 8009d76:	e003      	b.n	8009d80 <flashPageErase+0x70>
 8009d78:	f853 2b04 	ldr.w	r2, [r3], #4
 8009d7c:	3201      	adds	r2, #1
 8009d7e:	d103      	bne.n	8009d88 <flashPageErase+0x78>
  uint32_t* const stopAddress = (uint32_t*) FLASH_ADDRESS_OF_PAGE(page+1);

  uint32_t* addr;

  /* Cycle through the whole page and check for default set bits */
  for(addr = startAddress; addr < stopAddress; addr++){
 8009d80:	4298      	cmp	r0, r3
 8009d82:	d8f9      	bhi.n	8009d78 <flashPageErase+0x68>
  /* Check deleted page for errors */
  if(flashPageCheckErased(page) == FALSE)
    return FLASH_RETURN_BADFLASH;  /* Page is not empty despite the erase cycle! */

  /* Successfully deleted page */
  return FLASH_RETURN_SUCCESS;
 8009d84:	2001      	movs	r0, #1
 8009d86:	bd70      	pop	{r4, r5, r6, pc}
  /* Lock flash again */
  flashLock();

  /* Check deleted page for errors */
  if(flashPageCheckErased(page) == FALSE)
    return FLASH_RETURN_BADFLASH;  /* Page is not empty despite the erase cycle! */
 8009d88:	f06f 000a 	mvn.w	r0, #10

  /* Successfully deleted page */
  return FLASH_RETURN_SUCCESS;
}
 8009d8c:	bd70      	pop	{r4, r5, r6, pc}
 8009d8e:	f7ff ffa7 	bl	8009ce0 <flashUnlock.part.0>
  /* Only write on pages in the user area */
  if (!(FLASH_IS_ADDRESS_USERSPACE(FLASH_ADDRESS_OF_PAGE(page))))
    return FLASH_RETURN_NO_PERMISSION;

  /* Unlock flash for write access */
  if(flashUnlock() == CH_FAILED)
 8009d92:	2800      	cmp	r0, #0
 8009d94:	d1c8      	bne.n	8009d28 <flashPageErase+0x18>

int flashPageErase(flashpage_t page){

  /* Only write on pages in the user area */
  if (!(FLASH_IS_ADDRESS_USERSPACE(FLASH_ADDRESS_OF_PAGE(page))))
    return FLASH_RETURN_NO_PERMISSION;
 8009d96:	f04f 30ff 	mov.w	r0, #4294967295
 8009d9a:	bd70      	pop	{r4, r5, r6, pc}
 8009d9c:	001fff83 	.word	0x001fff83
 8009da0:	40022000 	.word	0x40022000
 8009da4:	0803e804 	.word	0x0803e804
	...

08009db0 <flashWrite>:

	return err;

}
int flashWrite(flashaddr_t src_address, const char* buffer, size_t size)
{
 8009db0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 * @return  CH_SUCCESS  Unlock was successful.
 * @return CH_FAILED    Unlock failed.
 */
static bool_t flashUnlock(void){
  /* Check if unlock is really needed */
  if (!(FLASH->CR & FLASH_CR_LOCK))
 8009db4:	4b43      	ldr	r3, [pc, #268]	; (8009ec4 <flashWrite+0x114>)

	return err;

}
int flashWrite(flashaddr_t src_address, const char* buffer, size_t size)
{
 8009db6:	4614      	mov	r4, r2
 * @return  CH_SUCCESS  Unlock was successful.
 * @return CH_FAILED    Unlock failed.
 */
static bool_t flashUnlock(void){
  /* Check if unlock is really needed */
  if (!(FLASH->CR & FLASH_CR_LOCK))
 8009db8:	691b      	ldr	r3, [r3, #16]

	return err;

}
int flashWrite(flashaddr_t src_address, const char* buffer, size_t size)
{
 8009dba:	b083      	sub	sp, #12
 * @return  CH_SUCCESS  Unlock was successful.
 * @return CH_FAILED    Unlock failed.
 */
static bool_t flashUnlock(void){
  /* Check if unlock is really needed */
  if (!(FLASH->CR & FLASH_CR_LOCK))
 8009dbc:	061a      	lsls	r2, r3, #24

	return err;

}
int flashWrite(flashaddr_t src_address, const char* buffer, size_t size)
{
 8009dbe:	4680      	mov	r8, r0
 8009dc0:	460d      	mov	r5, r1
	volatile flashdata_t* address = src_address;
 8009dc2:	4606      	mov	r6, r0
 * @return  CH_SUCCESS  Unlock was successful.
 * @return CH_FAILED    Unlock failed.
 */
static bool_t flashUnlock(void){
  /* Check if unlock is really needed */
  if (!(FLASH->CR & FLASH_CR_LOCK))
 8009dc4:	d45f      	bmi.n	8009e86 <flashWrite+0xd6>
    /* Unlock flash for write access */
    if(flashUnlock() == CH_FAILED)
        return FLASH_RETURN_NO_PERMISSION;

    /* Wait for any busy flags */
    flashWaitWhileBusy();
 8009dc6:	4a3f      	ldr	r2, [pc, #252]	; (8009ec4 <flashWrite+0x114>)
 8009dc8:	68d3      	ldr	r3, [r2, #12]
 8009dca:	4f3e      	ldr	r7, [pc, #248]	; (8009ec4 <flashWrite+0x114>)
 8009dcc:	07db      	lsls	r3, r3, #31
 8009dce:	d4fb      	bmi.n	8009dc8 <flashWrite+0x18>

    /* Check if the flash address is correctly aligned */
    size_t alignOffset = (size_t)address % sizeof(flashdata_t);
    if (alignOffset != 0)
 8009dd0:	f018 0f01 	tst.w	r8, #1
 8009dd4:	d131      	bne.n	8009e3a <flashWrite+0x8a>


    /* Now, address is correctly aligned. One can copy data directly from
     * buffer's data to flash memory until the size of the data remaining to be
     * copied requires special treatment. */
    while (size >= sizeof(flashdata_t))
 8009dd6:	2c01      	cmp	r4, #1
 8009dd8:	d924      	bls.n	8009e24 <flashWrite+0x74>
}

static void flashWriteData(volatile flashdata_t* address, const flashdata_t data)
{
    /* Enter flash programming mode */
    FLASH->CR |= FLASH_CR_PG;
 8009dda:	4a3a      	ldr	r2, [pc, #232]	; (8009ec4 <flashWrite+0x114>)


    /* Now, address is correctly aligned. One can copy data directly from
     * buffer's data to flash memory until the size of the data remaining to be
     * copied requires special treatment. */
    while (size >= sizeof(flashdata_t))
 8009ddc:	4630      	mov	r0, r6

    /* Write the data */
    *address = data;

    /* Wait for completion */
    flashWaitWhileBusy();
 8009dde:	4696      	mov	lr, r2


    /* Now, address is correctly aligned. One can copy data directly from
     * buffer's data to flash memory until the size of the data remaining to be
     * copied requires special treatment. */
    while (size >= sizeof(flashdata_t))
 8009de0:	4621      	mov	r1, r4
 8009de2:	1eaf      	subs	r7, r5, #2
}

static void flashWriteData(volatile flashdata_t* address, const flashdata_t data)
{
    /* Enter flash programming mode */
    FLASH->CR |= FLASH_CR_PG;
 8009de4:	6913      	ldr	r3, [r2, #16]
    /* Now, address is correctly aligned. One can copy data directly from
     * buffer's data to flash memory until the size of the data remaining to be
     * copied requires special treatment. */
    while (size >= sizeof(flashdata_t))
    {
        flashWriteData(address, *(const flashdata_t*)buffer);
 8009de6:	f837 cf02 	ldrh.w	ip, [r7, #2]!
}

static void flashWriteData(volatile flashdata_t* address, const flashdata_t data)
{
    /* Enter flash programming mode */
    FLASH->CR |= FLASH_CR_PG;
 8009dea:	f043 0301 	orr.w	r3, r3, #1
 8009dee:	6113      	str	r3, [r2, #16]

    /* Write the data */
    *address = data;
 8009df0:	f8a0 c000 	strh.w	ip, [r0]

    /* Wait for completion */
    flashWaitWhileBusy();
 8009df4:	68d3      	ldr	r3, [r2, #12]
 8009df6:	07db      	lsls	r3, r3, #31
 8009df8:	d4fc      	bmi.n	8009df4 <flashWrite+0x44>

    /* Exit flash programming mode */
    FLASH->CR &= ~FLASH_CR_PG;
 8009dfa:	f8de 3010 	ldr.w	r3, [lr, #16]
    while (size >= sizeof(flashdata_t))
    {
        flashWriteData(address, *(const flashdata_t*)buffer);
        address = (size_t)address + sizeof(flashdata_t);
        buffer += sizeof(flashdata_t);
        size -= sizeof(flashdata_t);
 8009dfe:	3902      	subs	r1, #2

    /* Wait for completion */
    flashWaitWhileBusy();

    /* Exit flash programming mode */
    FLASH->CR &= ~FLASH_CR_PG;
 8009e00:	f023 0301 	bic.w	r3, r3, #1


    /* Now, address is correctly aligned. One can copy data directly from
     * buffer's data to flash memory until the size of the data remaining to be
     * copied requires special treatment. */
    while (size >= sizeof(flashdata_t))
 8009e04:	2901      	cmp	r1, #1
 8009e06:	f100 0002 	add.w	r0, r0, #2

    /* Wait for completion */
    flashWaitWhileBusy();

    /* Exit flash programming mode */
    FLASH->CR &= ~FLASH_CR_PG;
 8009e0a:	f8ce 3010 	str.w	r3, [lr, #16]


    /* Now, address is correctly aligned. One can copy data directly from
     * buffer's data to flash memory until the size of the data remaining to be
     * copied requires special treatment. */
    while (size >= sizeof(flashdata_t))
 8009e0e:	d8e9      	bhi.n	8009de4 <flashWrite+0x34>
 8009e10:	1ea3      	subs	r3, r4, #2
 8009e12:	085b      	lsrs	r3, r3, #1
 8009e14:	3602      	adds	r6, #2
 8009e16:	1c5a      	adds	r2, r3, #1
 8009e18:	eb06 0643 	add.w	r6, r6, r3, lsl #1
 8009e1c:	eb05 0542 	add.w	r5, r5, r2, lsl #1
 8009e20:	f004 0401 	and.w	r4, r4, #1

    /* Now, address is correctly aligned, but the remaining data are to
     * small to fill a entier flashdata_t. Thus, one must read data already
     * in flash and update them with buffer's data before writing an entire
     * flashdata_t to flash memory. */
    if (size > 0)
 8009e24:	2c00      	cmp	r4, #0
 8009e26:	d135      	bne.n	8009e94 <flashWrite+0xe4>

/**
 * @brief Lock the flash memory for write access.
 */
static void flashLock(void) {
  FLASH->CR |= FLASH_CR_LOCK;
 8009e28:	4a26      	ldr	r2, [pc, #152]	; (8009ec4 <flashWrite+0x114>)
    }

    /* Lock flash again */
    flashLock();

    return FLASH_RETURN_SUCCESS;
 8009e2a:	2001      	movs	r0, #1

/**
 * @brief Lock the flash memory for write access.
 */
static void flashLock(void) {
  FLASH->CR |= FLASH_CR_LOCK;
 8009e2c:	6913      	ldr	r3, [r2, #16]
 8009e2e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009e32:	6113      	str	r3, [r2, #16]
    /* Lock flash again */
    flashLock();

    return FLASH_RETURN_SUCCESS;

}
 8009e34:	b003      	add	sp, #12
 8009e36:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        /* Read already present data */
        flashdata_t tmp = *(volatile flashdata_t*)alignedFlashAddress;

        /* Compute how much bytes one must update in the data read */
        size_t chunkSize = sizeof(flashdata_t) - alignOffset;
        if (chunkSize > size)
 8009e3a:	f114 0900 	adds.w	r9, r4, #0

        /* Align the flash address correctly */
        flashaddr_t alignedFlashAddress = address - alignOffset;

        /* Read already present data */
        flashdata_t tmp = *(volatile flashdata_t*)alignedFlashAddress;
 8009e3e:	f838 3c02 	ldrh.w	r3, [r8, #-2]

        /* Compute how much bytes one must update in the data read */
        size_t chunkSize = sizeof(flashdata_t) - alignOffset;
        if (chunkSize > size)
 8009e42:	bf18      	it	ne
 8009e44:	f04f 0901 	movne.w	r9, #1
            chunkSize = size; // this happens when both address and address + size are not aligned

        /* Update the read data with buffer's data */
        memcpy((char*)&tmp + alignOffset, buffer, chunkSize);
 8009e48:	464a      	mov	r2, r9
 8009e4a:	4629      	mov	r1, r5
 8009e4c:	f10d 0007 	add.w	r0, sp, #7

        /* Align the flash address correctly */
        flashaddr_t alignedFlashAddress = address - alignOffset;

        /* Read already present data */
        flashdata_t tmp = *(volatile flashdata_t*)alignedFlashAddress;
 8009e50:	f8ad 3006 	strh.w	r3, [sp, #6]
        size_t chunkSize = sizeof(flashdata_t) - alignOffset;
        if (chunkSize > size)
            chunkSize = size; // this happens when both address and address + size are not aligned

        /* Update the read data with buffer's data */
        memcpy((char*)&tmp + alignOffset, buffer, chunkSize);
 8009e54:	f7f7 f9f4 	bl	8001240 <memcpy>

    /* Write the data */
    *address = data;

    /* Wait for completion */
    flashWaitWhileBusy();
 8009e58:	4639      	mov	r1, r7
}

static void flashWriteData(volatile flashdata_t* address, const flashdata_t data)
{
    /* Enter flash programming mode */
    FLASH->CR |= FLASH_CR_PG;
 8009e5a:	693b      	ldr	r3, [r7, #16]

        /* Update the read data with buffer's data */
        memcpy((char*)&tmp + alignOffset, buffer, chunkSize);

        /* Write the new data in flash */
        flashWriteData(alignedFlashAddress, tmp);
 8009e5c:	f8bd 2006 	ldrh.w	r2, [sp, #6]
}

static void flashWriteData(volatile flashdata_t* address, const flashdata_t data)
{
    /* Enter flash programming mode */
    FLASH->CR |= FLASH_CR_PG;
 8009e60:	f043 0301 	orr.w	r3, r3, #1
 8009e64:	613b      	str	r3, [r7, #16]

    /* Write the data */
    *address = data;
 8009e66:	f828 2c02 	strh.w	r2, [r8, #-2]

    /* Wait for completion */
    flashWaitWhileBusy();
 8009e6a:	68cb      	ldr	r3, [r1, #12]
 8009e6c:	4a15      	ldr	r2, [pc, #84]	; (8009ec4 <flashWrite+0x114>)
 8009e6e:	07d8      	lsls	r0, r3, #31
 8009e70:	d4fb      	bmi.n	8009e6a <flashWrite+0xba>

    /* Exit flash programming mode */
    FLASH->CR &= ~FLASH_CR_PG;
 8009e72:	6913      	ldr	r3, [r2, #16]

        /* Write the new data in flash */
        flashWriteData(alignedFlashAddress, tmp);

        /* Advance */
        address += chunkSize;
 8009e74:	eb08 0649 	add.w	r6, r8, r9, lsl #1

    /* Wait for completion */
    flashWaitWhileBusy();

    /* Exit flash programming mode */
    FLASH->CR &= ~FLASH_CR_PG;
 8009e78:	f023 0301 	bic.w	r3, r3, #1
        /* Write the new data in flash */
        flashWriteData(alignedFlashAddress, tmp);

        /* Advance */
        address += chunkSize;
        buffer += chunkSize;
 8009e7c:	444d      	add	r5, r9
        size -= chunkSize;
 8009e7e:	ebc9 0404 	rsb	r4, r9, r4

    /* Wait for completion */
    flashWaitWhileBusy();

    /* Exit flash programming mode */
    FLASH->CR &= ~FLASH_CR_PG;
 8009e82:	6113      	str	r3, [r2, #16]
 8009e84:	e7a7      	b.n	8009dd6 <flashWrite+0x26>
 8009e86:	f7ff ff2b 	bl	8009ce0 <flashUnlock.part.0>
int flashWrite(flashaddr_t src_address, const char* buffer, size_t size)
{
	volatile flashdata_t* address = src_address;

    /* Unlock flash for write access */
    if(flashUnlock() == CH_FAILED)
 8009e8a:	2800      	cmp	r0, #0
 8009e8c:	d19b      	bne.n	8009dc6 <flashWrite+0x16>
        return FLASH_RETURN_NO_PERMISSION;
 8009e8e:	f04f 30ff 	mov.w	r0, #4294967295
 8009e92:	e7cf      	b.n	8009e34 <flashWrite+0x84>
}

static void flashWriteData(volatile flashdata_t* address, const flashdata_t data)
{
    /* Enter flash programming mode */
    FLASH->CR |= FLASH_CR_PG;
 8009e94:	4b0b      	ldr	r3, [pc, #44]	; (8009ec4 <flashWrite+0x114>)
     * small to fill a entier flashdata_t. Thus, one must read data already
     * in flash and update them with buffer's data before writing an entire
     * flashdata_t to flash memory. */
    if (size > 0)
    {
        flashdata_t tmp = *(volatile flashdata_t*)address;
 8009e96:	8830      	ldrh	r0, [r6, #0]

    /* Write the data */
    *address = data;

    /* Wait for completion */
    flashWaitWhileBusy();
 8009e98:	4619      	mov	r1, r3
     * in flash and update them with buffer's data before writing an entire
     * flashdata_t to flash memory. */
    if (size > 0)
    {
        flashdata_t tmp = *(volatile flashdata_t*)address;
        memcpy(&tmp, buffer, size);
 8009e9a:	782a      	ldrb	r2, [r5, #0]
     * small to fill a entier flashdata_t. Thus, one must read data already
     * in flash and update them with buffer's data before writing an entire
     * flashdata_t to flash memory. */
    if (size > 0)
    {
        flashdata_t tmp = *(volatile flashdata_t*)address;
 8009e9c:	f8ad 0006 	strh.w	r0, [sp, #6]
        memcpy(&tmp, buffer, size);
 8009ea0:	f88d 2006 	strb.w	r2, [sp, #6]
}

static void flashWriteData(volatile flashdata_t* address, const flashdata_t data)
{
    /* Enter flash programming mode */
    FLASH->CR |= FLASH_CR_PG;
 8009ea4:	691a      	ldr	r2, [r3, #16]
     * flashdata_t to flash memory. */
    if (size > 0)
    {
        flashdata_t tmp = *(volatile flashdata_t*)address;
        memcpy(&tmp, buffer, size);
        flashWriteData(address, tmp);
 8009ea6:	f8bd 0006 	ldrh.w	r0, [sp, #6]
}

static void flashWriteData(volatile flashdata_t* address, const flashdata_t data)
{
    /* Enter flash programming mode */
    FLASH->CR |= FLASH_CR_PG;
 8009eaa:	f042 0201 	orr.w	r2, r2, #1
 8009eae:	611a      	str	r2, [r3, #16]

    /* Write the data */
    *address = data;
 8009eb0:	8030      	strh	r0, [r6, #0]

    /* Wait for completion */
    flashWaitWhileBusy();
 8009eb2:	68cb      	ldr	r3, [r1, #12]
 8009eb4:	4a03      	ldr	r2, [pc, #12]	; (8009ec4 <flashWrite+0x114>)
 8009eb6:	07db      	lsls	r3, r3, #31
 8009eb8:	d4fb      	bmi.n	8009eb2 <flashWrite+0x102>

    /* Exit flash programming mode */
    FLASH->CR &= ~FLASH_CR_PG;
 8009eba:	6913      	ldr	r3, [r2, #16]
 8009ebc:	f023 0301 	bic.w	r3, r3, #1
 8009ec0:	6113      	str	r3, [r2, #16]
 8009ec2:	e7b1      	b.n	8009e28 <flashWrite+0x78>
 8009ec4:	40022000 	.word	0x40022000
	...

08009ed0 <QInvSqrtf>:
/**
 * Fast Inverse Square Root approximation from www.gamedev.net
 * with magic number proposed by Chris Lomont:
 * - Lomont, Chris (February 2003).
 */
static inline float QInvSqrtf(float x) {
 8009ed0:	b510      	push	{r4, lr}
  union {
    uint32_t i;
    float    f;
  } y;
  y.f = x;
  y.i = 0x5f375a86 - (y.i >> 1);      // gives initial guess y0
 8009ed2:	4c0c      	ldr	r4, [pc, #48]	; (8009f04 <QInvSqrtf+0x34>)
 * Fast Inverse Square Root approximation from www.gamedev.net
 * with magic number proposed by Chris Lomont:
 * - Lomont, Chris (February 2003).
 */
static inline float QInvSqrtf(float x) {
  float xhalf = 0.5f * x;
 8009ed4:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
  union {
    uint32_t i;
    float    f;
  } y;
  y.f = x;
  y.i = 0x5f375a86 - (y.i >> 1);      // gives initial guess y0
 8009ed8:	eba4 0450 	sub.w	r4, r4, r0, lsr #1
 * Fast Inverse Square Root approximation from www.gamedev.net
 * with magic number proposed by Chris Lomont:
 * - Lomont, Chris (February 2003).
 */
static inline float QInvSqrtf(float x) {
  float xhalf = 0.5f * x;
 8009edc:	f7f6 ffa0 	bl	8000e20 <__aeabi_fmul>
    uint32_t i;
    float    f;
  } y;
  y.f = x;
  y.i = 0x5f375a86 - (y.i >> 1);      // gives initial guess y0
  y.f *= 1.5f - xhalf * y.f * y.f;    // First Newton step, repeating increases accuracy
 8009ee0:	4621      	mov	r1, r4
 8009ee2:	f7f6 ff9d 	bl	8000e20 <__aeabi_fmul>
 8009ee6:	4601      	mov	r1, r0
 8009ee8:	4620      	mov	r0, r4
 8009eea:	f7f6 ff99 	bl	8000e20 <__aeabi_fmul>
 8009eee:	4601      	mov	r1, r0
 8009ef0:	f04f 507f 	mov.w	r0, #1069547520	; 0x3fc00000
 8009ef4:	f7f6 fe88 	bl	8000c08 <__aeabi_fsub>
 8009ef8:	4601      	mov	r1, r0
 8009efa:	4620      	mov	r0, r4
 8009efc:	f7f6 ff90 	bl	8000e20 <__aeabi_fmul>
  //y.f *= 1.5f - xhalf * y.f * y.f;    // Second Newton step
  // and so on...
  return y.f;
}
 8009f00:	bd10      	pop	{r4, pc}
 8009f02:	bf00      	nop
 8009f04:	5f375a86 	.word	0x5f375a86
	...

08009f10 <CrossProduct>:

/**
 * res = v1 x v2;
 */
static inline void CrossProduct(const float v1[3], const float v2[3], float res[3]) {
 8009f10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009f12:	4605      	mov	r5, r0
 8009f14:	460c      	mov	r4, r1
  res[0] = v1[1]*v2[2] - v2[1]*v1[2];
 8009f16:	6840      	ldr	r0, [r0, #4]
 8009f18:	6889      	ldr	r1, [r1, #8]
}

/**
 * res = v1 x v2;
 */
static inline void CrossProduct(const float v1[3], const float v2[3], float res[3]) {
 8009f1a:	4616      	mov	r6, r2
  res[0] = v1[1]*v2[2] - v2[1]*v1[2];
 8009f1c:	f7f6 ff80 	bl	8000e20 <__aeabi_fmul>
 8009f20:	68a9      	ldr	r1, [r5, #8]
 8009f22:	4607      	mov	r7, r0
 8009f24:	6860      	ldr	r0, [r4, #4]
 8009f26:	f7f6 ff7b 	bl	8000e20 <__aeabi_fmul>
 8009f2a:	4601      	mov	r1, r0
 8009f2c:	4638      	mov	r0, r7
 8009f2e:	f7f6 fe6b 	bl	8000c08 <__aeabi_fsub>
 8009f32:	6030      	str	r0, [r6, #0]
  res[1] = v2[0]*v1[2] - v1[0]*v2[2];
 8009f34:	68a9      	ldr	r1, [r5, #8]
 8009f36:	6820      	ldr	r0, [r4, #0]
 8009f38:	f7f6 ff72 	bl	8000e20 <__aeabi_fmul>
 8009f3c:	68a1      	ldr	r1, [r4, #8]
 8009f3e:	4607      	mov	r7, r0
 8009f40:	6828      	ldr	r0, [r5, #0]
 8009f42:	f7f6 ff6d 	bl	8000e20 <__aeabi_fmul>
 8009f46:	4601      	mov	r1, r0
 8009f48:	4638      	mov	r0, r7
 8009f4a:	f7f6 fe5d 	bl	8000c08 <__aeabi_fsub>
 8009f4e:	6070      	str	r0, [r6, #4]
  res[2] = v1[0]*v2[1] - v2[0]*v1[1];
 8009f50:	6861      	ldr	r1, [r4, #4]
 8009f52:	6828      	ldr	r0, [r5, #0]
 8009f54:	f7f6 ff64 	bl	8000e20 <__aeabi_fmul>
 8009f58:	6869      	ldr	r1, [r5, #4]
 8009f5a:	4607      	mov	r7, r0
 8009f5c:	6820      	ldr	r0, [r4, #0]
 8009f5e:	f7f6 ff5f 	bl	8000e20 <__aeabi_fmul>
 8009f62:	4601      	mov	r1, r0
 8009f64:	4638      	mov	r0, r7
 8009f66:	f7f6 fe4f 	bl	8000c08 <__aeabi_fsub>
 8009f6a:	60b0      	str	r0, [r6, #8]
 8009f6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009f6e:	bf00      	nop

08009f70 <pidUpdateStruct>:
}

/**
 * @brief
 */
static void pidUpdateStruct(void) {
 8009f70:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009f74:	f8df a05c 	ldr.w	sl, [pc, #92]	; 8009fd4 <pidUpdateStruct+0x64>
 8009f78:	f8df 905c 	ldr.w	r9, [pc, #92]	; 8009fd8 <pidUpdateStruct+0x68>
 8009f7c:	4656      	mov	r6, sl
 8009f7e:	464d      	mov	r5, r9
 8009f80:	f8df 8058 	ldr.w	r8, [pc, #88]	; 8009fdc <pidUpdateStruct+0x6c>
  for (i = 0; i < 3; i++) {
    PID[i].P = (float)g_pidSettings[i].P*0.1f;
    PID[i].I = (float)g_pidSettings[i].I*0.01f;
    PID[i].D = (float)g_pidSettings[i].D*1.0f;
    if (!g_pidSettings[i].I) {
      g_motorOffset[i] = 0.0f;
 8009f84:	f04f 0b00 	mov.w	fp, #0
}

/**
 * @brief
 */
static void pidUpdateStruct(void) {
 8009f88:	2400      	movs	r4, #0
  uint8_t i;
  for (i = 0; i < 3; i++) {
    PID[i].P = (float)g_pidSettings[i].P*0.1f;
 8009f8a:	f81a 0004 	ldrb.w	r0, [sl, r4]
 8009f8e:	f7f6 feed 	bl	8000d6c <__aeabi_ui2f>
 8009f92:	490e      	ldr	r1, [pc, #56]	; (8009fcc <pidUpdateStruct+0x5c>)
 8009f94:	f7f6 ff44 	bl	8000e20 <__aeabi_fmul>
    PID[i].I = (float)g_pidSettings[i].I*0.01f;
 8009f98:	7877      	ldrb	r7, [r6, #1]
 * @brief
 */
static void pidUpdateStruct(void) {
  uint8_t i;
  for (i = 0; i < 3; i++) {
    PID[i].P = (float)g_pidSettings[i].P*0.1f;
 8009f9a:	f849 0034 	str.w	r0, [r9, r4, lsl #3]
    PID[i].I = (float)g_pidSettings[i].I*0.01f;
 8009f9e:	4638      	mov	r0, r7
 8009fa0:	f7f6 fee4 	bl	8000d6c <__aeabi_ui2f>
 8009fa4:	490a      	ldr	r1, [pc, #40]	; (8009fd0 <pidUpdateStruct+0x60>)
 8009fa6:	f7f6 ff3b 	bl	8000e20 <__aeabi_fmul>
 8009faa:	6068      	str	r0, [r5, #4]
    PID[i].D = (float)g_pidSettings[i].D*1.0f;
 8009fac:	78b0      	ldrb	r0, [r6, #2]
 8009fae:	f7f6 fedd 	bl	8000d6c <__aeabi_ui2f>
 8009fb2:	3403      	adds	r4, #3
 8009fb4:	60a8      	str	r0, [r5, #8]
 8009fb6:	3603      	adds	r6, #3
 8009fb8:	3518      	adds	r5, #24
    if (!g_pidSettings[i].I) {
 8009fba:	b90f      	cbnz	r7, 8009fc0 <pidUpdateStruct+0x50>
      g_motorOffset[i] = 0.0f;
 8009fbc:	f8c8 b000 	str.w	fp, [r8]
/**
 * @brief
 */
static void pidUpdateStruct(void) {
  uint8_t i;
  for (i = 0; i < 3; i++) {
 8009fc0:	2c09      	cmp	r4, #9
 8009fc2:	f108 0804 	add.w	r8, r8, #4
 8009fc6:	d1e0      	bne.n	8009f8a <pidUpdateStruct+0x1a>
    PID[i].D = (float)g_pidSettings[i].D*1.0f;
    if (!g_pidSettings[i].I) {
      g_motorOffset[i] = 0.0f;
    }
  }
}
 8009fc8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009fcc:	3dcccccd 	.word	0x3dcccccd
 8009fd0:	3c23d70a 	.word	0x3c23d70a
 8009fd4:	20001db8 	.word	0x20001db8
 8009fd8:	20001d54 	.word	0x20001d54
 8009fdc:	20001dc4 	.word	0x20001dc4

08009fe0 <Quaternion2RPY>:
 * @note  The order of rotations is:
 *        1. pitch (X);
 *        2. roll (Y);
 *        3. yaw (Z).
 */
static inline void Quaternion2RPY(const float q[4], float rpy[3]) {
 8009fe0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  float R13, R11, R12, R23, R33;
  float q2s = q[2]*q[2];
 8009fe4:	6885      	ldr	r5, [r0, #8]
 * @note  The order of rotations is:
 *        1. pitch (X);
 *        2. roll (Y);
 *        3. yaw (Z).
 */
static inline void Quaternion2RPY(const float q[4], float rpy[3]) {
 8009fe6:	4606      	mov	r6, r0
 8009fe8:	460f      	mov	r7, r1
  float R13, R11, R12, R23, R33;
  float q2s = q[2]*q[2];
 8009fea:	4628      	mov	r0, r5
 8009fec:	4629      	mov	r1, r5
 8009fee:	f7f6 ff17 	bl	8000e20 <__aeabi_fmul>

  R11 = 1.0f - 2.0f * (q2s + q[3]*q[3]);
  R12 = 2.0f * (q[0]*q[3] + q[1]*q[2]);
 8009ff2:	f8d6 8000 	ldr.w	r8, [r6]
 *        2. roll (Y);
 *        3. yaw (Z).
 */
static inline void Quaternion2RPY(const float q[4], float rpy[3]) {
  float R13, R11, R12, R23, R33;
  float q2s = q[2]*q[2];
 8009ff6:	4681      	mov	r9, r0

  R11 = 1.0f - 2.0f * (q2s + q[3]*q[3]);
  R12 = 2.0f * (q[0]*q[3] + q[1]*q[2]);
  R13 = 2.0f * (q[0]*q[2] - q[1]*q[3]);
 8009ff8:	4641      	mov	r1, r8
 8009ffa:	4628      	mov	r0, r5
 8009ffc:	f7f6 ff10 	bl	8000e20 <__aeabi_fmul>
 */
static inline void Quaternion2RPY(const float q[4], float rpy[3]) {
  float R13, R11, R12, R23, R33;
  float q2s = q[2]*q[2];

  R11 = 1.0f - 2.0f * (q2s + q[3]*q[3]);
 800a000:	68f4      	ldr	r4, [r6, #12]
  R12 = 2.0f * (q[0]*q[3] + q[1]*q[2]);
 800a002:	6876      	ldr	r6, [r6, #4]
  R13 = 2.0f * (q[0]*q[2] - q[1]*q[3]);
 800a004:	4682      	mov	sl, r0
 800a006:	4631      	mov	r1, r6
 800a008:	4620      	mov	r0, r4
 800a00a:	f7f6 ff09 	bl	8000e20 <__aeabi_fmul>
 800a00e:	4601      	mov	r1, r0
 800a010:	4650      	mov	r0, sl
 800a012:	f7f6 fdf9 	bl	8000c08 <__aeabi_fsub>
 800a016:	4601      	mov	r1, r0
 800a018:	f7f6 fdf8 	bl	8000c0c <__addsf3>
  R23 = 2.0f * (q[0]*q[1] + q[2]*q[3]);
  R33 = 1.0f - 2.0f * (q2s + q[1]*q[1]);

  rpy[1] = asinf (R13);   // roll always between -pi/2 to pi/2
 800a01c:	f001 fe28 	bl	800bc70 <asinf>
static inline void Quaternion2RPY(const float q[4], float rpy[3]) {
  float R13, R11, R12, R23, R33;
  float q2s = q[2]*q[2];

  R11 = 1.0f - 2.0f * (q2s + q[3]*q[3]);
  R12 = 2.0f * (q[0]*q[3] + q[1]*q[2]);
 800a020:	4641      	mov	r1, r8
  R13 = 2.0f * (q[0]*q[2] - q[1]*q[3]);
  R23 = 2.0f * (q[0]*q[1] + q[2]*q[3]);
  R33 = 1.0f - 2.0f * (q2s + q[1]*q[1]);

  rpy[1] = asinf (R13);   // roll always between -pi/2 to pi/2
 800a022:	6078      	str	r0, [r7, #4]
static inline void Quaternion2RPY(const float q[4], float rpy[3]) {
  float R13, R11, R12, R23, R33;
  float q2s = q[2]*q[2];

  R11 = 1.0f - 2.0f * (q2s + q[3]*q[3]);
  R12 = 2.0f * (q[0]*q[3] + q[1]*q[2]);
 800a024:	4620      	mov	r0, r4
 800a026:	f7f6 fefb 	bl	8000e20 <__aeabi_fmul>
 800a02a:	4631      	mov	r1, r6
 800a02c:	4682      	mov	sl, r0
 800a02e:	4628      	mov	r0, r5
 800a030:	f7f6 fef6 	bl	8000e20 <__aeabi_fmul>
 800a034:	4601      	mov	r1, r0
 800a036:	4650      	mov	r0, sl
 800a038:	f7f6 fde8 	bl	8000c0c <__addsf3>
 800a03c:	4601      	mov	r1, r0
 800a03e:	f7f6 fde5 	bl	8000c0c <__addsf3>
 */
static inline void Quaternion2RPY(const float q[4], float rpy[3]) {
  float R13, R11, R12, R23, R33;
  float q2s = q[2]*q[2];

  R11 = 1.0f - 2.0f * (q2s + q[3]*q[3]);
 800a042:	4621      	mov	r1, r4
  R12 = 2.0f * (q[0]*q[3] + q[1]*q[2]);
 800a044:	4682      	mov	sl, r0
 */
static inline void Quaternion2RPY(const float q[4], float rpy[3]) {
  float R13, R11, R12, R23, R33;
  float q2s = q[2]*q[2];

  R11 = 1.0f - 2.0f * (q2s + q[3]*q[3]);
 800a046:	4620      	mov	r0, r4
 800a048:	f7f6 feea 	bl	8000e20 <__aeabi_fmul>
 800a04c:	4649      	mov	r1, r9
 800a04e:	f7f6 fddd 	bl	8000c0c <__addsf3>
 800a052:	4601      	mov	r1, r0
 800a054:	f7f6 fdda 	bl	8000c0c <__addsf3>
 800a058:	4601      	mov	r1, r0
 800a05a:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800a05e:	f7f6 fdd3 	bl	8000c08 <__aeabi_fsub>
 800a062:	4601      	mov	r1, r0
  R13 = 2.0f * (q[0]*q[2] - q[1]*q[3]);
  R23 = 2.0f * (q[0]*q[1] + q[2]*q[3]);
  R33 = 1.0f - 2.0f * (q2s + q[1]*q[1]);

  rpy[1] = asinf (R13);   // roll always between -pi/2 to pi/2
  rpy[2] = atan2f(R12, R11);
 800a064:	4650      	mov	r0, sl
 800a066:	f001 fe53 	bl	800bd10 <atan2f>
  float q2s = q[2]*q[2];

  R11 = 1.0f - 2.0f * (q2s + q[3]*q[3]);
  R12 = 2.0f * (q[0]*q[3] + q[1]*q[2]);
  R13 = 2.0f * (q[0]*q[2] - q[1]*q[3]);
  R23 = 2.0f * (q[0]*q[1] + q[2]*q[3]);
 800a06a:	4631      	mov	r1, r6
  R33 = 1.0f - 2.0f * (q2s + q[1]*q[1]);

  rpy[1] = asinf (R13);   // roll always between -pi/2 to pi/2
  rpy[2] = atan2f(R12, R11);
 800a06c:	60b8      	str	r0, [r7, #8]
  float q2s = q[2]*q[2];

  R11 = 1.0f - 2.0f * (q2s + q[3]*q[3]);
  R12 = 2.0f * (q[0]*q[3] + q[1]*q[2]);
  R13 = 2.0f * (q[0]*q[2] - q[1]*q[3]);
  R23 = 2.0f * (q[0]*q[1] + q[2]*q[3]);
 800a06e:	4640      	mov	r0, r8
 800a070:	f7f6 fed6 	bl	8000e20 <__aeabi_fmul>
 800a074:	4621      	mov	r1, r4
 800a076:	4680      	mov	r8, r0
 800a078:	4628      	mov	r0, r5
 800a07a:	f7f6 fed1 	bl	8000e20 <__aeabi_fmul>
 800a07e:	4601      	mov	r1, r0
 800a080:	4640      	mov	r0, r8
 800a082:	f7f6 fdc3 	bl	8000c0c <__addsf3>
 800a086:	4601      	mov	r1, r0
 800a088:	f7f6 fdc0 	bl	8000c0c <__addsf3>
  R33 = 1.0f - 2.0f * (q2s + q[1]*q[1]);
 800a08c:	4631      	mov	r1, r6
  float q2s = q[2]*q[2];

  R11 = 1.0f - 2.0f * (q2s + q[3]*q[3]);
  R12 = 2.0f * (q[0]*q[3] + q[1]*q[2]);
  R13 = 2.0f * (q[0]*q[2] - q[1]*q[3]);
  R23 = 2.0f * (q[0]*q[1] + q[2]*q[3]);
 800a08e:	4604      	mov	r4, r0
  R33 = 1.0f - 2.0f * (q2s + q[1]*q[1]);
 800a090:	4630      	mov	r0, r6
 800a092:	f7f6 fec5 	bl	8000e20 <__aeabi_fmul>
 800a096:	4649      	mov	r1, r9
 800a098:	f7f6 fdb8 	bl	8000c0c <__addsf3>
 800a09c:	4601      	mov	r1, r0
 800a09e:	f7f6 fdb5 	bl	8000c0c <__addsf3>
 800a0a2:	4601      	mov	r1, r0
 800a0a4:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800a0a8:	f7f6 fdae 	bl	8000c08 <__aeabi_fsub>
 800a0ac:	4601      	mov	r1, r0

  rpy[1] = asinf (R13);   // roll always between -pi/2 to pi/2
  rpy[2] = atan2f(R12, R11);
  rpy[0] = atan2f(R23, R33);
 800a0ae:	4620      	mov	r0, r4
 800a0b0:	f001 fe2e 	bl	800bd10 <atan2f>
 800a0b4:	6038      	str	r0, [r7, #0]
 800a0b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800a0ba:	bf00      	nop
 800a0bc:	0000      	movs	r0, r0
	...

0800a0c0 <pidControllerApply>:
 * @param  cmd_id - command id to apply PID action to.
 * @param  err - process error value.
 * @param  rot - rotation command value.
 * @return weighted sum of P, I and D actions.
 */
static float pidControllerApply(uint8_t cmd_id, float err, float rot) {
 800a0c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  float poles2 = (float)(g_pwmOutput[cmd_id].num_poles >> 1);
 800a0c4:	4b8e      	ldr	r3, [pc, #568]	; (800a300 <pidControllerApply+0x240>)
 * @param  cmd_id - command id to apply PID action to.
 * @param  err - process error value.
 * @param  rot - rotation command value.
 * @return weighted sum of P, I and D actions.
 */
static float pidControllerApply(uint8_t cmd_id, float err, float rot) {
 800a0c6:	4604      	mov	r4, r0
  float poles2 = (float)(g_pwmOutput[cmd_id].num_poles >> 1);
 800a0c8:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800a0cc:	7858      	ldrb	r0, [r3, #1]
 * @param  cmd_id - command id to apply PID action to.
 * @param  err - process error value.
 * @param  rot - rotation command value.
 * @return weighted sum of P, I and D actions.
 */
static float pidControllerApply(uint8_t cmd_id, float err, float rot) {
 800a0ce:	b085      	sub	sp, #20
  float poles2 = (float)(g_pwmOutput[cmd_id].num_poles >> 1);
 800a0d0:	0840      	lsrs	r0, r0, #1
 * @param  cmd_id - command id to apply PID action to.
 * @param  err - process error value.
 * @param  rot - rotation command value.
 * @return weighted sum of P, I and D actions.
 */
static float pidControllerApply(uint8_t cmd_id, float err, float rot) {
 800a0d2:	460d      	mov	r5, r1
 800a0d4:	4616      	mov	r6, r2
  float poles2 = (float)(g_pwmOutput[cmd_id].num_poles >> 1);
 800a0d6:	f7f6 fe4d 	bl	8000d74 <__aeabi_i2f>
 800a0da:	4607      	mov	r7, r0
  /* Distance for the motor to travel: */
  float dist = circadjust(err, M_PI);
 800a0dc:	4628      	mov	r0, r5
 800a0de:	f7f6 fa23 	bl	8000528 <__aeabi_f2d>
 800a0e2:	a37d      	add	r3, pc, #500	; (adr r3, 800a2d8 <pidControllerApply+0x218>)
 800a0e4:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a0e8:	4680      	mov	r8, r0
 800a0ea:	4689      	mov	r9, r1
 800a0ec:	f7f6 fce8 	bl	8000ac0 <__aeabi_dcmplt>
 800a0f0:	2800      	cmp	r0, #0
 800a0f2:	f000 80ab 	beq.w	800a24c <pidControllerApply+0x18c>
 800a0f6:	a37a      	add	r3, pc, #488	; (adr r3, 800a2e0 <pidControllerApply+0x220>)
 800a0f8:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a0fc:	4640      	mov	r0, r8
 800a0fe:	4649      	mov	r1, r9
 800a100:	f7f6 f8b4 	bl	800026c <__adddf3>
 800a104:	f7f6 fd2c 	bl	8000b60 <__aeabi_d2f>
 800a108:	4605      	mov	r5, r0
  /* Convert mechanical distance to electrical distance: */
  dist *= poles2;
 800a10a:	4628      	mov	r0, r5
 800a10c:	4639      	mov	r1, r7
 800a10e:	f7f6 fe87 	bl	8000e20 <__aeabi_fmul>
  /* Convert mechanical rotation to electrical rotation: */
  rot *= poles2;
 800a112:	4639      	mov	r1, r7
static float pidControllerApply(uint8_t cmd_id, float err, float rot) {
  float poles2 = (float)(g_pwmOutput[cmd_id].num_poles >> 1);
  /* Distance for the motor to travel: */
  float dist = circadjust(err, M_PI);
  /* Convert mechanical distance to electrical distance: */
  dist *= poles2;
 800a114:	4683      	mov	fp, r0
  /* Convert mechanical rotation to electrical rotation: */
  rot *= poles2;
 800a116:	4630      	mov	r0, r6
 800a118:	f7f6 fe82 	bl	8000e20 <__aeabi_fmul>
  /* If there is a distance to travel then rotate the motor in small steps: */
  float step = constrain(dist*PID[cmd_id].I, MOTOR_STEP_LIMIT_MIN, MOTOR_STEP_LIMIT_MAX);
 800a11c:	0066      	lsls	r6, r4, #1
 800a11e:	4d79      	ldr	r5, [pc, #484]	; (800a304 <pidControllerApply+0x244>)
 800a120:	1933      	adds	r3, r6, r4
 800a122:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
  /* Distance for the motor to travel: */
  float dist = circadjust(err, M_PI);
  /* Convert mechanical distance to electrical distance: */
  dist *= poles2;
  /* Convert mechanical rotation to electrical rotation: */
  rot *= poles2;
 800a126:	9003      	str	r0, [sp, #12]
  /* If there is a distance to travel then rotate the motor in small steps: */
  float step = constrain(dist*PID[cmd_id].I, MOTOR_STEP_LIMIT_MIN, MOTOR_STEP_LIMIT_MAX);
 800a128:	6859      	ldr	r1, [r3, #4]
 800a12a:	4658      	mov	r0, fp
 800a12c:	f7f6 fe78 	bl	8000e20 <__aeabi_fmul>
 800a130:	9000      	str	r0, [sp, #0]
 800a132:	f7f6 f9f9 	bl	8000528 <__aeabi_f2d>
 800a136:	a36c      	add	r3, pc, #432	; (adr r3, 800a2e8 <pidControllerApply+0x228>)
 800a138:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a13c:	4680      	mov	r8, r0
 800a13e:	4689      	mov	r9, r1
 800a140:	f7f6 fcbe 	bl	8000ac0 <__aeabi_dcmplt>
 800a144:	2800      	cmp	r0, #0
 800a146:	d17e      	bne.n	800a246 <pidControllerApply+0x186>
 800a148:	a369      	add	r3, pc, #420	; (adr r3, 800a2f0 <pidControllerApply+0x230>)
 800a14a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a14e:	4640      	mov	r0, r8
 800a150:	4649      	mov	r1, r9
 800a152:	f7f6 fcd3 	bl	8000afc <__aeabi_dcmpgt>
 800a156:	2800      	cmp	r0, #0
 800a158:	f040 80a1 	bne.w	800a29e <pidControllerApply+0x1de>
  /* Calculate proportional speed of the motor: */
  float speed = dist - PID[cmd_id].prevDist;
 800a15c:	eb06 0904 	add.w	r9, r6, r4
 800a160:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 800a164:	eb05 0a09 	add.w	sl, r5, r9
 800a168:	f8da 100c 	ldr.w	r1, [sl, #12]
 800a16c:	4658      	mov	r0, fp
 800a16e:	f7f6 fd4b 	bl	8000c08 <__aeabi_fsub>
  step += speed*PID[cmd_id].P;
 800a172:	f855 1009 	ldr.w	r1, [r5, r9]
  /* Convert mechanical rotation to electrical rotation: */
  rot *= poles2;
  /* If there is a distance to travel then rotate the motor in small steps: */
  float step = constrain(dist*PID[cmd_id].I, MOTOR_STEP_LIMIT_MIN, MOTOR_STEP_LIMIT_MAX);
  /* Calculate proportional speed of the motor: */
  float speed = dist - PID[cmd_id].prevDist;
 800a176:	4680      	mov	r8, r0
  step += speed*PID[cmd_id].P;
 800a178:	f7f6 fe52 	bl	8000e20 <__aeabi_fmul>
 800a17c:	4601      	mov	r1, r0
 800a17e:	9800      	ldr	r0, [sp, #0]
 800a180:	f7f6 fd44 	bl	8000c0c <__addsf3>
 800a184:	4681      	mov	r9, r0
  /* Account for the acceleration of the motor: */
  step += (speed - PID[cmd_id].prevSpeed)*PID[cmd_id].D;
 800a186:	f8da 1010 	ldr.w	r1, [sl, #16]
 800a18a:	4640      	mov	r0, r8
 800a18c:	f7f6 fd3c 	bl	8000c08 <__aeabi_fsub>
 800a190:	f8da 1008 	ldr.w	r1, [sl, #8]
 800a194:	f7f6 fe44 	bl	8000e20 <__aeabi_fmul>
 800a198:	4649      	mov	r1, r9
 800a19a:	f7f6 fd37 	bl	8000c0c <__addsf3>
  /* Add rotation command. */
  step += rot;
 800a19e:	9903      	ldr	r1, [sp, #12]
 800a1a0:	f7f6 fd34 	bl	8000c0c <__addsf3>
  /* Update offset of the motor: */
  g_motorOffset[cmd_id] += step / poles2;
 800a1a4:	f8df 9170 	ldr.w	r9, [pc, #368]	; 800a318 <pidControllerApply+0x258>
 800a1a8:	4639      	mov	r1, r7
  float speed = dist - PID[cmd_id].prevDist;
  step += speed*PID[cmd_id].P;
  /* Account for the acceleration of the motor: */
  step += (speed - PID[cmd_id].prevSpeed)*PID[cmd_id].D;
  /* Add rotation command. */
  step += rot;
 800a1aa:	4682      	mov	sl, r0
  /* Update offset of the motor: */
  g_motorOffset[cmd_id] += step / poles2;
 800a1ac:	f7f6 feec 	bl	8000f88 <__aeabi_fdiv>
 800a1b0:	f859 1024 	ldr.w	r1, [r9, r4, lsl #2]
 800a1b4:	f7f6 fd2a 	bl	8000c0c <__addsf3>
 800a1b8:	4607      	mov	r7, r0
  /* Wind-up guard limits motor offset range to one mechanical rotation: */
  g_motorOffset[cmd_id] = circadjust(g_motorOffset[cmd_id], M_PI);
 800a1ba:	f7f6 f9b5 	bl	8000528 <__aeabi_f2d>
 800a1be:	a346      	add	r3, pc, #280	; (adr r3, 800a2d8 <pidControllerApply+0x218>)
 800a1c0:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a1c4:	e9cd 0100 	strd	r0, r1, [sp]
 800a1c8:	f7f6 fc7a 	bl	8000ac0 <__aeabi_dcmplt>
 800a1cc:	2800      	cmp	r0, #0
 800a1ce:	d052      	beq.n	800a276 <pidControllerApply+0x1b6>
 800a1d0:	a343      	add	r3, pc, #268	; (adr r3, 800a2e0 <pidControllerApply+0x220>)
 800a1d2:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a1d6:	e9dd 0100 	ldrd	r0, r1, [sp]
 800a1da:	f7f6 f847 	bl	800026c <__adddf3>
 800a1de:	f7f6 fcbf 	bl	8000b60 <__aeabi_d2f>
 800a1e2:	4607      	mov	r7, r0
  /* Update motor position: */
  float cmd = PID[cmd_id].prevCmd + step;
 800a1e4:	1933      	adds	r3, r6, r4
 800a1e6:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
 800a1ea:	6959      	ldr	r1, [r3, #20]
 800a1ec:	4650      	mov	r0, sl
  /* Add rotation command. */
  step += rot;
  /* Update offset of the motor: */
  g_motorOffset[cmd_id] += step / poles2;
  /* Wind-up guard limits motor offset range to one mechanical rotation: */
  g_motorOffset[cmd_id] = circadjust(g_motorOffset[cmd_id], M_PI);
 800a1ee:	f849 7024 	str.w	r7, [r9, r4, lsl #2]
  /* Update motor position: */
  float cmd = PID[cmd_id].prevCmd + step;
 800a1f2:	f7f6 fd0b 	bl	8000c0c <__addsf3>
  /* Normalize command to -M_PI..M_PI range: */
  if (cmd < 0.0f) {
 800a1f6:	2100      	movs	r1, #0
  /* Update offset of the motor: */
  g_motorOffset[cmd_id] += step / poles2;
  /* Wind-up guard limits motor offset range to one mechanical rotation: */
  g_motorOffset[cmd_id] = circadjust(g_motorOffset[cmd_id], M_PI);
  /* Update motor position: */
  float cmd = PID[cmd_id].prevCmd + step;
 800a1f8:	4607      	mov	r7, r0
  /* Normalize command to -M_PI..M_PI range: */
  if (cmd < 0.0f) {
 800a1fa:	f7f6 ffaf 	bl	800115c <__aeabi_fcmplt>
 800a1fe:	2800      	cmp	r0, #0
 800a200:	d150      	bne.n	800a2a4 <pidControllerApply+0x1e4>
    cmd = fmodf(cmd - M_PI, -M_TWOPI) + M_PI;
  } else {
    cmd = fmodf(cmd + M_PI,  M_TWOPI) - M_PI;
 800a202:	4638      	mov	r0, r7
 800a204:	f7f6 f990 	bl	8000528 <__aeabi_f2d>
 800a208:	a33b      	add	r3, pc, #236	; (adr r3, 800a2f8 <pidControllerApply+0x238>)
 800a20a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a20e:	f7f6 f82d 	bl	800026c <__adddf3>
 800a212:	f7f6 fca5 	bl	8000b60 <__aeabi_d2f>
 800a216:	493c      	ldr	r1, [pc, #240]	; (800a308 <pidControllerApply+0x248>)
 800a218:	f001 fd82 	bl	800bd20 <fmodf>
 800a21c:	f7f6 f984 	bl	8000528 <__aeabi_f2d>
 800a220:	a335      	add	r3, pc, #212	; (adr r3, 800a2f8 <pidControllerApply+0x238>)
 800a222:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a226:	f7f6 f81f 	bl	8000268 <__aeabi_dsub>
 800a22a:	f7f6 fc99 	bl	8000b60 <__aeabi_d2f>
  }
  /* Save values for the next iteration: */
  PID[cmd_id].prevDist = dist;
 800a22e:	4434      	add	r4, r6
 800a230:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
  PID[cmd_id].prevSpeed = speed;
 800a234:	4623      	mov	r3, r4
 800a236:	f843 8f10 	str.w	r8, [r3, #16]!
    cmd = fmodf(cmd - M_PI, -M_TWOPI) + M_PI;
  } else {
    cmd = fmodf(cmd + M_PI,  M_TWOPI) - M_PI;
  }
  /* Save values for the next iteration: */
  PID[cmd_id].prevDist = dist;
 800a23a:	f8c4 b00c 	str.w	fp, [r4, #12]
  PID[cmd_id].prevSpeed = speed;
  PID[cmd_id].prevCmd = cmd;
 800a23e:	6058      	str	r0, [r3, #4]
  return cmd;
}
 800a240:	b005      	add	sp, #20
 800a242:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  /* Convert mechanical distance to electrical distance: */
  dist *= poles2;
  /* Convert mechanical rotation to electrical rotation: */
  rot *= poles2;
  /* If there is a distance to travel then rotate the motor in small steps: */
  float step = constrain(dist*PID[cmd_id].I, MOTOR_STEP_LIMIT_MIN, MOTOR_STEP_LIMIT_MAX);
 800a246:	4b31      	ldr	r3, [pc, #196]	; (800a30c <pidControllerApply+0x24c>)
 800a248:	9300      	str	r3, [sp, #0]
 800a24a:	e787      	b.n	800a15c <pidControllerApply+0x9c>
 * @return weighted sum of P, I and D actions.
 */
static float pidControllerApply(uint8_t cmd_id, float err, float rot) {
  float poles2 = (float)(g_pwmOutput[cmd_id].num_poles >> 1);
  /* Distance for the motor to travel: */
  float dist = circadjust(err, M_PI);
 800a24c:	4640      	mov	r0, r8
 800a24e:	a32a      	add	r3, pc, #168	; (adr r3, 800a2f8 <pidControllerApply+0x238>)
 800a250:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a254:	4649      	mov	r1, r9
 800a256:	f7f6 fc51 	bl	8000afc <__aeabi_dcmpgt>
 800a25a:	2800      	cmp	r0, #0
 800a25c:	f43f af55 	beq.w	800a10a <pidControllerApply+0x4a>
 800a260:	a31f      	add	r3, pc, #124	; (adr r3, 800a2e0 <pidControllerApply+0x220>)
 800a262:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a266:	4640      	mov	r0, r8
 800a268:	4649      	mov	r1, r9
 800a26a:	f7f5 fffd 	bl	8000268 <__aeabi_dsub>
 800a26e:	f7f6 fc77 	bl	8000b60 <__aeabi_d2f>
 800a272:	4605      	mov	r5, r0
 800a274:	e749      	b.n	800a10a <pidControllerApply+0x4a>
  /* Add rotation command. */
  step += rot;
  /* Update offset of the motor: */
  g_motorOffset[cmd_id] += step / poles2;
  /* Wind-up guard limits motor offset range to one mechanical rotation: */
  g_motorOffset[cmd_id] = circadjust(g_motorOffset[cmd_id], M_PI);
 800a276:	e9dd 0100 	ldrd	r0, r1, [sp]
 800a27a:	a31f      	add	r3, pc, #124	; (adr r3, 800a2f8 <pidControllerApply+0x238>)
 800a27c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a280:	f7f6 fc3c 	bl	8000afc <__aeabi_dcmpgt>
 800a284:	2800      	cmp	r0, #0
 800a286:	d0ad      	beq.n	800a1e4 <pidControllerApply+0x124>
 800a288:	a315      	add	r3, pc, #84	; (adr r3, 800a2e0 <pidControllerApply+0x220>)
 800a28a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a28e:	e9dd 0100 	ldrd	r0, r1, [sp]
 800a292:	f7f5 ffe9 	bl	8000268 <__aeabi_dsub>
 800a296:	f7f6 fc63 	bl	8000b60 <__aeabi_d2f>
 800a29a:	4607      	mov	r7, r0
 800a29c:	e7a2      	b.n	800a1e4 <pidControllerApply+0x124>
  /* Convert mechanical distance to electrical distance: */
  dist *= poles2;
  /* Convert mechanical rotation to electrical rotation: */
  rot *= poles2;
  /* If there is a distance to travel then rotate the motor in small steps: */
  float step = constrain(dist*PID[cmd_id].I, MOTOR_STEP_LIMIT_MIN, MOTOR_STEP_LIMIT_MAX);
 800a29e:	4b1c      	ldr	r3, [pc, #112]	; (800a310 <pidControllerApply+0x250>)
 800a2a0:	9300      	str	r3, [sp, #0]
 800a2a2:	e75b      	b.n	800a15c <pidControllerApply+0x9c>
  g_motorOffset[cmd_id] = circadjust(g_motorOffset[cmd_id], M_PI);
  /* Update motor position: */
  float cmd = PID[cmd_id].prevCmd + step;
  /* Normalize command to -M_PI..M_PI range: */
  if (cmd < 0.0f) {
    cmd = fmodf(cmd - M_PI, -M_TWOPI) + M_PI;
 800a2a4:	4638      	mov	r0, r7
 800a2a6:	f7f6 f93f 	bl	8000528 <__aeabi_f2d>
 800a2aa:	a313      	add	r3, pc, #76	; (adr r3, 800a2f8 <pidControllerApply+0x238>)
 800a2ac:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a2b0:	f7f5 ffda 	bl	8000268 <__aeabi_dsub>
 800a2b4:	f7f6 fc54 	bl	8000b60 <__aeabi_d2f>
 800a2b8:	4916      	ldr	r1, [pc, #88]	; (800a314 <pidControllerApply+0x254>)
 800a2ba:	f001 fd31 	bl	800bd20 <fmodf>
 800a2be:	f7f6 f933 	bl	8000528 <__aeabi_f2d>
 800a2c2:	a30d      	add	r3, pc, #52	; (adr r3, 800a2f8 <pidControllerApply+0x238>)
 800a2c4:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a2c8:	f7f5 ffd0 	bl	800026c <__adddf3>
 800a2cc:	f7f6 fc48 	bl	8000b60 <__aeabi_d2f>
 800a2d0:	e7ad      	b.n	800a22e <pidControllerApply+0x16e>
 800a2d2:	bf00      	nop
 800a2d4:	f3af 8000 	nop.w
 800a2d8:	54442d18 	.word	0x54442d18
 800a2dc:	c00921fb 	.word	0xc00921fb
 800a2e0:	54442d18 	.word	0x54442d18
 800a2e4:	401921fb 	.word	0x401921fb
 800a2e8:	a2529d39 	.word	0xa2529d39
 800a2ec:	bfb1df46 	.word	0xbfb1df46
 800a2f0:	a2529d39 	.word	0xa2529d39
 800a2f4:	3fb1df46 	.word	0x3fb1df46
 800a2f8:	54442d18 	.word	0x54442d18
 800a2fc:	400921fb 	.word	0x400921fb
 800a300:	20000808 	.word	0x20000808
 800a304:	20001d54 	.word	0x20001d54
 800a308:	40c90fdb 	.word	0x40c90fdb
 800a30c:	bd8efa35 	.word	0xbd8efa35
 800a310:	3d8efa35 	.word	0x3d8efa35
 800a314:	c0c90fdb 	.word	0xc0c90fdb
 800a318:	20001dc4 	.word	0x20001dc4
 800a31c:	00000000 	.word	0x00000000

0800a320 <accelFilterApply>:
/**
 * @brief  First order low-pass filter.
 * @param  raw - pointer to raw data array;
 * @param  filtered - pointer to filtered data array;
 */
static void accelFilterApply(const float raw[], float filtered[]) {
 800a320:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a322:	460c      	mov	r4, r1
  if (fAccelFilterEnabled) {
    filtered[0] = (filtered[0] - raw[0])*accel_alpha + raw[0];
 800a324:	4b16      	ldr	r3, [pc, #88]	; (800a380 <accelFilterApply+0x60>)
 800a326:	6807      	ldr	r7, [r0, #0]
 800a328:	681d      	ldr	r5, [r3, #0]
/**
 * @brief  First order low-pass filter.
 * @param  raw - pointer to raw data array;
 * @param  filtered - pointer to filtered data array;
 */
static void accelFilterApply(const float raw[], float filtered[]) {
 800a32a:	4606      	mov	r6, r0
  if (fAccelFilterEnabled) {
    filtered[0] = (filtered[0] - raw[0])*accel_alpha + raw[0];
 800a32c:	4639      	mov	r1, r7
 800a32e:	6820      	ldr	r0, [r4, #0]
 800a330:	f7f6 fc6a 	bl	8000c08 <__aeabi_fsub>
 800a334:	4629      	mov	r1, r5
 800a336:	f7f6 fd73 	bl	8000e20 <__aeabi_fmul>
 800a33a:	4601      	mov	r1, r0
 800a33c:	4638      	mov	r0, r7
 800a33e:	f7f6 fc65 	bl	8000c0c <__addsf3>
 800a342:	6020      	str	r0, [r4, #0]
    filtered[1] = (filtered[1] - raw[1])*accel_alpha + raw[1];
 800a344:	6877      	ldr	r7, [r6, #4]
 800a346:	6860      	ldr	r0, [r4, #4]
 800a348:	4639      	mov	r1, r7
 800a34a:	f7f6 fc5d 	bl	8000c08 <__aeabi_fsub>
 800a34e:	4601      	mov	r1, r0
 800a350:	4628      	mov	r0, r5
 800a352:	f7f6 fd65 	bl	8000e20 <__aeabi_fmul>
 800a356:	4601      	mov	r1, r0
 800a358:	4638      	mov	r0, r7
 800a35a:	f7f6 fc57 	bl	8000c0c <__addsf3>
 800a35e:	6060      	str	r0, [r4, #4]
    filtered[2] = (filtered[2] - raw[2])*accel_alpha + raw[2];
 800a360:	68b6      	ldr	r6, [r6, #8]
 800a362:	68a0      	ldr	r0, [r4, #8]
 800a364:	4631      	mov	r1, r6
 800a366:	f7f6 fc4f 	bl	8000c08 <__aeabi_fsub>
 800a36a:	4601      	mov	r1, r0
 800a36c:	4628      	mov	r0, r5
 800a36e:	f7f6 fd57 	bl	8000e20 <__aeabi_fmul>
 800a372:	4601      	mov	r1, r0
 800a374:	4630      	mov	r0, r6
 800a376:	f7f6 fc49 	bl	8000c0c <__addsf3>
 800a37a:	60a0      	str	r0, [r4, #8]
 800a37c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a37e:	bf00      	nop
 800a380:	20001db4 	.word	0x20001db4
	...

0800a390 <attitudeInit>:
}

/**
 * @brief
 */
void attitudeInit(void) {
 800a390:	b538      	push	{r3, r4, r5, lr}

/**
 * @brief
 */
static void cfUpdateSettings(void) {
  accel2Kp = g_cfSettings[0] * 0.1f;
 800a392:	4c0e      	ldr	r4, [pc, #56]	; (800a3cc <attitudeInit+0x3c>)

/**
 * @brief
 */
void attitudeInit(void) {
  memset((void *)PID, 0, sizeof(PID));
 800a394:	2248      	movs	r2, #72	; 0x48
 800a396:	2100      	movs	r1, #0
 800a398:	480d      	ldr	r0, [pc, #52]	; (800a3d0 <attitudeInit+0x40>)
 800a39a:	f002 ffd9 	bl	800d350 <memset>
  pidUpdateStruct();
 800a39e:	f7ff fde7 	bl	8009f70 <pidUpdateStruct>

/**
 * @brief
 */
static void cfUpdateSettings(void) {
  accel2Kp = g_cfSettings[0] * 0.1f;
 800a3a2:	8820      	ldrh	r0, [r4, #0]
 800a3a4:	f7f6 fce6 	bl	8000d74 <__aeabi_i2f>
 800a3a8:	490a      	ldr	r1, [pc, #40]	; (800a3d4 <attitudeInit+0x44>)
 800a3aa:	f7f6 fd39 	bl	8000e20 <__aeabi_fmul>
 800a3ae:	4b0a      	ldr	r3, [pc, #40]	; (800a3d8 <attitudeInit+0x48>)
  accel2Ki = g_cfSettings[1] * 0.00001f;
 800a3b0:	4d0a      	ldr	r5, [pc, #40]	; (800a3dc <attitudeInit+0x4c>)

/**
 * @brief
 */
static void cfUpdateSettings(void) {
  accel2Kp = g_cfSettings[0] * 0.1f;
 800a3b2:	6018      	str	r0, [r3, #0]
  accel2Ki = g_cfSettings[1] * 0.00001f;
 800a3b4:	8860      	ldrh	r0, [r4, #2]
 800a3b6:	f7f6 fcdd 	bl	8000d74 <__aeabi_i2f>
 800a3ba:	4909      	ldr	r1, [pc, #36]	; (800a3e0 <attitudeInit+0x50>)
 800a3bc:	f7f6 fd30 	bl	8000e20 <__aeabi_fmul>
 */
void attitudeInit(void) {
  memset((void *)PID, 0, sizeof(PID));
  pidUpdateStruct();
  cfUpdateSettings();
  accel_alpha = expf(-FIXED_DT_STEP / ACCEL_TAU);
 800a3c0:	4b08      	ldr	r3, [pc, #32]	; (800a3e4 <attitudeInit+0x54>)
 800a3c2:	4a09      	ldr	r2, [pc, #36]	; (800a3e8 <attitudeInit+0x58>)
/**
 * @brief
 */
static void cfUpdateSettings(void) {
  accel2Kp = g_cfSettings[0] * 0.1f;
  accel2Ki = g_cfSettings[1] * 0.00001f;
 800a3c4:	6028      	str	r0, [r5, #0]
 */
void attitudeInit(void) {
  memset((void *)PID, 0, sizeof(PID));
  pidUpdateStruct();
  cfUpdateSettings();
  accel_alpha = expf(-FIXED_DT_STEP / ACCEL_TAU);
 800a3c6:	601a      	str	r2, [r3, #0]
 800a3c8:	bd38      	pop	{r3, r4, r5, pc}
 800a3ca:	bf00      	nop
 800a3cc:	20000900 	.word	0x20000900
 800a3d0:	20001d54 	.word	0x20001d54
 800a3d4:	3dcccccd 	.word	0x3dcccccd
 800a3d8:	200008fc 	.word	0x200008fc
 800a3dc:	20000904 	.word	0x20000904
 800a3e0:	3727c5ac 	.word	0x3727c5ac
 800a3e4:	20001db4 	.word	0x20001db4
 800a3e8:	3f7c304c 	.word	0x3f7c304c
 800a3ec:	00000000 	.word	0x00000000

0800a3f0 <attitudeUpdate>:
}

/**
 * @brief
 */
__attribute__((optimize("O3"))) void attitudeUpdate(PIMUStruct pIMU) {
 800a3f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a3f4:	4604      	mov	r4, r0
 800a3f6:	b08b      	sub	sp, #44	; 0x2c
  float accelErr[3] = {0.0f};
  float mag;
  float dq[4];

  pIMU->accelData[0] -= pIMU->accelBias[0];
 800a3f8:	69a1      	ldr	r1, [r4, #24]

/**
 * @brief
 */
__attribute__((optimize("O3"))) void attitudeUpdate(PIMUStruct pIMU) {
  float accelErr[3] = {0.0f};
 800a3fa:	2300      	movs	r3, #0
  float mag;
  float dq[4];

  pIMU->accelData[0] -= pIMU->accelBias[0];
 800a3fc:	6800      	ldr	r0, [r0, #0]

/**
 * @brief
 */
__attribute__((optimize("O3"))) void attitudeUpdate(PIMUStruct pIMU) {
  float accelErr[3] = {0.0f};
 800a3fe:	9304      	str	r3, [sp, #16]
 800a400:	9305      	str	r3, [sp, #20]
 800a402:	9306      	str	r3, [sp, #24]
  float mag;
  float dq[4];

  pIMU->accelData[0] -= pIMU->accelBias[0];
 800a404:	f7f6 fc00 	bl	8000c08 <__aeabi_fsub>
  pIMU->accelData[1] -= pIMU->accelBias[1];
 800a408:	6863      	ldr	r3, [r4, #4]
__attribute__((optimize("O3"))) void attitudeUpdate(PIMUStruct pIMU) {
  float accelErr[3] = {0.0f};
  float mag;
  float dq[4];

  pIMU->accelData[0] -= pIMU->accelBias[0];
 800a40a:	4605      	mov	r5, r0
  pIMU->accelData[1] -= pIMU->accelBias[1];
 800a40c:	69e1      	ldr	r1, [r4, #28]
__attribute__((optimize("O3"))) void attitudeUpdate(PIMUStruct pIMU) {
  float accelErr[3] = {0.0f};
  float mag;
  float dq[4];

  pIMU->accelData[0] -= pIMU->accelBias[0];
 800a40e:	6020      	str	r0, [r4, #0]
  pIMU->accelData[1] -= pIMU->accelBias[1];
 800a410:	4618      	mov	r0, r3
 800a412:	f7f6 fbf9 	bl	8000c08 <__aeabi_fsub>
  pIMU->accelData[2] -= pIMU->accelBias[2];
 800a416:	68a3      	ldr	r3, [r4, #8]
  float accelErr[3] = {0.0f};
  float mag;
  float dq[4];

  pIMU->accelData[0] -= pIMU->accelBias[0];
  pIMU->accelData[1] -= pIMU->accelBias[1];
 800a418:	4607      	mov	r7, r0
  pIMU->accelData[2] -= pIMU->accelBias[2];
 800a41a:	6a21      	ldr	r1, [r4, #32]
  float accelErr[3] = {0.0f};
  float mag;
  float dq[4];

  pIMU->accelData[0] -= pIMU->accelBias[0];
  pIMU->accelData[1] -= pIMU->accelBias[1];
 800a41c:	6060      	str	r0, [r4, #4]
  pIMU->accelData[2] -= pIMU->accelBias[2];
 800a41e:	4618      	mov	r0, r3
 800a420:	f7f6 fbf2 	bl	8000c08 <__aeabi_fsub>

  // Account for accel's magnitude.
  mag = QInvSqrtf(pIMU->accelData[0]*pIMU->accelData[0] + pIMU->accelData[1]*pIMU->accelData[1] + pIMU->accelData[2]*pIMU->accelData[2]);
 800a424:	4629      	mov	r1, r5
  float mag;
  float dq[4];

  pIMU->accelData[0] -= pIMU->accelBias[0];
  pIMU->accelData[1] -= pIMU->accelBias[1];
  pIMU->accelData[2] -= pIMU->accelBias[2];
 800a426:	4606      	mov	r6, r0
 800a428:	60a0      	str	r0, [r4, #8]

  // Account for accel's magnitude.
  mag = QInvSqrtf(pIMU->accelData[0]*pIMU->accelData[0] + pIMU->accelData[1]*pIMU->accelData[1] + pIMU->accelData[2]*pIMU->accelData[2]);
 800a42a:	4628      	mov	r0, r5
 800a42c:	f7f6 fcf8 	bl	8000e20 <__aeabi_fmul>
 800a430:	4639      	mov	r1, r7
 800a432:	4605      	mov	r5, r0
 800a434:	4638      	mov	r0, r7
 800a436:	f7f6 fcf3 	bl	8000e20 <__aeabi_fmul>
 800a43a:	4601      	mov	r1, r0
 800a43c:	4628      	mov	r0, r5
 800a43e:	f7f6 fbe5 	bl	8000c0c <__addsf3>
 800a442:	4631      	mov	r1, r6
 800a444:	4605      	mov	r5, r0
 800a446:	4630      	mov	r0, r6
 800a448:	f7f6 fcea 	bl	8000e20 <__aeabi_fmul>
 800a44c:	4601      	mov	r1, r0
 800a44e:	4628      	mov	r0, r5
 800a450:	f7f6 fbdc 	bl	8000c0c <__addsf3>
 800a454:	f7ff fd3c 	bl	8009ed0 <QInvSqrtf>

  if ((mag > 0.0724f) && (mag < 0.1724f)) {
 800a458:	49a5      	ldr	r1, [pc, #660]	; (800a6f0 <attitudeUpdate+0x300>)
  pIMU->accelData[0] -= pIMU->accelBias[0];
  pIMU->accelData[1] -= pIMU->accelBias[1];
  pIMU->accelData[2] -= pIMU->accelBias[2];

  // Account for accel's magnitude.
  mag = QInvSqrtf(pIMU->accelData[0]*pIMU->accelData[0] + pIMU->accelData[1]*pIMU->accelData[1] + pIMU->accelData[2]*pIMU->accelData[2]);
 800a45a:	4605      	mov	r5, r0

  if ((mag > 0.0724f) && (mag < 0.1724f)) {
 800a45c:	f7f6 fe9c 	bl	8001198 <__aeabi_fcmpgt>
 800a460:	b130      	cbz	r0, 800a470 <attitudeUpdate+0x80>
 800a462:	4628      	mov	r0, r5
 800a464:	49a3      	ldr	r1, [pc, #652]	; (800a6f4 <attitudeUpdate+0x304>)
 800a466:	f7f6 fe79 	bl	800115c <__aeabi_fcmplt>
 800a46a:	2800      	cmp	r0, #0
 800a46c:	f040 8148 	bne.w	800a700 <attitudeUpdate+0x310>
 800a470:	2500      	movs	r5, #0
 800a472:	462f      	mov	r7, r5
 800a474:	46a8      	mov	r8, r5
    accelErr[1] *= mag;
    accelErr[2] *= mag;
  }

  // Correct rates based on error.
  pIMU->gyroBias[0] -= accelErr[0]*accel2Ki;
 800a476:	4ba0      	ldr	r3, [pc, #640]	; (800a6f8 <attitudeUpdate+0x308>)
 800a478:	4641      	mov	r1, r8
 800a47a:	681e      	ldr	r6, [r3, #0]
 800a47c:	f8d4 9024 	ldr.w	r9, [r4, #36]	; 0x24
 800a480:	4630      	mov	r0, r6
 800a482:	f7f6 fccd 	bl	8000e20 <__aeabi_fmul>
 800a486:	4601      	mov	r1, r0
 800a488:	4648      	mov	r0, r9
 800a48a:	f7f6 fbbd 	bl	8000c08 <__aeabi_fsub>
  pIMU->gyroBias[1] -= accelErr[1]*accel2Ki;
 800a48e:	4639      	mov	r1, r7
    accelErr[1] *= mag;
    accelErr[2] *= mag;
  }

  // Correct rates based on error.
  pIMU->gyroBias[0] -= accelErr[0]*accel2Ki;
 800a490:	4683      	mov	fp, r0
 800a492:	6260      	str	r0, [r4, #36]	; 0x24
  pIMU->gyroBias[1] -= accelErr[1]*accel2Ki;
 800a494:	4630      	mov	r0, r6
 800a496:	f7f6 fcc3 	bl	8000e20 <__aeabi_fmul>
 800a49a:	f8d4 9028 	ldr.w	r9, [r4, #40]	; 0x28
 800a49e:	4601      	mov	r1, r0
 800a4a0:	4648      	mov	r0, r9
 800a4a2:	f7f6 fbb1 	bl	8000c08 <__aeabi_fsub>
  pIMU->gyroBias[2] -= accelErr[2]*accel2Ki;
 800a4a6:	4629      	mov	r1, r5
    accelErr[2] *= mag;
  }

  // Correct rates based on error.
  pIMU->gyroBias[0] -= accelErr[0]*accel2Ki;
  pIMU->gyroBias[1] -= accelErr[1]*accel2Ki;
 800a4a8:	4681      	mov	r9, r0
 800a4aa:	62a0      	str	r0, [r4, #40]	; 0x28
  pIMU->gyroBias[2] -= accelErr[2]*accel2Ki;
 800a4ac:	4630      	mov	r0, r6
 800a4ae:	f7f6 fcb7 	bl	8000e20 <__aeabi_fmul>
 800a4b2:	f8d4 a02c 	ldr.w	sl, [r4, #44]	; 0x2c
 800a4b6:	4601      	mov	r1, r0
 800a4b8:	4650      	mov	r0, sl
 800a4ba:	f7f6 fba5 	bl	8000c08 <__aeabi_fsub>

  pIMU->gyroData[0] -= pIMU->gyroBias[0];
  pIMU->gyroData[1] -= pIMU->gyroBias[1];
 800a4be:	6923      	ldr	r3, [r4, #16]
  }

  // Correct rates based on error.
  pIMU->gyroBias[0] -= accelErr[0]*accel2Ki;
  pIMU->gyroBias[1] -= accelErr[1]*accel2Ki;
  pIMU->gyroBias[2] -= accelErr[2]*accel2Ki;
 800a4c0:	4606      	mov	r6, r0
 800a4c2:	62e0      	str	r0, [r4, #44]	; 0x2c

  pIMU->gyroData[0] -= pIMU->gyroBias[0];
  pIMU->gyroData[1] -= pIMU->gyroBias[1];
 800a4c4:	4649      	mov	r1, r9
 800a4c6:	4618      	mov	r0, r3
 800a4c8:	f7f6 fb9e 	bl	8000c08 <__aeabi_fsub>
  pIMU->gyroData[2] -= pIMU->gyroBias[2];
 800a4cc:	4631      	mov	r1, r6
  pIMU->gyroBias[0] -= accelErr[0]*accel2Ki;
  pIMU->gyroBias[1] -= accelErr[1]*accel2Ki;
  pIMU->gyroBias[2] -= accelErr[2]*accel2Ki;

  pIMU->gyroData[0] -= pIMU->gyroBias[0];
  pIMU->gyroData[1] -= pIMU->gyroBias[1];
 800a4ce:	4682      	mov	sl, r0
  pIMU->gyroData[2] -= pIMU->gyroBias[2];
 800a4d0:	6960      	ldr	r0, [r4, #20]
 800a4d2:	f7f6 fb99 	bl	8000c08 <__aeabi_fsub>

  // Correct rates based on error.
  pIMU->gyroData[0] += accelErr[0]*accel2Kp;
 800a4d6:	4b89      	ldr	r3, [pc, #548]	; (800a6fc <attitudeUpdate+0x30c>)
  pIMU->gyroBias[1] -= accelErr[1]*accel2Ki;
  pIMU->gyroBias[2] -= accelErr[2]*accel2Ki;

  pIMU->gyroData[0] -= pIMU->gyroBias[0];
  pIMU->gyroData[1] -= pIMU->gyroBias[1];
  pIMU->gyroData[2] -= pIMU->gyroBias[2];
 800a4d8:	4681      	mov	r9, r0
  // Correct rates based on error.
  pIMU->gyroBias[0] -= accelErr[0]*accel2Ki;
  pIMU->gyroBias[1] -= accelErr[1]*accel2Ki;
  pIMU->gyroBias[2] -= accelErr[2]*accel2Ki;

  pIMU->gyroData[0] -= pIMU->gyroBias[0];
 800a4da:	4659      	mov	r1, fp
 800a4dc:	68e0      	ldr	r0, [r4, #12]
  pIMU->gyroData[1] -= pIMU->gyroBias[1];
  pIMU->gyroData[2] -= pIMU->gyroBias[2];

  // Correct rates based on error.
  pIMU->gyroData[0] += accelErr[0]*accel2Kp;
 800a4de:	681e      	ldr	r6, [r3, #0]
  // Correct rates based on error.
  pIMU->gyroBias[0] -= accelErr[0]*accel2Ki;
  pIMU->gyroBias[1] -= accelErr[1]*accel2Ki;
  pIMU->gyroBias[2] -= accelErr[2]*accel2Ki;

  pIMU->gyroData[0] -= pIMU->gyroBias[0];
 800a4e0:	f7f6 fb92 	bl	8000c08 <__aeabi_fsub>
  pIMU->gyroData[1] -= pIMU->gyroBias[1];
  pIMU->gyroData[2] -= pIMU->gyroBias[2];

  // Correct rates based on error.
  pIMU->gyroData[0] += accelErr[0]*accel2Kp;
 800a4e4:	4641      	mov	r1, r8
  // Correct rates based on error.
  pIMU->gyroBias[0] -= accelErr[0]*accel2Ki;
  pIMU->gyroBias[1] -= accelErr[1]*accel2Ki;
  pIMU->gyroBias[2] -= accelErr[2]*accel2Ki;

  pIMU->gyroData[0] -= pIMU->gyroBias[0];
 800a4e6:	4683      	mov	fp, r0
  pIMU->gyroData[1] -= pIMU->gyroBias[1];
  pIMU->gyroData[2] -= pIMU->gyroBias[2];

  // Correct rates based on error.
  pIMU->gyroData[0] += accelErr[0]*accel2Kp;
 800a4e8:	4630      	mov	r0, r6
 800a4ea:	f7f6 fc99 	bl	8000e20 <__aeabi_fmul>
 800a4ee:	4601      	mov	r1, r0
 800a4f0:	4658      	mov	r0, fp
 800a4f2:	f7f6 fb8b 	bl	8000c0c <__addsf3>
  pIMU->gyroData[1] += accelErr[1]*accel2Kp;
 800a4f6:	4639      	mov	r1, r7
  pIMU->gyroData[0] -= pIMU->gyroBias[0];
  pIMU->gyroData[1] -= pIMU->gyroBias[1];
  pIMU->gyroData[2] -= pIMU->gyroBias[2];

  // Correct rates based on error.
  pIMU->gyroData[0] += accelErr[0]*accel2Kp;
 800a4f8:	4683      	mov	fp, r0
 800a4fa:	60e0      	str	r0, [r4, #12]
  pIMU->gyroData[1] += accelErr[1]*accel2Kp;
 800a4fc:	4630      	mov	r0, r6
 800a4fe:	f7f6 fc8f 	bl	8000e20 <__aeabi_fmul>
 800a502:	4601      	mov	r1, r0
 800a504:	4650      	mov	r0, sl
 800a506:	f7f6 fb81 	bl	8000c0c <__addsf3>
  pIMU->gyroData[2] += accelErr[2]*accel2Kp;
 800a50a:	4629      	mov	r1, r5
  pIMU->gyroData[1] -= pIMU->gyroBias[1];
  pIMU->gyroData[2] -= pIMU->gyroBias[2];

  // Correct rates based on error.
  pIMU->gyroData[0] += accelErr[0]*accel2Kp;
  pIMU->gyroData[1] += accelErr[1]*accel2Kp;
 800a50c:	4682      	mov	sl, r0
 800a50e:	6120      	str	r0, [r4, #16]
  pIMU->gyroData[2] += accelErr[2]*accel2Kp;
 800a510:	4630      	mov	r0, r6
 800a512:	f7f6 fc85 	bl	8000e20 <__aeabi_fmul>
 800a516:	4601      	mov	r1, r0
 800a518:	4648      	mov	r0, r9
 800a51a:	f7f6 fb77 	bl	8000c0c <__addsf3>

  dq[0] = (-pIMU->qIMU[1]*pIMU->gyroData[0] - pIMU->qIMU[2]*pIMU->gyroData[1] - pIMU->qIMU[3]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
 800a51e:	f8d4 904c 	ldr.w	r9, [r4, #76]	; 0x4c
  pIMU->gyroData[2] -= pIMU->gyroBias[2];

  // Correct rates based on error.
  pIMU->gyroData[0] += accelErr[0]*accel2Kp;
  pIMU->gyroData[1] += accelErr[1]*accel2Kp;
  pIMU->gyroData[2] += accelErr[2]*accel2Kp;
 800a522:	4680      	mov	r8, r0
 800a524:	6160      	str	r0, [r4, #20]

  dq[0] = (-pIMU->qIMU[1]*pIMU->gyroData[0] - pIMU->qIMU[2]*pIMU->gyroData[1] - pIMU->qIMU[3]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
 800a526:	f109 4100 	add.w	r1, r9, #2147483648	; 0x80000000
 800a52a:	4658      	mov	r0, fp
 800a52c:	f7f6 fc78 	bl	8000e20 <__aeabi_fmul>
 800a530:	6d25      	ldr	r5, [r4, #80]	; 0x50
 800a532:	4606      	mov	r6, r0
 800a534:	4629      	mov	r1, r5
 800a536:	4650      	mov	r0, sl
 800a538:	f7f6 fc72 	bl	8000e20 <__aeabi_fmul>
 800a53c:	4601      	mov	r1, r0
 800a53e:	4630      	mov	r0, r6
 800a540:	f7f6 fb62 	bl	8000c08 <__aeabi_fsub>
 800a544:	6d66      	ldr	r6, [r4, #84]	; 0x54
 800a546:	4607      	mov	r7, r0
 800a548:	4631      	mov	r1, r6
 800a54a:	4640      	mov	r0, r8
 800a54c:	f7f6 fc68 	bl	8000e20 <__aeabi_fmul>
 800a550:	4601      	mov	r1, r0
 800a552:	4638      	mov	r0, r7
 800a554:	f7f6 fb58 	bl	8000c08 <__aeabi_fsub>
 800a558:	f7f5 ffe6 	bl	8000528 <__aeabi_f2d>
 800a55c:	a362      	add	r3, pc, #392	; (adr r3, 800a6e8 <attitudeUpdate+0x2f8>)
 800a55e:	e9d3 2300 	ldrd	r2, r3, [r3]
  dq[1] = ( pIMU->qIMU[0]*pIMU->gyroData[0] - pIMU->qIMU[3]*pIMU->gyroData[1] + pIMU->qIMU[2]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
 800a562:	6ca7      	ldr	r7, [r4, #72]	; 0x48
  // Correct rates based on error.
  pIMU->gyroData[0] += accelErr[0]*accel2Kp;
  pIMU->gyroData[1] += accelErr[1]*accel2Kp;
  pIMU->gyroData[2] += accelErr[2]*accel2Kp;

  dq[0] = (-pIMU->qIMU[1]*pIMU->gyroData[0] - pIMU->qIMU[2]*pIMU->gyroData[1] - pIMU->qIMU[3]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
 800a564:	f7f6 f834 	bl	80005d0 <__aeabi_dmul>
 800a568:	f7f6 fafa 	bl	8000b60 <__aeabi_d2f>
  dq[1] = ( pIMU->qIMU[0]*pIMU->gyroData[0] - pIMU->qIMU[3]*pIMU->gyroData[1] + pIMU->qIMU[2]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
  dq[2] = ( pIMU->qIMU[3]*pIMU->gyroData[0] + pIMU->qIMU[0]*pIMU->gyroData[1] - pIMU->qIMU[1]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
  dq[3] = (-pIMU->qIMU[2]*pIMU->gyroData[0] + pIMU->qIMU[1]*pIMU->gyroData[1] + pIMU->qIMU[0]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);

  pIMU->qIMU[0] += dq[0];
 800a56c:	4639      	mov	r1, r7
 800a56e:	f7f6 fb4d 	bl	8000c0c <__addsf3>
  pIMU->gyroData[0] += accelErr[0]*accel2Kp;
  pIMU->gyroData[1] += accelErr[1]*accel2Kp;
  pIMU->gyroData[2] += accelErr[2]*accel2Kp;

  dq[0] = (-pIMU->qIMU[1]*pIMU->gyroData[0] - pIMU->qIMU[2]*pIMU->gyroData[1] - pIMU->qIMU[3]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
  dq[1] = ( pIMU->qIMU[0]*pIMU->gyroData[0] - pIMU->qIMU[3]*pIMU->gyroData[1] + pIMU->qIMU[2]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
 800a572:	4639      	mov	r1, r7
  dq[2] = ( pIMU->qIMU[3]*pIMU->gyroData[0] + pIMU->qIMU[0]*pIMU->gyroData[1] - pIMU->qIMU[1]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
  dq[3] = (-pIMU->qIMU[2]*pIMU->gyroData[0] + pIMU->qIMU[1]*pIMU->gyroData[1] + pIMU->qIMU[0]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);

  pIMU->qIMU[0] += dq[0];
 800a574:	9001      	str	r0, [sp, #4]
  pIMU->gyroData[0] += accelErr[0]*accel2Kp;
  pIMU->gyroData[1] += accelErr[1]*accel2Kp;
  pIMU->gyroData[2] += accelErr[2]*accel2Kp;

  dq[0] = (-pIMU->qIMU[1]*pIMU->gyroData[0] - pIMU->qIMU[2]*pIMU->gyroData[1] - pIMU->qIMU[3]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
  dq[1] = ( pIMU->qIMU[0]*pIMU->gyroData[0] - pIMU->qIMU[3]*pIMU->gyroData[1] + pIMU->qIMU[2]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
 800a576:	4658      	mov	r0, fp
 800a578:	f7f6 fc52 	bl	8000e20 <__aeabi_fmul>
 800a57c:	4631      	mov	r1, r6
 800a57e:	9002      	str	r0, [sp, #8]
 800a580:	4650      	mov	r0, sl
 800a582:	f7f6 fc4d 	bl	8000e20 <__aeabi_fmul>
 800a586:	9b02      	ldr	r3, [sp, #8]
 800a588:	4601      	mov	r1, r0
 800a58a:	4618      	mov	r0, r3
 800a58c:	f7f6 fb3c 	bl	8000c08 <__aeabi_fsub>
 800a590:	4629      	mov	r1, r5
 800a592:	9002      	str	r0, [sp, #8]
 800a594:	4640      	mov	r0, r8
 800a596:	f7f6 fc43 	bl	8000e20 <__aeabi_fmul>
 800a59a:	9b02      	ldr	r3, [sp, #8]
 800a59c:	4601      	mov	r1, r0
 800a59e:	4618      	mov	r0, r3
 800a5a0:	f7f6 fb34 	bl	8000c0c <__addsf3>
 800a5a4:	f7f5 ffc0 	bl	8000528 <__aeabi_f2d>
 800a5a8:	a34f      	add	r3, pc, #316	; (adr r3, 800a6e8 <attitudeUpdate+0x2f8>)
 800a5aa:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a5ae:	f7f6 f80f 	bl	80005d0 <__aeabi_dmul>
 800a5b2:	f7f6 fad5 	bl	8000b60 <__aeabi_d2f>
 800a5b6:	4601      	mov	r1, r0
  dq[2] = ( pIMU->qIMU[3]*pIMU->gyroData[0] + pIMU->qIMU[0]*pIMU->gyroData[1] - pIMU->qIMU[1]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
  dq[3] = (-pIMU->qIMU[2]*pIMU->gyroData[0] + pIMU->qIMU[1]*pIMU->gyroData[1] + pIMU->qIMU[0]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);

  pIMU->qIMU[0] += dq[0];
  pIMU->qIMU[1] += dq[1];
 800a5b8:	4648      	mov	r0, r9
 800a5ba:	f7f6 fb27 	bl	8000c0c <__addsf3>
  pIMU->gyroData[1] += accelErr[1]*accel2Kp;
  pIMU->gyroData[2] += accelErr[2]*accel2Kp;

  dq[0] = (-pIMU->qIMU[1]*pIMU->gyroData[0] - pIMU->qIMU[2]*pIMU->gyroData[1] - pIMU->qIMU[3]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
  dq[1] = ( pIMU->qIMU[0]*pIMU->gyroData[0] - pIMU->qIMU[3]*pIMU->gyroData[1] + pIMU->qIMU[2]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
  dq[2] = ( pIMU->qIMU[3]*pIMU->gyroData[0] + pIMU->qIMU[0]*pIMU->gyroData[1] - pIMU->qIMU[1]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
 800a5be:	4631      	mov	r1, r6
  dq[3] = (-pIMU->qIMU[2]*pIMU->gyroData[0] + pIMU->qIMU[1]*pIMU->gyroData[1] + pIMU->qIMU[0]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);

  pIMU->qIMU[0] += dq[0];
  pIMU->qIMU[1] += dq[1];
 800a5c0:	9002      	str	r0, [sp, #8]
  pIMU->gyroData[1] += accelErr[1]*accel2Kp;
  pIMU->gyroData[2] += accelErr[2]*accel2Kp;

  dq[0] = (-pIMU->qIMU[1]*pIMU->gyroData[0] - pIMU->qIMU[2]*pIMU->gyroData[1] - pIMU->qIMU[3]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
  dq[1] = ( pIMU->qIMU[0]*pIMU->gyroData[0] - pIMU->qIMU[3]*pIMU->gyroData[1] + pIMU->qIMU[2]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
  dq[2] = ( pIMU->qIMU[3]*pIMU->gyroData[0] + pIMU->qIMU[0]*pIMU->gyroData[1] - pIMU->qIMU[1]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
 800a5c2:	4658      	mov	r0, fp
 800a5c4:	f7f6 fc2c 	bl	8000e20 <__aeabi_fmul>
 800a5c8:	4639      	mov	r1, r7
 800a5ca:	9003      	str	r0, [sp, #12]
 800a5cc:	4650      	mov	r0, sl
 800a5ce:	f7f6 fc27 	bl	8000e20 <__aeabi_fmul>
 800a5d2:	9b03      	ldr	r3, [sp, #12]
 800a5d4:	4601      	mov	r1, r0
 800a5d6:	4618      	mov	r0, r3
 800a5d8:	f7f6 fb18 	bl	8000c0c <__addsf3>
 800a5dc:	4649      	mov	r1, r9
 800a5de:	9003      	str	r0, [sp, #12]
 800a5e0:	4640      	mov	r0, r8
 800a5e2:	f7f6 fc1d 	bl	8000e20 <__aeabi_fmul>
 800a5e6:	9b03      	ldr	r3, [sp, #12]
 800a5e8:	4601      	mov	r1, r0
 800a5ea:	4618      	mov	r0, r3
 800a5ec:	f7f6 fb0c 	bl	8000c08 <__aeabi_fsub>
 800a5f0:	f7f5 ff9a 	bl	8000528 <__aeabi_f2d>
 800a5f4:	a33c      	add	r3, pc, #240	; (adr r3, 800a6e8 <attitudeUpdate+0x2f8>)
 800a5f6:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a5fa:	f7f5 ffe9 	bl	80005d0 <__aeabi_dmul>
 800a5fe:	f7f6 faaf 	bl	8000b60 <__aeabi_d2f>
 800a602:	4601      	mov	r1, r0
  dq[3] = (-pIMU->qIMU[2]*pIMU->gyroData[0] + pIMU->qIMU[1]*pIMU->gyroData[1] + pIMU->qIMU[0]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);

  pIMU->qIMU[0] += dq[0];
  pIMU->qIMU[1] += dq[1];
  pIMU->qIMU[2] += dq[2];
 800a604:	4628      	mov	r0, r5
 800a606:	f7f6 fb01 	bl	8000c0c <__addsf3>
  pIMU->gyroData[2] += accelErr[2]*accel2Kp;

  dq[0] = (-pIMU->qIMU[1]*pIMU->gyroData[0] - pIMU->qIMU[2]*pIMU->gyroData[1] - pIMU->qIMU[3]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
  dq[1] = ( pIMU->qIMU[0]*pIMU->gyroData[0] - pIMU->qIMU[3]*pIMU->gyroData[1] + pIMU->qIMU[2]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
  dq[2] = ( pIMU->qIMU[3]*pIMU->gyroData[0] + pIMU->qIMU[0]*pIMU->gyroData[1] - pIMU->qIMU[1]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
  dq[3] = (-pIMU->qIMU[2]*pIMU->gyroData[0] + pIMU->qIMU[1]*pIMU->gyroData[1] + pIMU->qIMU[0]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
 800a60a:	f105 4100 	add.w	r1, r5, #2147483648	; 0x80000000

  pIMU->qIMU[0] += dq[0];
  pIMU->qIMU[1] += dq[1];
  pIMU->qIMU[2] += dq[2];
 800a60e:	9003      	str	r0, [sp, #12]
  pIMU->gyroData[2] += accelErr[2]*accel2Kp;

  dq[0] = (-pIMU->qIMU[1]*pIMU->gyroData[0] - pIMU->qIMU[2]*pIMU->gyroData[1] - pIMU->qIMU[3]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
  dq[1] = ( pIMU->qIMU[0]*pIMU->gyroData[0] - pIMU->qIMU[3]*pIMU->gyroData[1] + pIMU->qIMU[2]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
  dq[2] = ( pIMU->qIMU[3]*pIMU->gyroData[0] + pIMU->qIMU[0]*pIMU->gyroData[1] - pIMU->qIMU[1]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
  dq[3] = (-pIMU->qIMU[2]*pIMU->gyroData[0] + pIMU->qIMU[1]*pIMU->gyroData[1] + pIMU->qIMU[0]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);
 800a610:	4658      	mov	r0, fp
 800a612:	f7f6 fc05 	bl	8000e20 <__aeabi_fmul>
 800a616:	4649      	mov	r1, r9
 800a618:	4605      	mov	r5, r0
 800a61a:	4650      	mov	r0, sl
 800a61c:	f7f6 fc00 	bl	8000e20 <__aeabi_fmul>
 800a620:	4601      	mov	r1, r0
 800a622:	4628      	mov	r0, r5
 800a624:	f7f6 faf2 	bl	8000c0c <__addsf3>
 800a628:	4639      	mov	r1, r7
 800a62a:	4605      	mov	r5, r0
 800a62c:	4640      	mov	r0, r8
 800a62e:	f7f6 fbf7 	bl	8000e20 <__aeabi_fmul>
 800a632:	4601      	mov	r1, r0
 800a634:	4628      	mov	r0, r5
 800a636:	f7f6 fae9 	bl	8000c0c <__addsf3>
 800a63a:	f7f5 ff75 	bl	8000528 <__aeabi_f2d>
 800a63e:	a32a      	add	r3, pc, #168	; (adr r3, 800a6e8 <attitudeUpdate+0x2f8>)
 800a640:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a644:	f7f5 ffc4 	bl	80005d0 <__aeabi_dmul>
 800a648:	f7f6 fa8a 	bl	8000b60 <__aeabi_d2f>
 800a64c:	4601      	mov	r1, r0

  pIMU->qIMU[0] += dq[0];
  pIMU->qIMU[1] += dq[1];
  pIMU->qIMU[2] += dq[2];
  pIMU->qIMU[3] += dq[3];
 800a64e:	4630      	mov	r0, r6
 800a650:	f7f6 fadc 	bl	8000c0c <__addsf3>

  // Normalize attitude quaternion.
  mag = QInvSqrtf(pIMU->qIMU[0]*pIMU->qIMU[0] + pIMU->qIMU[1]*pIMU->qIMU[1] + pIMU->qIMU[2]*pIMU->qIMU[2] + pIMU->qIMU[3]*pIMU->qIMU[3]);
 800a654:	f8dd 8004 	ldr.w	r8, [sp, #4]
  dq[3] = (-pIMU->qIMU[2]*pIMU->gyroData[0] + pIMU->qIMU[1]*pIMU->gyroData[1] + pIMU->qIMU[0]*pIMU->gyroData[2])*(FIXED_DT_STEP*DEG2RAD*0.5f);

  pIMU->qIMU[0] += dq[0];
  pIMU->qIMU[1] += dq[1];
  pIMU->qIMU[2] += dq[2];
  pIMU->qIMU[3] += dq[3];
 800a658:	4606      	mov	r6, r0

  // Normalize attitude quaternion.
  mag = QInvSqrtf(pIMU->qIMU[0]*pIMU->qIMU[0] + pIMU->qIMU[1]*pIMU->qIMU[1] + pIMU->qIMU[2]*pIMU->qIMU[2] + pIMU->qIMU[3]*pIMU->qIMU[3]);
 800a65a:	4641      	mov	r1, r8
 800a65c:	4640      	mov	r0, r8
 800a65e:	f7f6 fbdf 	bl	8000e20 <__aeabi_fmul>
 800a662:	9f02      	ldr	r7, [sp, #8]
 800a664:	4605      	mov	r5, r0
 800a666:	4639      	mov	r1, r7
 800a668:	4638      	mov	r0, r7
 800a66a:	f7f6 fbd9 	bl	8000e20 <__aeabi_fmul>
 800a66e:	4601      	mov	r1, r0
 800a670:	4628      	mov	r0, r5
 800a672:	f7f6 facb 	bl	8000c0c <__addsf3>
 800a676:	f8dd c00c 	ldr.w	ip, [sp, #12]
 800a67a:	4605      	mov	r5, r0
 800a67c:	4661      	mov	r1, ip
 800a67e:	4660      	mov	r0, ip
 800a680:	f8cd c004 	str.w	ip, [sp, #4]
 800a684:	f7f6 fbcc 	bl	8000e20 <__aeabi_fmul>
 800a688:	4601      	mov	r1, r0
 800a68a:	4628      	mov	r0, r5
 800a68c:	f7f6 fabe 	bl	8000c0c <__addsf3>
 800a690:	4631      	mov	r1, r6
 800a692:	4605      	mov	r5, r0
 800a694:	4630      	mov	r0, r6
 800a696:	f7f6 fbc3 	bl	8000e20 <__aeabi_fmul>
 800a69a:	4601      	mov	r1, r0
 800a69c:	4628      	mov	r0, r5
 800a69e:	f7f6 fab5 	bl	8000c0c <__addsf3>
 800a6a2:	f7ff fc15 	bl	8009ed0 <QInvSqrtf>
 800a6a6:	4605      	mov	r5, r0
  pIMU->qIMU[0] *= mag;
 800a6a8:	4640      	mov	r0, r8
 800a6aa:	4629      	mov	r1, r5
 800a6ac:	f7f6 fbb8 	bl	8000e20 <__aeabi_fmul>
  pIMU->qIMU[1] *= mag;
 800a6b0:	4629      	mov	r1, r5
  pIMU->qIMU[2] += dq[2];
  pIMU->qIMU[3] += dq[3];

  // Normalize attitude quaternion.
  mag = QInvSqrtf(pIMU->qIMU[0]*pIMU->qIMU[0] + pIMU->qIMU[1]*pIMU->qIMU[1] + pIMU->qIMU[2]*pIMU->qIMU[2] + pIMU->qIMU[3]*pIMU->qIMU[3]);
  pIMU->qIMU[0] *= mag;
 800a6b2:	64a0      	str	r0, [r4, #72]	; 0x48
  pIMU->qIMU[1] *= mag;
 800a6b4:	4638      	mov	r0, r7
 800a6b6:	f7f6 fbb3 	bl	8000e20 <__aeabi_fmul>
  pIMU->qIMU[2] *= mag;
 800a6ba:	f8dd c004 	ldr.w	ip, [sp, #4]
 800a6be:	4629      	mov	r1, r5
  pIMU->qIMU[3] += dq[3];

  // Normalize attitude quaternion.
  mag = QInvSqrtf(pIMU->qIMU[0]*pIMU->qIMU[0] + pIMU->qIMU[1]*pIMU->qIMU[1] + pIMU->qIMU[2]*pIMU->qIMU[2] + pIMU->qIMU[3]*pIMU->qIMU[3]);
  pIMU->qIMU[0] *= mag;
  pIMU->qIMU[1] *= mag;
 800a6c0:	64e0      	str	r0, [r4, #76]	; 0x4c
  pIMU->qIMU[2] *= mag;
 800a6c2:	4660      	mov	r0, ip
 800a6c4:	f7f6 fbac 	bl	8000e20 <__aeabi_fmul>
  pIMU->qIMU[3] *= mag;
 800a6c8:	4629      	mov	r1, r5

  // Normalize attitude quaternion.
  mag = QInvSqrtf(pIMU->qIMU[0]*pIMU->qIMU[0] + pIMU->qIMU[1]*pIMU->qIMU[1] + pIMU->qIMU[2]*pIMU->qIMU[2] + pIMU->qIMU[3]*pIMU->qIMU[3]);
  pIMU->qIMU[0] *= mag;
  pIMU->qIMU[1] *= mag;
  pIMU->qIMU[2] *= mag;
 800a6ca:	6520      	str	r0, [r4, #80]	; 0x50
  pIMU->qIMU[3] *= mag;
 800a6cc:	4630      	mov	r0, r6
 800a6ce:	f7f6 fba7 	bl	8000e20 <__aeabi_fmul>

  // Convert attitude into Euler angles;
  Quaternion2RPY(pIMU->qIMU, pIMU->rpy);
 800a6d2:	f104 0158 	add.w	r1, r4, #88	; 0x58
  // Normalize attitude quaternion.
  mag = QInvSqrtf(pIMU->qIMU[0]*pIMU->qIMU[0] + pIMU->qIMU[1]*pIMU->qIMU[1] + pIMU->qIMU[2]*pIMU->qIMU[2] + pIMU->qIMU[3]*pIMU->qIMU[3]);
  pIMU->qIMU[0] *= mag;
  pIMU->qIMU[1] *= mag;
  pIMU->qIMU[2] *= mag;
  pIMU->qIMU[3] *= mag;
 800a6d6:	6560      	str	r0, [r4, #84]	; 0x54

  // Convert attitude into Euler angles;
  Quaternion2RPY(pIMU->qIMU, pIMU->rpy);
 800a6d8:	f104 0048 	add.w	r0, r4, #72	; 0x48
 800a6dc:	f7ff fc80 	bl	8009fe0 <Quaternion2RPY>
}
 800a6e0:	b00b      	add	sp, #44	; 0x2c
 800a6e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a6e6:	bf00      	nop
 800a6e8:	b5a6ab4d 	.word	0xb5a6ab4d
 800a6ec:	3eeb739f 	.word	0x3eeb739f
 800a6f0:	3d944674 	.word	0x3d944674
 800a6f4:	3e3089a0 	.word	0x3e3089a0
 800a6f8:	20000904 	.word	0x20000904
 800a6fc:	200008fc 	.word	0x200008fc
     *
     * Rotated gravity vector v2 is calculated by multiplying gravity
     * vector v={0,0,1} by conjugate (q`) of attitude quaternion (q) (v2=q`vq),
     * because MPU6050 senses gravity in opposite direction.
     */
    v2[0] = (pIMU->qIMU[1]*pIMU->qIMU[3] - pIMU->qIMU[0]*pIMU->qIMU[2]);
 800a700:	6d67      	ldr	r7, [r4, #84]	; 0x54
 800a702:	f8d4 804c 	ldr.w	r8, [r4, #76]	; 0x4c
 800a706:	4639      	mov	r1, r7
 800a708:	4640      	mov	r0, r8
 800a70a:	f7f6 fb89 	bl	8000e20 <__aeabi_fmul>
 800a70e:	6ca6      	ldr	r6, [r4, #72]	; 0x48
 800a710:	f8d4 9050 	ldr.w	r9, [r4, #80]	; 0x50
 800a714:	4682      	mov	sl, r0
 800a716:	4649      	mov	r1, r9
 800a718:	4630      	mov	r0, r6
 800a71a:	f7f6 fb81 	bl	8000e20 <__aeabi_fmul>
 800a71e:	4601      	mov	r1, r0
 800a720:	4650      	mov	r0, sl
 800a722:	f7f6 fa71 	bl	8000c08 <__aeabi_fsub>
    v2[1] = (pIMU->qIMU[2]*pIMU->qIMU[3] + pIMU->qIMU[0]*pIMU->qIMU[1]);
 800a726:	4649      	mov	r1, r9
     *
     * Rotated gravity vector v2 is calculated by multiplying gravity
     * vector v={0,0,1} by conjugate (q`) of attitude quaternion (q) (v2=q`vq),
     * because MPU6050 senses gravity in opposite direction.
     */
    v2[0] = (pIMU->qIMU[1]*pIMU->qIMU[3] - pIMU->qIMU[0]*pIMU->qIMU[2]);
 800a728:	9007      	str	r0, [sp, #28]
    v2[1] = (pIMU->qIMU[2]*pIMU->qIMU[3] + pIMU->qIMU[0]*pIMU->qIMU[1]);
 800a72a:	4638      	mov	r0, r7
 800a72c:	f7f6 fb78 	bl	8000e20 <__aeabi_fmul>
 800a730:	4631      	mov	r1, r6
 800a732:	4681      	mov	r9, r0
 800a734:	4640      	mov	r0, r8
 800a736:	f7f6 fb73 	bl	8000e20 <__aeabi_fmul>
 800a73a:	4601      	mov	r1, r0
 800a73c:	4648      	mov	r0, r9
 800a73e:	f7f6 fa65 	bl	8000c0c <__addsf3>
    v2[2] = (pIMU->qIMU[0]*pIMU->qIMU[0] + pIMU->qIMU[3]*pIMU->qIMU[3]) - 0.5f;
 800a742:	4631      	mov	r1, r6
     * Rotated gravity vector v2 is calculated by multiplying gravity
     * vector v={0,0,1} by conjugate (q`) of attitude quaternion (q) (v2=q`vq),
     * because MPU6050 senses gravity in opposite direction.
     */
    v2[0] = (pIMU->qIMU[1]*pIMU->qIMU[3] - pIMU->qIMU[0]*pIMU->qIMU[2]);
    v2[1] = (pIMU->qIMU[2]*pIMU->qIMU[3] + pIMU->qIMU[0]*pIMU->qIMU[1]);
 800a744:	9008      	str	r0, [sp, #32]
    v2[2] = (pIMU->qIMU[0]*pIMU->qIMU[0] + pIMU->qIMU[3]*pIMU->qIMU[3]) - 0.5f;
 800a746:	4630      	mov	r0, r6
 800a748:	f7f6 fb6a 	bl	8000e20 <__aeabi_fmul>
 800a74c:	4639      	mov	r1, r7
 800a74e:	4606      	mov	r6, r0
 800a750:	4638      	mov	r0, r7
 800a752:	f7f6 fb65 	bl	8000e20 <__aeabi_fmul>
 800a756:	4601      	mov	r1, r0
 800a758:	4630      	mov	r0, r6
 800a75a:	f7f6 fa57 	bl	8000c0c <__addsf3>
 800a75e:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800a762:	f7f6 fa51 	bl	8000c08 <__aeabi_fsub>

    // Apply smoothing to accel values, to reduce vibration noise before main calculations.
    accelFilterApply(pIMU->accelData, pIMU->accelFiltered);
 800a766:	f104 0730 	add.w	r7, r4, #48	; 0x30
 800a76a:	4639      	mov	r1, r7
     * vector v={0,0,1} by conjugate (q`) of attitude quaternion (q) (v2=q`vq),
     * because MPU6050 senses gravity in opposite direction.
     */
    v2[0] = (pIMU->qIMU[1]*pIMU->qIMU[3] - pIMU->qIMU[0]*pIMU->qIMU[2]);
    v2[1] = (pIMU->qIMU[2]*pIMU->qIMU[3] + pIMU->qIMU[0]*pIMU->qIMU[1]);
    v2[2] = (pIMU->qIMU[0]*pIMU->qIMU[0] + pIMU->qIMU[3]*pIMU->qIMU[3]) - 0.5f;
 800a76c:	9009      	str	r0, [sp, #36]	; 0x24

    // Apply smoothing to accel values, to reduce vibration noise before main calculations.
    accelFilterApply(pIMU->accelData, pIMU->accelFiltered);
    // Apply the same filtering to the estimated direction of gravity to match phase shift.
    accelFilterApply(v2, pIMU->v2Filtered);
 800a76e:	f104 063c 	add.w	r6, r4, #60	; 0x3c
    v2[0] = (pIMU->qIMU[1]*pIMU->qIMU[3] - pIMU->qIMU[0]*pIMU->qIMU[2]);
    v2[1] = (pIMU->qIMU[2]*pIMU->qIMU[3] + pIMU->qIMU[0]*pIMU->qIMU[1]);
    v2[2] = (pIMU->qIMU[0]*pIMU->qIMU[0] + pIMU->qIMU[3]*pIMU->qIMU[3]) - 0.5f;

    // Apply smoothing to accel values, to reduce vibration noise before main calculations.
    accelFilterApply(pIMU->accelData, pIMU->accelFiltered);
 800a772:	4620      	mov	r0, r4
 800a774:	f7ff fdd4 	bl	800a320 <accelFilterApply>
    // Apply the same filtering to the estimated direction of gravity to match phase shift.
    accelFilterApply(v2, pIMU->v2Filtered);
 800a778:	4631      	mov	r1, r6
 800a77a:	a807      	add	r0, sp, #28
 800a77c:	f7ff fdd0 	bl	800a320 <accelFilterApply>
    // Compute the error between the predicted direction of gravity and smoothed acceleration.
    CrossProduct(pIMU->accelFiltered, pIMU->v2Filtered, accelErr);
 800a780:	aa04      	add	r2, sp, #16
 800a782:	4638      	mov	r0, r7
 800a784:	4631      	mov	r1, r6
 800a786:	f7ff fbc3 	bl	8009f10 <CrossProduct>

    // Normalize accel_error.
    accelErr[0] *= mag;
 800a78a:	9904      	ldr	r1, [sp, #16]
 800a78c:	4628      	mov	r0, r5
 800a78e:	f7f6 fb47 	bl	8000e20 <__aeabi_fmul>
 800a792:	4680      	mov	r8, r0
    accelErr[1] *= mag;
 800a794:	9905      	ldr	r1, [sp, #20]
 800a796:	4628      	mov	r0, r5
    accelFilterApply(v2, pIMU->v2Filtered);
    // Compute the error between the predicted direction of gravity and smoothed acceleration.
    CrossProduct(pIMU->accelFiltered, pIMU->v2Filtered, accelErr);

    // Normalize accel_error.
    accelErr[0] *= mag;
 800a798:	f8cd 8010 	str.w	r8, [sp, #16]
    accelErr[1] *= mag;
 800a79c:	f7f6 fb40 	bl	8000e20 <__aeabi_fmul>
 800a7a0:	4607      	mov	r7, r0
    accelErr[2] *= mag;
 800a7a2:	9906      	ldr	r1, [sp, #24]
 800a7a4:	4628      	mov	r0, r5
    // Compute the error between the predicted direction of gravity and smoothed acceleration.
    CrossProduct(pIMU->accelFiltered, pIMU->v2Filtered, accelErr);

    // Normalize accel_error.
    accelErr[0] *= mag;
    accelErr[1] *= mag;
 800a7a6:	9705      	str	r7, [sp, #20]
    accelErr[2] *= mag;
 800a7a8:	f7f6 fb3a 	bl	8000e20 <__aeabi_fmul>
 800a7ac:	4605      	mov	r5, r0
 800a7ae:	9006      	str	r0, [sp, #24]
 800a7b0:	e661      	b.n	800a476 <attitudeUpdate+0x86>
 800a7b2:	bf00      	nop
	...

0800a7c0 <cameraRotationUpdate>:
}

/**
 * @brief
 */
void cameraRotationUpdate(void) {
 800a7c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a7c4:	4faa      	ldr	r7, [pc, #680]	; (800aa70 <cameraRotationUpdate+0x2b0>)
 800a7c6:	f8df a2c4 	ldr.w	sl, [pc, #708]	; 800aa8c <cameraRotationUpdate+0x2cc>
 800a7ca:	f8df b2cc 	ldr.w	fp, [pc, #716]	; 800aa98 <cameraRotationUpdate+0x2d8>
 800a7ce:	b083      	sub	sp, #12
 800a7d0:	2400      	movs	r4, #0
  uint8_t i;
  float coef;
  float speedLimit;

  for (i = 0; i < 3; i++) {
    speedLimit = ((float)g_modeSettings[i].speed)*DEG2RAD;
 800a7d2:	79b8      	ldrb	r0, [r7, #6]
 800a7d4:	f7f6 faca 	bl	8000d6c <__aeabi_ui2f>
 800a7d8:	f7f5 fea6 	bl	8000528 <__aeabi_f2d>
 800a7dc:	a39e      	add	r3, pc, #632	; (adr r3, 800aa58 <cameraRotationUpdate+0x298>)
 800a7de:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a7e2:	f7f5 fef5 	bl	80005d0 <__aeabi_dmul>
 800a7e6:	f7f6 f9bb 	bl	8000b60 <__aeabi_d2f>

    if (g_modeSettings[i].mode_id & INPUT_MODE_MAVLINK) {
 800a7ea:	79fe      	ldrb	r6, [r7, #7]
  uint8_t i;
  float coef;
  float speedLimit;

  for (i = 0; i < 3; i++) {
    speedLimit = ((float)g_modeSettings[i].speed)*DEG2RAD;
 800a7ec:	4605      	mov	r5, r0

    if (g_modeSettings[i].mode_id & INPUT_MODE_MAVLINK) {
 800a7ee:	07b1      	lsls	r1, r6, #30
 800a7f0:	d04e      	beq.n	800a890 <cameraRotationUpdate+0xd0>
      coef = g_mavAngle[i]; //mavlink angle in degrees
      coef = constrain(coef, (float )g_modeSettings[i].min_angle,
 800a7f2:	4a9f      	ldr	r2, [pc, #636]	; (800aa70 <cameraRotationUpdate+0x2b0>)

  for (i = 0; i < 3; i++) {
    speedLimit = ((float)g_modeSettings[i].speed)*DEG2RAD;

    if (g_modeSettings[i].mode_id & INPUT_MODE_MAVLINK) {
      coef = g_mavAngle[i]; //mavlink angle in degrees
 800a7f4:	4b9f      	ldr	r3, [pc, #636]	; (800aa74 <cameraRotationUpdate+0x2b4>)
      coef = constrain(coef, (float )g_modeSettings[i].min_angle,
 800a7f6:	f932 0034 	ldrsh.w	r0, [r2, r4, lsl #3]

  for (i = 0; i < 3; i++) {
    speedLimit = ((float)g_modeSettings[i].speed)*DEG2RAD;

    if (g_modeSettings[i].mode_id & INPUT_MODE_MAVLINK) {
      coef = g_mavAngle[i]; //mavlink angle in degrees
 800a7fa:	f853 9024 	ldr.w	r9, [r3, r4, lsl #2]
      coef = constrain(coef, (float )g_modeSettings[i].min_angle,
 800a7fe:	f7f6 fab9 	bl	8000d74 <__aeabi_i2f>
 800a802:	4680      	mov	r8, r0
 800a804:	4648      	mov	r0, r9
 800a806:	4641      	mov	r1, r8
 800a808:	00a6      	lsls	r6, r4, #2
 800a80a:	f7f6 fca7 	bl	800115c <__aeabi_fcmplt>
 800a80e:	b958      	cbnz	r0, 800a828 <cameraRotationUpdate+0x68>
 800a810:	f9b7 0002 	ldrsh.w	r0, [r7, #2]
 800a814:	f7f6 faae 	bl	8000d74 <__aeabi_i2f>
 800a818:	4680      	mov	r8, r0
 800a81a:	4648      	mov	r0, r9
 800a81c:	4641      	mov	r1, r8
 800a81e:	f7f6 fcbb 	bl	8001198 <__aeabi_fcmpgt>
 800a822:	2800      	cmp	r0, #0
 800a824:	f000 80af 	beq.w	800a986 <cameraRotationUpdate+0x1c6>
          (float )g_modeSettings[i].max_angle); //Do we need to constrain?
      coef *= DEG2RAD;
 800a828:	4640      	mov	r0, r8
 800a82a:	f7f5 fe7d 	bl	8000528 <__aeabi_f2d>
 800a82e:	a38a      	add	r3, pc, #552	; (adr r3, 800aa58 <cameraRotationUpdate+0x298>)
 800a830:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a834:	f7f5 fecc 	bl	80005d0 <__aeabi_dmul>
 800a838:	f7f6 f992 	bl	8000b60 <__aeabi_d2f>
      /* Convert angle difference to speed: */
      coef = (coef - camAtti[i]) / INPUT_SIGNAL_ALPHA / FIXED_DT_STEP;
 800a83c:	4b8e      	ldr	r3, [pc, #568]	; (800aa78 <cameraRotationUpdate+0x2b8>)
 800a83e:	5999      	ldr	r1, [r3, r6]
 800a840:	f7f6 f9e2 	bl	8000c08 <__aeabi_fsub>
 800a844:	498d      	ldr	r1, [pc, #564]	; (800aa7c <cameraRotationUpdate+0x2bc>)
 800a846:	f7f6 fb9f 	bl	8000f88 <__aeabi_fdiv>
 800a84a:	498d      	ldr	r1, [pc, #564]	; (800aa80 <cameraRotationUpdate+0x2c0>)
 800a84c:	f7f6 fb9c 	bl	8000f88 <__aeabi_fdiv>
 800a850:	4681      	mov	r9, r0

        /* Convert angle difference to speed: */
        coef = (coef - camAtti[i]) / INPUT_SIGNAL_ALPHA / FIXED_DT_STEP;
      }
    }
    coef = constrain(coef, -speedLimit, speedLimit);
 800a852:	f105 4800 	add.w	r8, r5, #2147483648	; 0x80000000
 800a856:	4641      	mov	r1, r8
 800a858:	4648      	mov	r0, r9
 800a85a:	f7f6 fc7f 	bl	800115c <__aeabi_fcmplt>
 800a85e:	b938      	cbnz	r0, 800a870 <cameraRotationUpdate+0xb0>
 800a860:	4648      	mov	r0, r9
 800a862:	4629      	mov	r1, r5
 800a864:	f7f6 fc98 	bl	8001198 <__aeabi_fcmpgt>
 800a868:	2800      	cmp	r0, #0
 800a86a:	f040 808a 	bne.w	800a982 <cameraRotationUpdate+0x1c2>
 800a86e:	46c8      	mov	r8, r9
    camRot[i] = coef*FIXED_DT_STEP;
 800a870:	4640      	mov	r0, r8
 800a872:	4983      	ldr	r1, [pc, #524]	; (800aa80 <cameraRotationUpdate+0x2c0>)
 800a874:	f7f6 fad4 	bl	8000e20 <__aeabi_fmul>
 800a878:	f84b 0006 	str.w	r0, [fp, r6]
 800a87c:	3401      	adds	r4, #1
void cameraRotationUpdate(void) {
  uint8_t i;
  float coef;
  float speedLimit;

  for (i = 0; i < 3; i++) {
 800a87e:	2c03      	cmp	r4, #3
 800a880:	f107 0708 	add.w	r7, r7, #8
 800a884:	f10a 0a07 	add.w	sl, sl, #7
 800a888:	d1a3      	bne.n	800a7d2 <cameraRotationUpdate+0x12>
      }
    }
    coef = constrain(coef, -speedLimit, speedLimit);
    camRot[i] = coef*FIXED_DT_STEP;
  }
}
 800a88a:	b003      	add	sp, #12
 800a88c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          (float )g_modeSettings[i].max_angle); //Do we need to constrain?
      coef *= DEG2RAD;
      /* Convert angle difference to speed: */
      coef = (coef - camAtti[i]) / INPUT_SIGNAL_ALPHA / FIXED_DT_STEP;
    }
    else if (g_modeSettings[i].mode_id & INPUT_MODE_FOLLOW) {
 800a890:	07b2      	lsls	r2, r6, #30
 800a892:	d531      	bpl.n	800a8f8 <cameraRotationUpdate+0x138>
      /* Calculate offset of the gimbal: */
      coef = g_modeSettings[i].offset*DEG2RAD - g_motorOffset[i];
 800a894:	f9b7 0004 	ldrsh.w	r0, [r7, #4]
 800a898:	f7f5 fe34 	bl	8000504 <__aeabi_i2d>
 800a89c:	a36e      	add	r3, pc, #440	; (adr r3, 800aa58 <cameraRotationUpdate+0x298>)
 800a89e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a8a2:	f7f5 fe95 	bl	80005d0 <__aeabi_dmul>
 800a8a6:	4b77      	ldr	r3, [pc, #476]	; (800aa84 <cameraRotationUpdate+0x2c4>)
 800a8a8:	4680      	mov	r8, r0
 800a8aa:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 800a8ae:	4689      	mov	r9, r1
 800a8b0:	f7f5 fe3a 	bl	8000528 <__aeabi_f2d>
 800a8b4:	4602      	mov	r2, r0
 800a8b6:	460b      	mov	r3, r1
 800a8b8:	4640      	mov	r0, r8
 800a8ba:	4649      	mov	r1, r9
 800a8bc:	f7f5 fcd4 	bl	8000268 <__aeabi_dsub>
 800a8c0:	f7f6 f94e 	bl	8000b60 <__aeabi_d2f>
      if (coef > MODE_FOLLOW_DEAD_BAND) {
 800a8c4:	f7f5 fe30 	bl	8000528 <__aeabi_f2d>
 800a8c8:	a365      	add	r3, pc, #404	; (adr r3, 800aa60 <cameraRotationUpdate+0x2a0>)
 800a8ca:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a8ce:	00a6      	lsls	r6, r4, #2
 800a8d0:	4680      	mov	r8, r0
 800a8d2:	4689      	mov	r9, r1
 800a8d4:	f7f6 f912 	bl	8000afc <__aeabi_dcmpgt>
 800a8d8:	2800      	cmp	r0, #0
 800a8da:	d056      	beq.n	800a98a <cameraRotationUpdate+0x1ca>
        coef -= MODE_FOLLOW_DEAD_BAND;
 800a8dc:	a360      	add	r3, pc, #384	; (adr r3, 800aa60 <cameraRotationUpdate+0x2a0>)
 800a8de:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a8e2:	4649      	mov	r1, r9
 800a8e4:	4640      	mov	r0, r8
 800a8e6:	f7f5 fcbf 	bl	8000268 <__aeabi_dsub>
 800a8ea:	f7f6 f939 	bl	8000b60 <__aeabi_d2f>
        /* Convert to speed: */
        coef /= INPUT_SIGNAL_ALPHA*FIXED_DT_STEP;
 800a8ee:	4966      	ldr	r1, [pc, #408]	; (800aa88 <cameraRotationUpdate+0x2c8>)
 800a8f0:	f7f6 fb4a 	bl	8000f88 <__aeabi_fdiv>
 800a8f4:	4681      	mov	r9, r0
 800a8f6:	e7ac      	b.n	800a852 <cameraRotationUpdate+0x92>
        /* Convert to speed: */
        coef /= INPUT_SIGNAL_ALPHA*FIXED_DT_STEP;
      } else {
        coef = 0.0f;
      }
    } else if (g_mixedInput[i].channel_id == INPUT_CHANNEL_DISABLED) {
 800a8f8:	f89a 2006 	ldrb.w	r2, [sl, #6]
 800a8fc:	2a05      	cmp	r2, #5
 800a8fe:	f000 809f 	beq.w	800aa40 <cameraRotationUpdate+0x280>
      camRot[i] = 0.0f;
      continue;
    } else {
      /* Calculate input scaling coefficient: */
      if (g_mixedInput[i].max_val == g_mixedInput[i].min_val) {
 800a902:	4962      	ldr	r1, [pc, #392]	; (800aa8c <cameraRotationUpdate+0x2cc>)
 800a904:	ea4f 09c4 	mov.w	r9, r4, lsl #3
 800a908:	ebc4 0309 	rsb	r3, r4, r9
 800a90c:	440b      	add	r3, r1
 800a90e:	f9b3 1004 	ldrsh.w	r1, [r3, #4]
 800a912:	f9b3 8000 	ldrsh.w	r8, [r3]
 800a916:	9100      	str	r1, [sp, #0]
 800a918:	4541      	cmp	r1, r8
 800a91a:	f000 8098 	beq.w	800aa4e <cameraRotationUpdate+0x28e>
        /* Avoid divisions by zero. */
        coef = 0.0f;
      } else {
        coef = ((float)(g_inputValues[g_mixedInput[i].channel_id] - g_mixedInput[i].mid_val)) /
 800a91e:	485c      	ldr	r0, [pc, #368]	; (800aa90 <cameraRotationUpdate+0x2d0>)
 800a920:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800a924:	f930 0012 	ldrsh.w	r0, [r0, r2, lsl #1]
 800a928:	1ac0      	subs	r0, r0, r3
 800a92a:	f7f6 fa23 	bl	8000d74 <__aeabi_i2f>
               ((float)(g_mixedInput[i].max_val - g_mixedInput[i].min_val));
 800a92e:	9900      	ldr	r1, [sp, #0]
      /* Calculate input scaling coefficient: */
      if (g_mixedInput[i].max_val == g_mixedInput[i].min_val) {
        /* Avoid divisions by zero. */
        coef = 0.0f;
      } else {
        coef = ((float)(g_inputValues[g_mixedInput[i].channel_id] - g_mixedInput[i].mid_val)) /
 800a930:	9001      	str	r0, [sp, #4]
               ((float)(g_mixedInput[i].max_val - g_mixedInput[i].min_val));
 800a932:	ebc8 0001 	rsb	r0, r8, r1
 800a936:	f7f6 fa1d 	bl	8000d74 <__aeabi_i2f>
      /* Calculate input scaling coefficient: */
      if (g_mixedInput[i].max_val == g_mixedInput[i].min_val) {
        /* Avoid divisions by zero. */
        coef = 0.0f;
      } else {
        coef = ((float)(g_inputValues[g_mixedInput[i].channel_id] - g_mixedInput[i].mid_val)) /
 800a93a:	9b01      	ldr	r3, [sp, #4]
               ((float)(g_mixedInput[i].max_val - g_mixedInput[i].min_val));
 800a93c:	4601      	mov	r1, r0
      /* Calculate input scaling coefficient: */
      if (g_mixedInput[i].max_val == g_mixedInput[i].min_val) {
        /* Avoid divisions by zero. */
        coef = 0.0f;
      } else {
        coef = ((float)(g_inputValues[g_mixedInput[i].channel_id] - g_mixedInput[i].mid_val)) /
 800a93e:	4618      	mov	r0, r3
 800a940:	f7f6 fb22 	bl	8000f88 <__aeabi_fdiv>
 800a944:	4603      	mov	r3, r0
 800a946:	9300      	str	r3, [sp, #0]
               ((float)(g_mixedInput[i].max_val - g_mixedInput[i].min_val));
      }

      if (g_modeSettings[i].mode_id & INPUT_MODE_SPEED) {
 800a948:	07f3      	lsls	r3, r6, #31
 800a94a:	d535      	bpl.n	800a9b8 <cameraRotationUpdate+0x1f8>
        /* Calculate speed from RC input data: */
        coef *= 2.0f*speedLimit;
 800a94c:	4629      	mov	r1, r5
 800a94e:	4628      	mov	r0, r5
 800a950:	f7f6 f95c 	bl	8000c0c <__addsf3>
 800a954:	9b00      	ldr	r3, [sp, #0]
 800a956:	4619      	mov	r1, r3
        camRotSpeedPrev[i] += (coef - camRotSpeedPrev[i]) / INPUT_SIGNAL_ALPHA;
 800a958:	4b4e      	ldr	r3, [pc, #312]	; (800aa94 <cameraRotationUpdate+0x2d4>)
 800a95a:	f853 6024 	ldr.w	r6, [r3, r4, lsl #2]
               ((float)(g_mixedInput[i].max_val - g_mixedInput[i].min_val));
      }

      if (g_modeSettings[i].mode_id & INPUT_MODE_SPEED) {
        /* Calculate speed from RC input data: */
        coef *= 2.0f*speedLimit;
 800a95e:	f7f6 fa5f 	bl	8000e20 <__aeabi_fmul>
        camRotSpeedPrev[i] += (coef - camRotSpeedPrev[i]) / INPUT_SIGNAL_ALPHA;
 800a962:	4631      	mov	r1, r6
 800a964:	f7f6 f950 	bl	8000c08 <__aeabi_fsub>
 800a968:	4944      	ldr	r1, [pc, #272]	; (800aa7c <cameraRotationUpdate+0x2bc>)
 800a96a:	f7f6 fb0d 	bl	8000f88 <__aeabi_fdiv>
 800a96e:	4601      	mov	r1, r0
 800a970:	4630      	mov	r0, r6
 800a972:	f7f6 f94b 	bl	8000c0c <__addsf3>
 800a976:	4b47      	ldr	r3, [pc, #284]	; (800aa94 <cameraRotationUpdate+0x2d4>)
 800a978:	4681      	mov	r9, r0
 800a97a:	00a6      	lsls	r6, r4, #2
 800a97c:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
 800a980:	e767      	b.n	800a852 <cameraRotationUpdate+0x92>

        /* Convert angle difference to speed: */
        coef = (coef - camAtti[i]) / INPUT_SIGNAL_ALPHA / FIXED_DT_STEP;
      }
    }
    coef = constrain(coef, -speedLimit, speedLimit);
 800a982:	46a8      	mov	r8, r5
 800a984:	e774      	b.n	800a870 <cameraRotationUpdate+0xb0>
  for (i = 0; i < 3; i++) {
    speedLimit = ((float)g_modeSettings[i].speed)*DEG2RAD;

    if (g_modeSettings[i].mode_id & INPUT_MODE_MAVLINK) {
      coef = g_mavAngle[i]; //mavlink angle in degrees
      coef = constrain(coef, (float )g_modeSettings[i].min_angle,
 800a986:	46c8      	mov	r8, r9
 800a988:	e74e      	b.n	800a828 <cameraRotationUpdate+0x68>
      coef = g_modeSettings[i].offset*DEG2RAD - g_motorOffset[i];
      if (coef > MODE_FOLLOW_DEAD_BAND) {
        coef -= MODE_FOLLOW_DEAD_BAND;
        /* Convert to speed: */
        coef /= INPUT_SIGNAL_ALPHA*FIXED_DT_STEP;
      } else if (coef < -MODE_FOLLOW_DEAD_BAND) {
 800a98a:	4640      	mov	r0, r8
 800a98c:	a336      	add	r3, pc, #216	; (adr r3, 800aa68 <cameraRotationUpdate+0x2a8>)
 800a98e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a992:	4649      	mov	r1, r9
 800a994:	f7f6 f894 	bl	8000ac0 <__aeabi_dcmplt>
 800a998:	2800      	cmp	r0, #0
 800a99a:	d055      	beq.n	800aa48 <cameraRotationUpdate+0x288>
        coef += MODE_FOLLOW_DEAD_BAND;
 800a99c:	a330      	add	r3, pc, #192	; (adr r3, 800aa60 <cameraRotationUpdate+0x2a0>)
 800a99e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a9a2:	4649      	mov	r1, r9
 800a9a4:	4640      	mov	r0, r8
 800a9a6:	f7f5 fc61 	bl	800026c <__adddf3>
 800a9aa:	f7f6 f8d9 	bl	8000b60 <__aeabi_d2f>
        /* Convert to speed: */
        coef /= INPUT_SIGNAL_ALPHA*FIXED_DT_STEP;
 800a9ae:	4936      	ldr	r1, [pc, #216]	; (800aa88 <cameraRotationUpdate+0x2c8>)
 800a9b0:	f7f6 faea 	bl	8000f88 <__aeabi_fdiv>
 800a9b4:	4681      	mov	r9, r0
 800a9b6:	e74c      	b.n	800a852 <cameraRotationUpdate+0x92>
        coef *= 2.0f*speedLimit;
        camRotSpeedPrev[i] += (coef - camRotSpeedPrev[i]) / INPUT_SIGNAL_ALPHA;
        coef = camRotSpeedPrev[i];
      } else { /* INPUT_MODE_ANGLE */
        /* Calculate angle from input data: */
        coef *= (g_modeSettings[i].max_angle - g_modeSettings[i].min_angle);
 800a9b8:	4b2d      	ldr	r3, [pc, #180]	; (800aa70 <cameraRotationUpdate+0x2b0>)
 800a9ba:	f9b7 6002 	ldrsh.w	r6, [r7, #2]
 800a9be:	f933 8009 	ldrsh.w	r8, [r3, r9]
 800a9c2:	ebc8 0006 	rsb	r0, r8, r6
 800a9c6:	f7f6 f9d5 	bl	8000d74 <__aeabi_i2f>
 800a9ca:	9b00      	ldr	r3, [sp, #0]
 800a9cc:	4619      	mov	r1, r3
 800a9ce:	f7f6 fa27 	bl	8000e20 <__aeabi_fmul>
 800a9d2:	4681      	mov	r9, r0
        coef += (g_modeSettings[i].max_angle + g_modeSettings[i].min_angle) / 2;
 800a9d4:	eb06 0008 	add.w	r0, r6, r8
 800a9d8:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
 800a9dc:	1040      	asrs	r0, r0, #1
 800a9de:	f7f6 f9c9 	bl	8000d74 <__aeabi_i2f>
 800a9e2:	4649      	mov	r1, r9
 800a9e4:	f7f6 f912 	bl	8000c0c <__addsf3>
 800a9e8:	4681      	mov	r9, r0
        coef = constrain(coef, (float)g_modeSettings[i].min_angle, (float)g_modeSettings[i].max_angle);
 800a9ea:	4640      	mov	r0, r8
 800a9ec:	f7f6 f9c2 	bl	8000d74 <__aeabi_i2f>
 800a9f0:	4680      	mov	r8, r0
 800a9f2:	4648      	mov	r0, r9
 800a9f4:	4641      	mov	r1, r8
 800a9f6:	f7f6 fbb1 	bl	800115c <__aeabi_fcmplt>
 800a9fa:	b948      	cbnz	r0, 800aa10 <cameraRotationUpdate+0x250>
 800a9fc:	4630      	mov	r0, r6
 800a9fe:	f7f6 f9b9 	bl	8000d74 <__aeabi_i2f>
 800aa02:	4680      	mov	r8, r0
 800aa04:	4648      	mov	r0, r9
 800aa06:	4641      	mov	r1, r8
 800aa08:	f7f6 fbc6 	bl	8001198 <__aeabi_fcmpgt>
 800aa0c:	b900      	cbnz	r0, 800aa10 <cameraRotationUpdate+0x250>
 800aa0e:	46c8      	mov	r8, r9
        coef *= DEG2RAD;
 800aa10:	4640      	mov	r0, r8
 800aa12:	f7f5 fd89 	bl	8000528 <__aeabi_f2d>
 800aa16:	a310      	add	r3, pc, #64	; (adr r3, 800aa58 <cameraRotationUpdate+0x298>)
 800aa18:	e9d3 2300 	ldrd	r2, r3, [r3]
 800aa1c:	f7f5 fdd8 	bl	80005d0 <__aeabi_dmul>
 800aa20:	f7f6 f89e 	bl	8000b60 <__aeabi_d2f>

        /* Convert angle difference to speed: */
        coef = (coef - camAtti[i]) / INPUT_SIGNAL_ALPHA / FIXED_DT_STEP;
 800aa24:	4b14      	ldr	r3, [pc, #80]	; (800aa78 <cameraRotationUpdate+0x2b8>)
 800aa26:	00a6      	lsls	r6, r4, #2
 800aa28:	f853 1024 	ldr.w	r1, [r3, r4, lsl #2]
 800aa2c:	f7f6 f8ec 	bl	8000c08 <__aeabi_fsub>
 800aa30:	4912      	ldr	r1, [pc, #72]	; (800aa7c <cameraRotationUpdate+0x2bc>)
 800aa32:	f7f6 faa9 	bl	8000f88 <__aeabi_fdiv>
 800aa36:	4912      	ldr	r1, [pc, #72]	; (800aa80 <cameraRotationUpdate+0x2c0>)
 800aa38:	f7f6 faa6 	bl	8000f88 <__aeabi_fdiv>
 800aa3c:	4681      	mov	r9, r0
 800aa3e:	e708      	b.n	800a852 <cameraRotationUpdate+0x92>
        coef /= INPUT_SIGNAL_ALPHA*FIXED_DT_STEP;
      } else {
        coef = 0.0f;
      }
    } else if (g_mixedInput[i].channel_id == INPUT_CHANNEL_DISABLED) {
      camRot[i] = 0.0f;
 800aa40:	2300      	movs	r3, #0
 800aa42:	f84b 3024 	str.w	r3, [fp, r4, lsl #2]
      continue;
 800aa46:	e719      	b.n	800a87c <cameraRotationUpdate+0xbc>
      } else if (coef < -MODE_FOLLOW_DEAD_BAND) {
        coef += MODE_FOLLOW_DEAD_BAND;
        /* Convert to speed: */
        coef /= INPUT_SIGNAL_ALPHA*FIXED_DT_STEP;
      } else {
        coef = 0.0f;
 800aa48:	f04f 0900 	mov.w	r9, #0
 800aa4c:	e701      	b.n	800a852 <cameraRotationUpdate+0x92>
      continue;
    } else {
      /* Calculate input scaling coefficient: */
      if (g_mixedInput[i].max_val == g_mixedInput[i].min_val) {
        /* Avoid divisions by zero. */
        coef = 0.0f;
 800aa4e:	2300      	movs	r3, #0
 800aa50:	e779      	b.n	800a946 <cameraRotationUpdate+0x186>
 800aa52:	bf00      	nop
 800aa54:	f3af 8000 	nop.w
 800aa58:	a2529d39 	.word	0xa2529d39
 800aa5c:	3f91df46 	.word	0x3f91df46
 800aa60:	4ae74487 	.word	0x4ae74487
 800aa64:	3fb65718 	.word	0x3fb65718
 800aa68:	4ae74487 	.word	0x4ae74487
 800aa6c:	bfb65718 	.word	0xbfb65718
 800aa70:	20000908 	.word	0x20000908
 800aa74:	20001ddc 	.word	0x20001ddc
 800aa78:	20001dd0 	.word	0x20001dd0
 800aa7c:	43960000 	.word	0x43960000
 800aa80:	3ac49ba6 	.word	0x3ac49ba6
 800aa84:	20001dc4 	.word	0x20001dc4
 800aa88:	3ee66667 	.word	0x3ee66667
 800aa8c:	20000814 	.word	0x20000814
 800aa90:	200015e8 	.word	0x200015e8
 800aa94:	20001da8 	.word	0x20001da8
 800aa98:	20001d9c 	.word	0x20001d9c
 800aa9c:	00000000 	.word	0x00000000

0800aaa0 <actuatorsUpdate>:
}

/**
 * @brief
 */
void actuatorsUpdate(void) {
 800aaa0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  float cmd = 0.0f;
  float err;
  /* Pitch: */
  uint8_t cmd_id = g_pwmOutput[PWM_OUT_PITCH].dt_cmd_id & PWM_OUT_CMD_ID_MASK;
 800aaa4:	4c82      	ldr	r4, [pc, #520]	; (800acb0 <actuatorsUpdate+0x210>)
 800aaa6:	78e7      	ldrb	r7, [r4, #3]
 800aaa8:	f007 070f 	and.w	r7, r7, #15
  if (cmd_id != PWM_OUT_CMD_DISABLED) {
 800aaac:	2f03      	cmp	r7, #3
 800aaae:	f000 80e8 	beq.w	800ac82 <actuatorsUpdate+0x1e2>
    err = camAtti[cmd_id] - g_IMU1.rpy[cmd_id];
 800aab2:	4d80      	ldr	r5, [pc, #512]	; (800acb4 <actuatorsUpdate+0x214>)
 800aab4:	4a80      	ldr	r2, [pc, #512]	; (800acb8 <actuatorsUpdate+0x218>)
 800aab6:	f855 6027 	ldr.w	r6, [r5, r7, lsl #2]
 800aaba:	f107 0316 	add.w	r3, r7, #22
 800aabe:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 800aac2:	4630      	mov	r0, r6
 800aac4:	f7f6 f8a0 	bl	8000c08 <__aeabi_fsub>
    camAtti[cmd_id] += camRot[cmd_id];
 800aac8:	4b7c      	ldr	r3, [pc, #496]	; (800acbc <actuatorsUpdate+0x21c>)
  float cmd = 0.0f;
  float err;
  /* Pitch: */
  uint8_t cmd_id = g_pwmOutput[PWM_OUT_PITCH].dt_cmd_id & PWM_OUT_CMD_ID_MASK;
  if (cmd_id != PWM_OUT_CMD_DISABLED) {
    err = camAtti[cmd_id] - g_IMU1.rpy[cmd_id];
 800aaca:	4682      	mov	sl, r0
    camAtti[cmd_id] += camRot[cmd_id];
 800aacc:	4630      	mov	r0, r6
 800aace:	f853 6027 	ldr.w	r6, [r3, r7, lsl #2]
 800aad2:	4631      	mov	r1, r6
 800aad4:	f7f6 f89a 	bl	8000c0c <__addsf3>
 800aad8:	4683      	mov	fp, r0
    camAtti[cmd_id] = circadjust(camAtti[cmd_id], M_PI);
 800aada:	f7f5 fd25 	bl	8000528 <__aeabi_f2d>
 800aade:	a36e      	add	r3, pc, #440	; (adr r3, 800ac98 <actuatorsUpdate+0x1f8>)
 800aae0:	e9d3 2300 	ldrd	r2, r3, [r3]
 800aae4:	4680      	mov	r8, r0
 800aae6:	4689      	mov	r9, r1
 800aae8:	f7f5 ffea 	bl	8000ac0 <__aeabi_dcmplt>
 800aaec:	2800      	cmp	r0, #0
 800aaee:	f000 8089 	beq.w	800ac04 <actuatorsUpdate+0x164>
 800aaf2:	a36b      	add	r3, pc, #428	; (adr r3, 800aca0 <actuatorsUpdate+0x200>)
 800aaf4:	e9d3 2300 	ldrd	r2, r3, [r3]
 800aaf8:	4640      	mov	r0, r8
 800aafa:	4649      	mov	r1, r9
 800aafc:	f7f5 fbb6 	bl	800026c <__adddf3>
 800ab00:	f7f6 f82e 	bl	8000b60 <__aeabi_d2f>
 800ab04:	4683      	mov	fp, r0
    cmd = pidControllerApply(cmd_id, err, camRot[cmd_id]);
 800ab06:	4651      	mov	r1, sl
 800ab08:	4632      	mov	r2, r6
 800ab0a:	4638      	mov	r0, r7
  /* Pitch: */
  uint8_t cmd_id = g_pwmOutput[PWM_OUT_PITCH].dt_cmd_id & PWM_OUT_CMD_ID_MASK;
  if (cmd_id != PWM_OUT_CMD_DISABLED) {
    err = camAtti[cmd_id] - g_IMU1.rpy[cmd_id];
    camAtti[cmd_id] += camRot[cmd_id];
    camAtti[cmd_id] = circadjust(camAtti[cmd_id], M_PI);
 800ab0c:	f845 b027 	str.w	fp, [r5, r7, lsl #2]
    cmd = pidControllerApply(cmd_id, err, camRot[cmd_id]);
 800ab10:	f7ff fad6 	bl	800a0c0 <pidControllerApply>
 800ab14:	4601      	mov	r1, r0
  }
  pwmOutputUpdate(PWM_OUT_PITCH, cmd);
 800ab16:	2000      	movs	r0, #0
 800ab18:	f7fb f802 	bl	8005b20 <pwmOutputUpdate>
  cmd = 0.0f;
  /* Roll: */
  cmd_id = g_pwmOutput[PWM_OUT_ROLL].dt_cmd_id & PWM_OUT_CMD_ID_MASK;
 800ab1c:	79e7      	ldrb	r7, [r4, #7]
 800ab1e:	f007 070f 	and.w	r7, r7, #15
  if (cmd_id != PWM_OUT_CMD_DISABLED) {
 800ab22:	2f03      	cmp	r7, #3
 800ab24:	f000 80ab 	beq.w	800ac7e <actuatorsUpdate+0x1de>
    err = camAtti[cmd_id] - g_IMU1.rpy[cmd_id];
 800ab28:	4d62      	ldr	r5, [pc, #392]	; (800acb4 <actuatorsUpdate+0x214>)
 800ab2a:	4a63      	ldr	r2, [pc, #396]	; (800acb8 <actuatorsUpdate+0x218>)
 800ab2c:	f855 6027 	ldr.w	r6, [r5, r7, lsl #2]
 800ab30:	f107 0316 	add.w	r3, r7, #22
 800ab34:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 800ab38:	4630      	mov	r0, r6
 800ab3a:	f7f6 f865 	bl	8000c08 <__aeabi_fsub>
    camAtti[cmd_id] += camRot[cmd_id];
 800ab3e:	4b5f      	ldr	r3, [pc, #380]	; (800acbc <actuatorsUpdate+0x21c>)
  pwmOutputUpdate(PWM_OUT_PITCH, cmd);
  cmd = 0.0f;
  /* Roll: */
  cmd_id = g_pwmOutput[PWM_OUT_ROLL].dt_cmd_id & PWM_OUT_CMD_ID_MASK;
  if (cmd_id != PWM_OUT_CMD_DISABLED) {
    err = camAtti[cmd_id] - g_IMU1.rpy[cmd_id];
 800ab40:	4682      	mov	sl, r0
    camAtti[cmd_id] += camRot[cmd_id];
 800ab42:	4630      	mov	r0, r6
 800ab44:	f853 6027 	ldr.w	r6, [r3, r7, lsl #2]
 800ab48:	4631      	mov	r1, r6
 800ab4a:	f7f6 f85f 	bl	8000c0c <__addsf3>
 800ab4e:	4683      	mov	fp, r0
    camAtti[cmd_id] = circadjust(camAtti[cmd_id], M_PI);
 800ab50:	f7f5 fcea 	bl	8000528 <__aeabi_f2d>
 800ab54:	a350      	add	r3, pc, #320	; (adr r3, 800ac98 <actuatorsUpdate+0x1f8>)
 800ab56:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ab5a:	4680      	mov	r8, r0
 800ab5c:	4689      	mov	r9, r1
 800ab5e:	f7f5 ffaf 	bl	8000ac0 <__aeabi_dcmplt>
 800ab62:	2800      	cmp	r0, #0
 800ab64:	d077      	beq.n	800ac56 <actuatorsUpdate+0x1b6>
 800ab66:	a34e      	add	r3, pc, #312	; (adr r3, 800aca0 <actuatorsUpdate+0x200>)
 800ab68:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ab6c:	4640      	mov	r0, r8
 800ab6e:	4649      	mov	r1, r9
 800ab70:	f7f5 fb7c 	bl	800026c <__adddf3>
 800ab74:	f7f5 fff4 	bl	8000b60 <__aeabi_d2f>
 800ab78:	4683      	mov	fp, r0
    cmd = pidControllerApply(cmd_id, err, camRot[cmd_id]);
 800ab7a:	4651      	mov	r1, sl
 800ab7c:	4632      	mov	r2, r6
 800ab7e:	4638      	mov	r0, r7
  /* Roll: */
  cmd_id = g_pwmOutput[PWM_OUT_ROLL].dt_cmd_id & PWM_OUT_CMD_ID_MASK;
  if (cmd_id != PWM_OUT_CMD_DISABLED) {
    err = camAtti[cmd_id] - g_IMU1.rpy[cmd_id];
    camAtti[cmd_id] += camRot[cmd_id];
    camAtti[cmd_id] = circadjust(camAtti[cmd_id], M_PI);
 800ab80:	f845 b027 	str.w	fp, [r5, r7, lsl #2]
    cmd = pidControllerApply(cmd_id, err, camRot[cmd_id]);
 800ab84:	f7ff fa9c 	bl	800a0c0 <pidControllerApply>
 800ab88:	4601      	mov	r1, r0
  }
  pwmOutputUpdate(PWM_OUT_ROLL, cmd);
 800ab8a:	2001      	movs	r0, #1
 800ab8c:	f7fa ffc8 	bl	8005b20 <pwmOutputUpdate>
  cmd = 0.0f;
  /* Yaw: */
  cmd_id = g_pwmOutput[PWM_OUT_YAW].dt_cmd_id & PWM_OUT_CMD_ID_MASK;
 800ab90:	7ae4      	ldrb	r4, [r4, #11]
 800ab92:	f004 040f 	and.w	r4, r4, #15
  if (cmd_id != PWM_OUT_CMD_DISABLED) {
 800ab96:	2c03      	cmp	r4, #3
 800ab98:	d075      	beq.n	800ac86 <actuatorsUpdate+0x1e6>
    err = camAtti[cmd_id] - g_IMU1.rpy[cmd_id];
 800ab9a:	4d46      	ldr	r5, [pc, #280]	; (800acb4 <actuatorsUpdate+0x214>)
 800ab9c:	4a46      	ldr	r2, [pc, #280]	; (800acb8 <actuatorsUpdate+0x218>)
 800ab9e:	f855 6024 	ldr.w	r6, [r5, r4, lsl #2]
 800aba2:	f104 0316 	add.w	r3, r4, #22
 800aba6:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 800abaa:	4630      	mov	r0, r6
 800abac:	f7f6 f82c 	bl	8000c08 <__aeabi_fsub>
    camAtti[cmd_id] += camRot[cmd_id];
 800abb0:	4b42      	ldr	r3, [pc, #264]	; (800acbc <actuatorsUpdate+0x21c>)
  pwmOutputUpdate(PWM_OUT_ROLL, cmd);
  cmd = 0.0f;
  /* Yaw: */
  cmd_id = g_pwmOutput[PWM_OUT_YAW].dt_cmd_id & PWM_OUT_CMD_ID_MASK;
  if (cmd_id != PWM_OUT_CMD_DISABLED) {
    err = camAtti[cmd_id] - g_IMU1.rpy[cmd_id];
 800abb2:	4682      	mov	sl, r0
    camAtti[cmd_id] += camRot[cmd_id];
 800abb4:	4630      	mov	r0, r6
 800abb6:	f853 6024 	ldr.w	r6, [r3, r4, lsl #2]
 800abba:	4631      	mov	r1, r6
 800abbc:	f7f6 f826 	bl	8000c0c <__addsf3>
 800abc0:	4607      	mov	r7, r0
    camAtti[cmd_id] = circadjust(camAtti[cmd_id], M_PI);
 800abc2:	f7f5 fcb1 	bl	8000528 <__aeabi_f2d>
 800abc6:	a334      	add	r3, pc, #208	; (adr r3, 800ac98 <actuatorsUpdate+0x1f8>)
 800abc8:	e9d3 2300 	ldrd	r2, r3, [r3]
 800abcc:	4680      	mov	r8, r0
 800abce:	4689      	mov	r9, r1
 800abd0:	f7f5 ff76 	bl	8000ac0 <__aeabi_dcmplt>
 800abd4:	b358      	cbz	r0, 800ac2e <actuatorsUpdate+0x18e>
 800abd6:	a332      	add	r3, pc, #200	; (adr r3, 800aca0 <actuatorsUpdate+0x200>)
 800abd8:	e9d3 2300 	ldrd	r2, r3, [r3]
 800abdc:	4640      	mov	r0, r8
 800abde:	4649      	mov	r1, r9
 800abe0:	f7f5 fb44 	bl	800026c <__adddf3>
 800abe4:	f7f5 ffbc 	bl	8000b60 <__aeabi_d2f>
 800abe8:	4607      	mov	r7, r0
    cmd = pidControllerApply(cmd_id, err, camRot[cmd_id]);
 800abea:	4651      	mov	r1, sl
 800abec:	4632      	mov	r2, r6
 800abee:	4620      	mov	r0, r4
  /* Yaw: */
  cmd_id = g_pwmOutput[PWM_OUT_YAW].dt_cmd_id & PWM_OUT_CMD_ID_MASK;
  if (cmd_id != PWM_OUT_CMD_DISABLED) {
    err = camAtti[cmd_id] - g_IMU1.rpy[cmd_id];
    camAtti[cmd_id] += camRot[cmd_id];
    camAtti[cmd_id] = circadjust(camAtti[cmd_id], M_PI);
 800abf0:	f845 7024 	str.w	r7, [r5, r4, lsl #2]
    cmd = pidControllerApply(cmd_id, err, camRot[cmd_id]);
 800abf4:	f7ff fa64 	bl	800a0c0 <pidControllerApply>
  }
  pwmOutputUpdate(PWM_OUT_YAW, cmd);
}
 800abf8:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  cmd_id = g_pwmOutput[PWM_OUT_YAW].dt_cmd_id & PWM_OUT_CMD_ID_MASK;
  if (cmd_id != PWM_OUT_CMD_DISABLED) {
    err = camAtti[cmd_id] - g_IMU1.rpy[cmd_id];
    camAtti[cmd_id] += camRot[cmd_id];
    camAtti[cmd_id] = circadjust(camAtti[cmd_id], M_PI);
    cmd = pidControllerApply(cmd_id, err, camRot[cmd_id]);
 800abfc:	4601      	mov	r1, r0
  }
  pwmOutputUpdate(PWM_OUT_YAW, cmd);
 800abfe:	2002      	movs	r0, #2
 800ac00:	f7fa bf8e 	b.w	8005b20 <pwmOutputUpdate>
  /* Pitch: */
  uint8_t cmd_id = g_pwmOutput[PWM_OUT_PITCH].dt_cmd_id & PWM_OUT_CMD_ID_MASK;
  if (cmd_id != PWM_OUT_CMD_DISABLED) {
    err = camAtti[cmd_id] - g_IMU1.rpy[cmd_id];
    camAtti[cmd_id] += camRot[cmd_id];
    camAtti[cmd_id] = circadjust(camAtti[cmd_id], M_PI);
 800ac04:	4640      	mov	r0, r8
 800ac06:	a328      	add	r3, pc, #160	; (adr r3, 800aca8 <actuatorsUpdate+0x208>)
 800ac08:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ac0c:	4649      	mov	r1, r9
 800ac0e:	f7f5 ff75 	bl	8000afc <__aeabi_dcmpgt>
 800ac12:	2800      	cmp	r0, #0
 800ac14:	f43f af77 	beq.w	800ab06 <actuatorsUpdate+0x66>
 800ac18:	a321      	add	r3, pc, #132	; (adr r3, 800aca0 <actuatorsUpdate+0x200>)
 800ac1a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ac1e:	4640      	mov	r0, r8
 800ac20:	4649      	mov	r1, r9
 800ac22:	f7f5 fb21 	bl	8000268 <__aeabi_dsub>
 800ac26:	f7f5 ff9b 	bl	8000b60 <__aeabi_d2f>
 800ac2a:	4683      	mov	fp, r0
 800ac2c:	e76b      	b.n	800ab06 <actuatorsUpdate+0x66>
  /* Yaw: */
  cmd_id = g_pwmOutput[PWM_OUT_YAW].dt_cmd_id & PWM_OUT_CMD_ID_MASK;
  if (cmd_id != PWM_OUT_CMD_DISABLED) {
    err = camAtti[cmd_id] - g_IMU1.rpy[cmd_id];
    camAtti[cmd_id] += camRot[cmd_id];
    camAtti[cmd_id] = circadjust(camAtti[cmd_id], M_PI);
 800ac2e:	4640      	mov	r0, r8
 800ac30:	a31d      	add	r3, pc, #116	; (adr r3, 800aca8 <actuatorsUpdate+0x208>)
 800ac32:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ac36:	4649      	mov	r1, r9
 800ac38:	f7f5 ff60 	bl	8000afc <__aeabi_dcmpgt>
 800ac3c:	2800      	cmp	r0, #0
 800ac3e:	d0d4      	beq.n	800abea <actuatorsUpdate+0x14a>
 800ac40:	a317      	add	r3, pc, #92	; (adr r3, 800aca0 <actuatorsUpdate+0x200>)
 800ac42:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ac46:	4640      	mov	r0, r8
 800ac48:	4649      	mov	r1, r9
 800ac4a:	f7f5 fb0d 	bl	8000268 <__aeabi_dsub>
 800ac4e:	f7f5 ff87 	bl	8000b60 <__aeabi_d2f>
 800ac52:	4607      	mov	r7, r0
 800ac54:	e7c9      	b.n	800abea <actuatorsUpdate+0x14a>
  /* Roll: */
  cmd_id = g_pwmOutput[PWM_OUT_ROLL].dt_cmd_id & PWM_OUT_CMD_ID_MASK;
  if (cmd_id != PWM_OUT_CMD_DISABLED) {
    err = camAtti[cmd_id] - g_IMU1.rpy[cmd_id];
    camAtti[cmd_id] += camRot[cmd_id];
    camAtti[cmd_id] = circadjust(camAtti[cmd_id], M_PI);
 800ac56:	4640      	mov	r0, r8
 800ac58:	a313      	add	r3, pc, #76	; (adr r3, 800aca8 <actuatorsUpdate+0x208>)
 800ac5a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ac5e:	4649      	mov	r1, r9
 800ac60:	f7f5 ff4c 	bl	8000afc <__aeabi_dcmpgt>
 800ac64:	2800      	cmp	r0, #0
 800ac66:	d088      	beq.n	800ab7a <actuatorsUpdate+0xda>
 800ac68:	a30d      	add	r3, pc, #52	; (adr r3, 800aca0 <actuatorsUpdate+0x200>)
 800ac6a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ac6e:	4640      	mov	r0, r8
 800ac70:	4649      	mov	r1, r9
 800ac72:	f7f5 faf9 	bl	8000268 <__aeabi_dsub>
 800ac76:	f7f5 ff73 	bl	8000b60 <__aeabi_d2f>
 800ac7a:	4683      	mov	fp, r0
 800ac7c:	e77d      	b.n	800ab7a <actuatorsUpdate+0xda>
    camAtti[cmd_id] += camRot[cmd_id];
    camAtti[cmd_id] = circadjust(camAtti[cmd_id], M_PI);
    cmd = pidControllerApply(cmd_id, err, camRot[cmd_id]);
  }
  pwmOutputUpdate(PWM_OUT_PITCH, cmd);
  cmd = 0.0f;
 800ac7e:	2100      	movs	r1, #0
 800ac80:	e783      	b.n	800ab8a <actuatorsUpdate+0xea>

/**
 * @brief
 */
void actuatorsUpdate(void) {
  float cmd = 0.0f;
 800ac82:	2100      	movs	r1, #0
 800ac84:	e747      	b.n	800ab16 <actuatorsUpdate+0x76>
    camAtti[cmd_id] += camRot[cmd_id];
    camAtti[cmd_id] = circadjust(camAtti[cmd_id], M_PI);
    cmd = pidControllerApply(cmd_id, err, camRot[cmd_id]);
  }
  pwmOutputUpdate(PWM_OUT_ROLL, cmd);
  cmd = 0.0f;
 800ac86:	2100      	movs	r1, #0
    err = camAtti[cmd_id] - g_IMU1.rpy[cmd_id];
    camAtti[cmd_id] += camRot[cmd_id];
    camAtti[cmd_id] = circadjust(camAtti[cmd_id], M_PI);
    cmd = pidControllerApply(cmd_id, err, camRot[cmd_id]);
  }
  pwmOutputUpdate(PWM_OUT_YAW, cmd);
 800ac88:	2002      	movs	r0, #2
}
 800ac8a:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    err = camAtti[cmd_id] - g_IMU1.rpy[cmd_id];
    camAtti[cmd_id] += camRot[cmd_id];
    camAtti[cmd_id] = circadjust(camAtti[cmd_id], M_PI);
    cmd = pidControllerApply(cmd_id, err, camRot[cmd_id]);
  }
  pwmOutputUpdate(PWM_OUT_YAW, cmd);
 800ac8e:	f7fa bf47 	b.w	8005b20 <pwmOutputUpdate>
 800ac92:	bf00      	nop
 800ac94:	f3af 8000 	nop.w
 800ac98:	54442d18 	.word	0x54442d18
 800ac9c:	c00921fb 	.word	0xc00921fb
 800aca0:	54442d18 	.word	0x54442d18
 800aca4:	401921fb 	.word	0x401921fb
 800aca8:	54442d18 	.word	0x54442d18
 800acac:	400921fb 	.word	0x400921fb
 800acb0:	20000808 	.word	0x20000808
 800acb4:	20001dd0 	.word	0x20001dd0
 800acb8:	20002abc 	.word	0x20002abc
 800acbc:	20001d9c 	.word	0x20001d9c

0800acc0 <pidSettingsUpdate>:
}

/**
 * @brief
 */
void pidSettingsUpdate(const PPIDSettings pNewSettings) {
 800acc0:	4602      	mov	r2, r0
  memcpy((void *)&g_pidSettings, (void *)pNewSettings, sizeof(g_pidSettings));
 800acc2:	4b04      	ldr	r3, [pc, #16]	; (800acd4 <pidSettingsUpdate+0x14>)
 800acc4:	6851      	ldr	r1, [r2, #4]
 800acc6:	6800      	ldr	r0, [r0, #0]
 800acc8:	c303      	stmia	r3!, {r0, r1}
 800acca:	7a12      	ldrb	r2, [r2, #8]
 800accc:	701a      	strb	r2, [r3, #0]
  pidUpdateStruct();
 800acce:	f7ff b94f 	b.w	8009f70 <pidUpdateStruct>
 800acd2:	bf00      	nop
 800acd4:	20001db8 	.word	0x20001db8
	...

0800ace0 <inputModeSettingsUpdate>:
}

/**
 * @brief
 */
void inputModeSettingsUpdate(const PInputModeStruct pNewSettings) {
 800ace0:	b430      	push	{r4, r5}
 800ace2:	4605      	mov	r5, r0
  memcpy((void *)&g_modeSettings, (void *)pNewSettings, sizeof(g_modeSettings));
 800ace4:	4c05      	ldr	r4, [pc, #20]	; (800acfc <inputModeSettingsUpdate+0x1c>)
 800ace6:	6869      	ldr	r1, [r5, #4]
 800ace8:	6800      	ldr	r0, [r0, #0]
 800acea:	68aa      	ldr	r2, [r5, #8]
 800acec:	68eb      	ldr	r3, [r5, #12]
 800acee:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800acf0:	6928      	ldr	r0, [r5, #16]
 800acf2:	6969      	ldr	r1, [r5, #20]
 800acf4:	c403      	stmia	r4!, {r0, r1}
}
 800acf6:	bc30      	pop	{r4, r5}
 800acf8:	4770      	bx	lr
 800acfa:	bf00      	nop
 800acfc:	20000908 	.word	0x20000908

0800ad00 <cfSettingsUpdate>:

/**
 * @brief
 */
void cfSettingsUpdate(const uint16_t *pNewSettings) {
 800ad00:	b538      	push	{r3, r4, r5, lr}
  memcpy((void *)&g_cfSettings, (void *)pNewSettings, sizeof(g_cfSettings));
 800ad02:	4c0a      	ldr	r4, [pc, #40]	; (800ad2c <cfSettingsUpdate+0x2c>)
 800ad04:	6800      	ldr	r0, [r0, #0]

/**
 * @brief
 */
static void cfUpdateSettings(void) {
  accel2Kp = g_cfSettings[0] * 0.1f;
 800ad06:	4d0a      	ldr	r5, [pc, #40]	; (800ad30 <cfSettingsUpdate+0x30>)

/**
 * @brief
 */
void cfSettingsUpdate(const uint16_t *pNewSettings) {
  memcpy((void *)&g_cfSettings, (void *)pNewSettings, sizeof(g_cfSettings));
 800ad08:	6020      	str	r0, [r4, #0]

/**
 * @brief
 */
static void cfUpdateSettings(void) {
  accel2Kp = g_cfSettings[0] * 0.1f;
 800ad0a:	8820      	ldrh	r0, [r4, #0]
 800ad0c:	f7f6 f832 	bl	8000d74 <__aeabi_i2f>
 800ad10:	4908      	ldr	r1, [pc, #32]	; (800ad34 <cfSettingsUpdate+0x34>)
 800ad12:	f7f6 f885 	bl	8000e20 <__aeabi_fmul>
 800ad16:	6028      	str	r0, [r5, #0]
  accel2Ki = g_cfSettings[1] * 0.00001f;
 800ad18:	8860      	ldrh	r0, [r4, #2]
 800ad1a:	f7f6 f82b 	bl	8000d74 <__aeabi_i2f>
 800ad1e:	4906      	ldr	r1, [pc, #24]	; (800ad38 <cfSettingsUpdate+0x38>)
 800ad20:	f7f6 f87e 	bl	8000e20 <__aeabi_fmul>
 800ad24:	4b05      	ldr	r3, [pc, #20]	; (800ad3c <cfSettingsUpdate+0x3c>)
 800ad26:	6018      	str	r0, [r3, #0]
 800ad28:	bd38      	pop	{r3, r4, r5, pc}
 800ad2a:	bf00      	nop
 800ad2c:	20000900 	.word	0x20000900
 800ad30:	200008fc 	.word	0x200008fc
 800ad34:	3dcccccd 	.word	0x3dcccccd
 800ad38:	3727c5ac 	.word	0x3727c5ac
 800ad3c:	20000904 	.word	0x20000904

0800ad40 <cmd_threads>:
  chprintf(chp, "heap free total  : %u bytes\r\n", size);
}
#endif

#if 1
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 800ad40:	4770      	bx	lr
 800ad42:	bf00      	nop
	...

0800ad50 <BlinkerThread_B>:

/**
 * Red LED blinker thread. Times are in milliseconds.
 */
static THD_WORKING_AREA(waBlinkerThread_B, 64);
static THD_FUNCTION(BlinkerThread_B,arg) {
 800ad50:	b570      	push	{r4, r5, r6, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800ad52:	4e0b      	ldr	r6, [pc, #44]	; (800ad80 <BlinkerThread_B+0x30>)
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 800ad54:	6933      	ldr	r3, [r6, #16]
 800ad56:	7c5b      	ldrb	r3, [r3, #17]
  (void)arg;
  systime_t time = 20;
  time = 2000; //ms
  while (!chThdShouldTerminateX()) {
 800ad58:	075a      	lsls	r2, r3, #29
 800ad5a:	d40c      	bmi.n	800ad76 <BlinkerThread_B+0x26>
    if (led_b) {
    palToggleLedRed();
    }
    else {palToggleLedRed();}
 800ad5c:	4c09      	ldr	r4, [pc, #36]	; (800ad84 <BlinkerThread_B+0x34>)
 800ad5e:	68e3      	ldr	r3, [r4, #12]
    chThdSleepMilliseconds(time);
 800ad60:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
  time = 2000; //ms
  while (!chThdShouldTerminateX()) {
    if (led_b) {
    palToggleLedRed();
    }
    else {palToggleLedRed();}
 800ad64:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 800ad68:	60e3      	str	r3, [r4, #12]
    chThdSleepMilliseconds(time);
 800ad6a:	f7f6 ff11 	bl	8001b90 <chThdSleep>
 800ad6e:	6933      	ldr	r3, [r6, #16]
 800ad70:	7c5b      	ldrb	r3, [r3, #17]
static THD_WORKING_AREA(waBlinkerThread_B, 64);
static THD_FUNCTION(BlinkerThread_B,arg) {
  (void)arg;
  systime_t time = 20;
  time = 2000; //ms
  while (!chThdShouldTerminateX()) {
 800ad72:	075b      	lsls	r3, r3, #29
 800ad74:	d5f3      	bpl.n	800ad5e <BlinkerThread_B+0xe>
    }
    else {palToggleLedRed();}
    chThdSleepMilliseconds(time);
  }
  /* This point may be reached if shut down is requested. */
  chThdExit(MSG_OK);
 800ad76:	2000      	movs	r0, #0
}
 800ad78:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    }
    else {palToggleLedRed();}
    chThdSleepMilliseconds(time);
  }
  /* This point may be reached if shut down is requested. */
  chThdExit(MSG_OK);
 800ad7c:	f7f6 bf60 	b.w	8001c40 <chThdExit>
 800ad80:	20001160 	.word	0x20001160
 800ad84:	40010c00 	.word	0x40010c00
	...

0800ad90 <BlinkerThread_A>:

/**
 * Green LED blinker thread. Times are in milliseconds.
 */
static THD_WORKING_AREA(waBlinkerThread_A, 64);
static THD_FUNCTION(BlinkerThread_A,arg) {
 800ad90:	b538      	push	{r3, r4, r5, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800ad92:	4d0b      	ldr	r5, [pc, #44]	; (800adc0 <BlinkerThread_A+0x30>)
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 800ad94:	692b      	ldr	r3, [r5, #16]
 800ad96:	7c5b      	ldrb	r3, [r3, #17]
  (void)arg;
  while (!chThdShouldTerminateX()) {
 800ad98:	075a      	lsls	r2, r3, #29
 800ad9a:	d40c      	bmi.n	800adb6 <BlinkerThread_A+0x26>
    } else {
      time = serusbcfg.usbp->state == USB_ACTIVE ? 250 : 500;
    }
#endif
    time = 1000;//ms
    palToggleLedGreen();
 800ad9c:	4c09      	ldr	r4, [pc, #36]	; (800adc4 <BlinkerThread_A+0x34>)
 800ad9e:	68e3      	ldr	r3, [r4, #12]
    //chnWriteTimeout(&SDU1, (uint8_t *)&constHexToSend, 1, TIME_INFINITE);
    //chnWriteTimeout(&SDU1, (uint8_t *)&constHexToSend, 1, TIME_IMMEDIATE);
    //chnWriteTimeout(&SDU1, (uint8_t *)"i\r\n", 3, TIME_IMMEDIATE);
    //chnWriteTimeout(&SD4, (uint8_t *)"i\r\n", 3, TIME_IMMEDIATE);
    
    chThdSleepMilliseconds(time);
 800ada0:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
    } else {
      time = serusbcfg.usbp->state == USB_ACTIVE ? 250 : 500;
    }
#endif
    time = 1000;//ms
    palToggleLedGreen();
 800ada4:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 800ada8:	60e3      	str	r3, [r4, #12]
    //chnWriteTimeout(&SDU1, (uint8_t *)&constHexToSend, 1, TIME_INFINITE);
    //chnWriteTimeout(&SDU1, (uint8_t *)&constHexToSend, 1, TIME_IMMEDIATE);
    //chnWriteTimeout(&SDU1, (uint8_t *)"i\r\n", 3, TIME_IMMEDIATE);
    //chnWriteTimeout(&SD4, (uint8_t *)"i\r\n", 3, TIME_IMMEDIATE);
    
    chThdSleepMilliseconds(time);
 800adaa:	f7f6 fef1 	bl	8001b90 <chThdSleep>
 800adae:	692b      	ldr	r3, [r5, #16]
 800adb0:	7c5b      	ldrb	r3, [r3, #17]
 * Green LED blinker thread. Times are in milliseconds.
 */
static THD_WORKING_AREA(waBlinkerThread_A, 64);
static THD_FUNCTION(BlinkerThread_A,arg) {
  (void)arg;
  while (!chThdShouldTerminateX()) {
 800adb2:	075b      	lsls	r3, r3, #29
 800adb4:	d5f3      	bpl.n	800ad9e <BlinkerThread_A+0xe>
    //chnWriteTimeout(&SD4, (uint8_t *)"i\r\n", 3, TIME_IMMEDIATE);
    
    chThdSleepMilliseconds(time);
  }
  /* This point may be reached if shut down is requested. */
  chThdExit(MSG_OK);
 800adb6:	2000      	movs	r0, #0
}
 800adb8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    //chnWriteTimeout(&SD4, (uint8_t *)"i\r\n", 3, TIME_IMMEDIATE);
    
    chThdSleepMilliseconds(time);
  }
  /* This point may be reached if shut down is requested. */
  chThdExit(MSG_OK);
 800adbc:	f7f6 bf40 	b.w	8001c40 <chThdExit>
 800adc0:	20001160 	.word	0x20001160
 800adc4:	40010c00 	.word	0x40010c00
	...

0800add0 <PollMPU6050Thread>:
/**
 * MPU6050 data polling thread. Times are in milliseconds.
 * This thread requests a new data from MPU6050 every 1.5 ms (@666 Hz).
 */
static THD_WORKING_AREA(waPollMPU6050Thread, 128);
static THD_FUNCTION(PollMPU6050Thread,arg) {
 800add0:	b570      	push	{r4, r5, r6, lr}
  systime_t time;
  uint32_t warmUp = 0;
  (void)arg;
  chprintf((BaseSequentialStream *)&SD4, "i2ccccc\n");
 800add2:	4930      	ldr	r1, [pc, #192]	; (800ae94 <PollMPU6050Thread+0xc4>)
 800add4:	4830      	ldr	r0, [pc, #192]	; (800ae98 <PollMPU6050Thread+0xc8>)
 800add6:	f7fe ff73 	bl	8009cc0 <chprintf>
 800adda:	2320      	movs	r3, #32
 800addc:	f383 8811 	msr	BASEPRI, r3
 800ade0:	4e2e      	ldr	r6, [pc, #184]	; (800ae9c <PollMPU6050Thread+0xcc>)
 800ade2:	2300      	movs	r3, #0
 800ade4:	8bf4      	ldrh	r4, [r6, #30]
 800ade6:	b2a4      	uxth	r4, r4
 800ade8:	f383 8811 	msr	BASEPRI, r3
 800adec:	f504 550c 	add.w	r5, r4, #8960	; 0x2300
 800adf0:	352b      	adds	r5, #43	; 0x2b
 800adf2:	b2ad      	uxth	r5, r5
 800adf4:	e006      	b.n	800ae04 <PollMPU6050Thread+0x34>
      palSetPadMode(GPIOB, 10, PAL_MODE_STM32_ALTERNATE_OPENDRAIN);   /* SCL */
palSetPadMode(GPIOB,11, PAL_MODE_STM32_ALTERNATE_OPENDRAIN);   /* SDA */

    }
    /* Wait until the next 1.5 milliseconds passes. */
    chThdSleepUntil(time += US2ST(1500));
 800adf6:	3403      	adds	r4, #3
 800adf8:	b2a4      	uxth	r4, r4
 800adfa:	4620      	mov	r0, r4
 800adfc:	f7f6 fed8 	bl	8001bb0 <chThdSleepUntil>
  } while (warmUp++ < WARM_UP_COUNTER_MAX);
 800ae00:	42ac      	cmp	r4, r5
 800ae02:	d02c      	beq.n	800ae5e <PollMPU6050Thread+0x8e>
  uint32_t warmUp = 0;
  (void)arg;
  chprintf((BaseSequentialStream *)&SD4, "i2ccccc\n");
  time = chVTGetSystemTime();
  do {
    if (!mpu6050GetNewData(&g_IMU1)) {
 800ae04:	4826      	ldr	r0, [pc, #152]	; (800aea0 <PollMPU6050Thread+0xd0>)
 800ae06:	f000 fc3b 	bl	800b680 <mpu6050GetNewData>
 800ae0a:	2800      	cmp	r0, #0
 800ae0c:	d1f3      	bne.n	800adf6 <PollMPU6050Thread+0x26>
      /* Restart I2C2 bus in case of an error. */
      chprintf((BaseSequentialStream *)&SD4, " restart i2c\n");
 800ae0e:	4925      	ldr	r1, [pc, #148]	; (800aea4 <PollMPU6050Thread+0xd4>)
 800ae10:	4821      	ldr	r0, [pc, #132]	; (800ae98 <PollMPU6050Thread+0xc8>)
 800ae12:	f7fe ff55 	bl	8009cc0 <chprintf>
      i2cStop(&I2CD2);
 800ae16:	4824      	ldr	r0, [pc, #144]	; (800aea8 <PollMPU6050Thread+0xd8>)
 800ae18:	f7f8 fc22 	bl	8003660 <i2cStop>
      i2cStart(&I2CD2, &i2cfg_d2);
 800ae1c:	4822      	ldr	r0, [pc, #136]	; (800aea8 <PollMPU6050Thread+0xd8>)
 800ae1e:	4923      	ldr	r1, [pc, #140]	; (800aeac <PollMPU6050Thread+0xdc>)
 800ae20:	f7f8 fc0e 	bl	8003640 <i2cStart>
    //  palSetPadMode(GPIOB, 10, PAL_MODE_ALTERNATE(4) | PAL_STM32_OTYPE_OPENDRAIN); //SCL
    //palSetPadMode(GPIOB, 11, PAL_MODE_ALTERNATE(4) | PAL_STM32_OTYPE_OPENDRAIN); //SDA
      palSetPadMode(GPIOB, 10, PAL_MODE_STM32_ALTERNATE_OPENDRAIN);   /* SCL */
 800ae24:	4822      	ldr	r0, [pc, #136]	; (800aeb0 <PollMPU6050Thread+0xe0>)
 800ae26:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800ae2a:	2211      	movs	r2, #17
 800ae2c:	f7f9 fd48 	bl	80048c0 <_pal_lld_setgroupmode>
palSetPadMode(GPIOB,11, PAL_MODE_STM32_ALTERNATE_OPENDRAIN);   /* SDA */
 800ae30:	481f      	ldr	r0, [pc, #124]	; (800aeb0 <PollMPU6050Thread+0xe0>)
 800ae32:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800ae36:	2211      	movs	r2, #17
 800ae38:	f7f9 fd42 	bl	80048c0 <_pal_lld_setgroupmode>
 800ae3c:	e7db      	b.n	800adf6 <PollMPU6050Thread+0x26>
 800ae3e:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 800ae42:	481c      	ldr	r0, [pc, #112]	; (800aeb4 <PollMPU6050Thread+0xe4>)
 800ae44:	6883      	ldr	r3, [r0, #8]
 800ae46:	2b00      	cmp	r3, #0
 800ae48:	dd20      	ble.n	800ae8c <PollMPU6050Thread+0xbc>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 800ae4a:	f7f6 fdd9 	bl	8001a00 <chSchRescheduleS>
 800ae4e:	2300      	movs	r3, #0
 800ae50:	f383 8811 	msr	BASEPRI, r3
      /* Restart I2C2 bus in case of an error. */
      i2cStop(&I2CD2);
      i2cStart(&I2CD2, &i2cfg_d2);
    }
    /* Wait until the next 1.5 milliseconds passes. */
    chThdSleepUntil(time += US2ST(1500));
 800ae54:	3503      	adds	r5, #3
 800ae56:	b2ad      	uxth	r5, r5
 800ae58:	4628      	mov	r0, r5
 800ae5a:	f7f6 fea9 	bl	8001bb0 <chThdSleepUntil>
 800ae5e:	6933      	ldr	r3, [r6, #16]
 800ae60:	7c5b      	ldrb	r3, [r3, #17]
    }
    /* Wait until the next 1.5 milliseconds passes. */
    chThdSleepUntil(time += US2ST(1500));
  } while (warmUp++ < WARM_UP_COUNTER_MAX);

  while (!chThdShouldTerminateX()) {
 800ae62:	075b      	lsls	r3, r3, #29
 800ae64:	d40d      	bmi.n	800ae82 <PollMPU6050Thread+0xb2>
    if (mpu6050GetNewData(&g_IMU1)) {
 800ae66:	480e      	ldr	r0, [pc, #56]	; (800aea0 <PollMPU6050Thread+0xd0>)
 800ae68:	f000 fc0a 	bl	800b680 <mpu6050GetNewData>
 800ae6c:	2320      	movs	r3, #32
 800ae6e:	2800      	cmp	r0, #0
 800ae70:	d1e5      	bne.n	800ae3e <PollMPU6050Thread+0x6e>
      chBSemSignal(&bsemIMU1DataReady);
    } else {
      /* Restart I2C2 bus in case of an error. */
      i2cStop(&I2CD2);
 800ae72:	480d      	ldr	r0, [pc, #52]	; (800aea8 <PollMPU6050Thread+0xd8>)
 800ae74:	f7f8 fbf4 	bl	8003660 <i2cStop>
      i2cStart(&I2CD2, &i2cfg_d2);
 800ae78:	480b      	ldr	r0, [pc, #44]	; (800aea8 <PollMPU6050Thread+0xd8>)
 800ae7a:	490c      	ldr	r1, [pc, #48]	; (800aeac <PollMPU6050Thread+0xdc>)
 800ae7c:	f7f8 fbe0 	bl	8003640 <i2cStart>
 800ae80:	e7e8      	b.n	800ae54 <PollMPU6050Thread+0x84>
    }
    /* Wait until the next 1.5 milliseconds passes. */
    chThdSleepUntil(time += US2ST(1500));
  }
  /* This point may be reached if shut down is requested. */
  chThdExit(MSG_OK);
 800ae82:	2000      	movs	r0, #0
}
 800ae84:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    }
    /* Wait until the next 1.5 milliseconds passes. */
    chThdSleepUntil(time += US2ST(1500));
  }
  /* This point may be reached if shut down is requested. */
  chThdExit(MSG_OK);
 800ae88:	f7f6 beda 	b.w	8001c40 <chThdExit>
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
    chSemSignalI(&bsp->bs_sem);
 800ae8c:	f7f7 f8c0 	bl	8002010 <chSemSignalI>
 800ae90:	e7db      	b.n	800ae4a <PollMPU6050Thread+0x7a>
 800ae92:	bf00      	nop
 800ae94:	0800e5d0 	.word	0x0800e5d0
 800ae98:	200013e4 	.word	0x200013e4
 800ae9c:	20001160 	.word	0x20001160
 800aea0:	20002abc 	.word	0x20002abc
 800aea4:	0800e5dc 	.word	0x0800e5dc
 800aea8:	2000133c 	.word	0x2000133c
 800aeac:	0800e580 	.word	0x0800e580
 800aeb0:	40010c00 	.word	0x40010c00
 800aeb4:	20001de8 	.word	0x20001de8
	...

0800aec0 <cmd_write>:
      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";

  (void)argv;
  if (argc > 0) {
 800aec0:	2900      	cmp	r1, #0
 800aec2:	dc17      	bgt.n	800aef4 <cmd_write+0x34>
#endif 

#if 1

/* Can be measured using dd if=/dev/xxxx of=/dev/null bs=512 count=10000.*/
static void cmd_write(BaseSequentialStream *chp, int argc, char *argv[]) {
 800aec4:	b538      	push	{r3, r4, r5, lr}
 800aec6:	4604      	mov	r4, r0
  }

  while (chnGetTimeout((BaseChannel *)chp, TIME_IMMEDIATE) == Q_TIMEOUT) {
#if 1
    /* Writing in channel mode.*/
    chnWrite(&SDU1, buf, sizeof buf - 1);
 800aec8:	4d0c      	ldr	r5, [pc, #48]	; (800aefc <cmd_write+0x3c>)
 800aeca:	e002      	b.n	800aed2 <cmd_write+0x12>
 800aecc:	682b      	ldr	r3, [r5, #0]
 800aece:	681b      	ldr	r3, [r3, #0]
 800aed0:	4798      	blx	r3
  if (argc > 0) {
    chprintf(chp, "Usage: write\r\n");
    return;
  }

  while (chnGetTimeout((BaseChannel *)chp, TIME_IMMEDIATE) == Q_TIMEOUT) {
 800aed2:	6823      	ldr	r3, [r4, #0]
 800aed4:	2100      	movs	r1, #0
 800aed6:	4620      	mov	r0, r4
 800aed8:	695b      	ldr	r3, [r3, #20]
 800aeda:	4798      	blx	r3
 800aedc:	3001      	adds	r0, #1
#if 1
    /* Writing in channel mode.*/
    chnWrite(&SDU1, buf, sizeof buf - 1);
 800aede:	4908      	ldr	r1, [pc, #32]	; (800af00 <cmd_write+0x40>)
 800aee0:	4806      	ldr	r0, [pc, #24]	; (800aefc <cmd_write+0x3c>)
 800aee2:	f44f 6280 	mov.w	r2, #1024	; 0x400
  if (argc > 0) {
    chprintf(chp, "Usage: write\r\n");
    return;
  }

  while (chnGetTimeout((BaseChannel *)chp, TIME_IMMEDIATE) == Q_TIMEOUT) {
 800aee6:	d0f1      	beq.n	800aecc <cmd_write+0xc>
    (void) obqGetEmptyBufferTimeout(&SDU1.obqueue, TIME_INFINITE);
    memcpy(SDU1.obqueue.ptr, buf, SERIAL_USB_BUFFERS_SIZE);
    obqPostFullBuffer(&SDU1.obqueue, SERIAL_USB_BUFFERS_SIZE);
#endif
  }
  chprintf(chp, "\r\n\nstopped\r\n");
 800aee8:	4620      	mov	r0, r4
}
 800aeea:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    (void) obqGetEmptyBufferTimeout(&SDU1.obqueue, TIME_INFINITE);
    memcpy(SDU1.obqueue.ptr, buf, SERIAL_USB_BUFFERS_SIZE);
    obqPostFullBuffer(&SDU1.obqueue, SERIAL_USB_BUFFERS_SIZE);
#endif
  }
  chprintf(chp, "\r\n\nstopped\r\n");
 800aeee:	4905      	ldr	r1, [pc, #20]	; (800af04 <cmd_write+0x44>)
 800aef0:	f7fe bee6 	b.w	8009cc0 <chprintf>
      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";

  (void)argv;
  if (argc > 0) {
    chprintf(chp, "Usage: write\r\n");
 800aef4:	4904      	ldr	r1, [pc, #16]	; (800af08 <cmd_write+0x48>)
 800aef6:	f7fe bee3 	b.w	8009cc0 <chprintf>
 800aefa:	bf00      	nop
 800aefc:	20002bc0 	.word	0x20002bc0
 800af00:	20000924 	.word	0x20000924
 800af04:	0800e5ec 	.word	0x0800e5ec
 800af08:	0800e5fc 	.word	0x0800e5fc
 800af0c:	00000000 	.word	0x00000000

0800af10 <cmd_test>:
#if 1
static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
 800af10:	2900      	cmp	r1, #0
 800af12:	dd02      	ble.n	800af1a <cmd_test+0xa>
    chprintf(chp, "Usage: test\r\n");
 800af14:	490e      	ldr	r1, [pc, #56]	; (800af50 <cmd_test+0x40>)
 800af16:	f7fe bed3 	b.w	8009cc0 <chprintf>
  */
}
#endif

#if 1
static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
 800af1a:	b510      	push	{r4, lr}
 800af1c:	4604      	mov	r4, r0
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800af1e:	4b0d      	ldr	r3, [pc, #52]	; (800af54 <cmd_test+0x44>)
 800af20:	b082      	sub	sp, #8
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 800af22:	691b      	ldr	r3, [r3, #16]
  (void)argv;
  if (argc > 0) {
    chprintf(chp, "Usage: test\r\n");
    return;
  }
  tp = chThdCreateFromHeap(NULL, TEST_WA_SIZE, chThdGetPriorityX(),
 800af24:	2000      	movs	r0, #0
 800af26:	689a      	ldr	r2, [r3, #8]
 800af28:	f44f 71e0 	mov.w	r1, #448	; 0x1c0
 800af2c:	4b0a      	ldr	r3, [pc, #40]	; (800af58 <cmd_test+0x48>)
 800af2e:	9400      	str	r4, [sp, #0]
 800af30:	f7f6 ff7e 	bl	8001e30 <chThdCreateFromHeap>
                           TestThread, chp);
  if (tp == NULL) {
 800af34:	b120      	cbz	r0, 800af40 <cmd_test+0x30>
    chprintf(chp, "out of memory\r\n");
    return;
  }
  chThdWait(tp);
}
 800af36:	b002      	add	sp, #8
 800af38:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
                           TestThread, chp);
  if (tp == NULL) {
    chprintf(chp, "out of memory\r\n");
    return;
  }
  chThdWait(tp);
 800af3c:	f7f6 be88 	b.w	8001c50 <chThdWait>
    return;
  }
  tp = chThdCreateFromHeap(NULL, TEST_WA_SIZE, chThdGetPriorityX(),
                           TestThread, chp);
  if (tp == NULL) {
    chprintf(chp, "out of memory\r\n");
 800af40:	4620      	mov	r0, r4
 800af42:	4906      	ldr	r1, [pc, #24]	; (800af5c <cmd_test+0x4c>)
    return;
  }
  chThdWait(tp);
}
 800af44:	b002      	add	sp, #8
 800af46:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return;
  }
  tp = chThdCreateFromHeap(NULL, TEST_WA_SIZE, chThdGetPriorityX(),
                           TestThread, chp);
  if (tp == NULL) {
    chprintf(chp, "out of memory\r\n");
 800af4a:	f7fe beb9 	b.w	8009cc0 <chprintf>
 800af4e:	bf00      	nop
 800af50:	0800e60c 	.word	0x0800e60c
 800af54:	20001160 	.word	0x20001160
 800af58:	08005f61 	.word	0x08005f61
 800af5c:	0800e61c 	.word	0x0800e61c

0800af60 <cmd_mem>:




#if 1
static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
 800af60:	b530      	push	{r4, r5, lr}
  size_t n, size;

  (void)argv;
  if (argc > 0) {
 800af62:	2900      	cmp	r1, #0




#if 1
static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
 800af64:	b083      	sub	sp, #12
  size_t n, size;

  (void)argv;
  if (argc > 0) {
 800af66:	dd04      	ble.n	800af72 <cmd_mem+0x12>
    chprintf(chp, "Usage: mem\r\n");
 800af68:	490e      	ldr	r1, [pc, #56]	; (800afa4 <cmd_mem+0x44>)
 800af6a:	f7fe fea9 	bl	8009cc0 <chprintf>
  }
  n = chHeapStatus(NULL, &size);
  chprintf(chp, "core free memory : %u bytes\r\n", chCoreGetStatusX());
  chprintf(chp, "heap fragments   : %u\r\n", n);
  chprintf(chp, "heap free total  : %u bytes\r\n", size);
}
 800af6e:	b003      	add	sp, #12
 800af70:	bd30      	pop	{r4, r5, pc}
 800af72:	4604      	mov	r4, r0
  (void)argv;
  if (argc > 0) {
    chprintf(chp, "Usage: mem\r\n");
    return;
  }
  n = chHeapStatus(NULL, &size);
 800af74:	a901      	add	r1, sp, #4
 800af76:	2000      	movs	r0, #0
 800af78:	f7f8 f80a 	bl	8002f90 <chHeapStatus>
 800af7c:	4605      	mov	r5, r0
  chprintf(chp, "core free memory : %u bytes\r\n", chCoreGetStatusX());
 800af7e:	f7f7 ff47 	bl	8002e10 <chCoreGetStatusX>
 800af82:	4909      	ldr	r1, [pc, #36]	; (800afa8 <cmd_mem+0x48>)
 800af84:	4602      	mov	r2, r0
 800af86:	4620      	mov	r0, r4
 800af88:	f7fe fe9a 	bl	8009cc0 <chprintf>
  chprintf(chp, "heap fragments   : %u\r\n", n);
 800af8c:	462a      	mov	r2, r5
 800af8e:	4620      	mov	r0, r4
 800af90:	4906      	ldr	r1, [pc, #24]	; (800afac <cmd_mem+0x4c>)
 800af92:	f7fe fe95 	bl	8009cc0 <chprintf>
  chprintf(chp, "heap free total  : %u bytes\r\n", size);
 800af96:	4620      	mov	r0, r4
 800af98:	4905      	ldr	r1, [pc, #20]	; (800afb0 <cmd_mem+0x50>)
 800af9a:	9a01      	ldr	r2, [sp, #4]
 800af9c:	f7fe fe90 	bl	8009cc0 <chprintf>
}
 800afa0:	b003      	add	sp, #12
 800afa2:	bd30      	pop	{r4, r5, pc}
 800afa4:	0800e62c 	.word	0x0800e62c
 800afa8:	0800e63c 	.word	0x0800e63c
 800afac:	0800e65c 	.word	0x0800e65c
 800afb0:	0800e674 	.word	0x0800e674
	...

0800afc0 <AttitudeThread>:
 * - This thread is synchronized by PollMPU6050Thread thread.
 * - This thread has the highest priority level.
 */
#if 1
static THD_WORKING_AREA(waAttitudeThread, 2048);
static THD_FUNCTION(AttitudeThread,arg) {
 800afc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  (void)arg;
  attitudeInit();
  while (!chThdShouldTerminateX()) {
    /* Process IMU1 new data ready event. */
    if (chBSemWait(&bsemIMU1DataReady) == MSG_OK) {
      if (g_boardStatus & IMU1_CALIBRATION_MASK) {
 800afc4:	4d5e      	ldr	r5, [pc, #376]	; (800b140 <AttitudeThread+0x180>)
 */
#if 1
static THD_WORKING_AREA(waAttitudeThread, 2048);
static THD_FUNCTION(AttitudeThread,arg) {
  (void)arg;
  attitudeInit();
 800afc6:	f7ff f9e3 	bl	800a390 <attitudeInit>
  while (!chThdShouldTerminateX()) {
    /* Process IMU1 new data ready event. */
    if (chBSemWait(&bsemIMU1DataReady) == MSG_OK) {
      if (g_boardStatus & IMU1_CALIBRATION_MASK) {
 800afca:	462e      	mov	r6, r5
 800afcc:	4c5d      	ldr	r4, [pc, #372]	; (800b144 <AttitudeThread+0x184>)
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 800afce:	6923      	ldr	r3, [r4, #16]
 800afd0:	7c5b      	ldrb	r3, [r3, #17]
#if 1
static THD_WORKING_AREA(waAttitudeThread, 2048);
static THD_FUNCTION(AttitudeThread,arg) {
  (void)arg;
  attitudeInit();
  while (!chThdShouldTerminateX()) {
 800afd2:	075b      	lsls	r3, r3, #29
 800afd4:	d411      	bmi.n	800affa <AttitudeThread+0x3a>
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {

  return chSemWait(&bsp->bs_sem);
 800afd6:	485c      	ldr	r0, [pc, #368]	; (800b148 <AttitudeThread+0x188>)
 800afd8:	f7f6 ffa2 	bl	8001f20 <chSemWait>
    /* Process IMU1 new data ready event. */
    if (chBSemWait(&bsemIMU1DataReady) == MSG_OK) {
 800afdc:	b1b8      	cbz	r0, 800b00e <AttitudeThread+0x4e>
 800afde:	4f58      	ldr	r7, [pc, #352]	; (800b140 <AttitudeThread+0x180>)
      } else {
        attitudeUpdate(&g_IMU1);
      }
    }

    if (g_streamDataID) {
 800afe0:	4a5a      	ldr	r2, [pc, #360]	; (800b14c <AttitudeThread+0x18c>)
 800afe2:	7813      	ldrb	r3, [r2, #0]
 800afe4:	bb3b      	cbnz	r3, 800b036 <AttitudeThread+0x76>
      streamUpdateData(&g_IMU1);
    }

    if (g_boardStatus & IMU_CALIBRATION_MASK) {
 800afe6:	683b      	ldr	r3, [r7, #0]
 800afe8:	f013 0f78 	tst.w	r3, #120	; 0x78
 800afec:	d00a      	beq.n	800b004 <AttitudeThread+0x44>
      pwmOutputDisableAll();
 800afee:	f7fa fe27 	bl	8005c40 <pwmOutputDisableAll>
 800aff2:	6923      	ldr	r3, [r4, #16]
 800aff4:	7c5b      	ldrb	r3, [r3, #17]
#if 1
static THD_WORKING_AREA(waAttitudeThread, 2048);
static THD_FUNCTION(AttitudeThread,arg) {
  (void)arg;
  attitudeInit();
  while (!chThdShouldTerminateX()) {
 800aff6:	075b      	lsls	r3, r3, #29
 800aff8:	d5ed      	bpl.n	800afd6 <AttitudeThread+0x16>
      cameraRotationUpdate();
      actuatorsUpdate();
    }
  }
  /* This point may be reached if shut down is requested. */
  chThdExit(MSG_OK);
 800affa:	2000      	movs	r0, #0
}
 800affc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      cameraRotationUpdate();
      actuatorsUpdate();
    }
  }
  /* This point may be reached if shut down is requested. */
  chThdExit(MSG_OK);
 800b000:	f7f6 be1e 	b.w	8001c40 <chThdExit>
    }

    if (g_boardStatus & IMU_CALIBRATION_MASK) {
      pwmOutputDisableAll();
    } else {
      cameraRotationUpdate();
 800b004:	f7ff fbdc 	bl	800a7c0 <cameraRotationUpdate>
      actuatorsUpdate();
 800b008:	f7ff fd4a 	bl	800aaa0 <actuatorsUpdate>
 800b00c:	e7df      	b.n	800afce <AttitudeThread+0xe>
  (void)arg;
  attitudeInit();
  while (!chThdShouldTerminateX()) {
    /* Process IMU1 new data ready event. */
    if (chBSemWait(&bsemIMU1DataReady) == MSG_OK) {
      if (g_boardStatus & IMU1_CALIBRATION_MASK) {
 800b00e:	6829      	ldr	r1, [r5, #0]
 800b010:	4f4b      	ldr	r7, [pc, #300]	; (800b140 <AttitudeThread+0x180>)
 800b012:	f011 0f18 	tst.w	r1, #24
 800b016:	d018      	beq.n	800b04a <AttitudeThread+0x8a>
        if (imuCalibrate(&g_IMU1, g_boardStatus & IMU1_CALIBRATE_ACCEL)) {
 800b018:	f001 0110 	and.w	r1, r1, #16
 800b01c:	484c      	ldr	r0, [pc, #304]	; (800b150 <AttitudeThread+0x190>)
 800b01e:	f000 f9cf 	bl	800b3c0 <imuCalibrate>
 800b022:	2800      	cmp	r0, #0
 800b024:	d0dc      	beq.n	800afe0 <AttitudeThread+0x20>
          g_boardStatus &= ~IMU1_CALIBRATION_MASK;
 800b026:	6833      	ldr	r3, [r6, #0]
      } else {
        attitudeUpdate(&g_IMU1);
      }
    }

    if (g_streamDataID) {
 800b028:	4a48      	ldr	r2, [pc, #288]	; (800b14c <AttitudeThread+0x18c>)
  while (!chThdShouldTerminateX()) {
    /* Process IMU1 new data ready event. */
    if (chBSemWait(&bsemIMU1DataReady) == MSG_OK) {
      if (g_boardStatus & IMU1_CALIBRATION_MASK) {
        if (imuCalibrate(&g_IMU1, g_boardStatus & IMU1_CALIBRATE_ACCEL)) {
          g_boardStatus &= ~IMU1_CALIBRATION_MASK;
 800b02a:	f023 0318 	bic.w	r3, r3, #24
 800b02e:	6033      	str	r3, [r6, #0]
      } else {
        attitudeUpdate(&g_IMU1);
      }
    }

    if (g_streamDataID) {
 800b030:	7813      	ldrb	r3, [r2, #0]
 800b032:	2b00      	cmp	r3, #0
 800b034:	d0d7      	beq.n	800afe6 <AttitudeThread+0x26>
static float dataStream[STREAM_BUFFER_SIZE];
/* Pointer to low or high part of the data streaming buffer. */
float *pStream = NULL;

static void streamUpdateData(PIMUStruct pIMU) {
  switch (g_streamDataID) {
 800b036:	3b01      	subs	r3, #1
 800b038:	2b08      	cmp	r3, #8
 800b03a:	d876      	bhi.n	800b12a <AttitudeThread+0x16a>
 800b03c:	e8df f003 	tbb	[pc, r3]
 800b040:	484f565d 	.word	0x484f565d
 800b044:	2c333a41 	.word	0x2c333a41
 800b048:	09          	.byte	0x09
 800b049:	00          	.byte	0x00
      if (g_boardStatus & IMU1_CALIBRATION_MASK) {
        if (imuCalibrate(&g_IMU1, g_boardStatus & IMU1_CALIBRATE_ACCEL)) {
          g_boardStatus &= ~IMU1_CALIBRATION_MASK;
        }
      } else {
        attitudeUpdate(&g_IMU1);
 800b04a:	4841      	ldr	r0, [pc, #260]	; (800b150 <AttitudeThread+0x190>)
 800b04c:	f7ff f9d0 	bl	800a3f0 <attitudeUpdate>
 800b050:	e7c6      	b.n	800afe0 <AttitudeThread+0x20>
    break;
  case 8: /* Atti Y;  */
    dataStream[g_streamIdx++] = pIMU->rpy[1];
    break;
  case 9: /* Atti Z;  */
    dataStream[g_streamIdx++] = pIMU->rpy[2];
 800b052:	f8df 8110 	ldr.w	r8, [pc, #272]	; 800b164 <AttitudeThread+0x1a4>
 800b056:	4b3e      	ldr	r3, [pc, #248]	; (800b150 <AttitudeThread+0x190>)
 800b058:	f898 1000 	ldrb.w	r1, [r8]
 800b05c:	6e18      	ldr	r0, [r3, #96]	; 0x60
 800b05e:	1c4b      	adds	r3, r1, #1
 800b060:	b2db      	uxtb	r3, r3
 800b062:	4a3c      	ldr	r2, [pc, #240]	; (800b154 <AttitudeThread+0x194>)
  default:
    g_streamIdx = 0;
    g_streamDataID = 0;
  }

  if (g_streamIdx == (STREAM_BUFFER_SIZE / 2)) {
 800b064:	2b10      	cmp	r3, #16
    break;
  case 8: /* Atti Y;  */
    dataStream[g_streamIdx++] = pIMU->rpy[1];
    break;
  case 9: /* Atti Z;  */
    dataStream[g_streamIdx++] = pIMU->rpy[2];
 800b066:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
 800b06a:	f888 3000 	strb.w	r3, [r8]
  default:
    g_streamIdx = 0;
    g_streamDataID = 0;
  }

  if (g_streamIdx == (STREAM_BUFFER_SIZE / 2)) {
 800b06e:	d04b      	beq.n	800b108 <AttitudeThread+0x148>
    pStream = &dataStream[0];
    chBSemSignal(&bsemStreamReady);
  }

  if (g_streamIdx == STREAM_BUFFER_SIZE) {
 800b070:	2b20      	cmp	r3, #32
 800b072:	d1b8      	bne.n	800afe6 <AttitudeThread+0x26>
    g_streamIdx = 0;
    pStream = &dataStream[STREAM_BUFFER_SIZE / 2];
 800b074:	4938      	ldr	r1, [pc, #224]	; (800b158 <AttitudeThread+0x198>)
 800b076:	4839      	ldr	r0, [pc, #228]	; (800b15c <AttitudeThread+0x19c>)
    pStream = &dataStream[0];
    chBSemSignal(&bsemStreamReady);
  }

  if (g_streamIdx == STREAM_BUFFER_SIZE) {
    g_streamIdx = 0;
 800b078:	2200      	movs	r2, #0
    pStream = &dataStream[STREAM_BUFFER_SIZE / 2];
 800b07a:	6008      	str	r0, [r1, #0]
    pStream = &dataStream[0];
    chBSemSignal(&bsemStreamReady);
  }

  if (g_streamIdx == STREAM_BUFFER_SIZE) {
    g_streamIdx = 0;
 800b07c:	f888 2000 	strb.w	r2, [r8]
 800b080:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 800b084:	4836      	ldr	r0, [pc, #216]	; (800b160 <AttitudeThread+0x1a0>)
 800b086:	6883      	ldr	r3, [r0, #8]
 800b088:	4293      	cmp	r3, r2
 800b08a:	dd53      	ble.n	800b134 <AttitudeThread+0x174>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 800b08c:	f7f6 fcb8 	bl	8001a00 <chSchRescheduleS>
 800b090:	2300      	movs	r3, #0
 800b092:	f383 8811 	msr	BASEPRI, r3
 800b096:	e7a6      	b.n	800afe6 <AttitudeThread+0x26>
    break;
  case 7: /* Atti X;  */
    dataStream[g_streamIdx++] = pIMU->rpy[0];
    break;
  case 8: /* Atti Y;  */
    dataStream[g_streamIdx++] = pIMU->rpy[1];
 800b098:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 800b164 <AttitudeThread+0x1a4>
 800b09c:	4b2c      	ldr	r3, [pc, #176]	; (800b150 <AttitudeThread+0x190>)
 800b09e:	f898 1000 	ldrb.w	r1, [r8]
 800b0a2:	6dd8      	ldr	r0, [r3, #92]	; 0x5c
 800b0a4:	e7db      	b.n	800b05e <AttitudeThread+0x9e>
    break;
  case 6: /* Gyro Z;  */
    dataStream[g_streamIdx++] = pIMU->gyroData[2];
    break;
  case 7: /* Atti X;  */
    dataStream[g_streamIdx++] = pIMU->rpy[0];
 800b0a6:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 800b164 <AttitudeThread+0x1a4>
 800b0aa:	4b29      	ldr	r3, [pc, #164]	; (800b150 <AttitudeThread+0x190>)
 800b0ac:	f898 1000 	ldrb.w	r1, [r8]
 800b0b0:	6d98      	ldr	r0, [r3, #88]	; 0x58
 800b0b2:	e7d4      	b.n	800b05e <AttitudeThread+0x9e>
    break;
  case 5: /* Gyro Y;  */
    dataStream[g_streamIdx++] = pIMU->gyroData[1];
    break;
  case 6: /* Gyro Z;  */
    dataStream[g_streamIdx++] = pIMU->gyroData[2];
 800b0b4:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 800b164 <AttitudeThread+0x1a4>
 800b0b8:	4b25      	ldr	r3, [pc, #148]	; (800b150 <AttitudeThread+0x190>)
 800b0ba:	f898 1000 	ldrb.w	r1, [r8]
 800b0be:	6958      	ldr	r0, [r3, #20]
 800b0c0:	e7cd      	b.n	800b05e <AttitudeThread+0x9e>
    break;
  case 4: /* Gyro X;  */
    dataStream[g_streamIdx++] = pIMU->gyroData[0];
    break;
  case 5: /* Gyro Y;  */
    dataStream[g_streamIdx++] = pIMU->gyroData[1];
 800b0c2:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 800b164 <AttitudeThread+0x1a4>
 800b0c6:	4b22      	ldr	r3, [pc, #136]	; (800b150 <AttitudeThread+0x190>)
 800b0c8:	f898 1000 	ldrb.w	r1, [r8]
 800b0cc:	6918      	ldr	r0, [r3, #16]
 800b0ce:	e7c6      	b.n	800b05e <AttitudeThread+0x9e>
    break;
  case 3: /* Accel Z; */
    dataStream[g_streamIdx++] = pIMU->accelData[2];
    break;
  case 4: /* Gyro X;  */
    dataStream[g_streamIdx++] = pIMU->gyroData[0];
 800b0d0:	f8df 8090 	ldr.w	r8, [pc, #144]	; 800b164 <AttitudeThread+0x1a4>
 800b0d4:	4b1e      	ldr	r3, [pc, #120]	; (800b150 <AttitudeThread+0x190>)
 800b0d6:	f898 1000 	ldrb.w	r1, [r8]
 800b0da:	68d8      	ldr	r0, [r3, #12]
 800b0dc:	e7bf      	b.n	800b05e <AttitudeThread+0x9e>
    break;
  case 2: /* Accel Y; */
    dataStream[g_streamIdx++] = pIMU->accelData[1];
    break;
  case 3: /* Accel Z; */
    dataStream[g_streamIdx++] = pIMU->accelData[2];
 800b0de:	f8df 8084 	ldr.w	r8, [pc, #132]	; 800b164 <AttitudeThread+0x1a4>
 800b0e2:	4b1b      	ldr	r3, [pc, #108]	; (800b150 <AttitudeThread+0x190>)
 800b0e4:	f898 1000 	ldrb.w	r1, [r8]
 800b0e8:	6898      	ldr	r0, [r3, #8]
 800b0ea:	e7b8      	b.n	800b05e <AttitudeThread+0x9e>
  switch (g_streamDataID) {
  case 1: /* Accel X; */
    dataStream[g_streamIdx++] = pIMU->accelData[0];
    break;
  case 2: /* Accel Y; */
    dataStream[g_streamIdx++] = pIMU->accelData[1];
 800b0ec:	f8df 8074 	ldr.w	r8, [pc, #116]	; 800b164 <AttitudeThread+0x1a4>
 800b0f0:	4b17      	ldr	r3, [pc, #92]	; (800b150 <AttitudeThread+0x190>)
 800b0f2:	f898 1000 	ldrb.w	r1, [r8]
 800b0f6:	6858      	ldr	r0, [r3, #4]
 800b0f8:	e7b1      	b.n	800b05e <AttitudeThread+0x9e>
float *pStream = NULL;

static void streamUpdateData(PIMUStruct pIMU) {
  switch (g_streamDataID) {
  case 1: /* Accel X; */
    dataStream[g_streamIdx++] = pIMU->accelData[0];
 800b0fa:	f8df 8068 	ldr.w	r8, [pc, #104]	; 800b164 <AttitudeThread+0x1a4>
 800b0fe:	4b14      	ldr	r3, [pc, #80]	; (800b150 <AttitudeThread+0x190>)
 800b100:	f898 1000 	ldrb.w	r1, [r8]
 800b104:	6818      	ldr	r0, [r3, #0]
 800b106:	e7aa      	b.n	800b05e <AttitudeThread+0x9e>
    g_streamIdx = 0;
    g_streamDataID = 0;
  }

  if (g_streamIdx == (STREAM_BUFFER_SIZE / 2)) {
    pStream = &dataStream[0];
 800b108:	4913      	ldr	r1, [pc, #76]	; (800b158 <AttitudeThread+0x198>)
 800b10a:	2320      	movs	r3, #32
 800b10c:	600a      	str	r2, [r1, #0]
 800b10e:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 800b112:	4813      	ldr	r0, [pc, #76]	; (800b160 <AttitudeThread+0x1a0>)
 800b114:	6883      	ldr	r3, [r0, #8]
 800b116:	2b00      	cmp	r3, #0
 800b118:	dd0f      	ble.n	800b13a <AttitudeThread+0x17a>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 800b11a:	f7f6 fc71 	bl	8001a00 <chSchRescheduleS>
 800b11e:	2300      	movs	r3, #0
 800b120:	f383 8811 	msr	BASEPRI, r3
 800b124:	f898 3000 	ldrb.w	r3, [r8]
 800b128:	e7a2      	b.n	800b070 <AttitudeThread+0xb0>
    break;
  case 9: /* Atti Z;  */
    dataStream[g_streamIdx++] = pIMU->rpy[2];
    break;
  default:
    g_streamIdx = 0;
 800b12a:	490e      	ldr	r1, [pc, #56]	; (800b164 <AttitudeThread+0x1a4>)
 800b12c:	2300      	movs	r3, #0
 800b12e:	700b      	strb	r3, [r1, #0]
    g_streamDataID = 0;
 800b130:	7013      	strb	r3, [r2, #0]
 800b132:	e758      	b.n	800afe6 <AttitudeThread+0x26>
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
    chSemSignalI(&bsp->bs_sem);
 800b134:	f7f6 ff6c 	bl	8002010 <chSemSignalI>
 800b138:	e7a8      	b.n	800b08c <AttitudeThread+0xcc>
 800b13a:	f7f6 ff69 	bl	8002010 <chSemSignalI>
 800b13e:	e7ec      	b.n	800b11a <AttitudeThread+0x15a>
 800b140:	20001df8 	.word	0x20001df8
 800b144:	20001160 	.word	0x20001160
 800b148:	20001de8 	.word	0x20001de8
 800b14c:	20001df4 	.word	0x20001df4
 800b150:	20002abc 	.word	0x20002abc
 800b154:	200026c8 	.word	0x200026c8
 800b158:	20002850 	.word	0x20002850
 800b15c:	20002708 	.word	0x20002708
 800b160:	20002a98 	.word	0x20002a98
 800b164:	20002748 	.word	0x20002748
	...

0800b170 <main>:

/**
 * @brief   Application entry point.
 * @details
 */
int main(void) {
 800b170:	b570      	push	{r4, r5, r6, lr}
  //osalInit();
  chSysInit();

  /* Initializes a serial-over-USB CDC driver. */
  sduObjectInit(&SDU1);
  sduStart(&SDU1, &serusbcfg);
 800b172:	4c5d      	ldr	r4, [pc, #372]	; (800b2e8 <main+0x178>)

/**
 * @brief   Application entry point.
 * @details
 */
int main(void) {
 800b174:	b082      	sub	sp, #8
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 800b176:	f7f7 ffb3 	bl	80030e0 <halInit>
  //osalInit();
  chSysInit();
 800b17a:	f7f6 fa09 	bl	8001590 <chSysInit>

  /* Initializes a serial-over-USB CDC driver. */
  sduObjectInit(&SDU1);
 800b17e:	485b      	ldr	r0, [pc, #364]	; (800b2ec <main+0x17c>)
 800b180:	f7f8 fc3e 	bl	8003a00 <sduObjectInit>
  sduStart(&SDU1, &serusbcfg);
 800b184:	4621      	mov	r1, r4
 800b186:	4859      	ldr	r0, [pc, #356]	; (800b2ec <main+0x17c>)
 800b188:	f7f8 fc6a 	bl	8003a60 <sduStart>
  /* Activates the USB driver and then the USB bus pull-up on D+.
   * Note, a delay is inserted in order to not have to disconnect the cable
   * after a reset.
   */
  usbStop(serusbcfg.usbp);
  usbDisconnectBus(serusbcfg.usbp);
 800b18c:	4d58      	ldr	r5, [pc, #352]	; (800b2f0 <main+0x180>)

  /* Initializes a serial-over-USB CDC driver. */
  sduObjectInit(&SDU1);
  sduStart(&SDU1, &serusbcfg);

  sdStart(&SD4, NULL);
 800b18e:	2100      	movs	r1, #0
 800b190:	4858      	ldr	r0, [pc, #352]	; (800b2f4 <main+0x184>)
 800b192:	f7f8 fb25 	bl	80037e0 <sdStart>
  /* Activates the USB driver and then the USB bus pull-up on D+.
   * Note, a delay is inserted in order to not have to disconnect the cable
   * after a reset.
   */
  usbStop(serusbcfg.usbp);
  usbDisconnectBus(serusbcfg.usbp);
 800b196:	2620      	movs	r6, #32
  
  /* Activates the USB driver and then the USB bus pull-up on D+.
   * Note, a delay is inserted in order to not have to disconnect the cable
   * after a reset.
   */
  usbStop(serusbcfg.usbp);
 800b198:	6820      	ldr	r0, [r4, #0]
 800b19a:	f7f8 fd81 	bl	8003ca0 <usbStop>
  usbDisconnectBus(serusbcfg.usbp);
 800b19e:	4631      	mov	r1, r6
 800b1a0:	2206      	movs	r2, #6
 800b1a2:	4628      	mov	r0, r5
 800b1a4:	f7f9 fb8c 	bl	80048c0 <_pal_lld_setgroupmode>
  chThdSleepMilliseconds(500);
 800b1a8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  /* Activates the USB driver and then the USB bus pull-up on D+.
   * Note, a delay is inserted in order to not have to disconnect the cable
   * after a reset.
   */
  usbStop(serusbcfg.usbp);
  usbDisconnectBus(serusbcfg.usbp);
 800b1ac:	616e      	str	r6, [r5, #20]
  chThdSleepMilliseconds(500);
 800b1ae:	f7f6 fcef 	bl	8001b90 <chThdSleep>
  usbConnectBus(serusbcfg.usbp);
 800b1b2:	2202      	movs	r2, #2
 800b1b4:	4628      	mov	r0, r5
 800b1b6:	4631      	mov	r1, r6
 800b1b8:	f7f9 fb82 	bl	80048c0 <_pal_lld_setgroupmode>
  usbStart(serusbcfg.usbp, &usbcfg);
 800b1bc:	6820      	ldr	r0, [r4, #0]
 800b1be:	494e      	ldr	r1, [pc, #312]	; (800b2f8 <main+0x188>)
 800b1c0:	f7f8 fd4e 	bl	8003c60 <usbStart>

  shellInit();
 800b1c4:	f7fe fa04 	bl	80095d0 <shellInit>
  //sdStart(&SD4, NULL);

  
  
  /* Activates the I2C driver 2. */
  i2cStart(&I2CD2, &i2cfg_d2);
 800b1c8:	484c      	ldr	r0, [pc, #304]	; (800b2fc <main+0x18c>)
 800b1ca:	494d      	ldr	r1, [pc, #308]	; (800b300 <main+0x190>)
 800b1cc:	f7f8 fa38 	bl	8003640 <i2cStart>

  /* Enables the CRC peripheral clock. */
  rccEnableAHB(RCC_AHBENR_CRCEN,FALSE);
 800b1d0:	4a4c      	ldr	r2, [pc, #304]	; (800b304 <main+0x194>)

  /* Initialize IMU data structure. */
  imuStructureInit(&g_IMU1, FALSE); // IMU1 on low address.
 800b1d2:	484d      	ldr	r0, [pc, #308]	; (800b308 <main+0x198>)
  
  /* Activates the I2C driver 2. */
  i2cStart(&I2CD2, &i2cfg_d2);

  /* Enables the CRC peripheral clock. */
  rccEnableAHB(RCC_AHBENR_CRCEN,FALSE);
 800b1d4:	6953      	ldr	r3, [r2, #20]

  /* Initialize IMU data structure. */
  imuStructureInit(&g_IMU1, FALSE); // IMU1 on low address.
 800b1d6:	2100      	movs	r1, #0
  
  /* Activates the I2C driver 2. */
  i2cStart(&I2CD2, &i2cfg_d2);

  /* Enables the CRC peripheral clock. */
  rccEnableAHB(RCC_AHBENR_CRCEN,FALSE);
 800b1d8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800b1dc:	6153      	str	r3, [r2, #20]

  /* Initialize IMU data structure. */
  imuStructureInit(&g_IMU1, FALSE); // IMU1 on low address.
 800b1de:	f000 f8b7 	bl	800b350 <imuStructureInit>
  /* Loads settings from external EEPROM chip.
     WARNING! If MPU6050 sensor is not connected to the I2C bus, there
     aren't pull-up resistors on SDA and SCL lines, therefore it is
     impossible to communicate with EEPROM without the sensor connected. */

  bool result = loadSettings();
 800b1e2:	f000 fcb5 	bl	800bb50 <loadSettings>
  if(result)
 800b1e6:	2800      	cmp	r0, #0
 800b1e8:	d079      	beq.n	800b2de <main+0x16e>
      chprintf((BaseSequentialStream *)&SD4, "pamiec OK\n");
 800b1ea:	4842      	ldr	r0, [pc, #264]	; (800b2f4 <main+0x184>)
 800b1ec:	4947      	ldr	r1, [pc, #284]	; (800b30c <main+0x19c>)
 800b1ee:	f7fe fd67 	bl	8009cc0 <chprintf>
  else 
      chprintf((BaseSequentialStream *)&SD4, "pamiec ZLE\n");
  g_boardStatus |= EEPROM_24C02_DETECTED;
 800b1f2:	4c47      	ldr	r4, [pc, #284]	; (800b310 <main+0x1a0>)

  /* Initializes the MPU6050 sensor1. */
  if (mpu6050Init(g_IMU1.addr)) {
 800b1f4:	4a44      	ldr	r2, [pc, #272]	; (800b308 <main+0x198>)
  bool result = loadSettings();
  if(result)
      chprintf((BaseSequentialStream *)&SD4, "pamiec OK\n");
  else 
      chprintf((BaseSequentialStream *)&SD4, "pamiec ZLE\n");
  g_boardStatus |= EEPROM_24C02_DETECTED;
 800b1f6:	6823      	ldr	r3, [r4, #0]

  /* Initializes the MPU6050 sensor1. */
  if (mpu6050Init(g_IMU1.addr)) {
 800b1f8:	f892 006b 	ldrb.w	r0, [r2, #107]	; 0x6b
  bool result = loadSettings();
  if(result)
      chprintf((BaseSequentialStream *)&SD4, "pamiec OK\n");
  else 
      chprintf((BaseSequentialStream *)&SD4, "pamiec ZLE\n");
  g_boardStatus |= EEPROM_24C02_DETECTED;
 800b1fc:	f043 0304 	orr.w	r3, r3, #4
 800b200:	6023      	str	r3, [r4, #0]

  /* Initializes the MPU6050 sensor1. */
  if (mpu6050Init(g_IMU1.addr)) {
 800b202:	f000 f995 	bl	800b530 <mpu6050Init>
      
    g_boardStatus |= MPU6050_LOW_DETECTED;
    g_boardStatus |= IMU1_CALIBRATE_GYRO;
 800b206:	6823      	ldr	r3, [r4, #0]
  else 
      chprintf((BaseSequentialStream *)&SD4, "pamiec ZLE\n");
  g_boardStatus |= EEPROM_24C02_DETECTED;

  /* Initializes the MPU6050 sensor1. */
  if (mpu6050Init(g_IMU1.addr)) {
 800b208:	b110      	cbz	r0, 800b210 <main+0xa0>
      
    g_boardStatus |= MPU6050_LOW_DETECTED;
    g_boardStatus |= IMU1_CALIBRATE_GYRO;
 800b20a:	f043 0309 	orr.w	r3, r3, #9
 800b20e:	6023      	str	r3, [r4, #0]
//tpPoller = chThdCreateStatic(waPollMPU6050Thread, sizeof(waPollMPU6050Thread),
      //NORMALPRIO + 1, PollMPU6050Thread, NULL);

#if 1
  //if (g_boardStatus & MPU6050_LOW_DETECTED) {
  if (g_boardStatus & MPU6050_LOW_DETECTED) {
 800b210:	07db      	lsls	r3, r3, #31
 800b212:	d44a      	bmi.n	800b2aa <main+0x13a>
  
  // na chwile to zakomentowuje, dopoki problem z USB
  // g_chnp = (BaseChannel *)&SDU1; //Default to USB for GUI

  /* Creates the blinker threads. */
  tpBlinker_A = chThdCreateStatic(waBlinkerThread_A, sizeof(waBlinkerThread_A),
 800b214:	2400      	movs	r4, #0
 800b216:	f44f 7180 	mov.w	r1, #256	; 0x100
 800b21a:	2202      	movs	r2, #2
 800b21c:	4b3d      	ldr	r3, [pc, #244]	; (800b314 <main+0x1a4>)
 800b21e:	9400      	str	r4, [sp, #0]
 800b220:	483d      	ldr	r0, [pc, #244]	; (800b318 <main+0x1a8>)
  /* Normal main() thread activity. */

  
  
#if 1
  while(g_runMain){
 800b222:	4d3e      	ldr	r5, [pc, #248]	; (800b31c <main+0x1ac>)
  
  // na chwile to zakomentowuje, dopoki problem z USB
  // g_chnp = (BaseChannel *)&SDU1; //Default to USB for GUI

  /* Creates the blinker threads. */
  tpBlinker_A = chThdCreateStatic(waBlinkerThread_A, sizeof(waBlinkerThread_A),
 800b224:	f7f6 fc44 	bl	8001ab0 <chThdCreateStatic>
    LOWPRIO, BlinkerThread_A, NULL);

  tpBlinker_B = chThdCreateStatic(waBlinkerThread_B, sizeof(waBlinkerThread_B),
 800b228:	4b3d      	ldr	r3, [pc, #244]	; (800b320 <main+0x1b0>)
 800b22a:	9400      	str	r4, [sp, #0]
 800b22c:	483d      	ldr	r0, [pc, #244]	; (800b324 <main+0x1b4>)
 800b22e:	f44f 7180 	mov.w	r1, #256	; 0x100
 800b232:	2202      	movs	r2, #2
 800b234:	f7f6 fc3c 	bl	8001ab0 <chThdCreateStatic>
  /* Normal main() thread activity. */

  
  
#if 1
  while(g_runMain){
 800b238:	782b      	ldrb	r3, [r5, #0]
 800b23a:	b15b      	cbz	r3, 800b254 <main+0xe4>
 800b23c:	4e2b      	ldr	r6, [pc, #172]	; (800b2ec <main+0x17c>)
#if 1      
    if (!shelltp && (SDU1.config->usbp->state == USB_ACTIVE)){
 800b23e:	b30c      	cbz	r4, 800b284 <main+0x114>
//              shelltp = chThdCreateFromHeap(NULL, SHELL_WA_SIZE,
                                              //"shell", NORMALPRIO + 1,
                                              //shellThread, (void *)&shell_cfg1);
        
        
    }else if (chThdTerminatedX(shelltp)) {
 800b240:	7c23      	ldrb	r3, [r4, #16]
 800b242:	2b0f      	cmp	r3, #15
 800b244:	d02c      	beq.n	800b2a0 <main+0x130>
      chThdRelease(shelltp);    /* Recovers memory of the previous shell.   */
      shelltp = NULL;           /* Triggers spawning of a new shell.        */
    }
    chThdSleepMilliseconds(1000);
 800b246:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 800b24a:	f7f6 fca1 	bl	8001b90 <chThdSleep>
  /* Normal main() thread activity. */

  
  
#if 1
  while(g_runMain){
 800b24e:	782b      	ldrb	r3, [r5, #0]
 800b250:	2b00      	cmp	r3, #0
 800b252:	d1f4      	bne.n	800b23e <main+0xce>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800b254:	b672      	cpsid	i
#endif
  
  osalSysDisable();

  /* Reset of all peripherals. */
  rccResetAPB1(0xFFFFFFFF);
 800b256:	4b2b      	ldr	r3, [pc, #172]	; (800b304 <main+0x194>)
 800b258:	f04f 31ff 	mov.w	r1, #4294967295
 800b25c:	2200      	movs	r2, #0
 800b25e:	6918      	ldr	r0, [r3, #16]
 800b260:	6119      	str	r1, [r3, #16]
 800b262:	611a      	str	r2, [r3, #16]
  rccResetAPB2(0xFFFFFFFF);
 800b264:	68d8      	ldr	r0, [r3, #12]
 800b266:	60d9      	str	r1, [r3, #12]
 800b268:	60da      	str	r2, [r3, #12]
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800b26a:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800b26e:	492e      	ldr	r1, [pc, #184]	; (800b328 <main+0x1b8>)
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800b270:	4b2e      	ldr	r3, [pc, #184]	; (800b32c <main+0x1bc>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800b272:	68ca      	ldr	r2, [r1, #12]
 800b274:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800b278:	4313      	orrs	r3, r2
 800b27a:	60cb      	str	r3, [r1, #12]
 800b27c:	f3bf 8f4f 	dsb	sy

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 800b280:	bf00      	nop
 800b282:	e7fd      	b.n	800b280 <main+0x110>
  
  
#if 1
  while(g_runMain){
#if 1      
    if (!shelltp && (SDU1.config->usbp->state == USB_ACTIVE)){
 800b284:	f8d6 3484 	ldr.w	r3, [r6, #1156]	; 0x484
 800b288:	681b      	ldr	r3, [r3, #0]
 800b28a:	781b      	ldrb	r3, [r3, #0]
 800b28c:	2b04      	cmp	r3, #4
 800b28e:	d1d7      	bne.n	800b240 <main+0xd0>
        // wersja oryginalna z demo z testhal w ChibiOS
       shelltp = shellCreate(&shell_cfg1, SHELL_WA_SIZE, NORMALPRIO+1);
 800b290:	4827      	ldr	r0, [pc, #156]	; (800b330 <main+0x1c0>)
 800b292:	f44f 610c 	mov.w	r1, #2240	; 0x8c0
 800b296:	2241      	movs	r2, #65	; 0x41
 800b298:	f7fe f9b2 	bl	8009600 <shellCreate>
 800b29c:	4604      	mov	r4, r0
 800b29e:	e7d2      	b.n	800b246 <main+0xd6>
                                              //"shell", NORMALPRIO + 1,
                                              //shellThread, (void *)&shell_cfg1);
        
        
    }else if (chThdTerminatedX(shelltp)) {
      chThdRelease(shelltp);    /* Recovers memory of the previous shell.   */
 800b2a0:	4620      	mov	r0, r4
 800b2a2:	f7f6 fda5 	bl	8001df0 <chThdRelease>
      shelltp = NULL;           /* Triggers spawning of a new shell.        */
 800b2a6:	2400      	movs	r4, #0
 800b2a8:	e7cd      	b.n	800b246 <main+0xd6>
    chBSemObjectInit(&bsemIMU1DataReady, TRUE);
    /* Creates a taken binary semaphore. */
    chBSemObjectInit(&bsemStreamReady, TRUE);

    /* Creates the MPU6050 polling thread and attitude calculation thread. */
    tpPoller = chThdCreateStatic(waPollMPU6050Thread, sizeof(waPollMPU6050Thread),
 800b2aa:	2400      	movs	r4, #0
 *
 * @init
 */
static inline void chBSemObjectInit(binary_semaphore_t *bsp, bool taken) {

  chSemObjectInit(&bsp->bs_sem, taken ? (cnt_t)0 : (cnt_t)1);
 800b2ac:	4821      	ldr	r0, [pc, #132]	; (800b334 <main+0x1c4>)
 800b2ae:	2100      	movs	r1, #0
 800b2b0:	f7f6 fe06 	bl	8001ec0 <chSemObjectInit>
 800b2b4:	4621      	mov	r1, r4
 800b2b6:	4820      	ldr	r0, [pc, #128]	; (800b338 <main+0x1c8>)
 800b2b8:	f7f6 fe02 	bl	8001ec0 <chSemObjectInit>
 800b2bc:	9400      	str	r4, [sp, #0]
 800b2be:	f44f 71a0 	mov.w	r1, #320	; 0x140
 800b2c2:	2241      	movs	r2, #65	; 0x41
 800b2c4:	4b1d      	ldr	r3, [pc, #116]	; (800b33c <main+0x1cc>)
 800b2c6:	481e      	ldr	r0, [pc, #120]	; (800b340 <main+0x1d0>)
 800b2c8:	f7f6 fbf2 	bl	8001ab0 <chThdCreateStatic>
      NORMALPRIO + 1, PollMPU6050Thread, NULL);
    tpAttitude = chThdCreateStatic(waAttitudeThread, sizeof(waAttitudeThread),
 800b2cc:	9400      	str	r4, [sp, #0]
 800b2ce:	f44f 610c 	mov.w	r1, #2240	; 0x8c0
 800b2d2:	227f      	movs	r2, #127	; 0x7f
 800b2d4:	4b1b      	ldr	r3, [pc, #108]	; (800b344 <main+0x1d4>)
 800b2d6:	481c      	ldr	r0, [pc, #112]	; (800b348 <main+0x1d8>)
 800b2d8:	f7f6 fbea 	bl	8001ab0 <chThdCreateStatic>
 800b2dc:	e79a      	b.n	800b214 <main+0xa4>

  bool result = loadSettings();
  if(result)
      chprintf((BaseSequentialStream *)&SD4, "pamiec OK\n");
  else 
      chprintf((BaseSequentialStream *)&SD4, "pamiec ZLE\n");
 800b2de:	491b      	ldr	r1, [pc, #108]	; (800b34c <main+0x1dc>)
 800b2e0:	4804      	ldr	r0, [pc, #16]	; (800b2f4 <main+0x184>)
 800b2e2:	f7fe fced 	bl	8009cc0 <chprintf>
 800b2e6:	e784      	b.n	800b1f2 <main+0x82>
 800b2e8:	0800e8f0 	.word	0x0800e8f0
 800b2ec:	20002bc0 	.word	0x20002bc0
 800b2f0:	40010c00 	.word	0x40010c00
 800b2f4:	200013e4 	.word	0x200013e4
 800b2f8:	0800e7c0 	.word	0x0800e7c0
 800b2fc:	2000133c 	.word	0x2000133c
 800b300:	0800e580 	.word	0x0800e580
 800b304:	40021000 	.word	0x40021000
 800b308:	20002abc 	.word	0x20002abc
 800b30c:	0800e694 	.word	0x0800e694
 800b310:	20001df8 	.word	0x20001df8
 800b314:	0800ad91 	.word	0x0800ad91
 800b318:	20002858 	.word	0x20002858
 800b31c:	20000920 	.word	0x20000920
 800b320:	0800ad51 	.word	0x0800ad51
 800b324:	20002750 	.word	0x20002750
 800b328:	e000ed00 	.word	0xe000ed00
 800b32c:	05fa0004 	.word	0x05fa0004
 800b330:	0800e590 	.word	0x0800e590
 800b334:	20001de8 	.word	0x20001de8
 800b338:	20002a98 	.word	0x20002a98
 800b33c:	0800add1 	.word	0x0800add1
 800b340:	20002958 	.word	0x20002958
 800b344:	0800afc1 	.word	0x0800afc1
 800b348:	20001e00 	.word	0x20001e00
 800b34c:	0800e6a0 	.word	0x0800e6a0

0800b350 <imuStructureInit>:
/**
 * @brief  Initialization function of IMU data structure.
 * @param  pIMU - pointer to IMU data structure;
 * @param  fAddrLow - IMU address pin A0 is pulled low flag.
 */
void imuStructureInit(PIMUStruct pIMU, uint8_t fAddrHigh) {
 800b350:	b538      	push	{r3, r4, r5, lr}
 800b352:	4604      	mov	r4, r0
 800b354:	460d      	mov	r5, r1
  uint8_t i;
  /* Initialize to zero. */
  memset((void *)pIMU, 0, sizeof(IMUStruct));
 800b356:	226c      	movs	r2, #108	; 0x6c
 800b358:	2100      	movs	r1, #0
 800b35a:	f001 fff9 	bl	800d350 <memset>
  /* Initialize to unity quaternion. */
  pIMU->qIMU[0] = 1.0f;
 800b35e:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800b362:	64a3      	str	r3, [r4, #72]	; 0x48

  if (fAddrHigh) {
    pIMU->addr = MPU6050_I2C_ADDR_A0_HIGH;
    for (i = 0; i < 3; i++) {
      pIMU->axes_conf[i] = g_sensorSettings[i] >> 4;
 800b364:	4b12      	ldr	r3, [pc, #72]	; (800b3b0 <imuStructureInit+0x60>)
  /* Initialize to zero. */
  memset((void *)pIMU, 0, sizeof(IMUStruct));
  /* Initialize to unity quaternion. */
  pIMU->qIMU[0] = 1.0f;

  if (fAddrHigh) {
 800b366:	b17d      	cbz	r5, 800b388 <imuStructureInit+0x38>
    pIMU->addr = MPU6050_I2C_ADDR_A0_HIGH;
    for (i = 0; i < 3; i++) {
      pIMU->axes_conf[i] = g_sensorSettings[i] >> 4;
 800b368:	7819      	ldrb	r1, [r3, #0]
 800b36a:	785a      	ldrb	r2, [r3, #1]
 800b36c:	789b      	ldrb	r3, [r3, #2]
  memset((void *)pIMU, 0, sizeof(IMUStruct));
  /* Initialize to unity quaternion. */
  pIMU->qIMU[0] = 1.0f;

  if (fAddrHigh) {
    pIMU->addr = MPU6050_I2C_ADDR_A0_HIGH;
 800b36e:	2069      	movs	r0, #105	; 0x69
    for (i = 0; i < 3; i++) {
      pIMU->axes_conf[i] = g_sensorSettings[i] >> 4;
 800b370:	0909      	lsrs	r1, r1, #4
 800b372:	0912      	lsrs	r2, r2, #4
 800b374:	091b      	lsrs	r3, r3, #4
 800b376:	f884 1068 	strb.w	r1, [r4, #104]	; 0x68
 800b37a:	f884 2069 	strb.w	r2, [r4, #105]	; 0x69
 800b37e:	f884 306a 	strb.w	r3, [r4, #106]	; 0x6a
  memset((void *)pIMU, 0, sizeof(IMUStruct));
  /* Initialize to unity quaternion. */
  pIMU->qIMU[0] = 1.0f;

  if (fAddrHigh) {
    pIMU->addr = MPU6050_I2C_ADDR_A0_HIGH;
 800b382:	f884 006b 	strb.w	r0, [r4, #107]	; 0x6b
 800b386:	bd38      	pop	{r3, r4, r5, pc}
      pIMU->axes_conf[i] = g_sensorSettings[i] >> 4;
    }
  } else {
    pIMU->addr = MPU6050_I2C_ADDR_A0_LOW;
    for (i = 0; i < 3; i++) {
      pIMU->axes_conf[i] = g_sensorSettings[i] & IMU1_CONF_MASK;
 800b388:	7819      	ldrb	r1, [r3, #0]
 800b38a:	785a      	ldrb	r2, [r3, #1]
 800b38c:	789b      	ldrb	r3, [r3, #2]
    pIMU->addr = MPU6050_I2C_ADDR_A0_HIGH;
    for (i = 0; i < 3; i++) {
      pIMU->axes_conf[i] = g_sensorSettings[i] >> 4;
    }
  } else {
    pIMU->addr = MPU6050_I2C_ADDR_A0_LOW;
 800b38e:	2068      	movs	r0, #104	; 0x68
    for (i = 0; i < 3; i++) {
      pIMU->axes_conf[i] = g_sensorSettings[i] & IMU1_CONF_MASK;
 800b390:	f001 010f 	and.w	r1, r1, #15
 800b394:	f002 020f 	and.w	r2, r2, #15
 800b398:	f003 030f 	and.w	r3, r3, #15
 800b39c:	f884 1068 	strb.w	r1, [r4, #104]	; 0x68
 800b3a0:	f884 2069 	strb.w	r2, [r4, #105]	; 0x69
 800b3a4:	f884 306a 	strb.w	r3, [r4, #106]	; 0x6a
    pIMU->addr = MPU6050_I2C_ADDR_A0_HIGH;
    for (i = 0; i < 3; i++) {
      pIMU->axes_conf[i] = g_sensorSettings[i] >> 4;
    }
  } else {
    pIMU->addr = MPU6050_I2C_ADDR_A0_LOW;
 800b3a8:	f884 006b 	strb.w	r0, [r4, #107]	; 0x6b
 800b3ac:	bd38      	pop	{r3, r4, r5, pc}
 800b3ae:	bf00      	nop
 800b3b0:	20000d28 	.word	0x20000d28
	...

0800b3c0 <imuCalibrate>:
 * @param  pIMU - pointer to IMU data structure;
 * @param  fCalibrateAcc - accelerometer calibration flag.
 * @return 0 - if calibration is not finished;
 *         1 - if calibration is finished.
 */
uint8_t imuCalibrate(PIMUStruct pIMU, uint8_t fCalibrateAcc) {
 800b3c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800b3c2:	4604      	mov	r4, r0
  if (fCalibrateAcc) {
 800b3c4:	460e      	mov	r6, r1
    if (pIMU->clbrCounter == 0) {
 800b3c6:	6e45      	ldr	r5, [r0, #100]	; 0x64
 * @param  fCalibrateAcc - accelerometer calibration flag.
 * @return 0 - if calibration is not finished;
 *         1 - if calibration is finished.
 */
uint8_t imuCalibrate(PIMUStruct pIMU, uint8_t fCalibrateAcc) {
  if (fCalibrateAcc) {
 800b3c8:	b351      	cbz	r1, 800b420 <imuCalibrate+0x60>
    if (pIMU->clbrCounter == 0) {
 800b3ca:	2d00      	cmp	r5, #0
 800b3cc:	d058      	beq.n	800b480 <imuCalibrate+0xc0>
      pIMU->accelBias[0] = pIMU->accelData[0];
      pIMU->accelBias[1] = pIMU->accelData[1];
      pIMU->accelBias[2] = pIMU->accelData[2] - GRAV;
      pIMU->clbrCounter++;
      return 0;
    } else if (pIMU->clbrCounter < CALIBRATION_COUNTER_MAX) {
 800b3ce:	f5b5 6ffa 	cmp.w	r5, #2000	; 0x7d0
      /* Accumulate accelerometer bias. */
      pIMU->accelBias[0] += pIMU->accelData[0];
 800b3d2:	6980      	ldr	r0, [r0, #24]
      pIMU->accelBias[0] = pIMU->accelData[0];
      pIMU->accelBias[1] = pIMU->accelData[1];
      pIMU->accelBias[2] = pIMU->accelData[2] - GRAV;
      pIMU->clbrCounter++;
      return 0;
    } else if (pIMU->clbrCounter < CALIBRATION_COUNTER_MAX) {
 800b3d4:	d26e      	bcs.n	800b4b4 <imuCalibrate+0xf4>
      /* Accumulate accelerometer bias. */
      pIMU->accelBias[0] += pIMU->accelData[0];
 800b3d6:	6821      	ldr	r1, [r4, #0]
 800b3d8:	f7f5 fc18 	bl	8000c0c <__addsf3>
      pIMU->accelBias[1] += pIMU->accelData[1];
 800b3dc:	69e3      	ldr	r3, [r4, #28]
 800b3de:	6861      	ldr	r1, [r4, #4]
      pIMU->accelBias[2] = pIMU->accelData[2] - GRAV;
      pIMU->clbrCounter++;
      return 0;
    } else if (pIMU->clbrCounter < CALIBRATION_COUNTER_MAX) {
      /* Accumulate accelerometer bias. */
      pIMU->accelBias[0] += pIMU->accelData[0];
 800b3e0:	61a0      	str	r0, [r4, #24]
      pIMU->accelBias[1] += pIMU->accelData[1];
 800b3e2:	4618      	mov	r0, r3
 800b3e4:	f7f5 fc12 	bl	8000c0c <__addsf3>
      pIMU->accelBias[2] += pIMU->accelData[2] - GRAV;
 800b3e8:	6a23      	ldr	r3, [r4, #32]
      pIMU->clbrCounter++;
      return 0;
    } else if (pIMU->clbrCounter < CALIBRATION_COUNTER_MAX) {
      /* Accumulate accelerometer bias. */
      pIMU->accelBias[0] += pIMU->accelData[0];
      pIMU->accelBias[1] += pIMU->accelData[1];
 800b3ea:	61e0      	str	r0, [r4, #28]
      pIMU->accelBias[2] += pIMU->accelData[2] - GRAV;
 800b3ec:	4618      	mov	r0, r3
 800b3ee:	f7f5 f89b 	bl	8000528 <__aeabi_f2d>
 800b3f2:	4606      	mov	r6, r0
 800b3f4:	68a0      	ldr	r0, [r4, #8]
 800b3f6:	460f      	mov	r7, r1
 800b3f8:	f7f5 f896 	bl	8000528 <__aeabi_f2d>
 800b3fc:	a346      	add	r3, pc, #280	; (adr r3, 800b518 <imuCalibrate+0x158>)
 800b3fe:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b402:	f7f4 ff31 	bl	8000268 <__aeabi_dsub>
 800b406:	4602      	mov	r2, r0
 800b408:	460b      	mov	r3, r1
 800b40a:	4630      	mov	r0, r6
 800b40c:	4639      	mov	r1, r7
 800b40e:	f7f4 ff2d 	bl	800026c <__adddf3>
 800b412:	f7f5 fba5 	bl	8000b60 <__aeabi_d2f>
      pIMU->clbrCounter++;
 800b416:	3501      	adds	r5, #1
      return 0;
    } else if (pIMU->clbrCounter < CALIBRATION_COUNTER_MAX) {
      /* Accumulate accelerometer bias. */
      pIMU->accelBias[0] += pIMU->accelData[0];
      pIMU->accelBias[1] += pIMU->accelData[1];
      pIMU->accelBias[2] += pIMU->accelData[2] - GRAV;
 800b418:	6220      	str	r0, [r4, #32]
      pIMU->clbrCounter++;
 800b41a:	6665      	str	r5, [r4, #100]	; 0x64
      return 0;
 800b41c:	2000      	movs	r0, #0
 800b41e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      pIMU->accelBias[1] /= (float)CALIBRATION_COUNTER_MAX;
      pIMU->accelBias[2] /= (float)CALIBRATION_COUNTER_MAX;
      pIMU->clbrCounter = 0;
    }
  } else {
    if (pIMU->clbrCounter == 0) {
 800b420:	b1ed      	cbz	r5, 800b45e <imuCalibrate+0x9e>
      pIMU->gyroBias[0] = pIMU->gyroData[0];
      pIMU->gyroBias[1] = pIMU->gyroData[1];
      pIMU->gyroBias[2] = pIMU->gyroData[2];
      pIMU->clbrCounter++;
      return 0;
    } else if (pIMU->clbrCounter < CALIBRATION_COUNTER_MAX) {
 800b422:	f5b5 6ffa 	cmp.w	r5, #2000	; 0x7d0
      /* Accumulate gyroscope bias. */
      pIMU->gyroBias[0] += pIMU->gyroData[0];
 800b426:	6a40      	ldr	r0, [r0, #36]	; 0x24
      pIMU->gyroBias[0] = pIMU->gyroData[0];
      pIMU->gyroBias[1] = pIMU->gyroData[1];
      pIMU->gyroBias[2] = pIMU->gyroData[2];
      pIMU->clbrCounter++;
      return 0;
    } else if (pIMU->clbrCounter < CALIBRATION_COUNTER_MAX) {
 800b428:	d35f      	bcc.n	800b4ea <imuCalibrate+0x12a>
      pIMU->gyroBias[2] += pIMU->gyroData[2];
      pIMU->clbrCounter++;
      return 0;
    } else {
      /* Update gyroscope bias. */
      pIMU->gyroBias[0] /= (float)CALIBRATION_COUNTER_MAX;
 800b42a:	493d      	ldr	r1, [pc, #244]	; (800b520 <imuCalibrate+0x160>)
 800b42c:	f7f5 fdac 	bl	8000f88 <__aeabi_fdiv>
      pIMU->gyroBias[1] /= (float)CALIBRATION_COUNTER_MAX;
 800b430:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      pIMU->gyroBias[2] += pIMU->gyroData[2];
      pIMU->clbrCounter++;
      return 0;
    } else {
      /* Update gyroscope bias. */
      pIMU->gyroBias[0] /= (float)CALIBRATION_COUNTER_MAX;
 800b432:	6260      	str	r0, [r4, #36]	; 0x24
      pIMU->gyroBias[1] /= (float)CALIBRATION_COUNTER_MAX;
 800b434:	493a      	ldr	r1, [pc, #232]	; (800b520 <imuCalibrate+0x160>)
 800b436:	4618      	mov	r0, r3
 800b438:	f7f5 fda6 	bl	8000f88 <__aeabi_fdiv>
      pIMU->gyroBias[2] /= (float)CALIBRATION_COUNTER_MAX;
 800b43c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
      pIMU->clbrCounter++;
      return 0;
    } else {
      /* Update gyroscope bias. */
      pIMU->gyroBias[0] /= (float)CALIBRATION_COUNTER_MAX;
      pIMU->gyroBias[1] /= (float)CALIBRATION_COUNTER_MAX;
 800b43e:	62a0      	str	r0, [r4, #40]	; 0x28
      pIMU->gyroBias[2] /= (float)CALIBRATION_COUNTER_MAX;
 800b440:	4937      	ldr	r1, [pc, #220]	; (800b520 <imuCalibrate+0x160>)
 800b442:	4618      	mov	r0, r3
 800b444:	f7f5 fda0 	bl	8000f88 <__aeabi_fdiv>
      pIMU->clbrCounter = 0;
 800b448:	f884 6064 	strb.w	r6, [r4, #100]	; 0x64
      return 0;
    } else {
      /* Update gyroscope bias. */
      pIMU->gyroBias[0] /= (float)CALIBRATION_COUNTER_MAX;
      pIMU->gyroBias[1] /= (float)CALIBRATION_COUNTER_MAX;
      pIMU->gyroBias[2] /= (float)CALIBRATION_COUNTER_MAX;
 800b44c:	62e0      	str	r0, [r4, #44]	; 0x2c
      pIMU->clbrCounter = 0;
 800b44e:	f884 6065 	strb.w	r6, [r4, #101]	; 0x65
 800b452:	f884 6066 	strb.w	r6, [r4, #102]	; 0x66
 800b456:	f884 6067 	strb.w	r6, [r4, #103]	; 0x67
    }
  }
  return 1;
 800b45a:	2001      	movs	r0, #1
}
 800b45c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      pIMU->clbrCounter = 0;
    }
  } else {
    if (pIMU->clbrCounter == 0) {
      /* Reset gyroscope bias. */
      pIMU->gyroBias[0] = pIMU->gyroData[0];
 800b45e:	68c1      	ldr	r1, [r0, #12]
      pIMU->gyroBias[1] = pIMU->gyroData[1];
 800b460:	6902      	ldr	r2, [r0, #16]
      pIMU->gyroBias[2] = pIMU->gyroData[2];
 800b462:	6943      	ldr	r3, [r0, #20]
      pIMU->clbrCounter++;
 800b464:	2601      	movs	r6, #1
 800b466:	f880 5065 	strb.w	r5, [r0, #101]	; 0x65
 800b46a:	f880 5066 	strb.w	r5, [r0, #102]	; 0x66
 800b46e:	f880 5067 	strb.w	r5, [r0, #103]	; 0x67
      return 0;
 800b472:	4628      	mov	r0, r5
      pIMU->clbrCounter = 0;
    }
  } else {
    if (pIMU->clbrCounter == 0) {
      /* Reset gyroscope bias. */
      pIMU->gyroBias[0] = pIMU->gyroData[0];
 800b474:	6261      	str	r1, [r4, #36]	; 0x24
      pIMU->gyroBias[1] = pIMU->gyroData[1];
 800b476:	62a2      	str	r2, [r4, #40]	; 0x28
      pIMU->gyroBias[2] = pIMU->gyroData[2];
 800b478:	62e3      	str	r3, [r4, #44]	; 0x2c
      pIMU->clbrCounter++;
 800b47a:	f884 6064 	strb.w	r6, [r4, #100]	; 0x64
      return 0;
 800b47e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
uint8_t imuCalibrate(PIMUStruct pIMU, uint8_t fCalibrateAcc) {
  if (fCalibrateAcc) {
    if (pIMU->clbrCounter == 0) {
      /* Reset accelerometer bias. */
      pIMU->accelBias[0] = pIMU->accelData[0];
 800b480:	6802      	ldr	r2, [r0, #0]
      pIMU->accelBias[1] = pIMU->accelData[1];
 800b482:	6843      	ldr	r3, [r0, #4]
      pIMU->accelBias[2] = pIMU->accelData[2] - GRAV;
 800b484:	6880      	ldr	r0, [r0, #8]
 */
uint8_t imuCalibrate(PIMUStruct pIMU, uint8_t fCalibrateAcc) {
  if (fCalibrateAcc) {
    if (pIMU->clbrCounter == 0) {
      /* Reset accelerometer bias. */
      pIMU->accelBias[0] = pIMU->accelData[0];
 800b486:	61a2      	str	r2, [r4, #24]
      pIMU->accelBias[1] = pIMU->accelData[1];
 800b488:	61e3      	str	r3, [r4, #28]
      pIMU->accelBias[2] = pIMU->accelData[2] - GRAV;
 800b48a:	f7f5 f84d 	bl	8000528 <__aeabi_f2d>
 800b48e:	a322      	add	r3, pc, #136	; (adr r3, 800b518 <imuCalibrate+0x158>)
 800b490:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b494:	f7f4 fee8 	bl	8000268 <__aeabi_dsub>
 800b498:	f7f5 fb62 	bl	8000b60 <__aeabi_d2f>
      pIMU->clbrCounter++;
 800b49c:	2301      	movs	r3, #1
  if (fCalibrateAcc) {
    if (pIMU->clbrCounter == 0) {
      /* Reset accelerometer bias. */
      pIMU->accelBias[0] = pIMU->accelData[0];
      pIMU->accelBias[1] = pIMU->accelData[1];
      pIMU->accelBias[2] = pIMU->accelData[2] - GRAV;
 800b49e:	6220      	str	r0, [r4, #32]
      pIMU->clbrCounter++;
 800b4a0:	f884 5065 	strb.w	r5, [r4, #101]	; 0x65
 800b4a4:	f884 5066 	strb.w	r5, [r4, #102]	; 0x66
 800b4a8:	f884 5067 	strb.w	r5, [r4, #103]	; 0x67
      return 0;
 800b4ac:	4628      	mov	r0, r5
    if (pIMU->clbrCounter == 0) {
      /* Reset accelerometer bias. */
      pIMU->accelBias[0] = pIMU->accelData[0];
      pIMU->accelBias[1] = pIMU->accelData[1];
      pIMU->accelBias[2] = pIMU->accelData[2] - GRAV;
      pIMU->clbrCounter++;
 800b4ae:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
      return 0;
 800b4b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      pIMU->accelBias[2] += pIMU->accelData[2] - GRAV;
      pIMU->clbrCounter++;
      return 0;
    } else {
      /* Update accelerometer bias. */
      pIMU->accelBias[0] /= (float)CALIBRATION_COUNTER_MAX;
 800b4b4:	491a      	ldr	r1, [pc, #104]	; (800b520 <imuCalibrate+0x160>)
 800b4b6:	f7f5 fd67 	bl	8000f88 <__aeabi_fdiv>
      pIMU->accelBias[1] /= (float)CALIBRATION_COUNTER_MAX;
 800b4ba:	69e3      	ldr	r3, [r4, #28]
      pIMU->accelBias[2] += pIMU->accelData[2] - GRAV;
      pIMU->clbrCounter++;
      return 0;
    } else {
      /* Update accelerometer bias. */
      pIMU->accelBias[0] /= (float)CALIBRATION_COUNTER_MAX;
 800b4bc:	61a0      	str	r0, [r4, #24]
      pIMU->accelBias[1] /= (float)CALIBRATION_COUNTER_MAX;
 800b4be:	4918      	ldr	r1, [pc, #96]	; (800b520 <imuCalibrate+0x160>)
 800b4c0:	4618      	mov	r0, r3
 800b4c2:	f7f5 fd61 	bl	8000f88 <__aeabi_fdiv>
      pIMU->accelBias[2] /= (float)CALIBRATION_COUNTER_MAX;
 800b4c6:	6a23      	ldr	r3, [r4, #32]
      pIMU->clbrCounter++;
      return 0;
    } else {
      /* Update accelerometer bias. */
      pIMU->accelBias[0] /= (float)CALIBRATION_COUNTER_MAX;
      pIMU->accelBias[1] /= (float)CALIBRATION_COUNTER_MAX;
 800b4c8:	61e0      	str	r0, [r4, #28]
      pIMU->accelBias[2] /= (float)CALIBRATION_COUNTER_MAX;
 800b4ca:	4915      	ldr	r1, [pc, #84]	; (800b520 <imuCalibrate+0x160>)
 800b4cc:	4618      	mov	r0, r3
 800b4ce:	f7f5 fd5b 	bl	8000f88 <__aeabi_fdiv>
      pIMU->clbrCounter = 0;
 800b4d2:	2300      	movs	r3, #0
      return 0;
    } else {
      /* Update accelerometer bias. */
      pIMU->accelBias[0] /= (float)CALIBRATION_COUNTER_MAX;
      pIMU->accelBias[1] /= (float)CALIBRATION_COUNTER_MAX;
      pIMU->accelBias[2] /= (float)CALIBRATION_COUNTER_MAX;
 800b4d4:	6220      	str	r0, [r4, #32]
      pIMU->clbrCounter = 0;
 800b4d6:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 800b4da:	f884 3065 	strb.w	r3, [r4, #101]	; 0x65
 800b4de:	f884 3066 	strb.w	r3, [r4, #102]	; 0x66
 800b4e2:	f884 3067 	strb.w	r3, [r4, #103]	; 0x67
      pIMU->gyroBias[1] /= (float)CALIBRATION_COUNTER_MAX;
      pIMU->gyroBias[2] /= (float)CALIBRATION_COUNTER_MAX;
      pIMU->clbrCounter = 0;
    }
  }
  return 1;
 800b4e6:	2001      	movs	r0, #1
 800b4e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      pIMU->gyroBias[2] = pIMU->gyroData[2];
      pIMU->clbrCounter++;
      return 0;
    } else if (pIMU->clbrCounter < CALIBRATION_COUNTER_MAX) {
      /* Accumulate gyroscope bias. */
      pIMU->gyroBias[0] += pIMU->gyroData[0];
 800b4ea:	68e1      	ldr	r1, [r4, #12]
 800b4ec:	f7f5 fb8e 	bl	8000c0c <__addsf3>
      pIMU->gyroBias[1] += pIMU->gyroData[1];
 800b4f0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800b4f2:	6921      	ldr	r1, [r4, #16]
      pIMU->gyroBias[2] = pIMU->gyroData[2];
      pIMU->clbrCounter++;
      return 0;
    } else if (pIMU->clbrCounter < CALIBRATION_COUNTER_MAX) {
      /* Accumulate gyroscope bias. */
      pIMU->gyroBias[0] += pIMU->gyroData[0];
 800b4f4:	6260      	str	r0, [r4, #36]	; 0x24
      pIMU->gyroBias[1] += pIMU->gyroData[1];
 800b4f6:	4618      	mov	r0, r3
 800b4f8:	f7f5 fb88 	bl	8000c0c <__addsf3>
      pIMU->gyroBias[2] += pIMU->gyroData[2];
 800b4fc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
      pIMU->clbrCounter++;
      return 0;
    } else if (pIMU->clbrCounter < CALIBRATION_COUNTER_MAX) {
      /* Accumulate gyroscope bias. */
      pIMU->gyroBias[0] += pIMU->gyroData[0];
      pIMU->gyroBias[1] += pIMU->gyroData[1];
 800b4fe:	62a0      	str	r0, [r4, #40]	; 0x28
      pIMU->gyroBias[2] += pIMU->gyroData[2];
 800b500:	6961      	ldr	r1, [r4, #20]
 800b502:	4618      	mov	r0, r3
 800b504:	f7f5 fb82 	bl	8000c0c <__addsf3>
      pIMU->clbrCounter++;
 800b508:	1c6b      	adds	r3, r5, #1
      return 0;
    } else if (pIMU->clbrCounter < CALIBRATION_COUNTER_MAX) {
      /* Accumulate gyroscope bias. */
      pIMU->gyroBias[0] += pIMU->gyroData[0];
      pIMU->gyroBias[1] += pIMU->gyroData[1];
      pIMU->gyroBias[2] += pIMU->gyroData[2];
 800b50a:	62e0      	str	r0, [r4, #44]	; 0x2c
      pIMU->clbrCounter++;
 800b50c:	6663      	str	r3, [r4, #100]	; 0x64
      return 0;
 800b50e:	4630      	mov	r0, r6
 800b510:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800b512:	bf00      	nop
 800b514:	f3af 8000 	nop.w
 800b518:	51eb851f 	.word	0x51eb851f
 800b51c:	40239eb8 	.word	0x40239eb8
 800b520:	44fa0000 	.word	0x44fa0000
	...

0800b530 <mpu6050Init>:
 * @param  addr - I2C address of MPU6050 chip.
 * @return 1 - if initialization was successful;
 *         0 - if initialization failed.
 * called not in the worker thread
 */
uint8_t mpu6050Init(uint8_t addr) {
 800b530:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800b534:	4607      	mov	r7, r0
 800b536:	b085      	sub	sp, #20
    
  chprintf((BaseSequentialStream *)&SD4, "III6050 init\n");
 800b538:	4946      	ldr	r1, [pc, #280]	; (800b654 <mpu6050Init+0x124>)
    
  msg_t status = MSG_OK;

  /* Reset all MPU6050 registers to their default values */
  mpu6050TXData[0] = MPU6050_PWR_MGMT_1;  // Start register address;
 800b53a:	4c47      	ldr	r4, [pc, #284]	; (800b658 <mpu6050Init+0x128>)
 *         0 - if initialization failed.
 * called not in the worker thread
 */
uint8_t mpu6050Init(uint8_t addr) {
    
  chprintf((BaseSequentialStream *)&SD4, "III6050 init\n");
 800b53c:	4847      	ldr	r0, [pc, #284]	; (800b65c <mpu6050Init+0x12c>)
 800b53e:	f7fe fbbf 	bl	8009cc0 <chprintf>
  mpu6050TXData[0] = MPU6050_PWR_MGMT_1;  // Start register address;
  mpu6050TXData[1] = 0b11000000;          // Register value;

  i2cAcquireBus(&I2CD2);

  status = i2cMasterTransmitTimeout(&I2CD2, addr, mpu6050TXData, 2,
 800b542:	2500      	movs	r5, #0
    
  msg_t status = MSG_OK;

  /* Reset all MPU6050 registers to their default values */
  mpu6050TXData[0] = MPU6050_PWR_MGMT_1;  // Start register address;
  mpu6050TXData[1] = 0b11000000;          // Register value;
 800b544:	23c0      	movs	r3, #192	; 0xc0

  i2cAcquireBus(&I2CD2);
 800b546:	4846      	ldr	r0, [pc, #280]	; (800b660 <mpu6050Init+0x130>)

  status = i2cMasterTransmitTimeout(&I2CD2, addr, mpu6050TXData, 2,
 800b548:	f04f 0902 	mov.w	r9, #2
 800b54c:	b2bf      	uxth	r7, r7
  chprintf((BaseSequentialStream *)&SD4, "III6050 init\n");
    
  msg_t status = MSG_OK;

  /* Reset all MPU6050 registers to their default values */
  mpu6050TXData[0] = MPU6050_PWR_MGMT_1;  // Start register address;
 800b54e:	266b      	movs	r6, #107	; 0x6b
  mpu6050TXData[1] = 0b11000000;          // Register value;
 800b550:	7063      	strb	r3, [r4, #1]
  chprintf((BaseSequentialStream *)&SD4, "III6050 init\n");
    
  msg_t status = MSG_OK;

  /* Reset all MPU6050 registers to their default values */
  mpu6050TXData[0] = MPU6050_PWR_MGMT_1;  // Start register address;
 800b552:	7026      	strb	r6, [r4, #0]
  mpu6050TXData[1] = 0b11000000;          // Register value;

  i2cAcquireBus(&I2CD2);
 800b554:	f7f8 f8bc 	bl	80036d0 <i2cAcquireBus>

  status = i2cMasterTransmitTimeout(&I2CD2, addr, mpu6050TXData, 2,
 800b558:	4639      	mov	r1, r7
 800b55a:	4622      	mov	r2, r4
 800b55c:	9500      	str	r5, [sp, #0]
 800b55e:	9501      	str	r5, [sp, #4]
 800b560:	f8cd 9008 	str.w	r9, [sp, #8]
 800b564:	464b      	mov	r3, r9
 800b566:	483e      	ldr	r0, [pc, #248]	; (800b660 <mpu6050Init+0x130>)
 800b568:	f7f8 f892 	bl	8003690 <i2cMasterTransmitTimeout>
    NULL, 0, MS2ST(MPU6050_WRITE_TIMEOUT_MS));

  if (status != MSG_OK) {
 800b56c:	4680      	mov	r8, r0
 800b56e:	b188      	cbz	r0, 800b594 <mpu6050Init+0x64>
    chprintf((BaseSequentialStream *)&SD4, "III6050 not OK\n");
 800b570:	493c      	ldr	r1, [pc, #240]	; (800b664 <mpu6050Init+0x134>)
 800b572:	483a      	ldr	r0, [pc, #232]	; (800b65c <mpu6050Init+0x12c>)
 800b574:	f7fe fba4 	bl	8009cc0 <chprintf>
    i2cReleaseBus(&I2CD2);
 800b578:	4839      	ldr	r0, [pc, #228]	; (800b660 <mpu6050Init+0x130>)
 800b57a:	f7f8 f8b1 	bl	80036e0 <i2cReleaseBus>
    g_i2cErrorInfo.last_i2c_error = i2cGetErrors(&I2CD2);
 800b57e:	4838      	ldr	r0, [pc, #224]	; (800b660 <mpu6050Init+0x130>)
 800b580:	f7f8 f87e 	bl	8003680 <i2cGetErrors>
 800b584:	4b38      	ldr	r3, [pc, #224]	; (800b668 <mpu6050Init+0x138>)
 800b586:	6018      	str	r0, [r3, #0]
    if (g_i2cErrorInfo.last_i2c_error) {
 800b588:	2800      	cmp	r0, #0
 800b58a:	d14a      	bne.n	800b622 <mpu6050Init+0xf2>
      g_i2cErrorInfo.i2c_error_counter++;
      debugLog("E:mpu6050i-tx1");
    }
    return 0;
 800b58c:	2000      	movs	r0, #0
    }
    return 0;
  }

  return 1;
}
 800b58e:	b005      	add	sp, #20
 800b590:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    }
    return 0;
  }

  /* Wait 100 ms for the MPU6050 to reset */
  chThdSleepMilliseconds(100);
 800b594:	20c8      	movs	r0, #200	; 0xc8

  /* Clear the SLEEP flag, set the clock and start measuring. */
  mpu6050TXData[0] = MPU6050_PWR_MGMT_1;  // Start register address;
  mpu6050TXData[1] = 0b00000011;          // Register value CLKSEL = PLL_Z;
 800b596:	2503      	movs	r5, #3
    }
    return 0;
  }

  /* Wait 100 ms for the MPU6050 to reset */
  chThdSleepMilliseconds(100);
 800b598:	f7f6 fafa 	bl	8001b90 <chThdSleep>

  /* Clear the SLEEP flag, set the clock and start measuring. */
  mpu6050TXData[0] = MPU6050_PWR_MGMT_1;  // Start register address;
  mpu6050TXData[1] = 0b00000011;          // Register value CLKSEL = PLL_Z;

  status = i2cMasterTransmitTimeout(&I2CD2, addr, mpu6050TXData, 2,
 800b59c:	f8cd 8000 	str.w	r8, [sp]
 800b5a0:	f8cd 8004 	str.w	r8, [sp, #4]
 800b5a4:	f8cd 9008 	str.w	r9, [sp, #8]
 800b5a8:	482d      	ldr	r0, [pc, #180]	; (800b660 <mpu6050Init+0x130>)

  /* Wait 100 ms for the MPU6050 to reset */
  chThdSleepMilliseconds(100);

  /* Clear the SLEEP flag, set the clock and start measuring. */
  mpu6050TXData[0] = MPU6050_PWR_MGMT_1;  // Start register address;
 800b5aa:	7026      	strb	r6, [r4, #0]
  mpu6050TXData[1] = 0b00000011;          // Register value CLKSEL = PLL_Z;

  status = i2cMasterTransmitTimeout(&I2CD2, addr, mpu6050TXData, 2,
 800b5ac:	4639      	mov	r1, r7
 800b5ae:	4622      	mov	r2, r4
 800b5b0:	464b      	mov	r3, r9
  /* Wait 100 ms for the MPU6050 to reset */
  chThdSleepMilliseconds(100);

  /* Clear the SLEEP flag, set the clock and start measuring. */
  mpu6050TXData[0] = MPU6050_PWR_MGMT_1;  // Start register address;
  mpu6050TXData[1] = 0b00000011;          // Register value CLKSEL = PLL_Z;
 800b5b2:	7065      	strb	r5, [r4, #1]

  status = i2cMasterTransmitTimeout(&I2CD2, addr, mpu6050TXData, 2,
 800b5b4:	f7f8 f86c 	bl	8003690 <i2cMasterTransmitTimeout>
    NULL, 0, MS2ST(MPU6050_WRITE_TIMEOUT_MS));

  if (status != MSG_OK) {
 800b5b8:	4606      	mov	r6, r0
 800b5ba:	b1a8      	cbz	r0, 800b5e8 <mpu6050Init+0xb8>
    chprintf((BaseSequentialStream *)&SD4, "III6050 not OK2\n");
 800b5bc:	492b      	ldr	r1, [pc, #172]	; (800b66c <mpu6050Init+0x13c>)
 800b5be:	4827      	ldr	r0, [pc, #156]	; (800b65c <mpu6050Init+0x12c>)
 800b5c0:	f7fe fb7e 	bl	8009cc0 <chprintf>
    i2cReleaseBus(&I2CD2);
 800b5c4:	4826      	ldr	r0, [pc, #152]	; (800b660 <mpu6050Init+0x130>)
 800b5c6:	f7f8 f88b 	bl	80036e0 <i2cReleaseBus>
    g_i2cErrorInfo.last_i2c_error = i2cGetErrors(&I2CD2);
 800b5ca:	4825      	ldr	r0, [pc, #148]	; (800b660 <mpu6050Init+0x130>)
 800b5cc:	f7f8 f858 	bl	8003680 <i2cGetErrors>
 800b5d0:	4b25      	ldr	r3, [pc, #148]	; (800b668 <mpu6050Init+0x138>)
 800b5d2:	6018      	str	r0, [r3, #0]
    if (g_i2cErrorInfo.last_i2c_error) {
 800b5d4:	2800      	cmp	r0, #0
 800b5d6:	d0d9      	beq.n	800b58c <mpu6050Init+0x5c>
      g_i2cErrorInfo.i2c_error_counter++;
 800b5d8:	685a      	ldr	r2, [r3, #4]
      debugLog("E:mpu6050i-rst");
 800b5da:	4825      	ldr	r0, [pc, #148]	; (800b670 <mpu6050Init+0x140>)
  if (status != MSG_OK) {
    chprintf((BaseSequentialStream *)&SD4, "III6050 not OK2\n");
    i2cReleaseBus(&I2CD2);
    g_i2cErrorInfo.last_i2c_error = i2cGetErrors(&I2CD2);
    if (g_i2cErrorInfo.last_i2c_error) {
      g_i2cErrorInfo.i2c_error_counter++;
 800b5dc:	3201      	adds	r2, #1
 800b5de:	605a      	str	r2, [r3, #4]
      debugLog("E:mpu6050i-rst");
 800b5e0:	f000 f9be 	bl	800b960 <debugLog>
    }
    return 0;
 800b5e4:	4640      	mov	r0, r8
 800b5e6:	e7d2      	b.n	800b58e <mpu6050Init+0x5e>
  mpu6050TXData[1] = 11;                  // SMPLRT_DIV register value (8000 / (11 + 1) = 666 Hz);
  mpu6050TXData[2] = 0b00000000;          // CONFIG register value DLPF_CFG = 0 (256-260 Hz);
  mpu6050TXData[3] = 0b00010000;          // GYRO_CONFIG register value FS_SEL = +-1000 deg/s;
  mpu6050TXData[4] = 0b00010000;          // ACCEL_CONFIG register value AFS_SEL = +-8G;

  status = i2cMasterTransmitTimeout(&I2CD2, addr, mpu6050TXData, 5,
 800b5e8:	4639      	mov	r1, r7

  /* Configure the MPU6050 sensor        */
  /* NOTE:                               */
  /* - SLEEP flag must be cleared before */
  /*   configuring the sensor.           */
  mpu6050TXData[0] = MPU6050_SMPLRT_DIV;  // Start register address;
 800b5ea:	f04f 0e19 	mov.w	lr, #25
  mpu6050TXData[1] = 11;                  // SMPLRT_DIV register value (8000 / (11 + 1) = 666 Hz);
  mpu6050TXData[2] = 0b00000000;          // CONFIG register value DLPF_CFG = 0 (256-260 Hz);
  mpu6050TXData[3] = 0b00010000;          // GYRO_CONFIG register value FS_SEL = +-1000 deg/s;
 800b5ee:	2510      	movs	r5, #16
  /* Configure the MPU6050 sensor        */
  /* NOTE:                               */
  /* - SLEEP flag must be cleared before */
  /*   configuring the sensor.           */
  mpu6050TXData[0] = MPU6050_SMPLRT_DIV;  // Start register address;
  mpu6050TXData[1] = 11;                  // SMPLRT_DIV register value (8000 / (11 + 1) = 666 Hz);
 800b5f0:	270b      	movs	r7, #11
  mpu6050TXData[2] = 0b00000000;          // CONFIG register value DLPF_CFG = 0 (256-260 Hz);
  mpu6050TXData[3] = 0b00010000;          // GYRO_CONFIG register value FS_SEL = +-1000 deg/s;
  mpu6050TXData[4] = 0b00010000;          // ACCEL_CONFIG register value AFS_SEL = +-8G;

  status = i2cMasterTransmitTimeout(&I2CD2, addr, mpu6050TXData, 5,
 800b5f2:	9000      	str	r0, [sp, #0]
 800b5f4:	9001      	str	r0, [sp, #4]
 800b5f6:	f8cd 9008 	str.w	r9, [sp, #8]
 800b5fa:	4622      	mov	r2, r4
  /* NOTE:                               */
  /* - SLEEP flag must be cleared before */
  /*   configuring the sensor.           */
  mpu6050TXData[0] = MPU6050_SMPLRT_DIV;  // Start register address;
  mpu6050TXData[1] = 11;                  // SMPLRT_DIV register value (8000 / (11 + 1) = 666 Hz);
  mpu6050TXData[2] = 0b00000000;          // CONFIG register value DLPF_CFG = 0 (256-260 Hz);
 800b5fc:	70a6      	strb	r6, [r4, #2]

  /* Configure the MPU6050 sensor        */
  /* NOTE:                               */
  /* - SLEEP flag must be cleared before */
  /*   configuring the sensor.           */
  mpu6050TXData[0] = MPU6050_SMPLRT_DIV;  // Start register address;
 800b5fe:	f884 e000 	strb.w	lr, [r4]
  mpu6050TXData[1] = 11;                  // SMPLRT_DIV register value (8000 / (11 + 1) = 666 Hz);
 800b602:	7067      	strb	r7, [r4, #1]
  mpu6050TXData[2] = 0b00000000;          // CONFIG register value DLPF_CFG = 0 (256-260 Hz);
  mpu6050TXData[3] = 0b00010000;          // GYRO_CONFIG register value FS_SEL = +-1000 deg/s;
 800b604:	70e5      	strb	r5, [r4, #3]
  mpu6050TXData[4] = 0b00010000;          // ACCEL_CONFIG register value AFS_SEL = +-8G;
 800b606:	7125      	strb	r5, [r4, #4]

  status = i2cMasterTransmitTimeout(&I2CD2, addr, mpu6050TXData, 5,
 800b608:	4815      	ldr	r0, [pc, #84]	; (800b660 <mpu6050Init+0x130>)
 800b60a:	2305      	movs	r3, #5
 800b60c:	f7f8 f840 	bl	8003690 <i2cMasterTransmitTimeout>
 800b610:	4604      	mov	r4, r0
    NULL, 0, MS2ST(MPU6050_WRITE_TIMEOUT_MS));

  i2cReleaseBus(&I2CD2);
 800b612:	4813      	ldr	r0, [pc, #76]	; (800b660 <mpu6050Init+0x130>)
 800b614:	f7f8 f864 	bl	80036e0 <i2cReleaseBus>

  if (status != MSG_OK) {
 800b618:	b96c      	cbnz	r4, 800b636 <mpu6050Init+0x106>
      debugLog("E:mpu6050i-cfg");
    }
    return 0;
  }

  return 1;
 800b61a:	2001      	movs	r0, #1
}
 800b61c:	b005      	add	sp, #20
 800b61e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (status != MSG_OK) {
    chprintf((BaseSequentialStream *)&SD4, "III6050 not OK\n");
    i2cReleaseBus(&I2CD2);
    g_i2cErrorInfo.last_i2c_error = i2cGetErrors(&I2CD2);
    if (g_i2cErrorInfo.last_i2c_error) {
      g_i2cErrorInfo.i2c_error_counter++;
 800b622:	685a      	ldr	r2, [r3, #4]
      debugLog("E:mpu6050i-tx1");
 800b624:	4813      	ldr	r0, [pc, #76]	; (800b674 <mpu6050Init+0x144>)
  if (status != MSG_OK) {
    chprintf((BaseSequentialStream *)&SD4, "III6050 not OK\n");
    i2cReleaseBus(&I2CD2);
    g_i2cErrorInfo.last_i2c_error = i2cGetErrors(&I2CD2);
    if (g_i2cErrorInfo.last_i2c_error) {
      g_i2cErrorInfo.i2c_error_counter++;
 800b626:	3201      	adds	r2, #1
 800b628:	605a      	str	r2, [r3, #4]
      debugLog("E:mpu6050i-tx1");
 800b62a:	f000 f999 	bl	800b960 <debugLog>
    }
    return 0;
 800b62e:	4628      	mov	r0, r5
    }
    return 0;
  }

  return 1;
}
 800b630:	b005      	add	sp, #20
 800b632:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    NULL, 0, MS2ST(MPU6050_WRITE_TIMEOUT_MS));

  i2cReleaseBus(&I2CD2);

  if (status != MSG_OK) {
    g_i2cErrorInfo.last_i2c_error = i2cGetErrors(&I2CD2);
 800b636:	480a      	ldr	r0, [pc, #40]	; (800b660 <mpu6050Init+0x130>)
 800b638:	f7f8 f822 	bl	8003680 <i2cGetErrors>
 800b63c:	4b0a      	ldr	r3, [pc, #40]	; (800b668 <mpu6050Init+0x138>)
 800b63e:	6018      	str	r0, [r3, #0]
    if (g_i2cErrorInfo.last_i2c_error) {
 800b640:	2800      	cmp	r0, #0
 800b642:	d0a3      	beq.n	800b58c <mpu6050Init+0x5c>
      g_i2cErrorInfo.i2c_error_counter++;
 800b644:	685a      	ldr	r2, [r3, #4]
      debugLog("E:mpu6050i-cfg");
 800b646:	480c      	ldr	r0, [pc, #48]	; (800b678 <mpu6050Init+0x148>)
  i2cReleaseBus(&I2CD2);

  if (status != MSG_OK) {
    g_i2cErrorInfo.last_i2c_error = i2cGetErrors(&I2CD2);
    if (g_i2cErrorInfo.last_i2c_error) {
      g_i2cErrorInfo.i2c_error_counter++;
 800b648:	3201      	adds	r2, #1
 800b64a:	605a      	str	r2, [r3, #4]
      debugLog("E:mpu6050i-cfg");
 800b64c:	f000 f988 	bl	800b960 <debugLog>
    }
    return 0;
 800b650:	4630      	mov	r0, r6
 800b652:	e79c      	b.n	800b58e <mpu6050Init+0x5e>
 800b654:	0800e6c0 	.word	0x0800e6c0
 800b658:	20002aa4 	.word	0x20002aa4
 800b65c:	200013e4 	.word	0x200013e4
 800b660:	2000133c 	.word	0x2000133c
 800b664:	0800e6d0 	.word	0x0800e6d0
 800b668:	200026c0 	.word	0x200026c0
 800b66c:	0800e6f0 	.word	0x0800e6f0
 800b670:	0800e704 	.word	0x0800e704
 800b674:	0800e6e0 	.word	0x0800e6e0
 800b678:	0800e714 	.word	0x0800e714
 800b67c:	00000000 	.word	0x00000000

0800b680 <mpu6050GetNewData>:
 * @brief  Reads new data from the sensor
 * @param  pIMU - pointer to IMU data structure;
 * @return 1 - if reading was successful;
 *         0 - if reading failed.
 */
uint8_t mpu6050GetNewData(PIMUStruct pIMU) {
 800b680:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b684:	4605      	mov	r5, r0
  msg_t status = MSG_OK;
  uint8_t id;
  int16_t mpu6050Data[6];

  /* Set the start register address for bulk data transfer. */
  mpu6050TXData[0] = MPU6050_ACCEL_XOUT_H;
 800b686:	4e8c      	ldr	r6, [pc, #560]	; (800b8b8 <mpu6050GetNewData+0x238>)
 * @brief  Reads new data from the sensor
 * @param  pIMU - pointer to IMU data structure;
 * @return 1 - if reading was successful;
 *         0 - if reading failed.
 */
uint8_t mpu6050GetNewData(PIMUStruct pIMU) {
 800b688:	b089      	sub	sp, #36	; 0x24
  msg_t status = MSG_OK;
  uint8_t id;
  int16_t mpu6050Data[6];

  /* Set the start register address for bulk data transfer. */
  mpu6050TXData[0] = MPU6050_ACCEL_XOUT_H;
 800b68a:	233b      	movs	r3, #59	; 0x3b
  i2cAcquireBus(&I2CD2);
 800b68c:	488b      	ldr	r0, [pc, #556]	; (800b8bc <mpu6050GetNewData+0x23c>)
  status = i2cMasterTransmitTimeout(&I2CD2, pIMU->addr, mpu6050TXData, 1,
 800b68e:	4c8c      	ldr	r4, [pc, #560]	; (800b8c0 <mpu6050GetNewData+0x240>)
  msg_t status = MSG_OK;
  uint8_t id;
  int16_t mpu6050Data[6];

  /* Set the start register address for bulk data transfer. */
  mpu6050TXData[0] = MPU6050_ACCEL_XOUT_H;
 800b690:	7033      	strb	r3, [r6, #0]
  i2cAcquireBus(&I2CD2);
 800b692:	f7f8 f81d 	bl	80036d0 <i2cAcquireBus>
  status = i2cMasterTransmitTimeout(&I2CD2, pIMU->addr, mpu6050TXData, 1,
 800b696:	200e      	movs	r0, #14
 800b698:	2302      	movs	r3, #2
 800b69a:	f895 106b 	ldrb.w	r1, [r5, #107]	; 0x6b
 800b69e:	4632      	mov	r2, r6
 800b6a0:	9001      	str	r0, [sp, #4]
 800b6a2:	9302      	str	r3, [sp, #8]
 800b6a4:	9400      	str	r4, [sp, #0]
 800b6a6:	4885      	ldr	r0, [pc, #532]	; (800b8bc <mpu6050GetNewData+0x23c>)
 800b6a8:	2301      	movs	r3, #1
 800b6aa:	f7f7 fff1 	bl	8003690 <i2cMasterTransmitTimeout>
 800b6ae:	4606      	mov	r6, r0
    mpu6050RXData, 14, MS2ST(MPU6050_READ_TIMEOUT_MS));
  i2cReleaseBus(&I2CD2);
 800b6b0:	4882      	ldr	r0, [pc, #520]	; (800b8bc <mpu6050GetNewData+0x23c>)
 800b6b2:	f7f8 f815 	bl	80036e0 <i2cReleaseBus>

  if (status != MSG_OK) {
 800b6b6:	2e00      	cmp	r6, #0
 800b6b8:	f040 80d5 	bne.w	800b866 <mpu6050GetNewData+0x1e6>
      debugLog("E:mpu6050gnd");
    }
    return 0;
  }

  mpu6050Data[0] = (int16_t)((mpu6050RXData[ 0]<<8) | mpu6050RXData[ 1]); /* Accel X */
 800b6bc:	f894 b000 	ldrb.w	fp, [r4]
 800b6c0:	7867      	ldrb	r7, [r4, #1]
  mpu6050Data[1] = (int16_t)((mpu6050RXData[ 2]<<8) | mpu6050RXData[ 3]); /* Accel Y */
 800b6c2:	f894 a002 	ldrb.w	sl, [r4, #2]
 800b6c6:	78e6      	ldrb	r6, [r4, #3]
  mpu6050Data[2] = (int16_t)((mpu6050RXData[ 4]<<8) | mpu6050RXData[ 5]); /* Accel Z */
 800b6c8:	f894 9004 	ldrb.w	r9, [r4, #4]
 800b6cc:	7960      	ldrb	r0, [r4, #5]
  mpu6050Data[3] = (int16_t)((mpu6050RXData[ 8]<<8) | mpu6050RXData[ 9]); /* Gyro X  */
 800b6ce:	f894 8008 	ldrb.w	r8, [r4, #8]
 800b6d2:	7a61      	ldrb	r1, [r4, #9]
  mpu6050Data[4] = (int16_t)((mpu6050RXData[10]<<8) | mpu6050RXData[11]); /* Gyro Y  */
 800b6d4:	f894 c00a 	ldrb.w	ip, [r4, #10]
 800b6d8:	7ae2      	ldrb	r2, [r4, #11]
  mpu6050Data[5] = (int16_t)((mpu6050RXData[12]<<8) | mpu6050RXData[13]); /* Gyro Z  */
 800b6da:	7b23      	ldrb	r3, [r4, #12]
 800b6dc:	7b64      	ldrb	r4, [r4, #13]
  //chprintf((BaseSequentialStream *)&SD4, "gnd\n");
  
  
  
  /* Pitch: */
  id = pIMU->axes_conf[0] & IMU_AXIS_ID_MASK;
 800b6de:	f895 e068 	ldrb.w	lr, [r5, #104]	; 0x68
  mpu6050Data[0] = (int16_t)((mpu6050RXData[ 0]<<8) | mpu6050RXData[ 1]); /* Accel X */
  mpu6050Data[1] = (int16_t)((mpu6050RXData[ 2]<<8) | mpu6050RXData[ 3]); /* Accel Y */
  mpu6050Data[2] = (int16_t)((mpu6050RXData[ 4]<<8) | mpu6050RXData[ 5]); /* Accel Z */
  mpu6050Data[3] = (int16_t)((mpu6050RXData[ 8]<<8) | mpu6050RXData[ 9]); /* Gyro X  */
  mpu6050Data[4] = (int16_t)((mpu6050RXData[10]<<8) | mpu6050RXData[11]); /* Gyro Y  */
  mpu6050Data[5] = (int16_t)((mpu6050RXData[12]<<8) | mpu6050RXData[13]); /* Gyro Z  */
 800b6e2:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
    return 0;
  }

  mpu6050Data[0] = (int16_t)((mpu6050RXData[ 0]<<8) | mpu6050RXData[ 1]); /* Accel X */
  mpu6050Data[1] = (int16_t)((mpu6050RXData[ 2]<<8) | mpu6050RXData[ 3]); /* Accel Y */
  mpu6050Data[2] = (int16_t)((mpu6050RXData[ 4]<<8) | mpu6050RXData[ 5]); /* Accel Z */
 800b6e6:	ea40 2009 	orr.w	r0, r0, r9, lsl #8
  mpu6050Data[3] = (int16_t)((mpu6050RXData[ 8]<<8) | mpu6050RXData[ 9]); /* Gyro X  */
  mpu6050Data[4] = (int16_t)((mpu6050RXData[10]<<8) | mpu6050RXData[11]); /* Gyro Y  */
  mpu6050Data[5] = (int16_t)((mpu6050RXData[12]<<8) | mpu6050RXData[13]); /* Gyro Z  */
 800b6ea:	f8ad 301e 	strh.w	r3, [sp, #30]
      debugLog("E:mpu6050gnd");
    }
    return 0;
  }

  mpu6050Data[0] = (int16_t)((mpu6050RXData[ 0]<<8) | mpu6050RXData[ 1]); /* Accel X */
 800b6ee:	ea47 270b 	orr.w	r7, r7, fp, lsl #8
  mpu6050Data[1] = (int16_t)((mpu6050RXData[ 2]<<8) | mpu6050RXData[ 3]); /* Accel Y */
 800b6f2:	ea46 260a 	orr.w	r6, r6, sl, lsl #8
  mpu6050Data[2] = (int16_t)((mpu6050RXData[ 4]<<8) | mpu6050RXData[ 5]); /* Accel Z */
  mpu6050Data[3] = (int16_t)((mpu6050RXData[ 8]<<8) | mpu6050RXData[ 9]); /* Gyro X  */
 800b6f6:	ea41 2108 	orr.w	r1, r1, r8, lsl #8
  mpu6050Data[4] = (int16_t)((mpu6050RXData[10]<<8) | mpu6050RXData[11]); /* Gyro Y  */
 800b6fa:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
  //chprintf((BaseSequentialStream *)&SD4, "gnd\n");
  
  
  
  /* Pitch: */
  id = pIMU->axes_conf[0] & IMU_AXIS_ID_MASK;
 800b6fe:	f00e 0407 	and.w	r4, lr, #7
  if (pIMU->axes_conf[0] & IMU_AXIS_DIR_POS) {
    pIMU->accelData[0] = mpu6050Data[id + 0]*MPU6050_ACCEL_SCALE;
 800b702:	ab08      	add	r3, sp, #32
      debugLog("E:mpu6050gnd");
    }
    return 0;
  }

  mpu6050Data[0] = (int16_t)((mpu6050RXData[ 0]<<8) | mpu6050RXData[ 1]); /* Accel X */
 800b704:	f8ad 7014 	strh.w	r7, [sp, #20]
  mpu6050Data[1] = (int16_t)((mpu6050RXData[ 2]<<8) | mpu6050RXData[ 3]); /* Accel Y */
 800b708:	f8ad 6016 	strh.w	r6, [sp, #22]
  mpu6050Data[2] = (int16_t)((mpu6050RXData[ 4]<<8) | mpu6050RXData[ 5]); /* Accel Z */
 800b70c:	f8ad 0018 	strh.w	r0, [sp, #24]
  mpu6050Data[3] = (int16_t)((mpu6050RXData[ 8]<<8) | mpu6050RXData[ 9]); /* Gyro X  */
 800b710:	f8ad 101a 	strh.w	r1, [sp, #26]
  mpu6050Data[4] = (int16_t)((mpu6050RXData[10]<<8) | mpu6050RXData[11]); /* Gyro Y  */
 800b714:	f8ad 201c 	strh.w	r2, [sp, #28]
  
  
  /* Pitch: */
  id = pIMU->axes_conf[0] & IMU_AXIS_ID_MASK;
  if (pIMU->axes_conf[0] & IMU_AXIS_DIR_POS) {
    pIMU->accelData[0] = mpu6050Data[id + 0]*MPU6050_ACCEL_SCALE;
 800b718:	eb03 0344 	add.w	r3, r3, r4, lsl #1
  
  
  
  /* Pitch: */
  id = pIMU->axes_conf[0] & IMU_AXIS_ID_MASK;
  if (pIMU->axes_conf[0] & IMU_AXIS_DIR_POS) {
 800b71c:	f01e 0f08 	tst.w	lr, #8
    pIMU->accelData[0] = mpu6050Data[id + 0]*MPU6050_ACCEL_SCALE;
 800b720:	f933 0c0c 	ldrsh.w	r0, [r3, #-12]
  
  
  
  /* Pitch: */
  id = pIMU->axes_conf[0] & IMU_AXIS_ID_MASK;
  if (pIMU->axes_conf[0] & IMU_AXIS_DIR_POS) {
 800b724:	d170      	bne.n	800b808 <mpu6050GetNewData+0x188>
    pIMU->accelData[0] = mpu6050Data[id + 0]*MPU6050_ACCEL_SCALE;
    pIMU->gyroData[0]  = mpu6050Data[id + 3]*MPU6050_GYRO_SCALE;
  } else {
    pIMU->accelData[0] = (-1 - mpu6050Data[id + 0])*MPU6050_ACCEL_SCALE;
 800b726:	43c0      	mvns	r0, r0
 800b728:	f7f4 feec 	bl	8000504 <__aeabi_i2d>
 800b72c:	a360      	add	r3, pc, #384	; (adr r3, 800b8b0 <mpu6050GetNewData+0x230>)
 800b72e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b732:	f7f4 ff4d 	bl	80005d0 <__aeabi_dmul>
 800b736:	f7f5 fa13 	bl	8000b60 <__aeabi_d2f>
    pIMU->gyroData[0]  = (-1 - mpu6050Data[id + 3])*MPU6050_GYRO_SCALE;
 800b73a:	ab08      	add	r3, sp, #32
 800b73c:	eb03 0444 	add.w	r4, r3, r4, lsl #1
 800b740:	f934 3c06 	ldrsh.w	r3, [r4, #-6]
  id = pIMU->axes_conf[0] & IMU_AXIS_ID_MASK;
  if (pIMU->axes_conf[0] & IMU_AXIS_DIR_POS) {
    pIMU->accelData[0] = mpu6050Data[id + 0]*MPU6050_ACCEL_SCALE;
    pIMU->gyroData[0]  = mpu6050Data[id + 3]*MPU6050_GYRO_SCALE;
  } else {
    pIMU->accelData[0] = (-1 - mpu6050Data[id + 0])*MPU6050_ACCEL_SCALE;
 800b744:	6028      	str	r0, [r5, #0]
 800b746:	4606      	mov	r6, r0
    pIMU->gyroData[0]  = (-1 - mpu6050Data[id + 3])*MPU6050_GYRO_SCALE;
 800b748:	43d8      	mvns	r0, r3
 800b74a:	f7f5 fb13 	bl	8000d74 <__aeabi_i2f>
 800b74e:	495d      	ldr	r1, [pc, #372]	; (800b8c4 <mpu6050GetNewData+0x244>)
 800b750:	f7f5 fb66 	bl	8000e20 <__aeabi_fmul>
 800b754:	60e8      	str	r0, [r5, #12]
  }

//  chprintf((BaseSequentialStream *)&SD4, "g%D\n", (uint8_t)pIMU->accelData[0]);
chprintf((BaseSequentialStream *)&SD4, "g%D ", (uint8_t)pIMU->accelData[0]);
 800b756:	4630      	mov	r0, r6
 800b758:	f7f5 fd52 	bl	8001200 <__aeabi_f2uiz>
 800b75c:	495a      	ldr	r1, [pc, #360]	; (800b8c8 <mpu6050GetNewData+0x248>)
 800b75e:	b2c2      	uxtb	r2, r0
 800b760:	485a      	ldr	r0, [pc, #360]	; (800b8cc <mpu6050GetNewData+0x24c>)
 800b762:	f7fe faad 	bl	8009cc0 <chprintf>
chprintf((BaseSequentialStream *)&SD4, "g%D\r", (uint8_t)pIMU->accelData[1]);
 800b766:	6868      	ldr	r0, [r5, #4]
 800b768:	f7f5 fd4a 	bl	8001200 <__aeabi_f2uiz>
 800b76c:	4958      	ldr	r1, [pc, #352]	; (800b8d0 <mpu6050GetNewData+0x250>)
 800b76e:	b2c2      	uxtb	r2, r0
 800b770:	4856      	ldr	r0, [pc, #344]	; (800b8cc <mpu6050GetNewData+0x24c>)
 800b772:	f7fe faa5 	bl	8009cc0 <chprintf>
  //chprintf((BaseSequentialStream *)&SD4, "g%f\r", pIMU->accelData[0]);
  //chprintf((BaseSequentialStream *)&SD4, "g%f\r", pIMU->accelData[0]);
  
  /* Roll: */
  id = pIMU->axes_conf[1] & IMU_AXIS_ID_MASK;
 800b776:	f895 3069 	ldrb.w	r3, [r5, #105]	; 0x69
 800b77a:	f003 0407 	and.w	r4, r3, #7
  if (pIMU->axes_conf[1] & IMU_AXIS_DIR_POS) {
 800b77e:	f013 0f08 	tst.w	r3, #8
    pIMU->accelData[1] = mpu6050Data[id + 0]*MPU6050_ACCEL_SCALE;
 800b782:	ab08      	add	r3, sp, #32
 800b784:	eb03 0344 	add.w	r3, r3, r4, lsl #1
 800b788:	f933 0c0c 	ldrsh.w	r0, [r3, #-12]
  //chprintf((BaseSequentialStream *)&SD4, "g%f\r", pIMU->accelData[0]);
  //chprintf((BaseSequentialStream *)&SD4, "g%f\r", pIMU->accelData[0]);
  
  /* Roll: */
  id = pIMU->axes_conf[1] & IMU_AXIS_ID_MASK;
  if (pIMU->axes_conf[1] & IMU_AXIS_DIR_POS) {
 800b78c:	d053      	beq.n	800b836 <mpu6050GetNewData+0x1b6>
    pIMU->accelData[1] = mpu6050Data[id + 0]*MPU6050_ACCEL_SCALE;
 800b78e:	f7f4 feb9 	bl	8000504 <__aeabi_i2d>
 800b792:	a347      	add	r3, pc, #284	; (adr r3, 800b8b0 <mpu6050GetNewData+0x230>)
 800b794:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b798:	f7f4 ff1a 	bl	80005d0 <__aeabi_dmul>
 800b79c:	f7f5 f9e0 	bl	8000b60 <__aeabi_d2f>
    pIMU->gyroData[1]  = mpu6050Data[id + 3]*MPU6050_GYRO_SCALE;
 800b7a0:	ab08      	add	r3, sp, #32
 800b7a2:	eb03 0444 	add.w	r4, r3, r4, lsl #1
  //chprintf((BaseSequentialStream *)&SD4, "g%f\r", pIMU->accelData[0]);
  
  /* Roll: */
  id = pIMU->axes_conf[1] & IMU_AXIS_ID_MASK;
  if (pIMU->axes_conf[1] & IMU_AXIS_DIR_POS) {
    pIMU->accelData[1] = mpu6050Data[id + 0]*MPU6050_ACCEL_SCALE;
 800b7a6:	6068      	str	r0, [r5, #4]
    pIMU->gyroData[1]  = mpu6050Data[id + 3]*MPU6050_GYRO_SCALE;
 800b7a8:	f934 0c06 	ldrsh.w	r0, [r4, #-6]
 800b7ac:	f7f5 fae2 	bl	8000d74 <__aeabi_i2f>
 800b7b0:	4944      	ldr	r1, [pc, #272]	; (800b8c4 <mpu6050GetNewData+0x244>)
 800b7b2:	f7f5 fb35 	bl	8000e20 <__aeabi_fmul>
 800b7b6:	6128      	str	r0, [r5, #16]
    pIMU->accelData[1] = (-1 - mpu6050Data[id + 0])*MPU6050_ACCEL_SCALE;
    pIMU->gyroData[1]  = (-1 - mpu6050Data[id + 3])*MPU6050_GYRO_SCALE;
  }

  /* Yaw: */
  id = pIMU->axes_conf[2] & IMU_AXIS_ID_MASK;
 800b7b8:	f895 306a 	ldrb.w	r3, [r5, #106]	; 0x6a
 800b7bc:	f003 0407 	and.w	r4, r3, #7
  if (pIMU->axes_conf[2] & IMU_AXIS_DIR_POS) {
 800b7c0:	f013 0f08 	tst.w	r3, #8
    pIMU->accelData[2] = mpu6050Data[id + 0]*MPU6050_ACCEL_SCALE;
 800b7c4:	ab08      	add	r3, sp, #32
 800b7c6:	eb03 0344 	add.w	r3, r3, r4, lsl #1
 800b7ca:	f933 0c0c 	ldrsh.w	r0, [r3, #-12]
    pIMU->gyroData[1]  = (-1 - mpu6050Data[id + 3])*MPU6050_GYRO_SCALE;
  }

  /* Yaw: */
  id = pIMU->axes_conf[2] & IMU_AXIS_ID_MASK;
  if (pIMU->axes_conf[2] & IMU_AXIS_DIR_POS) {
 800b7ce:	d155      	bne.n	800b87c <mpu6050GetNewData+0x1fc>
    pIMU->accelData[2] = mpu6050Data[id + 0]*MPU6050_ACCEL_SCALE;
    pIMU->gyroData[2]  = mpu6050Data[id + 3]*MPU6050_GYRO_SCALE;
  } else {
    pIMU->accelData[2] = (-1 - mpu6050Data[id + 0])*MPU6050_ACCEL_SCALE;
 800b7d0:	43c0      	mvns	r0, r0
 800b7d2:	f7f4 fe97 	bl	8000504 <__aeabi_i2d>
 800b7d6:	a336      	add	r3, pc, #216	; (adr r3, 800b8b0 <mpu6050GetNewData+0x230>)
 800b7d8:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b7dc:	f7f4 fef8 	bl	80005d0 <__aeabi_dmul>
 800b7e0:	f7f5 f9be 	bl	8000b60 <__aeabi_d2f>
    pIMU->gyroData[2]  = (-1 - mpu6050Data[id + 3])*MPU6050_GYRO_SCALE;
 800b7e4:	ab08      	add	r3, sp, #32
 800b7e6:	eb03 0444 	add.w	r4, r3, r4, lsl #1
 800b7ea:	f934 3c06 	ldrsh.w	r3, [r4, #-6]
  id = pIMU->axes_conf[2] & IMU_AXIS_ID_MASK;
  if (pIMU->axes_conf[2] & IMU_AXIS_DIR_POS) {
    pIMU->accelData[2] = mpu6050Data[id + 0]*MPU6050_ACCEL_SCALE;
    pIMU->gyroData[2]  = mpu6050Data[id + 3]*MPU6050_GYRO_SCALE;
  } else {
    pIMU->accelData[2] = (-1 - mpu6050Data[id + 0])*MPU6050_ACCEL_SCALE;
 800b7ee:	60a8      	str	r0, [r5, #8]
    pIMU->gyroData[2]  = (-1 - mpu6050Data[id + 3])*MPU6050_GYRO_SCALE;
 800b7f0:	43d8      	mvns	r0, r3
 800b7f2:	f7f5 fabf 	bl	8000d74 <__aeabi_i2f>
 800b7f6:	4933      	ldr	r1, [pc, #204]	; (800b8c4 <mpu6050GetNewData+0x244>)
 800b7f8:	f7f5 fb12 	bl	8000e20 <__aeabi_fmul>
  }

  return 1;
 800b7fc:	2301      	movs	r3, #1
  if (pIMU->axes_conf[2] & IMU_AXIS_DIR_POS) {
    pIMU->accelData[2] = mpu6050Data[id + 0]*MPU6050_ACCEL_SCALE;
    pIMU->gyroData[2]  = mpu6050Data[id + 3]*MPU6050_GYRO_SCALE;
  } else {
    pIMU->accelData[2] = (-1 - mpu6050Data[id + 0])*MPU6050_ACCEL_SCALE;
    pIMU->gyroData[2]  = (-1 - mpu6050Data[id + 3])*MPU6050_GYRO_SCALE;
 800b7fe:	6168      	str	r0, [r5, #20]
  }

  return 1;
}
 800b800:	4618      	mov	r0, r3
 800b802:	b009      	add	sp, #36	; 0x24
 800b804:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  
  
  /* Pitch: */
  id = pIMU->axes_conf[0] & IMU_AXIS_ID_MASK;
  if (pIMU->axes_conf[0] & IMU_AXIS_DIR_POS) {
    pIMU->accelData[0] = mpu6050Data[id + 0]*MPU6050_ACCEL_SCALE;
 800b808:	f7f4 fe7c 	bl	8000504 <__aeabi_i2d>
 800b80c:	a328      	add	r3, pc, #160	; (adr r3, 800b8b0 <mpu6050GetNewData+0x230>)
 800b80e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b812:	f7f4 fedd 	bl	80005d0 <__aeabi_dmul>
 800b816:	f7f5 f9a3 	bl	8000b60 <__aeabi_d2f>
    pIMU->gyroData[0]  = mpu6050Data[id + 3]*MPU6050_GYRO_SCALE;
 800b81a:	ab08      	add	r3, sp, #32
 800b81c:	eb03 0444 	add.w	r4, r3, r4, lsl #1
  
  
  /* Pitch: */
  id = pIMU->axes_conf[0] & IMU_AXIS_ID_MASK;
  if (pIMU->axes_conf[0] & IMU_AXIS_DIR_POS) {
    pIMU->accelData[0] = mpu6050Data[id + 0]*MPU6050_ACCEL_SCALE;
 800b820:	6028      	str	r0, [r5, #0]
 800b822:	4606      	mov	r6, r0
    pIMU->gyroData[0]  = mpu6050Data[id + 3]*MPU6050_GYRO_SCALE;
 800b824:	f934 0c06 	ldrsh.w	r0, [r4, #-6]
 800b828:	f7f5 faa4 	bl	8000d74 <__aeabi_i2f>
 800b82c:	4925      	ldr	r1, [pc, #148]	; (800b8c4 <mpu6050GetNewData+0x244>)
 800b82e:	f7f5 faf7 	bl	8000e20 <__aeabi_fmul>
 800b832:	60e8      	str	r0, [r5, #12]
 800b834:	e78f      	b.n	800b756 <mpu6050GetNewData+0xd6>
  id = pIMU->axes_conf[1] & IMU_AXIS_ID_MASK;
  if (pIMU->axes_conf[1] & IMU_AXIS_DIR_POS) {
    pIMU->accelData[1] = mpu6050Data[id + 0]*MPU6050_ACCEL_SCALE;
    pIMU->gyroData[1]  = mpu6050Data[id + 3]*MPU6050_GYRO_SCALE;
  } else {
    pIMU->accelData[1] = (-1 - mpu6050Data[id + 0])*MPU6050_ACCEL_SCALE;
 800b836:	43c0      	mvns	r0, r0
 800b838:	f7f4 fe64 	bl	8000504 <__aeabi_i2d>
 800b83c:	a31c      	add	r3, pc, #112	; (adr r3, 800b8b0 <mpu6050GetNewData+0x230>)
 800b83e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b842:	f7f4 fec5 	bl	80005d0 <__aeabi_dmul>
 800b846:	f7f5 f98b 	bl	8000b60 <__aeabi_d2f>
    pIMU->gyroData[1]  = (-1 - mpu6050Data[id + 3])*MPU6050_GYRO_SCALE;
 800b84a:	ab08      	add	r3, sp, #32
 800b84c:	eb03 0444 	add.w	r4, r3, r4, lsl #1
 800b850:	f934 3c06 	ldrsh.w	r3, [r4, #-6]
  id = pIMU->axes_conf[1] & IMU_AXIS_ID_MASK;
  if (pIMU->axes_conf[1] & IMU_AXIS_DIR_POS) {
    pIMU->accelData[1] = mpu6050Data[id + 0]*MPU6050_ACCEL_SCALE;
    pIMU->gyroData[1]  = mpu6050Data[id + 3]*MPU6050_GYRO_SCALE;
  } else {
    pIMU->accelData[1] = (-1 - mpu6050Data[id + 0])*MPU6050_ACCEL_SCALE;
 800b854:	6068      	str	r0, [r5, #4]
    pIMU->gyroData[1]  = (-1 - mpu6050Data[id + 3])*MPU6050_GYRO_SCALE;
 800b856:	43d8      	mvns	r0, r3
 800b858:	f7f5 fa8c 	bl	8000d74 <__aeabi_i2f>
 800b85c:	4919      	ldr	r1, [pc, #100]	; (800b8c4 <mpu6050GetNewData+0x244>)
 800b85e:	f7f5 fadf 	bl	8000e20 <__aeabi_fmul>
 800b862:	6128      	str	r0, [r5, #16]
 800b864:	e7a8      	b.n	800b7b8 <mpu6050GetNewData+0x138>
  status = i2cMasterTransmitTimeout(&I2CD2, pIMU->addr, mpu6050TXData, 1,
    mpu6050RXData, 14, MS2ST(MPU6050_READ_TIMEOUT_MS));
  i2cReleaseBus(&I2CD2);

  if (status != MSG_OK) {
    g_i2cErrorInfo.last_i2c_error = i2cGetErrors(&I2CD2);
 800b866:	4815      	ldr	r0, [pc, #84]	; (800b8bc <mpu6050GetNewData+0x23c>)
 800b868:	f7f7 ff0a 	bl	8003680 <i2cGetErrors>
 800b86c:	4b19      	ldr	r3, [pc, #100]	; (800b8d4 <mpu6050GetNewData+0x254>)
 800b86e:	6018      	str	r0, [r3, #0]
    if (g_i2cErrorInfo.last_i2c_error) {
 800b870:	b9a0      	cbnz	r0, 800b89c <mpu6050GetNewData+0x21c>
      g_i2cErrorInfo.i2c_error_counter++;
      debugLog("E:mpu6050gnd");
    }
    return 0;
 800b872:	4603      	mov	r3, r0
    pIMU->accelData[2] = (-1 - mpu6050Data[id + 0])*MPU6050_ACCEL_SCALE;
    pIMU->gyroData[2]  = (-1 - mpu6050Data[id + 3])*MPU6050_GYRO_SCALE;
  }

  return 1;
}
 800b874:	4618      	mov	r0, r3
 800b876:	b009      	add	sp, #36	; 0x24
 800b878:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  }

  /* Yaw: */
  id = pIMU->axes_conf[2] & IMU_AXIS_ID_MASK;
  if (pIMU->axes_conf[2] & IMU_AXIS_DIR_POS) {
    pIMU->accelData[2] = mpu6050Data[id + 0]*MPU6050_ACCEL_SCALE;
 800b87c:	f7f4 fe42 	bl	8000504 <__aeabi_i2d>
 800b880:	a30b      	add	r3, pc, #44	; (adr r3, 800b8b0 <mpu6050GetNewData+0x230>)
 800b882:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b886:	f7f4 fea3 	bl	80005d0 <__aeabi_dmul>
 800b88a:	f7f5 f969 	bl	8000b60 <__aeabi_d2f>
    pIMU->gyroData[2]  = mpu6050Data[id + 3]*MPU6050_GYRO_SCALE;
 800b88e:	ab08      	add	r3, sp, #32
 800b890:	eb03 0444 	add.w	r4, r3, r4, lsl #1
  }

  /* Yaw: */
  id = pIMU->axes_conf[2] & IMU_AXIS_ID_MASK;
  if (pIMU->axes_conf[2] & IMU_AXIS_DIR_POS) {
    pIMU->accelData[2] = mpu6050Data[id + 0]*MPU6050_ACCEL_SCALE;
 800b894:	60a8      	str	r0, [r5, #8]
    pIMU->gyroData[2]  = mpu6050Data[id + 3]*MPU6050_GYRO_SCALE;
 800b896:	f934 0c06 	ldrsh.w	r0, [r4, #-6]
 800b89a:	e7aa      	b.n	800b7f2 <mpu6050GetNewData+0x172>
  i2cReleaseBus(&I2CD2);

  if (status != MSG_OK) {
    g_i2cErrorInfo.last_i2c_error = i2cGetErrors(&I2CD2);
    if (g_i2cErrorInfo.last_i2c_error) {
      g_i2cErrorInfo.i2c_error_counter++;
 800b89c:	685a      	ldr	r2, [r3, #4]
      debugLog("E:mpu6050gnd");
 800b89e:	480e      	ldr	r0, [pc, #56]	; (800b8d8 <mpu6050GetNewData+0x258>)
  i2cReleaseBus(&I2CD2);

  if (status != MSG_OK) {
    g_i2cErrorInfo.last_i2c_error = i2cGetErrors(&I2CD2);
    if (g_i2cErrorInfo.last_i2c_error) {
      g_i2cErrorInfo.i2c_error_counter++;
 800b8a0:	3201      	adds	r2, #1
 800b8a2:	605a      	str	r2, [r3, #4]
      debugLog("E:mpu6050gnd");
 800b8a4:	f000 f85c 	bl	800b960 <debugLog>
    }
    return 0;
 800b8a8:	2300      	movs	r3, #0
 800b8aa:	e7a9      	b.n	800b800 <mpu6050GetNewData+0x180>
 800b8ac:	f3af 8000 	nop.w
 800b8b0:	51eb851f 	.word	0x51eb851f
 800b8b4:	3f639eb8 	.word	0x3f639eb8
 800b8b8:	20002aa4 	.word	0x20002aa4
 800b8bc:	2000133c 	.word	0x2000133c
 800b8c0:	20002aac 	.word	0x20002aac
 800b8c4:	3cf9c190 	.word	0x3cf9c190
 800b8c8:	0800e734 	.word	0x0800e734
 800b8cc:	200013e4 	.word	0x200013e4
 800b8d0:	0800e73c 	.word	0x0800e73c
 800b8d4:	200026c0 	.word	0x200026c0
 800b8d8:	0800e724 	.word	0x0800e724
 800b8dc:	00000000 	.word	0x00000000

0800b8e0 <sensorSettingsUpdate>:
}

/**
 * @brief
 */
void sensorSettingsUpdate(const uint8_t *pNewSettings) {
 800b8e0:	b430      	push	{r4, r5}
  uint8_t i;
  memcpy((void *)g_sensorSettings, (void *)pNewSettings, sizeof(g_sensorSettings));
 800b8e2:	4b0b      	ldr	r3, [pc, #44]	; (800b910 <sensorSettingsUpdate+0x30>)
 800b8e4:	8802      	ldrh	r2, [r0, #0]
 800b8e6:	7884      	ldrb	r4, [r0, #2]
 800b8e8:	801a      	strh	r2, [r3, #0]
  for (i = 0; i < 3; i++) {
    g_IMU1.axes_conf[i] = g_sensorSettings[i] & IMU1_CONF_MASK;
 800b8ea:	7818      	ldrb	r0, [r3, #0]
 800b8ec:	7859      	ldrb	r1, [r3, #1]
 800b8ee:	4a09      	ldr	r2, [pc, #36]	; (800b914 <sensorSettingsUpdate+0x34>)
 800b8f0:	f004 050f 	and.w	r5, r4, #15
 800b8f4:	f000 000f 	and.w	r0, r0, #15
 800b8f8:	f001 010f 	and.w	r1, r1, #15
/**
 * @brief
 */
void sensorSettingsUpdate(const uint8_t *pNewSettings) {
  uint8_t i;
  memcpy((void *)g_sensorSettings, (void *)pNewSettings, sizeof(g_sensorSettings));
 800b8fc:	709c      	strb	r4, [r3, #2]
  for (i = 0; i < 3; i++) {
    g_IMU1.axes_conf[i] = g_sensorSettings[i] & IMU1_CONF_MASK;
 800b8fe:	f882 506a 	strb.w	r5, [r2, #106]	; 0x6a
 800b902:	f882 0068 	strb.w	r0, [r2, #104]	; 0x68
 800b906:	f882 1069 	strb.w	r1, [r2, #105]	; 0x69
  }
}
 800b90a:	bc30      	pop	{r4, r5}
 800b90c:	4770      	bx	lr
 800b90e:	bf00      	nop
 800b910:	20000d28 	.word	0x20000d28
 800b914:	20002abc 	.word	0x20002abc
	...

0800b920 <accelBiasUpdate>:

/**
 * @brief
 */
void accelBiasUpdate(PIMUStruct pIMU, const float *pNewSettings) {
 800b920:	b430      	push	{r4, r5}
  memcpy((void *)pIMU->accelBias, (void *)pNewSettings, sizeof(pIMU->accelBias));
 800b922:	688a      	ldr	r2, [r1, #8]
 800b924:	680d      	ldr	r5, [r1, #0]
 800b926:	684c      	ldr	r4, [r1, #4]
 800b928:	6185      	str	r5, [r0, #24]
 800b92a:	61c4      	str	r4, [r0, #28]
 800b92c:	6202      	str	r2, [r0, #32]
}
 800b92e:	bc30      	pop	{r4, r5}
 800b930:	4770      	bx	lr
 800b932:	bf00      	nop
	...

0800b940 <gyroBiasUpdate>:

/**
 * @brief
 */
void gyroBiasUpdate(PIMUStruct pIMU, const float *pNewSettings) {
 800b940:	b430      	push	{r4, r5}
	memcpy((void *)pIMU->gyroBias, (void *)pNewSettings, sizeof(pIMU->gyroBias));
 800b942:	688a      	ldr	r2, [r1, #8]
 800b944:	680d      	ldr	r5, [r1, #0]
 800b946:	684c      	ldr	r4, [r1, #4]
 800b948:	6245      	str	r5, [r0, #36]	; 0x24
 800b94a:	6284      	str	r4, [r0, #40]	; 0x28
 800b94c:	62c2      	str	r2, [r0, #44]	; 0x2c
}
 800b94e:	bc30      	pop	{r4, r5}
 800b950:	4770      	bx	lr
 800b952:	bf00      	nop
	...

0800b960 <debugLog>:
}

/**
 * @brief
 */
void debugLog(const char *str) {
 800b960:	b570      	push	{r4, r5, r6, lr}
 800b962:	4606      	mov	r6, r0
  uint8_t l = strlen(str) + 1;
 800b964:	f001 fd44 	bl	800d3f0 <strlen>
 800b968:	3001      	adds	r0, #1
 800b96a:	b2c4      	uxtb	r4, r0
 800b96c:	2c80      	cmp	r4, #128	; 0x80
  if (l > sizeof(debugMsg.data)) {
    l = sizeof(debugMsg.data);
  }

  memcpy(debugMsg.data, str, l);
 800b96e:	4d05      	ldr	r5, [pc, #20]	; (800b984 <debugLog+0x24>)
 800b970:	bf28      	it	cs
 800b972:	2480      	movcs	r4, #128	; 0x80
 800b974:	4622      	mov	r2, r4
 800b976:	4631      	mov	r1, r6
 800b978:	1d28      	adds	r0, r5, #4
  debugMsg.size = l + TELEMETRY_MSG_SVC_SIZE;
 800b97a:	3408      	adds	r4, #8
  uint8_t l = strlen(str) + 1;
  if (l > sizeof(debugMsg.data)) {
    l = sizeof(debugMsg.data);
  }

  memcpy(debugMsg.data, str, l);
 800b97c:	f7f5 fc60 	bl	8001240 <memcpy>
  debugMsg.size = l + TELEMETRY_MSG_SVC_SIZE;
 800b980:	70ac      	strb	r4, [r5, #2]
 800b982:	bd70      	pop	{r4, r5, r6, pc}
 800b984:	20002b28 	.word	0x20002b28
	...

0800b990 <get_descriptor>:
                                           uint8_t dindex,
                                           uint16_t lang) {

  (void)usbp;
  (void)lang;
  switch (dtype) {
 800b990:	2902      	cmp	r1, #2
 800b992:	d006      	beq.n	800b9a2 <get_descriptor+0x12>
 800b994:	2903      	cmp	r1, #3
 800b996:	d006      	beq.n	800b9a6 <get_descriptor+0x16>
 800b998:	2901      	cmp	r1, #1
    return &vcom_configuration_descriptor;
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
      return &vcom_strings[dindex];
  }
  return NULL;
 800b99a:	4806      	ldr	r0, [pc, #24]	; (800b9b4 <get_descriptor+0x24>)
 800b99c:	bf18      	it	ne
 800b99e:	2000      	movne	r0, #0
 800b9a0:	4770      	bx	lr
  (void)lang;
  switch (dtype) {
  case USB_DESCRIPTOR_DEVICE:
    return &vcom_device_descriptor;
  case USB_DESCRIPTOR_CONFIGURATION:
    return &vcom_configuration_descriptor;
 800b9a2:	4805      	ldr	r0, [pc, #20]	; (800b9b8 <get_descriptor+0x28>)
 800b9a4:	4770      	bx	lr
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
 800b9a6:	2a03      	cmp	r2, #3
      return &vcom_strings[dindex];
 800b9a8:	bf9a      	itte	ls
 800b9aa:	4b04      	ldrls	r3, [pc, #16]	; (800b9bc <get_descriptor+0x2c>)
 800b9ac:	eb03 00c2 	addls.w	r0, r3, r2, lsl #3
  }
  return NULL;
 800b9b0:	2000      	movhi	r0, #0
}
 800b9b2:	4770      	bx	lr
 800b9b4:	0800e900 	.word	0x0800e900
 800b9b8:	0800e780 	.word	0x0800e780
 800b9bc:	0800e8d0 	.word	0x0800e8d0

0800b9c0 <usb_event>:
 * Handles the USB driver global events.
 */
static void usb_event(USBDriver *usbp, usbevent_t event) {
  extern SerialUSBDriver SDU1;

  switch (event) {
 800b9c0:	2902      	cmp	r1, #2
 800b9c2:	d115      	bne.n	800b9f0 <usb_event+0x30>
};

/*
 * Handles the USB driver global events.
 */
static void usb_event(USBDriver *usbp, usbevent_t event) {
 800b9c4:	b538      	push	{r3, r4, r5, lr}
 800b9c6:	4605      	mov	r5, r0
 800b9c8:	460c      	mov	r4, r1

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800b9ca:	2320      	movs	r3, #32
 800b9cc:	f383 8811 	msr	BASEPRI, r3
    chSysLockFromISR();

    /* Enables the endpoints specified into the configuration.
       Note, this callback is invoked from an ISR so I-Class functions
       must be used.*/
    usbInitEndpointI(usbp, USBD1_DATA_REQUEST_EP, &ep1config);
 800b9d0:	2101      	movs	r1, #1
 800b9d2:	4a08      	ldr	r2, [pc, #32]	; (800b9f4 <usb_event+0x34>)
 800b9d4:	f7f8 f984 	bl	8003ce0 <usbInitEndpointI>
    usbInitEndpointI(usbp, USBD1_INTERRUPT_REQUEST_EP, &ep2config);
 800b9d8:	4628      	mov	r0, r5
 800b9da:	4621      	mov	r1, r4
 800b9dc:	4a06      	ldr	r2, [pc, #24]	; (800b9f8 <usb_event+0x38>)
 800b9de:	f7f8 f97f 	bl	8003ce0 <usbInitEndpointI>

    /* Resetting the state of the CDC subsystem.*/
    sduConfigureHookI(&SDU1);
 800b9e2:	4806      	ldr	r0, [pc, #24]	; (800b9fc <usb_event+0x3c>)
 800b9e4:	f7f8 f85c 	bl	8003aa0 <sduConfigureHookI>
 800b9e8:	2300      	movs	r3, #0
 800b9ea:	f383 8811 	msr	BASEPRI, r3
 800b9ee:	bd38      	pop	{r3, r4, r5, pc}
 800b9f0:	4770      	bx	lr
 800b9f2:	bf00      	nop
 800b9f4:	0800e750 	.word	0x0800e750
 800b9f8:	0800e790 	.word	0x0800e790
 800b9fc:	20002bc0 	.word	0x20002bc0

0800ba00 <saveSettings>:
 * @brief  Starts saving all user defined settings to external EEPROM chip.
 * @return 1 - if write operation is successful;
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
 800ba00:	4a47      	ldr	r2, [pc, #284]	; (800bb20 <saveSettings+0x120>)
/**
 * @brief  Starts saving all user defined settings to external EEPROM chip.
 * @return 1 - if write operation is successful;
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
 800ba02:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
 800ba06:	4616      	mov	r6, r2
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
  memcpy((void *)paramsData.cfSettings, (void *)g_cfSettings, sizeof(g_cfSettings));
  memcpy((void *)paramsData.accelBias, (void *)g_IMU1.accelBias, sizeof(g_IMU1.accelBias));
 800ba08:	4f46      	ldr	r7, [pc, #280]	; (800bb24 <saveSettings+0x124>)
 * @retval 32-bit CRC
 */
static inline uint32_t crcCRC32(const uint32_t pBuf[], uint32_t length) {
  uint32_t i;
  /* Resets CRC generator. */
  CRC->CR = CRC_CR_RESET;
 800ba0a:	f8df 912c 	ldr.w	r9, [pc, #300]	; 800bb38 <saveSettings+0x138>
  memcpy((void *)paramsData.gyroBias, (void *)g_IMU1.gyroBias, sizeof(g_IMU1.gyroBias));
 800ba0e:	46be      	mov	lr, r7
  /* Calculates CRC32 checksum. */
  for(i = 0; i < length; i++) {
    CRC->DR = pBuf[i];
 800ba10:	464b      	mov	r3, r9
 * @brief  Starts saving all user defined settings to external EEPROM chip.
 * @return 1 - if write operation is successful;
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
 800ba12:	f8df a12c 	ldr.w	sl, [pc, #300]	; 800bb40 <saveSettings+0x140>
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
 800ba16:	4d44      	ldr	r5, [pc, #272]	; (800bb28 <saveSettings+0x128>)
 * @brief  Starts saving all user defined settings to external EEPROM chip.
 * @return 1 - if write operation is successful;
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
 800ba18:	f8da 0000 	ldr.w	r0, [sl]
 800ba1c:	f8da 1004 	ldr.w	r1, [sl, #4]
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
 800ba20:	4c42      	ldr	r4, [pc, #264]	; (800bb2c <saveSettings+0x12c>)
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
 800ba22:	f8d5 c000 	ldr.w	ip, [r5]
 * @brief  Starts saving all user defined settings to external EEPROM chip.
 * @return 1 - if write operation is successful;
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
 800ba26:	c603      	stmia	r6!, {r0, r1}
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
 800ba28:	f8df 8118 	ldr.w	r8, [pc, #280]	; 800bb44 <saveSettings+0x144>
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
 800ba2c:	6821      	ldr	r1, [r4, #0]
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
 800ba2e:	f8c2 c015 	str.w	ip, [r2, #21]
 * @brief  Starts saving all user defined settings to external EEPROM chip.
 * @return 1 - if write operation is successful;
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
 800ba32:	f89a c008 	ldrb.w	ip, [sl, #8]
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
 800ba36:	f8d8 b000 	ldr.w	fp, [r8]
 * @brief  Starts saving all user defined settings to external EEPROM chip.
 * @return 1 - if write operation is successful;
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
 800ba3a:	f886 c000 	strb.w	ip, [r6]
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
 800ba3e:	f8d8 a004 	ldr.w	sl, [r8, #4]
 800ba42:	f8d8 0008 	ldr.w	r0, [r8, #8]
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
 800ba46:	68ee      	ldr	r6, [r5, #12]
 800ba48:	f8d5 c010 	ldr.w	ip, [r5, #16]
 800ba4c:	f8d5 8004 	ldr.w	r8, [r5, #4]
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
 800ba50:	f8c2 102a 	str.w	r1, [r2, #42]	; 0x2a
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
 800ba54:	68a9      	ldr	r1, [r5, #8]
 800ba56:	7d2d      	ldrb	r5, [r5, #20]
/**
 * @brief  Starts saving all user defined settings to external EEPROM chip.
 * @return 1 - if write operation is successful;
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
 800ba58:	b083      	sub	sp, #12
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
 800ba5a:	9501      	str	r5, [sp, #4]
 * @return 1 - if write operation is successful;
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
 800ba5c:	f8c2 a00d 	str.w	sl, [r2, #13]
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
 800ba60:	6865      	ldr	r5, [r4, #4]
 800ba62:	f8d4 a008 	ldr.w	sl, [r4, #8]
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
 800ba66:	f8c2 101d 	str.w	r1, [r2, #29]
 800ba6a:	f89d 1004 	ldrb.w	r1, [sp, #4]
 * @return 1 - if write operation is successful;
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
 800ba6e:	f8c2 b009 	str.w	fp, [r2, #9]
 800ba72:	f8c2 0011 	str.w	r0, [r2, #17]
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
 800ba76:	f8d4 b00c 	ldr.w	fp, [r4, #12]
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
 800ba7a:	482d      	ldr	r0, [pc, #180]	; (800bb30 <saveSettings+0x130>)
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
 800ba7c:	f8c2 6021 	str.w	r6, [r2, #33]	; 0x21
 800ba80:	f8c2 c025 	str.w	ip, [r2, #37]	; 0x25
 800ba84:	f882 1029 	strb.w	r1, [r2, #41]	; 0x29
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
 800ba88:	f8c2 502e 	str.w	r5, [r2, #46]	; 0x2e
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
  memcpy((void *)paramsData.cfSettings, (void *)g_cfSettings, sizeof(g_cfSettings));
 800ba8c:	4e29      	ldr	r6, [pc, #164]	; (800bb34 <saveSettings+0x134>)
 *         0 - if write operation fails.
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
 800ba8e:	f8c2 8019 	str.w	r8, [r2, #25]
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
 800ba92:	f8c2 a032 	str.w	sl, [r2, #50]	; 0x32
 800ba96:	6921      	ldr	r1, [r4, #16]
 800ba98:	6965      	ldr	r5, [r4, #20]
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
  memcpy((void *)paramsData.cfSettings, (void *)g_cfSettings, sizeof(g_cfSettings));
  memcpy((void *)paramsData.accelBias, (void *)g_IMU1.accelBias, sizeof(g_IMU1.accelBias));
  memcpy((void *)paramsData.gyroBias, (void *)g_IMU1.gyroBias, sizeof(g_IMU1.gyroBias));
 800ba9a:	f85e 4f0c 	ldr.w	r4, [lr, #12]!
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
 800ba9e:	f8c2 b036 	str.w	fp, [r2, #54]	; 0x36
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
 800baa2:	f8b0 b000 	ldrh.w	fp, [r0]
 800baa6:	f890 a002 	ldrb.w	sl, [r0, #2]
  memcpy((void *)paramsData.cfSettings, (void *)g_cfSettings, sizeof(g_cfSettings));
 800baaa:	f8d6 c000 	ldr.w	ip, [r6]
  memcpy((void *)paramsData.accelBias, (void *)g_IMU1.accelBias, sizeof(g_IMU1.accelBias));
  memcpy((void *)paramsData.gyroBias, (void *)g_IMU1.gyroBias, sizeof(g_IMU1.gyroBias));
 800baae:	f8de 0004 	ldr.w	r0, [lr, #4]
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
  memcpy((void *)paramsData.cfSettings, (void *)g_cfSettings, sizeof(g_cfSettings));
  memcpy((void *)paramsData.accelBias, (void *)g_IMU1.accelBias, sizeof(g_IMU1.accelBias));
 800bab2:	683e      	ldr	r6, [r7, #0]
  memcpy((void *)paramsData.gyroBias, (void *)g_IMU1.gyroBias, sizeof(g_IMU1.gyroBias));
 800bab4:	f8de e008 	ldr.w	lr, [lr, #8]
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
 800bab8:	f8c2 103a 	str.w	r1, [r2, #58]	; 0x3a
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
  memcpy((void *)paramsData.cfSettings, (void *)g_cfSettings, sizeof(g_cfSettings));
  memcpy((void *)paramsData.accelBias, (void *)g_IMU1.accelBias, sizeof(g_IMU1.accelBias));
 800babc:	6879      	ldr	r1, [r7, #4]
 800babe:	68bf      	ldr	r7, [r7, #8]
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
 800bac0:	f8a2 b042 	strh.w	fp, [r2, #66]	; 0x42
 * @retval 32-bit CRC
 */
static inline uint32_t crcCRC32(const uint32_t pBuf[], uint32_t length) {
  uint32_t i;
  /* Resets CRC generator. */
  CRC->CR = CRC_CR_RESET;
 800bac4:	f04f 0b01 	mov.w	fp, #1
 */
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
 800bac8:	f8c2 503e 	str.w	r5, [r2, #62]	; 0x3e
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
  memcpy((void *)paramsData.cfSettings, (void *)g_cfSettings, sizeof(g_cfSettings));
  memcpy((void *)paramsData.accelBias, (void *)g_IMU1.accelBias, sizeof(g_IMU1.accelBias));
 800bacc:	f8c2 104d 	str.w	r1, [r2, #77]	; 0x4d
uint8_t saveSettings(void) {
  memcpy((void *)paramsData.pidSettings, (void *)g_pidSettings, sizeof(g_pidSettings));
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
 800bad0:	f882 a044 	strb.w	sl, [r2, #68]	; 0x44
  memcpy((void *)paramsData.cfSettings, (void *)g_cfSettings, sizeof(g_cfSettings));
 800bad4:	f8c2 c045 	str.w	ip, [r2, #69]	; 0x45
  memcpy((void *)paramsData.accelBias, (void *)g_IMU1.accelBias, sizeof(g_IMU1.accelBias));
 800bad8:	f8c2 6049 	str.w	r6, [r2, #73]	; 0x49
  memcpy((void *)paramsData.gyroBias, (void *)g_IMU1.gyroBias, sizeof(g_IMU1.gyroBias));
 800badc:	f8c2 4055 	str.w	r4, [r2, #85]	; 0x55
 800bae0:	f8c2 0059 	str.w	r0, [r2, #89]	; 0x59
 800bae4:	f8c2 e05d 	str.w	lr, [r2, #93]	; 0x5d
  memcpy((void *)paramsData.pwmOutput, (void *)g_pwmOutput, sizeof(g_pwmOutput));
  memcpy((void *)paramsData.mixedInput, (void *)g_mixedInput, sizeof(g_mixedInput));
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
  memcpy((void *)paramsData.cfSettings, (void *)g_cfSettings, sizeof(g_cfSettings));
  memcpy((void *)paramsData.accelBias, (void *)g_IMU1.accelBias, sizeof(g_IMU1.accelBias));
 800bae8:	f8c2 7051 	str.w	r7, [r2, #81]	; 0x51
 800baec:	1f11      	subs	r1, r2, #4
 800baee:	f102 055c 	add.w	r5, r2, #92	; 0x5c
 800baf2:	f8c9 b008 	str.w	fp, [r9, #8]
  /* Calculates CRC32 checksum. */
  for(i = 0; i < length; i++) {
    CRC->DR = pBuf[i];
 800baf6:	f851 0f04 	ldr.w	r0, [r1, #4]!
 800bafa:	4c0f      	ldr	r4, [pc, #60]	; (800bb38 <saveSettings+0x138>)
static inline uint32_t crcCRC32(const uint32_t pBuf[], uint32_t length) {
  uint32_t i;
  /* Resets CRC generator. */
  CRC->CR = CRC_CR_RESET;
  /* Calculates CRC32 checksum. */
  for(i = 0; i < length; i++) {
 800bafc:	42a9      	cmp	r1, r5
    CRC->DR = pBuf[i];
 800bafe:	6018      	str	r0, [r3, #0]
static inline uint32_t crcCRC32(const uint32_t pBuf[], uint32_t length) {
  uint32_t i;
  /* Resets CRC generator. */
  CRC->CR = CRC_CR_RESET;
  /* Calculates CRC32 checksum. */
  for(i = 0; i < length; i++) {
 800bb00:	d1f9      	bne.n	800baf6 <saveSettings+0xf6>
    CRC->DR = pBuf[i];
  }
  return CRC->DR;
 800bb02:	6823      	ldr	r3, [r4, #0]
  memcpy((void *)paramsData.gyroBias, (void *)g_IMU1.gyroBias, sizeof(g_IMU1.gyroBias));
  paramsData.crc32 = crcCRC32((uint32_t *)&paramsData, sizeof(paramsData) / sizeof(uint32_t) - 1);

  flashPageErase(FLASH_PARAMS_PAGE);
 800bb04:	207d      	movs	r0, #125	; 0x7d
  memcpy((void *)paramsData.modeSettings, (void *)g_modeSettings, sizeof(g_modeSettings));
  memcpy((void *)paramsData.sensorSettings, (void *)g_sensorSettings, sizeof(g_sensorSettings));
  memcpy((void *)paramsData.cfSettings, (void *)g_cfSettings, sizeof(g_cfSettings));
  memcpy((void *)paramsData.accelBias, (void *)g_IMU1.accelBias, sizeof(g_IMU1.accelBias));
  memcpy((void *)paramsData.gyroBias, (void *)g_IMU1.gyroBias, sizeof(g_IMU1.gyroBias));
  paramsData.crc32 = crcCRC32((uint32_t *)&paramsData, sizeof(paramsData) / sizeof(uint32_t) - 1);
 800bb06:	f8c2 3061 	str.w	r3, [r2, #97]	; 0x61

  flashPageErase(FLASH_PARAMS_PAGE);
 800bb0a:	f7fe f901 	bl	8009d10 <flashPageErase>
  return flashWrite((flashaddr_t) FLASH_ADDRESS_OF_PAGE(FLASH_PARAMS_PAGE), (char*) &paramsData, sizeof(paramsData));
 800bb0e:	4904      	ldr	r1, [pc, #16]	; (800bb20 <saveSettings+0x120>)
 800bb10:	2265      	movs	r2, #101	; 0x65
 800bb12:	480a      	ldr	r0, [pc, #40]	; (800bb3c <saveSettings+0x13c>)
 800bb14:	f7fe f94c 	bl	8009db0 <flashWrite>
}
 800bb18:	b2c0      	uxtb	r0, r0
 800bb1a:	b003      	add	sp, #12
 800bb1c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800bb20:	20003068 	.word	0x20003068
 800bb24:	20002ad4 	.word	0x20002ad4
 800bb28:	20000814 	.word	0x20000814
 800bb2c:	20000908 	.word	0x20000908
 800bb30:	20000d28 	.word	0x20000d28
 800bb34:	20000900 	.word	0x20000900
 800bb38:	40023000 	.word	0x40023000
 800bb3c:	0803e800 	.word	0x0803e800
 800bb40:	20001db8 	.word	0x20001db8
 800bb44:	20000808 	.word	0x20000808
	...

0800bb50 <loadSettings>:
/**
 * @brief  Loads all user defined settings from external EEPROM chip.
 * @return 1 - if write operation is successful;
 *         0 - if write operation fails.
 */
uint8_t loadSettings(void) {
 800bb50:	b570      	push	{r4, r5, r6, lr}

  memcpy((void *)&paramsData, (void *)FLASH_ADDRESS_OF_PAGE(FLASH_PARAMS_PAGE), sizeof(paramsData));
 800bb52:	4c1c      	ldr	r4, [pc, #112]	; (800bbc4 <loadSettings+0x74>)
 800bb54:	491c      	ldr	r1, [pc, #112]	; (800bbc8 <loadSettings+0x78>)
 800bb56:	2265      	movs	r2, #101	; 0x65
 800bb58:	4620      	mov	r0, r4
 800bb5a:	f7f5 fb71 	bl	8001240 <memcpy>
 * @retval 32-bit CRC
 */
static inline uint32_t crcCRC32(const uint32_t pBuf[], uint32_t length) {
  uint32_t i;
  /* Resets CRC generator. */
  CRC->CR = CRC_CR_RESET;
 800bb5e:	4a1b      	ldr	r2, [pc, #108]	; (800bbcc <loadSettings+0x7c>)
 800bb60:	2001      	movs	r0, #1
  /* Calculates CRC32 checksum. */
  for(i = 0; i < length; i++) {
    CRC->DR = pBuf[i];
 800bb62:	4615      	mov	r5, r2

  if (paramsData.crc32 != crcCRC32((uint32_t *)&paramsData, sizeof(paramsData) / sizeof(uint32_t) - 1)) {
 800bb64:	f8d4 6061 	ldr.w	r6, [r4, #97]	; 0x61
 800bb68:	1f23      	subs	r3, r4, #4
 800bb6a:	f104 015c 	add.w	r1, r4, #92	; 0x5c
 * @retval 32-bit CRC
 */
static inline uint32_t crcCRC32(const uint32_t pBuf[], uint32_t length) {
  uint32_t i;
  /* Resets CRC generator. */
  CRC->CR = CRC_CR_RESET;
 800bb6e:	6090      	str	r0, [r2, #8]
  /* Calculates CRC32 checksum. */
  for(i = 0; i < length; i++) {
    CRC->DR = pBuf[i];
 800bb70:	f853 2f04 	ldr.w	r2, [r3, #4]!
 800bb74:	4815      	ldr	r0, [pc, #84]	; (800bbcc <loadSettings+0x7c>)
static inline uint32_t crcCRC32(const uint32_t pBuf[], uint32_t length) {
  uint32_t i;
  /* Resets CRC generator. */
  CRC->CR = CRC_CR_RESET;
  /* Calculates CRC32 checksum. */
  for(i = 0; i < length; i++) {
 800bb76:	428b      	cmp	r3, r1
    CRC->DR = pBuf[i];
 800bb78:	602a      	str	r2, [r5, #0]
static inline uint32_t crcCRC32(const uint32_t pBuf[], uint32_t length) {
  uint32_t i;
  /* Resets CRC generator. */
  CRC->CR = CRC_CR_RESET;
  /* Calculates CRC32 checksum. */
  for(i = 0; i < length; i++) {
 800bb7a:	d1f9      	bne.n	800bb70 <loadSettings+0x20>
    CRC->DR = pBuf[i];
  }
  return CRC->DR;
 800bb7c:	6803      	ldr	r3, [r0, #0]
 800bb7e:	429e      	cmp	r6, r3
 800bb80:	d003      	beq.n	800bb8a <loadSettings+0x3a>
    accelBiasUpdate(&g_IMU1, paramsData.accelBias);
    gyroBiasUpdate(&g_IMU1, paramsData.gyroBias);
  }

  return 1;
}
 800bb82:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  memcpy((void *)&paramsData, (void *)FLASH_ADDRESS_OF_PAGE(FLASH_PARAMS_PAGE), sizeof(paramsData));

  if (paramsData.crc32 != crcCRC32((uint32_t *)&paramsData, sizeof(paramsData) / sizeof(uint32_t) - 1)) {
    /* Fill with default settings. */
    return saveSettings();
 800bb86:	f7ff bf3b 	b.w	800ba00 <saveSettings>
  } else {
    pidSettingsUpdate(paramsData.pidSettings);
 800bb8a:	480e      	ldr	r0, [pc, #56]	; (800bbc4 <loadSettings+0x74>)
 800bb8c:	f7ff f898 	bl	800acc0 <pidSettingsUpdate>
    pwmOutputSettingsUpdate(paramsData.pwmOutput);
 800bb90:	480f      	ldr	r0, [pc, #60]	; (800bbd0 <loadSettings+0x80>)
 800bb92:	f7fa f865 	bl	8005c60 <pwmOutputSettingsUpdate>
    mixedInputSettingsUpdate(paramsData.mixedInput);
 800bb96:	480f      	ldr	r0, [pc, #60]	; (800bbd4 <loadSettings+0x84>)
 800bb98:	f7fa f872 	bl	8005c80 <mixedInputSettingsUpdate>
    inputModeSettingsUpdate(paramsData.modeSettings);
 800bb9c:	480e      	ldr	r0, [pc, #56]	; (800bbd8 <loadSettings+0x88>)
 800bb9e:	f7ff f89f 	bl	800ace0 <inputModeSettingsUpdate>
    sensorSettingsUpdate(paramsData.sensorSettings);
 800bba2:	480e      	ldr	r0, [pc, #56]	; (800bbdc <loadSettings+0x8c>)
 800bba4:	f7ff fe9c 	bl	800b8e0 <sensorSettingsUpdate>
    cfSettingsUpdate(paramsData.cfSettings);
 800bba8:	480d      	ldr	r0, [pc, #52]	; (800bbe0 <loadSettings+0x90>)
 800bbaa:	f7ff f8a9 	bl	800ad00 <cfSettingsUpdate>
    accelBiasUpdate(&g_IMU1, paramsData.accelBias);
 800bbae:	480d      	ldr	r0, [pc, #52]	; (800bbe4 <loadSettings+0x94>)
 800bbb0:	490d      	ldr	r1, [pc, #52]	; (800bbe8 <loadSettings+0x98>)
 800bbb2:	f7ff feb5 	bl	800b920 <accelBiasUpdate>
    gyroBiasUpdate(&g_IMU1, paramsData.gyroBias);
 800bbb6:	480b      	ldr	r0, [pc, #44]	; (800bbe4 <loadSettings+0x94>)
 800bbb8:	490c      	ldr	r1, [pc, #48]	; (800bbec <loadSettings+0x9c>)
 800bbba:	f7ff fec1 	bl	800b940 <gyroBiasUpdate>
  }

  return 1;
}
 800bbbe:	2001      	movs	r0, #1
 800bbc0:	bd70      	pop	{r4, r5, r6, pc}
 800bbc2:	bf00      	nop
 800bbc4:	20003068 	.word	0x20003068
 800bbc8:	0803e800 	.word	0x0803e800
 800bbcc:	40023000 	.word	0x40023000
 800bbd0:	20003071 	.word	0x20003071
 800bbd4:	2000307d 	.word	0x2000307d
 800bbd8:	20003092 	.word	0x20003092
 800bbdc:	200030aa 	.word	0x200030aa
 800bbe0:	200030ad 	.word	0x200030ad
 800bbe4:	20002abc 	.word	0x20002abc
 800bbe8:	200030b1 	.word	0x200030b1
 800bbec:	200030bd 	.word	0x200030bd

0800bbf0 <sinf>:
 800bbf0:	b500      	push	{lr}
 800bbf2:	4a1d      	ldr	r2, [pc, #116]	; (800bc68 <sinf+0x78>)
 800bbf4:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
 800bbf8:	4293      	cmp	r3, r2
 800bbfa:	b083      	sub	sp, #12
 800bbfc:	4601      	mov	r1, r0
 800bbfe:	dd18      	ble.n	800bc32 <sinf+0x42>
 800bc00:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 800bc04:	db04      	blt.n	800bc10 <sinf+0x20>
 800bc06:	f7f4 ffff 	bl	8000c08 <__aeabi_fsub>
 800bc0a:	b003      	add	sp, #12
 800bc0c:	f85d fb04 	ldr.w	pc, [sp], #4
 800bc10:	4669      	mov	r1, sp
 800bc12:	f000 fb4d 	bl	800c2b0 <__ieee754_rem_pio2f>
 800bc16:	f000 0003 	and.w	r0, r0, #3
 800bc1a:	2801      	cmp	r0, #1
 800bc1c:	d018      	beq.n	800bc50 <sinf+0x60>
 800bc1e:	2802      	cmp	r0, #2
 800bc20:	d00e      	beq.n	800bc40 <sinf+0x50>
 800bc22:	b1d0      	cbz	r0, 800bc5a <sinf+0x6a>
 800bc24:	9800      	ldr	r0, [sp, #0]
 800bc26:	9901      	ldr	r1, [sp, #4]
 800bc28:	f000 fd12 	bl	800c650 <__kernel_cosf>
 800bc2c:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 800bc30:	e7eb      	b.n	800bc0a <sinf+0x1a>
 800bc32:	2100      	movs	r1, #0
 800bc34:	2200      	movs	r2, #0
 800bc36:	f001 f913 	bl	800ce60 <__kernel_sinf>
 800bc3a:	b003      	add	sp, #12
 800bc3c:	f85d fb04 	ldr.w	pc, [sp], #4
 800bc40:	9800      	ldr	r0, [sp, #0]
 800bc42:	9901      	ldr	r1, [sp, #4]
 800bc44:	2201      	movs	r2, #1
 800bc46:	f001 f90b 	bl	800ce60 <__kernel_sinf>
 800bc4a:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 800bc4e:	e7dc      	b.n	800bc0a <sinf+0x1a>
 800bc50:	9800      	ldr	r0, [sp, #0]
 800bc52:	9901      	ldr	r1, [sp, #4]
 800bc54:	f000 fcfc 	bl	800c650 <__kernel_cosf>
 800bc58:	e7d7      	b.n	800bc0a <sinf+0x1a>
 800bc5a:	9800      	ldr	r0, [sp, #0]
 800bc5c:	9901      	ldr	r1, [sp, #4]
 800bc5e:	2201      	movs	r2, #1
 800bc60:	f001 f8fe 	bl	800ce60 <__kernel_sinf>
 800bc64:	e7d1      	b.n	800bc0a <sinf+0x1a>
 800bc66:	bf00      	nop
 800bc68:	3f490fd8 	.word	0x3f490fd8
 800bc6c:	00000000 	.word	0x00000000

0800bc70 <asinf>:
 800bc70:	b570      	push	{r4, r5, r6, lr}
 800bc72:	b08a      	sub	sp, #40	; 0x28
 800bc74:	4606      	mov	r6, r0
 800bc76:	f000 f8b3 	bl	800bde0 <__ieee754_asinf>
 800bc7a:	4d22      	ldr	r5, [pc, #136]	; (800bd04 <asinf+0x94>)
 800bc7c:	4604      	mov	r4, r0
 800bc7e:	f995 3000 	ldrsb.w	r3, [r5]
 800bc82:	3301      	adds	r3, #1
 800bc84:	d003      	beq.n	800bc8e <asinf+0x1e>
 800bc86:	4630      	mov	r0, r6
 800bc88:	f001 fada 	bl	800d240 <__fpclassifyf>
 800bc8c:	b910      	cbnz	r0, 800bc94 <asinf+0x24>
 800bc8e:	4620      	mov	r0, r4
 800bc90:	b00a      	add	sp, #40	; 0x28
 800bc92:	bd70      	pop	{r4, r5, r6, pc}
 800bc94:	4630      	mov	r0, r6
 800bc96:	f001 fa83 	bl	800d1a0 <fabsf>
 800bc9a:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800bc9e:	f7f5 fa7b 	bl	8001198 <__aeabi_fcmpgt>
 800bca2:	2800      	cmp	r0, #0
 800bca4:	d0f3      	beq.n	800bc8e <asinf+0x1e>
 800bca6:	4918      	ldr	r1, [pc, #96]	; (800bd08 <asinf+0x98>)
 800bca8:	2201      	movs	r2, #1
 800bcaa:	2300      	movs	r3, #0
 800bcac:	4630      	mov	r0, r6
 800bcae:	9200      	str	r2, [sp, #0]
 800bcb0:	9308      	str	r3, [sp, #32]
 800bcb2:	9101      	str	r1, [sp, #4]
 800bcb4:	f7f4 fc38 	bl	8000528 <__aeabi_f2d>
 800bcb8:	4602      	mov	r2, r0
 800bcba:	460b      	mov	r3, r1
 800bcbc:	4813      	ldr	r0, [pc, #76]	; (800bd0c <asinf+0x9c>)
 800bcbe:	e9cd 2304 	strd	r2, r3, [sp, #16]
 800bcc2:	e9cd 2302 	strd	r2, r3, [sp, #8]
 800bcc6:	f001 f94b 	bl	800cf60 <nan>
 800bcca:	f995 3000 	ldrsb.w	r3, [r5]
 800bcce:	e9cd 0106 	strd	r0, r1, [sp, #24]
 800bcd2:	2b02      	cmp	r3, #2
 800bcd4:	d00b      	beq.n	800bcee <asinf+0x7e>
 800bcd6:	4668      	mov	r0, sp
 800bcd8:	f001 f93a 	bl	800cf50 <matherr>
 800bcdc:	b138      	cbz	r0, 800bcee <asinf+0x7e>
 800bcde:	9b08      	ldr	r3, [sp, #32]
 800bce0:	b953      	cbnz	r3, 800bcf8 <asinf+0x88>
 800bce2:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 800bce6:	f7f4 ff3b 	bl	8000b60 <__aeabi_d2f>
 800bcea:	b00a      	add	sp, #40	; 0x28
 800bcec:	bd70      	pop	{r4, r5, r6, pc}
 800bcee:	f001 fb27 	bl	800d340 <__errno>
 800bcf2:	2321      	movs	r3, #33	; 0x21
 800bcf4:	6003      	str	r3, [r0, #0]
 800bcf6:	e7f2      	b.n	800bcde <asinf+0x6e>
 800bcf8:	f001 fb22 	bl	800d340 <__errno>
 800bcfc:	9b08      	ldr	r3, [sp, #32]
 800bcfe:	6003      	str	r3, [r0, #0]
 800bd00:	e7ef      	b.n	800bce2 <asinf+0x72>
 800bd02:	bf00      	nop
 800bd04:	20000d2b 	.word	0x20000d2b
 800bd08:	0800e910 	.word	0x0800e910
 800bd0c:	0800e534 	.word	0x0800e534

0800bd10 <atan2f>:
 800bd10:	f000 b9b6 	b.w	800c080 <__ieee754_atan2f>
	...

0800bd20 <fmodf>:
 800bd20:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800bd24:	b08b      	sub	sp, #44	; 0x2c
 800bd26:	4607      	mov	r7, r0
 800bd28:	460e      	mov	r6, r1
 800bd2a:	f000 fa39 	bl	800c1a0 <__ieee754_fmodf>
 800bd2e:	4d27      	ldr	r5, [pc, #156]	; (800bdcc <fmodf+0xac>)
 800bd30:	4604      	mov	r4, r0
 800bd32:	f995 3000 	ldrsb.w	r3, [r5]
 800bd36:	3301      	adds	r3, #1
 800bd38:	d003      	beq.n	800bd42 <fmodf+0x22>
 800bd3a:	4630      	mov	r0, r6
 800bd3c:	f001 fa80 	bl	800d240 <__fpclassifyf>
 800bd40:	b918      	cbnz	r0, 800bd4a <fmodf+0x2a>
 800bd42:	4620      	mov	r0, r4
 800bd44:	b00b      	add	sp, #44	; 0x2c
 800bd46:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800bd4a:	4638      	mov	r0, r7
 800bd4c:	f001 fa78 	bl	800d240 <__fpclassifyf>
 800bd50:	2800      	cmp	r0, #0
 800bd52:	d0f6      	beq.n	800bd42 <fmodf+0x22>
 800bd54:	4630      	mov	r0, r6
 800bd56:	2100      	movs	r1, #0
 800bd58:	f7f5 f9f6 	bl	8001148 <__aeabi_fcmpeq>
 800bd5c:	2800      	cmp	r0, #0
 800bd5e:	d0f0      	beq.n	800bd42 <fmodf+0x22>
 800bd60:	491b      	ldr	r1, [pc, #108]	; (800bdd0 <fmodf+0xb0>)
 800bd62:	2201      	movs	r2, #1
 800bd64:	2300      	movs	r3, #0
 800bd66:	4638      	mov	r0, r7
 800bd68:	9200      	str	r2, [sp, #0]
 800bd6a:	9308      	str	r3, [sp, #32]
 800bd6c:	9101      	str	r1, [sp, #4]
 800bd6e:	f7f4 fbdb 	bl	8000528 <__aeabi_f2d>
 800bd72:	4680      	mov	r8, r0
 800bd74:	4689      	mov	r9, r1
 800bd76:	4630      	mov	r0, r6
 800bd78:	e9cd 8902 	strd	r8, r9, [sp, #8]
 800bd7c:	f7f4 fbd4 	bl	8000528 <__aeabi_f2d>
 800bd80:	782c      	ldrb	r4, [r5, #0]
 800bd82:	e9cd 0104 	strd	r0, r1, [sp, #16]
 800bd86:	b1a4      	cbz	r4, 800bdb2 <fmodf+0x92>
 800bd88:	2000      	movs	r0, #0
 800bd8a:	2100      	movs	r1, #0
 800bd8c:	4602      	mov	r2, r0
 800bd8e:	460b      	mov	r3, r1
 800bd90:	f7f4 fd48 	bl	8000824 <__aeabi_ddiv>
 800bd94:	2c02      	cmp	r4, #2
 800bd96:	e9cd 0106 	strd	r0, r1, [sp, #24]
 800bd9a:	d10c      	bne.n	800bdb6 <fmodf+0x96>
 800bd9c:	f001 fad0 	bl	800d340 <__errno>
 800bda0:	2321      	movs	r3, #33	; 0x21
 800bda2:	6003      	str	r3, [r0, #0]
 800bda4:	9b08      	ldr	r3, [sp, #32]
 800bda6:	b963      	cbnz	r3, 800bdc2 <fmodf+0xa2>
 800bda8:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 800bdac:	f7f4 fed8 	bl	8000b60 <__aeabi_d2f>
 800bdb0:	e7c8      	b.n	800bd44 <fmodf+0x24>
 800bdb2:	e9cd 8906 	strd	r8, r9, [sp, #24]
 800bdb6:	4668      	mov	r0, sp
 800bdb8:	f001 f8ca 	bl	800cf50 <matherr>
 800bdbc:	2800      	cmp	r0, #0
 800bdbe:	d1f1      	bne.n	800bda4 <fmodf+0x84>
 800bdc0:	e7ec      	b.n	800bd9c <fmodf+0x7c>
 800bdc2:	f001 fabd 	bl	800d340 <__errno>
 800bdc6:	9b08      	ldr	r3, [sp, #32]
 800bdc8:	6003      	str	r3, [r0, #0]
 800bdca:	e7ed      	b.n	800bda8 <fmodf+0x88>
 800bdcc:	20000d2b 	.word	0x20000d2b
 800bdd0:	0800e920 	.word	0x0800e920
	...

0800bde0 <__ieee754_asinf>:
 800bde0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800bde4:	f020 4500 	bic.w	r5, r0, #2147483648	; 0x80000000
 800bde8:	f1b5 5f7e 	cmp.w	r5, #1065353216	; 0x3f800000
 800bdec:	4604      	mov	r4, r0
 800bdee:	4606      	mov	r6, r0
 800bdf0:	f000 80c7 	beq.w	800bf82 <__ieee754_asinf+0x1a2>
 800bdf4:	dc11      	bgt.n	800be1a <__ieee754_asinf+0x3a>
 800bdf6:	f1b5 5f7c 	cmp.w	r5, #1056964608	; 0x3f000000
 800bdfa:	da16      	bge.n	800be2a <__ieee754_asinf+0x4a>
 800bdfc:	f1b5 5f48 	cmp.w	r5, #838860800	; 0x32000000
 800be00:	f280 80cd 	bge.w	800bf9e <__ieee754_asinf+0x1be>
 800be04:	498c      	ldr	r1, [pc, #560]	; (800c038 <__ieee754_asinf+0x258>)
 800be06:	f7f4 ff01 	bl	8000c0c <__addsf3>
 800be0a:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800be0e:	f7f5 f9c3 	bl	8001198 <__aeabi_fcmpgt>
 800be12:	b150      	cbz	r0, 800be2a <__ieee754_asinf+0x4a>
 800be14:	4620      	mov	r0, r4
 800be16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800be1a:	4601      	mov	r1, r0
 800be1c:	f7f4 fef4 	bl	8000c08 <__aeabi_fsub>
 800be20:	4601      	mov	r1, r0
 800be22:	f7f5 f8b1 	bl	8000f88 <__aeabi_fdiv>
 800be26:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800be2a:	4620      	mov	r0, r4
 800be2c:	f001 f9b8 	bl	800d1a0 <fabsf>
 800be30:	4601      	mov	r1, r0
 800be32:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800be36:	f7f4 fee7 	bl	8000c08 <__aeabi_fsub>
 800be3a:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800be3e:	f7f4 ffef 	bl	8000e20 <__aeabi_fmul>
 800be42:	4604      	mov	r4, r0
 800be44:	497d      	ldr	r1, [pc, #500]	; (800c03c <__ieee754_asinf+0x25c>)
 800be46:	f7f4 ffeb 	bl	8000e20 <__aeabi_fmul>
 800be4a:	497d      	ldr	r1, [pc, #500]	; (800c040 <__ieee754_asinf+0x260>)
 800be4c:	f7f4 fede 	bl	8000c0c <__addsf3>
 800be50:	4621      	mov	r1, r4
 800be52:	f7f4 ffe5 	bl	8000e20 <__aeabi_fmul>
 800be56:	497b      	ldr	r1, [pc, #492]	; (800c044 <__ieee754_asinf+0x264>)
 800be58:	f7f4 fed6 	bl	8000c08 <__aeabi_fsub>
 800be5c:	4621      	mov	r1, r4
 800be5e:	f7f4 ffdf 	bl	8000e20 <__aeabi_fmul>
 800be62:	4979      	ldr	r1, [pc, #484]	; (800c048 <__ieee754_asinf+0x268>)
 800be64:	f7f4 fed2 	bl	8000c0c <__addsf3>
 800be68:	4621      	mov	r1, r4
 800be6a:	f7f4 ffd9 	bl	8000e20 <__aeabi_fmul>
 800be6e:	4977      	ldr	r1, [pc, #476]	; (800c04c <__ieee754_asinf+0x26c>)
 800be70:	f7f4 feca 	bl	8000c08 <__aeabi_fsub>
 800be74:	4621      	mov	r1, r4
 800be76:	f7f4 ffd3 	bl	8000e20 <__aeabi_fmul>
 800be7a:	4975      	ldr	r1, [pc, #468]	; (800c050 <__ieee754_asinf+0x270>)
 800be7c:	f7f4 fec6 	bl	8000c0c <__addsf3>
 800be80:	4621      	mov	r1, r4
 800be82:	f7f4 ffcd 	bl	8000e20 <__aeabi_fmul>
 800be86:	4973      	ldr	r1, [pc, #460]	; (800c054 <__ieee754_asinf+0x274>)
 800be88:	4681      	mov	r9, r0
 800be8a:	4620      	mov	r0, r4
 800be8c:	f7f4 ffc8 	bl	8000e20 <__aeabi_fmul>
 800be90:	4971      	ldr	r1, [pc, #452]	; (800c058 <__ieee754_asinf+0x278>)
 800be92:	f7f4 feb9 	bl	8000c08 <__aeabi_fsub>
 800be96:	4621      	mov	r1, r4
 800be98:	f7f4 ffc2 	bl	8000e20 <__aeabi_fmul>
 800be9c:	496f      	ldr	r1, [pc, #444]	; (800c05c <__ieee754_asinf+0x27c>)
 800be9e:	f7f4 feb5 	bl	8000c0c <__addsf3>
 800bea2:	4621      	mov	r1, r4
 800bea4:	f7f4 ffbc 	bl	8000e20 <__aeabi_fmul>
 800bea8:	496d      	ldr	r1, [pc, #436]	; (800c060 <__ieee754_asinf+0x280>)
 800beaa:	f7f4 fead 	bl	8000c08 <__aeabi_fsub>
 800beae:	4621      	mov	r1, r4
 800beb0:	f7f4 ffb6 	bl	8000e20 <__aeabi_fmul>
 800beb4:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800beb8:	f7f4 fea8 	bl	8000c0c <__addsf3>
 800bebc:	4680      	mov	r8, r0
 800bebe:	4620      	mov	r0, r4
 800bec0:	f000 fb6e 	bl	800c5a0 <__ieee754_sqrtf>
 800bec4:	4b67      	ldr	r3, [pc, #412]	; (800c064 <__ieee754_asinf+0x284>)
 800bec6:	4607      	mov	r7, r0
 800bec8:	429d      	cmp	r5, r3
 800beca:	dc44      	bgt.n	800bf56 <__ieee754_asinf+0x176>
 800becc:	4601      	mov	r1, r0
 800bece:	f7f4 fe9d 	bl	8000c0c <__addsf3>
 800bed2:	4641      	mov	r1, r8
 800bed4:	4682      	mov	sl, r0
 800bed6:	4648      	mov	r0, r9
 800bed8:	f7f5 f856 	bl	8000f88 <__aeabi_fdiv>
 800bedc:	4601      	mov	r1, r0
 800bede:	4650      	mov	r0, sl
 800bee0:	f7f4 ff9e 	bl	8000e20 <__aeabi_fmul>
 800bee4:	f427 657f 	bic.w	r5, r7, #4080	; 0xff0
 800bee8:	f025 050f 	bic.w	r5, r5, #15
 800beec:	4680      	mov	r8, r0
 800beee:	4629      	mov	r1, r5
 800bef0:	4628      	mov	r0, r5
 800bef2:	f7f4 ff95 	bl	8000e20 <__aeabi_fmul>
 800bef6:	4601      	mov	r1, r0
 800bef8:	4620      	mov	r0, r4
 800befa:	f7f4 fe85 	bl	8000c08 <__aeabi_fsub>
 800befe:	4629      	mov	r1, r5
 800bf00:	4604      	mov	r4, r0
 800bf02:	4638      	mov	r0, r7
 800bf04:	f7f4 fe82 	bl	8000c0c <__addsf3>
 800bf08:	4601      	mov	r1, r0
 800bf0a:	4620      	mov	r0, r4
 800bf0c:	f7f5 f83c 	bl	8000f88 <__aeabi_fdiv>
 800bf10:	4601      	mov	r1, r0
 800bf12:	f7f4 fe7b 	bl	8000c0c <__addsf3>
 800bf16:	4601      	mov	r1, r0
 800bf18:	4853      	ldr	r0, [pc, #332]	; (800c068 <__ieee754_asinf+0x288>)
 800bf1a:	f7f4 fe75 	bl	8000c08 <__aeabi_fsub>
 800bf1e:	4601      	mov	r1, r0
 800bf20:	4640      	mov	r0, r8
 800bf22:	f7f4 fe71 	bl	8000c08 <__aeabi_fsub>
 800bf26:	4629      	mov	r1, r5
 800bf28:	4604      	mov	r4, r0
 800bf2a:	4628      	mov	r0, r5
 800bf2c:	f7f4 fe6e 	bl	8000c0c <__addsf3>
 800bf30:	4601      	mov	r1, r0
 800bf32:	484e      	ldr	r0, [pc, #312]	; (800c06c <__ieee754_asinf+0x28c>)
 800bf34:	f7f4 fe68 	bl	8000c08 <__aeabi_fsub>
 800bf38:	4601      	mov	r1, r0
 800bf3a:	4620      	mov	r0, r4
 800bf3c:	f7f4 fe64 	bl	8000c08 <__aeabi_fsub>
 800bf40:	4601      	mov	r1, r0
 800bf42:	484a      	ldr	r0, [pc, #296]	; (800c06c <__ieee754_asinf+0x28c>)
 800bf44:	f7f4 fe60 	bl	8000c08 <__aeabi_fsub>
 800bf48:	2e00      	cmp	r6, #0
 800bf4a:	f73f af64 	bgt.w	800be16 <__ieee754_asinf+0x36>
 800bf4e:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 800bf52:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800bf56:	4641      	mov	r1, r8
 800bf58:	4648      	mov	r0, r9
 800bf5a:	f7f5 f815 	bl	8000f88 <__aeabi_fdiv>
 800bf5e:	4601      	mov	r1, r0
 800bf60:	4638      	mov	r0, r7
 800bf62:	f7f4 ff5d 	bl	8000e20 <__aeabi_fmul>
 800bf66:	4639      	mov	r1, r7
 800bf68:	f7f4 fe50 	bl	8000c0c <__addsf3>
 800bf6c:	4601      	mov	r1, r0
 800bf6e:	f7f4 fe4d 	bl	8000c0c <__addsf3>
 800bf72:	493f      	ldr	r1, [pc, #252]	; (800c070 <__ieee754_asinf+0x290>)
 800bf74:	f7f4 fe4a 	bl	8000c0c <__addsf3>
 800bf78:	4601      	mov	r1, r0
 800bf7a:	483e      	ldr	r0, [pc, #248]	; (800c074 <__ieee754_asinf+0x294>)
 800bf7c:	f7f4 fe44 	bl	8000c08 <__aeabi_fsub>
 800bf80:	e7e2      	b.n	800bf48 <__ieee754_asinf+0x168>
 800bf82:	493c      	ldr	r1, [pc, #240]	; (800c074 <__ieee754_asinf+0x294>)
 800bf84:	f7f4 ff4c 	bl	8000e20 <__aeabi_fmul>
 800bf88:	4937      	ldr	r1, [pc, #220]	; (800c068 <__ieee754_asinf+0x288>)
 800bf8a:	4605      	mov	r5, r0
 800bf8c:	4620      	mov	r0, r4
 800bf8e:	f7f4 ff47 	bl	8000e20 <__aeabi_fmul>
 800bf92:	4601      	mov	r1, r0
 800bf94:	4628      	mov	r0, r5
 800bf96:	f7f4 fe39 	bl	8000c0c <__addsf3>
 800bf9a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800bf9e:	4601      	mov	r1, r0
 800bfa0:	f7f4 ff3e 	bl	8000e20 <__aeabi_fmul>
 800bfa4:	4605      	mov	r5, r0
 800bfa6:	4925      	ldr	r1, [pc, #148]	; (800c03c <__ieee754_asinf+0x25c>)
 800bfa8:	f7f4 ff3a 	bl	8000e20 <__aeabi_fmul>
 800bfac:	4924      	ldr	r1, [pc, #144]	; (800c040 <__ieee754_asinf+0x260>)
 800bfae:	f7f4 fe2d 	bl	8000c0c <__addsf3>
 800bfb2:	4629      	mov	r1, r5
 800bfb4:	f7f4 ff34 	bl	8000e20 <__aeabi_fmul>
 800bfb8:	4922      	ldr	r1, [pc, #136]	; (800c044 <__ieee754_asinf+0x264>)
 800bfba:	f7f4 fe25 	bl	8000c08 <__aeabi_fsub>
 800bfbe:	4629      	mov	r1, r5
 800bfc0:	f7f4 ff2e 	bl	8000e20 <__aeabi_fmul>
 800bfc4:	4920      	ldr	r1, [pc, #128]	; (800c048 <__ieee754_asinf+0x268>)
 800bfc6:	f7f4 fe21 	bl	8000c0c <__addsf3>
 800bfca:	4629      	mov	r1, r5
 800bfcc:	f7f4 ff28 	bl	8000e20 <__aeabi_fmul>
 800bfd0:	491e      	ldr	r1, [pc, #120]	; (800c04c <__ieee754_asinf+0x26c>)
 800bfd2:	f7f4 fe19 	bl	8000c08 <__aeabi_fsub>
 800bfd6:	4629      	mov	r1, r5
 800bfd8:	f7f4 ff22 	bl	8000e20 <__aeabi_fmul>
 800bfdc:	491c      	ldr	r1, [pc, #112]	; (800c050 <__ieee754_asinf+0x270>)
 800bfde:	f7f4 fe15 	bl	8000c0c <__addsf3>
 800bfe2:	4629      	mov	r1, r5
 800bfe4:	f7f4 ff1c 	bl	8000e20 <__aeabi_fmul>
 800bfe8:	491a      	ldr	r1, [pc, #104]	; (800c054 <__ieee754_asinf+0x274>)
 800bfea:	4606      	mov	r6, r0
 800bfec:	4628      	mov	r0, r5
 800bfee:	f7f4 ff17 	bl	8000e20 <__aeabi_fmul>
 800bff2:	4919      	ldr	r1, [pc, #100]	; (800c058 <__ieee754_asinf+0x278>)
 800bff4:	f7f4 fe08 	bl	8000c08 <__aeabi_fsub>
 800bff8:	4629      	mov	r1, r5
 800bffa:	f7f4 ff11 	bl	8000e20 <__aeabi_fmul>
 800bffe:	4917      	ldr	r1, [pc, #92]	; (800c05c <__ieee754_asinf+0x27c>)
 800c000:	f7f4 fe04 	bl	8000c0c <__addsf3>
 800c004:	4629      	mov	r1, r5
 800c006:	f7f4 ff0b 	bl	8000e20 <__aeabi_fmul>
 800c00a:	4915      	ldr	r1, [pc, #84]	; (800c060 <__ieee754_asinf+0x280>)
 800c00c:	f7f4 fdfc 	bl	8000c08 <__aeabi_fsub>
 800c010:	4629      	mov	r1, r5
 800c012:	f7f4 ff05 	bl	8000e20 <__aeabi_fmul>
 800c016:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800c01a:	f7f4 fdf7 	bl	8000c0c <__addsf3>
 800c01e:	4601      	mov	r1, r0
 800c020:	4630      	mov	r0, r6
 800c022:	f7f4 ffb1 	bl	8000f88 <__aeabi_fdiv>
 800c026:	4601      	mov	r1, r0
 800c028:	4620      	mov	r0, r4
 800c02a:	f7f4 fef9 	bl	8000e20 <__aeabi_fmul>
 800c02e:	4621      	mov	r1, r4
 800c030:	f7f4 fdec 	bl	8000c0c <__addsf3>
 800c034:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800c038:	7149f2ca 	.word	0x7149f2ca
 800c03c:	3811ef08 	.word	0x3811ef08
 800c040:	3a4f7f04 	.word	0x3a4f7f04
 800c044:	3d241146 	.word	0x3d241146
 800c048:	3e4e0aa8 	.word	0x3e4e0aa8
 800c04c:	3ea6b090 	.word	0x3ea6b090
 800c050:	3e2aaaab 	.word	0x3e2aaaab
 800c054:	3d9dc62e 	.word	0x3d9dc62e
 800c058:	3f303361 	.word	0x3f303361
 800c05c:	4001572d 	.word	0x4001572d
 800c060:	4019d139 	.word	0x4019d139
 800c064:	3f799999 	.word	0x3f799999
 800c068:	b33bbd2e 	.word	0xb33bbd2e
 800c06c:	3f490fdb 	.word	0x3f490fdb
 800c070:	333bbd2e 	.word	0x333bbd2e
 800c074:	3fc90fdb 	.word	0x3fc90fdb
	...

0800c080 <__ieee754_atan2f>:
 800c080:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c082:	f021 4400 	bic.w	r4, r1, #2147483648	; 0x80000000
 800c086:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 800c08a:	4603      	mov	r3, r0
 800c08c:	dc14      	bgt.n	800c0b8 <__ieee754_atan2f+0x38>
 800c08e:	f020 4600 	bic.w	r6, r0, #2147483648	; 0x80000000
 800c092:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
 800c096:	4607      	mov	r7, r0
 800c098:	dc0e      	bgt.n	800c0b8 <__ieee754_atan2f+0x38>
 800c09a:	f1b1 5f7e 	cmp.w	r1, #1065353216	; 0x3f800000
 800c09e:	d03a      	beq.n	800c116 <__ieee754_atan2f+0x96>
 800c0a0:	178d      	asrs	r5, r1, #30
 800c0a2:	f005 0502 	and.w	r5, r5, #2
 800c0a6:	ea45 75d0 	orr.w	r5, r5, r0, lsr #31
 800c0aa:	b956      	cbnz	r6, 800c0c2 <__ieee754_atan2f+0x42>
 800c0ac:	2d02      	cmp	r5, #2
 800c0ae:	d030      	beq.n	800c112 <__ieee754_atan2f+0x92>
 800c0b0:	2d03      	cmp	r5, #3
 800c0b2:	d12b      	bne.n	800c10c <__ieee754_atan2f+0x8c>
 800c0b4:	4831      	ldr	r0, [pc, #196]	; (800c17c <__ieee754_atan2f+0xfc>)
 800c0b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c0b8:	4608      	mov	r0, r1
 800c0ba:	4619      	mov	r1, r3
 800c0bc:	f7f4 fda6 	bl	8000c0c <__addsf3>
 800c0c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c0c2:	b1fc      	cbz	r4, 800c104 <__ieee754_atan2f+0x84>
 800c0c4:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 800c0c8:	d029      	beq.n	800c11e <__ieee754_atan2f+0x9e>
 800c0ca:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
 800c0ce:	d019      	beq.n	800c104 <__ieee754_atan2f+0x84>
 800c0d0:	1b34      	subs	r4, r6, r4
 800c0d2:	15e4      	asrs	r4, r4, #23
 800c0d4:	2c3c      	cmp	r4, #60	; 0x3c
 800c0d6:	dc1a      	bgt.n	800c10e <__ieee754_atan2f+0x8e>
 800c0d8:	2900      	cmp	r1, #0
 800c0da:	db38      	blt.n	800c14e <__ieee754_atan2f+0xce>
 800c0dc:	4618      	mov	r0, r3
 800c0de:	f7f4 ff53 	bl	8000f88 <__aeabi_fdiv>
 800c0e2:	f001 f85d 	bl	800d1a0 <fabsf>
 800c0e6:	f000 ff43 	bl	800cf70 <atanf>
 800c0ea:	2d01      	cmp	r5, #1
 800c0ec:	d02c      	beq.n	800c148 <__ieee754_atan2f+0xc8>
 800c0ee:	2d02      	cmp	r5, #2
 800c0f0:	d022      	beq.n	800c138 <__ieee754_atan2f+0xb8>
 800c0f2:	2d00      	cmp	r5, #0
 800c0f4:	d02f      	beq.n	800c156 <__ieee754_atan2f+0xd6>
 800c0f6:	4922      	ldr	r1, [pc, #136]	; (800c180 <__ieee754_atan2f+0x100>)
 800c0f8:	f7f4 fd88 	bl	8000c0c <__addsf3>
 800c0fc:	4921      	ldr	r1, [pc, #132]	; (800c184 <__ieee754_atan2f+0x104>)
 800c0fe:	f7f4 fd83 	bl	8000c08 <__aeabi_fsub>
 800c102:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c104:	2f00      	cmp	r7, #0
 800c106:	db15      	blt.n	800c134 <__ieee754_atan2f+0xb4>
 800c108:	481f      	ldr	r0, [pc, #124]	; (800c188 <__ieee754_atan2f+0x108>)
 800c10a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c10c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c10e:	481e      	ldr	r0, [pc, #120]	; (800c188 <__ieee754_atan2f+0x108>)
 800c110:	e7eb      	b.n	800c0ea <__ieee754_atan2f+0x6a>
 800c112:	481c      	ldr	r0, [pc, #112]	; (800c184 <__ieee754_atan2f+0x104>)
 800c114:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c116:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 800c11a:	f000 bf29 	b.w	800cf70 <atanf>
 800c11e:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
 800c122:	d019      	beq.n	800c158 <__ieee754_atan2f+0xd8>
 800c124:	2d02      	cmp	r5, #2
 800c126:	d0f4      	beq.n	800c112 <__ieee754_atan2f+0x92>
 800c128:	2d03      	cmp	r5, #3
 800c12a:	d0c3      	beq.n	800c0b4 <__ieee754_atan2f+0x34>
 800c12c:	2d01      	cmp	r5, #1
 800c12e:	d01b      	beq.n	800c168 <__ieee754_atan2f+0xe8>
 800c130:	2000      	movs	r0, #0
 800c132:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c134:	4815      	ldr	r0, [pc, #84]	; (800c18c <__ieee754_atan2f+0x10c>)
 800c136:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c138:	4911      	ldr	r1, [pc, #68]	; (800c180 <__ieee754_atan2f+0x100>)
 800c13a:	f7f4 fd67 	bl	8000c0c <__addsf3>
 800c13e:	4601      	mov	r1, r0
 800c140:	4810      	ldr	r0, [pc, #64]	; (800c184 <__ieee754_atan2f+0x104>)
 800c142:	f7f4 fd61 	bl	8000c08 <__aeabi_fsub>
 800c146:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c148:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 800c14c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c14e:	343c      	adds	r4, #60	; 0x3c
 800c150:	dac4      	bge.n	800c0dc <__ieee754_atan2f+0x5c>
 800c152:	2000      	movs	r0, #0
 800c154:	e7c9      	b.n	800c0ea <__ieee754_atan2f+0x6a>
 800c156:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c158:	2d02      	cmp	r5, #2
 800c15a:	d00c      	beq.n	800c176 <__ieee754_atan2f+0xf6>
 800c15c:	2d03      	cmp	r5, #3
 800c15e:	d008      	beq.n	800c172 <__ieee754_atan2f+0xf2>
 800c160:	2d01      	cmp	r5, #1
 800c162:	d004      	beq.n	800c16e <__ieee754_atan2f+0xee>
 800c164:	480a      	ldr	r0, [pc, #40]	; (800c190 <__ieee754_atan2f+0x110>)
 800c166:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c168:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800c16c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c16e:	4809      	ldr	r0, [pc, #36]	; (800c194 <__ieee754_atan2f+0x114>)
 800c170:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c172:	4809      	ldr	r0, [pc, #36]	; (800c198 <__ieee754_atan2f+0x118>)
 800c174:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c176:	4809      	ldr	r0, [pc, #36]	; (800c19c <__ieee754_atan2f+0x11c>)
 800c178:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c17a:	bf00      	nop
 800c17c:	c0490fdb 	.word	0xc0490fdb
 800c180:	33bbbd2e 	.word	0x33bbbd2e
 800c184:	40490fdb 	.word	0x40490fdb
 800c188:	3fc90fdb 	.word	0x3fc90fdb
 800c18c:	bfc90fdb 	.word	0xbfc90fdb
 800c190:	3f490fdb 	.word	0x3f490fdb
 800c194:	bf490fdb 	.word	0xbf490fdb
 800c198:	c016cbe4 	.word	0xc016cbe4
 800c19c:	4016cbe4 	.word	0x4016cbe4

0800c1a0 <__ieee754_fmodf>:
 800c1a0:	b570      	push	{r4, r5, r6, lr}
 800c1a2:	f031 4400 	bics.w	r4, r1, #2147483648	; 0x80000000
 800c1a6:	460e      	mov	r6, r1
 800c1a8:	d03d      	beq.n	800c226 <__ieee754_fmodf+0x86>
 800c1aa:	4603      	mov	r3, r0
 800c1ac:	f000 4500 	and.w	r5, r0, #2147483648	; 0x80000000
 800c1b0:	406b      	eors	r3, r5
 800c1b2:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 800c1b6:	da36      	bge.n	800c226 <__ieee754_fmodf+0x86>
 800c1b8:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 800c1bc:	dc33      	bgt.n	800c226 <__ieee754_fmodf+0x86>
 800c1be:	42a3      	cmp	r3, r4
 800c1c0:	db3d      	blt.n	800c23e <__ieee754_fmodf+0x9e>
 800c1c2:	d041      	beq.n	800c248 <__ieee754_fmodf+0xa8>
 800c1c4:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 800c1c8:	da43      	bge.n	800c252 <__ieee754_fmodf+0xb2>
 800c1ca:	0219      	lsls	r1, r3, #8
 800c1cc:	2900      	cmp	r1, #0
 800c1ce:	f06f 027d 	mvn.w	r2, #125	; 0x7d
 800c1d2:	dd04      	ble.n	800c1de <__ieee754_fmodf+0x3e>
 800c1d4:	0049      	lsls	r1, r1, #1
 800c1d6:	2900      	cmp	r1, #0
 800c1d8:	f102 32ff 	add.w	r2, r2, #4294967295
 800c1dc:	dcfa      	bgt.n	800c1d4 <__ieee754_fmodf+0x34>
 800c1de:	f5b4 0f00 	cmp.w	r4, #8388608	; 0x800000
 800c1e2:	da43      	bge.n	800c26c <__ieee754_fmodf+0xcc>
 800c1e4:	0220      	lsls	r0, r4, #8
 800c1e6:	f06f 017d 	mvn.w	r1, #125	; 0x7d
 800c1ea:	d403      	bmi.n	800c1f4 <__ieee754_fmodf+0x54>
 800c1ec:	0040      	lsls	r0, r0, #1
 800c1ee:	f101 31ff 	add.w	r1, r1, #4294967295
 800c1f2:	d5fb      	bpl.n	800c1ec <__ieee754_fmodf+0x4c>
 800c1f4:	f112 0f7e 	cmn.w	r2, #126	; 0x7e
 800c1f8:	db33      	blt.n	800c262 <__ieee754_fmodf+0xc2>
 800c1fa:	f3c3 0316 	ubfx	r3, r3, #0, #23
 800c1fe:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800c202:	f111 0f7e 	cmn.w	r1, #126	; 0x7e
 800c206:	db27      	blt.n	800c258 <__ieee754_fmodf+0xb8>
 800c208:	f3c6 0416 	ubfx	r4, r6, #0, #23
 800c20c:	f444 0400 	orr.w	r4, r4, #8388608	; 0x800000
 800c210:	1a52      	subs	r2, r2, r1
 800c212:	e002      	b.n	800c21a <__ieee754_fmodf+0x7a>
 800c214:	d018      	beq.n	800c248 <__ieee754_fmodf+0xa8>
 800c216:	0043      	lsls	r3, r0, #1
 800c218:	3a01      	subs	r2, #1
 800c21a:	1b18      	subs	r0, r3, r4
 800c21c:	b182      	cbz	r2, 800c240 <__ieee754_fmodf+0xa0>
 800c21e:	2800      	cmp	r0, #0
 800c220:	daf8      	bge.n	800c214 <__ieee754_fmodf+0x74>
 800c222:	005b      	lsls	r3, r3, #1
 800c224:	e7f8      	b.n	800c218 <__ieee754_fmodf+0x78>
 800c226:	f7f4 fdfb 	bl	8000e20 <__aeabi_fmul>
 800c22a:	4601      	mov	r1, r0
 800c22c:	f7f4 feac 	bl	8000f88 <__aeabi_fdiv>
 800c230:	bd70      	pop	{r4, r5, r6, pc}
 800c232:	f06f 037d 	mvn.w	r3, #125	; 0x7d
 800c236:	1a5b      	subs	r3, r3, r1
 800c238:	411c      	asrs	r4, r3
 800c23a:	ea44 0005 	orr.w	r0, r4, r5
 800c23e:	bd70      	pop	{r4, r5, r6, pc}
 800c240:	1b1c      	subs	r4, r3, r4
 800c242:	bf48      	it	mi
 800c244:	461c      	movmi	r4, r3
 800c246:	b9a4      	cbnz	r4, 800c272 <__ieee754_fmodf+0xd2>
 800c248:	4a14      	ldr	r2, [pc, #80]	; (800c29c <__ieee754_fmodf+0xfc>)
 800c24a:	0fe8      	lsrs	r0, r5, #31
 800c24c:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
 800c250:	bd70      	pop	{r4, r5, r6, pc}
 800c252:	15da      	asrs	r2, r3, #23
 800c254:	3a7f      	subs	r2, #127	; 0x7f
 800c256:	e7c2      	b.n	800c1de <__ieee754_fmodf+0x3e>
 800c258:	f06f 007d 	mvn.w	r0, #125	; 0x7d
 800c25c:	1a40      	subs	r0, r0, r1
 800c25e:	4084      	lsls	r4, r0
 800c260:	e7d6      	b.n	800c210 <__ieee754_fmodf+0x70>
 800c262:	f06f 007d 	mvn.w	r0, #125	; 0x7d
 800c266:	1a80      	subs	r0, r0, r2
 800c268:	4083      	lsls	r3, r0
 800c26a:	e7ca      	b.n	800c202 <__ieee754_fmodf+0x62>
 800c26c:	15e1      	asrs	r1, r4, #23
 800c26e:	397f      	subs	r1, #127	; 0x7f
 800c270:	e7c0      	b.n	800c1f4 <__ieee754_fmodf+0x54>
 800c272:	4b0b      	ldr	r3, [pc, #44]	; (800c2a0 <__ieee754_fmodf+0x100>)
 800c274:	429c      	cmp	r4, r3
 800c276:	dc04      	bgt.n	800c282 <__ieee754_fmodf+0xe2>
 800c278:	0064      	lsls	r4, r4, #1
 800c27a:	429c      	cmp	r4, r3
 800c27c:	f101 31ff 	add.w	r1, r1, #4294967295
 800c280:	ddfa      	ble.n	800c278 <__ieee754_fmodf+0xd8>
 800c282:	f111 0f7e 	cmn.w	r1, #126	; 0x7e
 800c286:	dbd4      	blt.n	800c232 <__ieee754_fmodf+0x92>
 800c288:	f5a4 0400 	sub.w	r4, r4, #8388608	; 0x800000
 800c28c:	ea44 0305 	orr.w	r3, r4, r5
 800c290:	f101 007f 	add.w	r0, r1, #127	; 0x7f
 800c294:	ea43 50c0 	orr.w	r0, r3, r0, lsl #23
 800c298:	bd70      	pop	{r4, r5, r6, pc}
 800c29a:	bf00      	nop
 800c29c:	0800e930 	.word	0x0800e930
 800c2a0:	007fffff 	.word	0x007fffff
	...

0800c2b0 <__ieee754_rem_pio2f>:
 800c2b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c2b4:	4aaa      	ldr	r2, [pc, #680]	; (800c560 <__ieee754_rem_pio2f+0x2b0>)
 800c2b6:	f020 4400 	bic.w	r4, r0, #2147483648	; 0x80000000
 800c2ba:	4294      	cmp	r4, r2
 800c2bc:	b089      	sub	sp, #36	; 0x24
 800c2be:	4607      	mov	r7, r0
 800c2c0:	460d      	mov	r5, r1
 800c2c2:	dd64      	ble.n	800c38e <__ieee754_rem_pio2f+0xde>
 800c2c4:	4aa7      	ldr	r2, [pc, #668]	; (800c564 <__ieee754_rem_pio2f+0x2b4>)
 800c2c6:	4294      	cmp	r4, r2
 800c2c8:	dc1c      	bgt.n	800c304 <__ieee754_rem_pio2f+0x54>
 800c2ca:	2800      	cmp	r0, #0
 800c2cc:	49a6      	ldr	r1, [pc, #664]	; (800c568 <__ieee754_rem_pio2f+0x2b8>)
 800c2ce:	f340 80eb 	ble.w	800c4a8 <__ieee754_rem_pio2f+0x1f8>
 800c2d2:	f7f4 fc99 	bl	8000c08 <__aeabi_fsub>
 800c2d6:	4ba5      	ldr	r3, [pc, #660]	; (800c56c <__ieee754_rem_pio2f+0x2bc>)
 800c2d8:	f024 040f 	bic.w	r4, r4, #15
 800c2dc:	429c      	cmp	r4, r3
 800c2de:	4606      	mov	r6, r0
 800c2e0:	d064      	beq.n	800c3ac <__ieee754_rem_pio2f+0xfc>
 800c2e2:	49a3      	ldr	r1, [pc, #652]	; (800c570 <__ieee754_rem_pio2f+0x2c0>)
 800c2e4:	f7f4 fc90 	bl	8000c08 <__aeabi_fsub>
 800c2e8:	4601      	mov	r1, r0
 800c2ea:	4630      	mov	r0, r6
 800c2ec:	6029      	str	r1, [r5, #0]
 800c2ee:	f7f4 fc8b 	bl	8000c08 <__aeabi_fsub>
 800c2f2:	499f      	ldr	r1, [pc, #636]	; (800c570 <__ieee754_rem_pio2f+0x2c0>)
 800c2f4:	f7f4 fc88 	bl	8000c08 <__aeabi_fsub>
 800c2f8:	2301      	movs	r3, #1
 800c2fa:	6068      	str	r0, [r5, #4]
 800c2fc:	4618      	mov	r0, r3
 800c2fe:	b009      	add	sp, #36	; 0x24
 800c300:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c304:	4a9b      	ldr	r2, [pc, #620]	; (800c574 <__ieee754_rem_pio2f+0x2c4>)
 800c306:	4294      	cmp	r4, r2
 800c308:	dd62      	ble.n	800c3d0 <__ieee754_rem_pio2f+0x120>
 800c30a:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 800c30e:	da46      	bge.n	800c39e <__ieee754_rem_pio2f+0xee>
 800c310:	15e6      	asrs	r6, r4, #23
 800c312:	3e86      	subs	r6, #134	; 0x86
 800c314:	eba4 54c6 	sub.w	r4, r4, r6, lsl #23
 800c318:	4620      	mov	r0, r4
 800c31a:	f7f4 ff49 	bl	80011b0 <__aeabi_f2iz>
 800c31e:	f7f4 fd29 	bl	8000d74 <__aeabi_i2f>
 800c322:	4603      	mov	r3, r0
 800c324:	4620      	mov	r0, r4
 800c326:	4619      	mov	r1, r3
 800c328:	9305      	str	r3, [sp, #20]
 800c32a:	f7f4 fc6d 	bl	8000c08 <__aeabi_fsub>
 800c32e:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 800c332:	f7f4 fd75 	bl	8000e20 <__aeabi_fmul>
 800c336:	4680      	mov	r8, r0
 800c338:	f7f4 ff3a 	bl	80011b0 <__aeabi_f2iz>
 800c33c:	f7f4 fd1a 	bl	8000d74 <__aeabi_i2f>
 800c340:	4604      	mov	r4, r0
 800c342:	4640      	mov	r0, r8
 800c344:	4621      	mov	r1, r4
 800c346:	9406      	str	r4, [sp, #24]
 800c348:	f7f4 fc5e 	bl	8000c08 <__aeabi_fsub>
 800c34c:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 800c350:	f7f4 fd66 	bl	8000e20 <__aeabi_fmul>
 800c354:	2100      	movs	r1, #0
 800c356:	9007      	str	r0, [sp, #28]
 800c358:	f7f4 fef6 	bl	8001148 <__aeabi_fcmpeq>
 800c35c:	2800      	cmp	r0, #0
 800c35e:	f000 80c4 	beq.w	800c4ea <__ieee754_rem_pio2f+0x23a>
 800c362:	4620      	mov	r0, r4
 800c364:	2100      	movs	r1, #0
 800c366:	f7f4 feef 	bl	8001148 <__aeabi_fcmpeq>
 800c36a:	2800      	cmp	r0, #0
 800c36c:	bf14      	ite	ne
 800c36e:	2301      	movne	r3, #1
 800c370:	2302      	moveq	r3, #2
 800c372:	4881      	ldr	r0, [pc, #516]	; (800c578 <__ieee754_rem_pio2f+0x2c8>)
 800c374:	2102      	movs	r1, #2
 800c376:	9001      	str	r0, [sp, #4]
 800c378:	9100      	str	r1, [sp, #0]
 800c37a:	4632      	mov	r2, r6
 800c37c:	a805      	add	r0, sp, #20
 800c37e:	4629      	mov	r1, r5
 800c380:	f000 fa2e 	bl	800c7e0 <__kernel_rem_pio2f>
 800c384:	2f00      	cmp	r7, #0
 800c386:	f2c0 80a6 	blt.w	800c4d6 <__ieee754_rem_pio2f+0x226>
 800c38a:	4603      	mov	r3, r0
 800c38c:	e003      	b.n	800c396 <__ieee754_rem_pio2f+0xe6>
 800c38e:	2200      	movs	r2, #0
 800c390:	6028      	str	r0, [r5, #0]
 800c392:	2300      	movs	r3, #0
 800c394:	604a      	str	r2, [r1, #4]
 800c396:	4618      	mov	r0, r3
 800c398:	b009      	add	sp, #36	; 0x24
 800c39a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c39e:	4601      	mov	r1, r0
 800c3a0:	f7f4 fc32 	bl	8000c08 <__aeabi_fsub>
 800c3a4:	2300      	movs	r3, #0
 800c3a6:	6068      	str	r0, [r5, #4]
 800c3a8:	6028      	str	r0, [r5, #0]
 800c3aa:	e7f4      	b.n	800c396 <__ieee754_rem_pio2f+0xe6>
 800c3ac:	4973      	ldr	r1, [pc, #460]	; (800c57c <__ieee754_rem_pio2f+0x2cc>)
 800c3ae:	f7f4 fc2b 	bl	8000c08 <__aeabi_fsub>
 800c3b2:	4973      	ldr	r1, [pc, #460]	; (800c580 <__ieee754_rem_pio2f+0x2d0>)
 800c3b4:	4604      	mov	r4, r0
 800c3b6:	f7f4 fc27 	bl	8000c08 <__aeabi_fsub>
 800c3ba:	4601      	mov	r1, r0
 800c3bc:	4620      	mov	r0, r4
 800c3be:	6029      	str	r1, [r5, #0]
 800c3c0:	f7f4 fc22 	bl	8000c08 <__aeabi_fsub>
 800c3c4:	496e      	ldr	r1, [pc, #440]	; (800c580 <__ieee754_rem_pio2f+0x2d0>)
 800c3c6:	f7f4 fc1f 	bl	8000c08 <__aeabi_fsub>
 800c3ca:	2301      	movs	r3, #1
 800c3cc:	6068      	str	r0, [r5, #4]
 800c3ce:	e7e2      	b.n	800c396 <__ieee754_rem_pio2f+0xe6>
 800c3d0:	f000 fee6 	bl	800d1a0 <fabsf>
 800c3d4:	496b      	ldr	r1, [pc, #428]	; (800c584 <__ieee754_rem_pio2f+0x2d4>)
 800c3d6:	4680      	mov	r8, r0
 800c3d8:	f7f4 fd22 	bl	8000e20 <__aeabi_fmul>
 800c3dc:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800c3e0:	f7f4 fc14 	bl	8000c0c <__addsf3>
 800c3e4:	f7f4 fee4 	bl	80011b0 <__aeabi_f2iz>
 800c3e8:	4606      	mov	r6, r0
 800c3ea:	f7f4 fcc3 	bl	8000d74 <__aeabi_i2f>
 800c3ee:	495e      	ldr	r1, [pc, #376]	; (800c568 <__ieee754_rem_pio2f+0x2b8>)
 800c3f0:	4683      	mov	fp, r0
 800c3f2:	f7f4 fd15 	bl	8000e20 <__aeabi_fmul>
 800c3f6:	4601      	mov	r1, r0
 800c3f8:	4640      	mov	r0, r8
 800c3fa:	f7f4 fc05 	bl	8000c08 <__aeabi_fsub>
 800c3fe:	495c      	ldr	r1, [pc, #368]	; (800c570 <__ieee754_rem_pio2f+0x2c0>)
 800c400:	4681      	mov	r9, r0
 800c402:	4658      	mov	r0, fp
 800c404:	f7f4 fd0c 	bl	8000e20 <__aeabi_fmul>
 800c408:	4682      	mov	sl, r0
 800c40a:	2e1f      	cmp	r6, #31
 800c40c:	4648      	mov	r0, r9
 800c40e:	4651      	mov	r1, sl
 800c410:	dc18      	bgt.n	800c444 <__ieee754_rem_pio2f+0x194>
 800c412:	4b5d      	ldr	r3, [pc, #372]	; (800c588 <__ieee754_rem_pio2f+0x2d8>)
 800c414:	1e72      	subs	r2, r6, #1
 800c416:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800c41a:	f024 02ff 	bic.w	r2, r4, #255	; 0xff
 800c41e:	429a      	cmp	r2, r3
 800c420:	d010      	beq.n	800c444 <__ieee754_rem_pio2f+0x194>
 800c422:	f7f4 fbf1 	bl	8000c08 <__aeabi_fsub>
 800c426:	4680      	mov	r8, r0
 800c428:	f8c5 8000 	str.w	r8, [r5]
 800c42c:	4641      	mov	r1, r8
 800c42e:	4648      	mov	r0, r9
 800c430:	f7f4 fbea 	bl	8000c08 <__aeabi_fsub>
 800c434:	4651      	mov	r1, sl
 800c436:	f7f4 fbe7 	bl	8000c08 <__aeabi_fsub>
 800c43a:	2f00      	cmp	r7, #0
 800c43c:	6068      	str	r0, [r5, #4]
 800c43e:	db56      	blt.n	800c4ee <__ieee754_rem_pio2f+0x23e>
 800c440:	4633      	mov	r3, r6
 800c442:	e7a8      	b.n	800c396 <__ieee754_rem_pio2f+0xe6>
 800c444:	f7f4 fbe0 	bl	8000c08 <__aeabi_fsub>
 800c448:	15e2      	asrs	r2, r4, #23
 800c44a:	f3c0 53c7 	ubfx	r3, r0, #23, #8
 800c44e:	1ad3      	subs	r3, r2, r3
 800c450:	2b08      	cmp	r3, #8
 800c452:	4680      	mov	r8, r0
 800c454:	dde8      	ble.n	800c428 <__ieee754_rem_pio2f+0x178>
 800c456:	4949      	ldr	r1, [pc, #292]	; (800c57c <__ieee754_rem_pio2f+0x2cc>)
 800c458:	4658      	mov	r0, fp
 800c45a:	9203      	str	r2, [sp, #12]
 800c45c:	f7f4 fce0 	bl	8000e20 <__aeabi_fmul>
 800c460:	4680      	mov	r8, r0
 800c462:	4648      	mov	r0, r9
 800c464:	4641      	mov	r1, r8
 800c466:	f7f4 fbcf 	bl	8000c08 <__aeabi_fsub>
 800c46a:	4604      	mov	r4, r0
 800c46c:	4648      	mov	r0, r9
 800c46e:	4621      	mov	r1, r4
 800c470:	f7f4 fbca 	bl	8000c08 <__aeabi_fsub>
 800c474:	4641      	mov	r1, r8
 800c476:	f7f4 fbc7 	bl	8000c08 <__aeabi_fsub>
 800c47a:	4680      	mov	r8, r0
 800c47c:	4940      	ldr	r1, [pc, #256]	; (800c580 <__ieee754_rem_pio2f+0x2d0>)
 800c47e:	4658      	mov	r0, fp
 800c480:	f7f4 fcce 	bl	8000e20 <__aeabi_fmul>
 800c484:	4641      	mov	r1, r8
 800c486:	f7f4 fbbf 	bl	8000c08 <__aeabi_fsub>
 800c48a:	4682      	mov	sl, r0
 800c48c:	4620      	mov	r0, r4
 800c48e:	4651      	mov	r1, sl
 800c490:	f7f4 fbba 	bl	8000c08 <__aeabi_fsub>
 800c494:	9a03      	ldr	r2, [sp, #12]
 800c496:	f3c0 53c7 	ubfx	r3, r0, #23, #8
 800c49a:	1ad2      	subs	r2, r2, r3
 800c49c:	2a19      	cmp	r2, #25
 800c49e:	4680      	mov	r8, r0
 800c4a0:	dc41      	bgt.n	800c526 <__ieee754_rem_pio2f+0x276>
 800c4a2:	6028      	str	r0, [r5, #0]
 800c4a4:	46a1      	mov	r9, r4
 800c4a6:	e7c1      	b.n	800c42c <__ieee754_rem_pio2f+0x17c>
 800c4a8:	f7f4 fbb0 	bl	8000c0c <__addsf3>
 800c4ac:	4b2f      	ldr	r3, [pc, #188]	; (800c56c <__ieee754_rem_pio2f+0x2bc>)
 800c4ae:	f024 040f 	bic.w	r4, r4, #15
 800c4b2:	429c      	cmp	r4, r3
 800c4b4:	4606      	mov	r6, r0
 800c4b6:	d023      	beq.n	800c500 <__ieee754_rem_pio2f+0x250>
 800c4b8:	492d      	ldr	r1, [pc, #180]	; (800c570 <__ieee754_rem_pio2f+0x2c0>)
 800c4ba:	f7f4 fba7 	bl	8000c0c <__addsf3>
 800c4be:	4601      	mov	r1, r0
 800c4c0:	4630      	mov	r0, r6
 800c4c2:	6029      	str	r1, [r5, #0]
 800c4c4:	f7f4 fba0 	bl	8000c08 <__aeabi_fsub>
 800c4c8:	4929      	ldr	r1, [pc, #164]	; (800c570 <__ieee754_rem_pio2f+0x2c0>)
 800c4ca:	f7f4 fb9f 	bl	8000c0c <__addsf3>
 800c4ce:	f04f 33ff 	mov.w	r3, #4294967295
 800c4d2:	6068      	str	r0, [r5, #4]
 800c4d4:	e75f      	b.n	800c396 <__ieee754_rem_pio2f+0xe6>
 800c4d6:	e895 000c 	ldmia.w	r5, {r2, r3}
 800c4da:	f102 4100 	add.w	r1, r2, #2147483648	; 0x80000000
 800c4de:	f103 4200 	add.w	r2, r3, #2147483648	; 0x80000000
 800c4e2:	6029      	str	r1, [r5, #0]
 800c4e4:	4243      	negs	r3, r0
 800c4e6:	606a      	str	r2, [r5, #4]
 800c4e8:	e755      	b.n	800c396 <__ieee754_rem_pio2f+0xe6>
 800c4ea:	2303      	movs	r3, #3
 800c4ec:	e741      	b.n	800c372 <__ieee754_rem_pio2f+0xc2>
 800c4ee:	f108 4800 	add.w	r8, r8, #2147483648	; 0x80000000
 800c4f2:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 800c4f6:	f8c5 8000 	str.w	r8, [r5]
 800c4fa:	6068      	str	r0, [r5, #4]
 800c4fc:	4273      	negs	r3, r6
 800c4fe:	e74a      	b.n	800c396 <__ieee754_rem_pio2f+0xe6>
 800c500:	491e      	ldr	r1, [pc, #120]	; (800c57c <__ieee754_rem_pio2f+0x2cc>)
 800c502:	f7f4 fb83 	bl	8000c0c <__addsf3>
 800c506:	491e      	ldr	r1, [pc, #120]	; (800c580 <__ieee754_rem_pio2f+0x2d0>)
 800c508:	4604      	mov	r4, r0
 800c50a:	f7f4 fb7f 	bl	8000c0c <__addsf3>
 800c50e:	4601      	mov	r1, r0
 800c510:	4620      	mov	r0, r4
 800c512:	6029      	str	r1, [r5, #0]
 800c514:	f7f4 fb78 	bl	8000c08 <__aeabi_fsub>
 800c518:	4919      	ldr	r1, [pc, #100]	; (800c580 <__ieee754_rem_pio2f+0x2d0>)
 800c51a:	f7f4 fb77 	bl	8000c0c <__addsf3>
 800c51e:	f04f 33ff 	mov.w	r3, #4294967295
 800c522:	6068      	str	r0, [r5, #4]
 800c524:	e737      	b.n	800c396 <__ieee754_rem_pio2f+0xe6>
 800c526:	4919      	ldr	r1, [pc, #100]	; (800c58c <__ieee754_rem_pio2f+0x2dc>)
 800c528:	4658      	mov	r0, fp
 800c52a:	f7f4 fc79 	bl	8000e20 <__aeabi_fmul>
 800c52e:	4680      	mov	r8, r0
 800c530:	4620      	mov	r0, r4
 800c532:	4641      	mov	r1, r8
 800c534:	f7f4 fb68 	bl	8000c08 <__aeabi_fsub>
 800c538:	4681      	mov	r9, r0
 800c53a:	4620      	mov	r0, r4
 800c53c:	4649      	mov	r1, r9
 800c53e:	f7f4 fb63 	bl	8000c08 <__aeabi_fsub>
 800c542:	4641      	mov	r1, r8
 800c544:	f7f4 fb60 	bl	8000c08 <__aeabi_fsub>
 800c548:	4604      	mov	r4, r0
 800c54a:	4911      	ldr	r1, [pc, #68]	; (800c590 <__ieee754_rem_pio2f+0x2e0>)
 800c54c:	4658      	mov	r0, fp
 800c54e:	f7f4 fc67 	bl	8000e20 <__aeabi_fmul>
 800c552:	4621      	mov	r1, r4
 800c554:	f7f4 fb58 	bl	8000c08 <__aeabi_fsub>
 800c558:	4682      	mov	sl, r0
 800c55a:	4648      	mov	r0, r9
 800c55c:	4651      	mov	r1, sl
 800c55e:	e760      	b.n	800c422 <__ieee754_rem_pio2f+0x172>
 800c560:	3f490fd8 	.word	0x3f490fd8
 800c564:	4016cbe3 	.word	0x4016cbe3
 800c568:	3fc90f80 	.word	0x3fc90f80
 800c56c:	3fc90fd0 	.word	0x3fc90fd0
 800c570:	37354443 	.word	0x37354443
 800c574:	43490f80 	.word	0x43490f80
 800c578:	0800e9c0 	.word	0x0800e9c0
 800c57c:	37354400 	.word	0x37354400
 800c580:	2e85a308 	.word	0x2e85a308
 800c584:	3f22f984 	.word	0x3f22f984
 800c588:	0800e940 	.word	0x0800e940
 800c58c:	2e85a300 	.word	0x2e85a300
 800c590:	248d3132 	.word	0x248d3132
	...

0800c5a0 <__ieee754_sqrtf>:
 800c5a0:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 800c5a4:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 800c5a8:	b570      	push	{r4, r5, r6, lr}
 800c5aa:	4603      	mov	r3, r0
 800c5ac:	4604      	mov	r4, r0
 800c5ae:	d22d      	bcs.n	800c60c <__ieee754_sqrtf+0x6c>
 800c5b0:	b35a      	cbz	r2, 800c60a <__ieee754_sqrtf+0x6a>
 800c5b2:	2800      	cmp	r0, #0
 800c5b4:	db3d      	blt.n	800c632 <__ieee754_sqrtf+0x92>
 800c5b6:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 800c5ba:	ea4f 50e0 	mov.w	r0, r0, asr #23
 800c5be:	d32c      	bcc.n	800c61a <__ieee754_sqrtf+0x7a>
 800c5c0:	2600      	movs	r6, #0
 800c5c2:	4631      	mov	r1, r6
 800c5c4:	387f      	subs	r0, #127	; 0x7f
 800c5c6:	f3c3 0316 	ubfx	r3, r3, #0, #23
 800c5ca:	07c2      	lsls	r2, r0, #31
 800c5cc:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800c5d0:	bf48      	it	mi
 800c5d2:	005b      	lslmi	r3, r3, #1
 800c5d4:	1040      	asrs	r0, r0, #1
 800c5d6:	005b      	lsls	r3, r3, #1
 800c5d8:	2419      	movs	r4, #25
 800c5da:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800c5de:	188d      	adds	r5, r1, r2
 800c5e0:	429d      	cmp	r5, r3
 800c5e2:	dc02      	bgt.n	800c5ea <__ieee754_sqrtf+0x4a>
 800c5e4:	1b5b      	subs	r3, r3, r5
 800c5e6:	18a9      	adds	r1, r5, r2
 800c5e8:	4416      	add	r6, r2
 800c5ea:	3c01      	subs	r4, #1
 800c5ec:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800c5f0:	ea4f 0252 	mov.w	r2, r2, lsr #1
 800c5f4:	d1f3      	bne.n	800c5de <__ieee754_sqrtf+0x3e>
 800c5f6:	b113      	cbz	r3, 800c5fe <__ieee754_sqrtf+0x5e>
 800c5f8:	f006 0301 	and.w	r3, r6, #1
 800c5fc:	441e      	add	r6, r3
 800c5fe:	1076      	asrs	r6, r6, #1
 800c600:	f106 567c 	add.w	r6, r6, #1056964608	; 0x3f000000
 800c604:	eb06 50c0 	add.w	r0, r6, r0, lsl #23
 800c608:	bd70      	pop	{r4, r5, r6, pc}
 800c60a:	bd70      	pop	{r4, r5, r6, pc}
 800c60c:	4601      	mov	r1, r0
 800c60e:	f7f4 fc07 	bl	8000e20 <__aeabi_fmul>
 800c612:	4621      	mov	r1, r4
 800c614:	f7f4 fafa 	bl	8000c0c <__addsf3>
 800c618:	bd70      	pop	{r4, r5, r6, pc}
 800c61a:	f414 0200 	ands.w	r2, r4, #8388608	; 0x800000
 800c61e:	d10f      	bne.n	800c640 <__ieee754_sqrtf+0xa0>
 800c620:	005b      	lsls	r3, r3, #1
 800c622:	0219      	lsls	r1, r3, #8
 800c624:	f102 0201 	add.w	r2, r2, #1
 800c628:	d5fa      	bpl.n	800c620 <__ieee754_sqrtf+0x80>
 800c62a:	f1c2 0201 	rsb	r2, r2, #1
 800c62e:	4410      	add	r0, r2
 800c630:	e7c6      	b.n	800c5c0 <__ieee754_sqrtf+0x20>
 800c632:	4601      	mov	r1, r0
 800c634:	f7f4 fae8 	bl	8000c08 <__aeabi_fsub>
 800c638:	4601      	mov	r1, r0
 800c63a:	f7f4 fca5 	bl	8000f88 <__aeabi_fdiv>
 800c63e:	bd70      	pop	{r4, r5, r6, pc}
 800c640:	2201      	movs	r2, #1
 800c642:	4410      	add	r0, r2
 800c644:	e7bc      	b.n	800c5c0 <__ieee754_sqrtf+0x20>
 800c646:	bf00      	nop
	...

0800c650 <__kernel_cosf>:
 800c650:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800c654:	f020 4400 	bic.w	r4, r0, #2147483648	; 0x80000000
 800c658:	f1b4 5f48 	cmp.w	r4, #838860800	; 0x32000000
 800c65c:	4606      	mov	r6, r0
 800c65e:	460f      	mov	r7, r1
 800c660:	da49      	bge.n	800c6f6 <__kernel_cosf+0xa6>
 800c662:	f7f4 fda5 	bl	80011b0 <__aeabi_f2iz>
 800c666:	2800      	cmp	r0, #0
 800c668:	f000 809d 	beq.w	800c7a6 <__kernel_cosf+0x156>
 800c66c:	4631      	mov	r1, r6
 800c66e:	4630      	mov	r0, r6
 800c670:	f7f4 fbd6 	bl	8000e20 <__aeabi_fmul>
 800c674:	4605      	mov	r5, r0
 800c676:	494e      	ldr	r1, [pc, #312]	; (800c7b0 <__kernel_cosf+0x160>)
 800c678:	f7f4 fbd2 	bl	8000e20 <__aeabi_fmul>
 800c67c:	494d      	ldr	r1, [pc, #308]	; (800c7b4 <__kernel_cosf+0x164>)
 800c67e:	f7f4 fac5 	bl	8000c0c <__addsf3>
 800c682:	4629      	mov	r1, r5
 800c684:	f7f4 fbcc 	bl	8000e20 <__aeabi_fmul>
 800c688:	494b      	ldr	r1, [pc, #300]	; (800c7b8 <__kernel_cosf+0x168>)
 800c68a:	f7f4 fabd 	bl	8000c08 <__aeabi_fsub>
 800c68e:	4629      	mov	r1, r5
 800c690:	f7f4 fbc6 	bl	8000e20 <__aeabi_fmul>
 800c694:	4949      	ldr	r1, [pc, #292]	; (800c7bc <__kernel_cosf+0x16c>)
 800c696:	f7f4 fab9 	bl	8000c0c <__addsf3>
 800c69a:	4629      	mov	r1, r5
 800c69c:	f7f4 fbc0 	bl	8000e20 <__aeabi_fmul>
 800c6a0:	4947      	ldr	r1, [pc, #284]	; (800c7c0 <__kernel_cosf+0x170>)
 800c6a2:	f7f4 fab1 	bl	8000c08 <__aeabi_fsub>
 800c6a6:	4629      	mov	r1, r5
 800c6a8:	f7f4 fbba 	bl	8000e20 <__aeabi_fmul>
 800c6ac:	4945      	ldr	r1, [pc, #276]	; (800c7c4 <__kernel_cosf+0x174>)
 800c6ae:	f7f4 faad 	bl	8000c0c <__addsf3>
 800c6b2:	4629      	mov	r1, r5
 800c6b4:	f7f4 fbb4 	bl	8000e20 <__aeabi_fmul>
 800c6b8:	4680      	mov	r8, r0
 800c6ba:	4628      	mov	r0, r5
 800c6bc:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800c6c0:	f7f4 fbae 	bl	8000e20 <__aeabi_fmul>
 800c6c4:	4641      	mov	r1, r8
 800c6c6:	4604      	mov	r4, r0
 800c6c8:	4628      	mov	r0, r5
 800c6ca:	f7f4 fba9 	bl	8000e20 <__aeabi_fmul>
 800c6ce:	4639      	mov	r1, r7
 800c6d0:	4605      	mov	r5, r0
 800c6d2:	4630      	mov	r0, r6
 800c6d4:	f7f4 fba4 	bl	8000e20 <__aeabi_fmul>
 800c6d8:	4601      	mov	r1, r0
 800c6da:	4628      	mov	r0, r5
 800c6dc:	f7f4 fa94 	bl	8000c08 <__aeabi_fsub>
 800c6e0:	4601      	mov	r1, r0
 800c6e2:	4620      	mov	r0, r4
 800c6e4:	f7f4 fa90 	bl	8000c08 <__aeabi_fsub>
 800c6e8:	4601      	mov	r1, r0
 800c6ea:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800c6ee:	f7f4 fa8b 	bl	8000c08 <__aeabi_fsub>
 800c6f2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800c6f6:	4601      	mov	r1, r0
 800c6f8:	f7f4 fb92 	bl	8000e20 <__aeabi_fmul>
 800c6fc:	4605      	mov	r5, r0
 800c6fe:	492c      	ldr	r1, [pc, #176]	; (800c7b0 <__kernel_cosf+0x160>)
 800c700:	f7f4 fb8e 	bl	8000e20 <__aeabi_fmul>
 800c704:	492b      	ldr	r1, [pc, #172]	; (800c7b4 <__kernel_cosf+0x164>)
 800c706:	f7f4 fa81 	bl	8000c0c <__addsf3>
 800c70a:	4629      	mov	r1, r5
 800c70c:	f7f4 fb88 	bl	8000e20 <__aeabi_fmul>
 800c710:	4929      	ldr	r1, [pc, #164]	; (800c7b8 <__kernel_cosf+0x168>)
 800c712:	f7f4 fa79 	bl	8000c08 <__aeabi_fsub>
 800c716:	4629      	mov	r1, r5
 800c718:	f7f4 fb82 	bl	8000e20 <__aeabi_fmul>
 800c71c:	4927      	ldr	r1, [pc, #156]	; (800c7bc <__kernel_cosf+0x16c>)
 800c71e:	f7f4 fa75 	bl	8000c0c <__addsf3>
 800c722:	4629      	mov	r1, r5
 800c724:	f7f4 fb7c 	bl	8000e20 <__aeabi_fmul>
 800c728:	4925      	ldr	r1, [pc, #148]	; (800c7c0 <__kernel_cosf+0x170>)
 800c72a:	f7f4 fa6d 	bl	8000c08 <__aeabi_fsub>
 800c72e:	4629      	mov	r1, r5
 800c730:	f7f4 fb76 	bl	8000e20 <__aeabi_fmul>
 800c734:	4923      	ldr	r1, [pc, #140]	; (800c7c4 <__kernel_cosf+0x174>)
 800c736:	f7f4 fa69 	bl	8000c0c <__addsf3>
 800c73a:	4629      	mov	r1, r5
 800c73c:	f7f4 fb70 	bl	8000e20 <__aeabi_fmul>
 800c740:	4b21      	ldr	r3, [pc, #132]	; (800c7c8 <__kernel_cosf+0x178>)
 800c742:	4680      	mov	r8, r0
 800c744:	429c      	cmp	r4, r3
 800c746:	ddb8      	ble.n	800c6ba <__kernel_cosf+0x6a>
 800c748:	4b20      	ldr	r3, [pc, #128]	; (800c7cc <__kernel_cosf+0x17c>)
 800c74a:	429c      	cmp	r4, r3
 800c74c:	dc27      	bgt.n	800c79e <__kernel_cosf+0x14e>
 800c74e:	f104 447f 	add.w	r4, r4, #4278190080	; 0xff000000
 800c752:	4621      	mov	r1, r4
 800c754:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800c758:	f7f4 fa56 	bl	8000c08 <__aeabi_fsub>
 800c75c:	4681      	mov	r9, r0
 800c75e:	4628      	mov	r0, r5
 800c760:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800c764:	f7f4 fb5c 	bl	8000e20 <__aeabi_fmul>
 800c768:	4621      	mov	r1, r4
 800c76a:	f7f4 fa4d 	bl	8000c08 <__aeabi_fsub>
 800c76e:	4641      	mov	r1, r8
 800c770:	4604      	mov	r4, r0
 800c772:	4628      	mov	r0, r5
 800c774:	f7f4 fb54 	bl	8000e20 <__aeabi_fmul>
 800c778:	4639      	mov	r1, r7
 800c77a:	4605      	mov	r5, r0
 800c77c:	4630      	mov	r0, r6
 800c77e:	f7f4 fb4f 	bl	8000e20 <__aeabi_fmul>
 800c782:	4601      	mov	r1, r0
 800c784:	4628      	mov	r0, r5
 800c786:	f7f4 fa3f 	bl	8000c08 <__aeabi_fsub>
 800c78a:	4601      	mov	r1, r0
 800c78c:	4620      	mov	r0, r4
 800c78e:	f7f4 fa3b 	bl	8000c08 <__aeabi_fsub>
 800c792:	4601      	mov	r1, r0
 800c794:	4648      	mov	r0, r9
 800c796:	f7f4 fa37 	bl	8000c08 <__aeabi_fsub>
 800c79a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800c79e:	f8df 9034 	ldr.w	r9, [pc, #52]	; 800c7d4 <__kernel_cosf+0x184>
 800c7a2:	4c0b      	ldr	r4, [pc, #44]	; (800c7d0 <__kernel_cosf+0x180>)
 800c7a4:	e7db      	b.n	800c75e <__kernel_cosf+0x10e>
 800c7a6:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800c7aa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800c7ae:	bf00      	nop
 800c7b0:	ad47d74e 	.word	0xad47d74e
 800c7b4:	310f74f6 	.word	0x310f74f6
 800c7b8:	3493f27c 	.word	0x3493f27c
 800c7bc:	37d00d01 	.word	0x37d00d01
 800c7c0:	3ab60b61 	.word	0x3ab60b61
 800c7c4:	3d2aaaab 	.word	0x3d2aaaab
 800c7c8:	3e999999 	.word	0x3e999999
 800c7cc:	3f480000 	.word	0x3f480000
 800c7d0:	3e900000 	.word	0x3e900000
 800c7d4:	3f380000 	.word	0x3f380000
	...

0800c7e0 <__kernel_rem_pio2f>:
 800c7e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c7e4:	461c      	mov	r4, r3
 800c7e6:	b0df      	sub	sp, #380	; 0x17c
 800c7e8:	9108      	str	r1, [sp, #32]
 800c7ea:	1e61      	subs	r1, r4, #1
 800c7ec:	9101      	str	r1, [sp, #4]
 800c7ee:	930a      	str	r3, [sp, #40]	; 0x28
 800c7f0:	9968      	ldr	r1, [sp, #416]	; 0x1a0
 800c7f2:	4bba      	ldr	r3, [pc, #744]	; (800cadc <__kernel_rem_pio2f+0x2fc>)
 800c7f4:	9003      	str	r0, [sp, #12]
 800c7f6:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 800c7fa:	9801      	ldr	r0, [sp, #4]
 800c7fc:	9307      	str	r3, [sp, #28]
 800c7fe:	1ed3      	subs	r3, r2, #3
 800c800:	bf48      	it	mi
 800c802:	1d13      	addmi	r3, r2, #4
 800c804:	10db      	asrs	r3, r3, #3
 800c806:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800c80a:	4619      	mov	r1, r3
 800c80c:	930c      	str	r3, [sp, #48]	; 0x30
 800c80e:	43db      	mvns	r3, r3
 800c810:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800c814:	9306      	str	r3, [sp, #24]
 800c816:	9b07      	ldr	r3, [sp, #28]
 800c818:	1a0d      	subs	r5, r1, r0
 800c81a:	18c4      	adds	r4, r0, r3
 800c81c:	d415      	bmi.n	800c84a <__kernel_rem_pio2f+0x6a>
 800c81e:	442c      	add	r4, r5
 800c820:	3401      	adds	r4, #1
 800c822:	ae21      	add	r6, sp, #132	; 0x84
 800c824:	9f69      	ldr	r7, [sp, #420]	; 0x1a4
 800c826:	e008      	b.n	800c83a <__kernel_rem_pio2f+0x5a>
 800c828:	f857 0025 	ldr.w	r0, [r7, r5, lsl #2]
 800c82c:	f7f4 faa2 	bl	8000d74 <__aeabi_i2f>
 800c830:	3501      	adds	r5, #1
 800c832:	42a5      	cmp	r5, r4
 800c834:	f846 0f04 	str.w	r0, [r6, #4]!
 800c838:	d007      	beq.n	800c84a <__kernel_rem_pio2f+0x6a>
 800c83a:	2d00      	cmp	r5, #0
 800c83c:	daf4      	bge.n	800c828 <__kernel_rem_pio2f+0x48>
 800c83e:	3501      	adds	r5, #1
 800c840:	2000      	movs	r0, #0
 800c842:	42a5      	cmp	r5, r4
 800c844:	f846 0f04 	str.w	r0, [r6, #4]!
 800c848:	d1f7      	bne.n	800c83a <__kernel_rem_pio2f+0x5a>
 800c84a:	9b07      	ldr	r3, [sp, #28]
 800c84c:	2b00      	cmp	r3, #0
 800c84e:	db2c      	blt.n	800c8aa <__kernel_rem_pio2f+0xca>
 800c850:	9b07      	ldr	r3, [sp, #28]
 800c852:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800c854:	4619      	mov	r1, r3
 800c856:	9b01      	ldr	r3, [sp, #4]
 800c858:	eb01 0802 	add.w	r8, r1, r2
 800c85c:	ebc2 7782 	rsb	r7, r2, r2, lsl #30
 800c860:	aa22      	add	r2, sp, #136	; 0x88
 800c862:	eb02 0583 	add.w	r5, r2, r3, lsl #2
 800c866:	eb02 0888 	add.w	r8, r2, r8, lsl #2
 800c86a:	00bf      	lsls	r7, r7, #2
 800c86c:	ae49      	add	r6, sp, #292	; 0x124
 800c86e:	9b01      	ldr	r3, [sp, #4]
 800c870:	2b00      	cmp	r3, #0
 800c872:	f2c0 81f5 	blt.w	800cc60 <__kernel_rem_pio2f+0x480>
 800c876:	462c      	mov	r4, r5
 800c878:	9b03      	ldr	r3, [sp, #12]
 800c87a:	eb05 0907 	add.w	r9, r5, r7
 800c87e:	f1a3 0b04 	sub.w	fp, r3, #4
 800c882:	f04f 0a00 	mov.w	sl, #0
 800c886:	f854 0904 	ldr.w	r0, [r4], #-4
 800c88a:	f85b 1f04 	ldr.w	r1, [fp, #4]!
 800c88e:	f7f4 fac7 	bl	8000e20 <__aeabi_fmul>
 800c892:	4601      	mov	r1, r0
 800c894:	4650      	mov	r0, sl
 800c896:	f7f4 f9b9 	bl	8000c0c <__addsf3>
 800c89a:	454c      	cmp	r4, r9
 800c89c:	4682      	mov	sl, r0
 800c89e:	d1f2      	bne.n	800c886 <__kernel_rem_pio2f+0xa6>
 800c8a0:	3504      	adds	r5, #4
 800c8a2:	4545      	cmp	r5, r8
 800c8a4:	f846 af04 	str.w	sl, [r6, #4]!
 800c8a8:	d1e1      	bne.n	800c86e <__kernel_rem_pio2f+0x8e>
 800c8aa:	9b07      	ldr	r3, [sp, #28]
 800c8ac:	a90e      	add	r1, sp, #56	; 0x38
 800c8ae:	461d      	mov	r5, r3
 800c8b0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800c8b4:	3b01      	subs	r3, #1
 800c8b6:	009b      	lsls	r3, r3, #2
 800c8b8:	1d1a      	adds	r2, r3, #4
 800c8ba:	440a      	add	r2, r1
 800c8bc:	440b      	add	r3, r1
 800c8be:	920d      	str	r2, [sp, #52]	; 0x34
 800c8c0:	930b      	str	r3, [sp, #44]	; 0x2c
 800c8c2:	00ab      	lsls	r3, r5, #2
 800c8c4:	a95e      	add	r1, sp, #376	; 0x178
 800c8c6:	461a      	mov	r2, r3
 800c8c8:	9302      	str	r3, [sp, #8]
 800c8ca:	2d00      	cmp	r5, #0
 800c8cc:	440b      	add	r3, r1
 800c8ce:	f853 8c50 	ldr.w	r8, [r3, #-80]
 800c8d2:	dd20      	ble.n	800c916 <__kernel_rem_pio2f+0x136>
 800c8d4:	af4a      	add	r7, sp, #296	; 0x128
 800c8d6:	18bc      	adds	r4, r7, r2
 800c8d8:	ae0d      	add	r6, sp, #52	; 0x34
 800c8da:	f04f 516e 	mov.w	r1, #998244352	; 0x3b800000
 800c8de:	4640      	mov	r0, r8
 800c8e0:	f7f4 fa9e 	bl	8000e20 <__aeabi_fmul>
 800c8e4:	f7f4 fc64 	bl	80011b0 <__aeabi_f2iz>
 800c8e8:	f7f4 fa44 	bl	8000d74 <__aeabi_i2f>
 800c8ec:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 800c8f0:	4681      	mov	r9, r0
 800c8f2:	f7f4 fa95 	bl	8000e20 <__aeabi_fmul>
 800c8f6:	4601      	mov	r1, r0
 800c8f8:	4640      	mov	r0, r8
 800c8fa:	f7f4 f985 	bl	8000c08 <__aeabi_fsub>
 800c8fe:	f7f4 fc57 	bl	80011b0 <__aeabi_f2iz>
 800c902:	f854 1d04 	ldr.w	r1, [r4, #-4]!
 800c906:	f846 0f04 	str.w	r0, [r6, #4]!
 800c90a:	4648      	mov	r0, r9
 800c90c:	f7f4 f97e 	bl	8000c0c <__addsf3>
 800c910:	42bc      	cmp	r4, r7
 800c912:	4680      	mov	r8, r0
 800c914:	d1e1      	bne.n	800c8da <__kernel_rem_pio2f+0xfa>
 800c916:	9e06      	ldr	r6, [sp, #24]
 800c918:	4640      	mov	r0, r8
 800c91a:	4631      	mov	r1, r6
 800c91c:	f000 fcb0 	bl	800d280 <scalbnf>
 800c920:	f04f 5178 	mov.w	r1, #1040187392	; 0x3e000000
 800c924:	4604      	mov	r4, r0
 800c926:	f7f4 fa7b 	bl	8000e20 <__aeabi_fmul>
 800c92a:	f000 fc41 	bl	800d1b0 <floorf>
 800c92e:	f04f 4182 	mov.w	r1, #1090519040	; 0x41000000
 800c932:	f7f4 fa75 	bl	8000e20 <__aeabi_fmul>
 800c936:	4601      	mov	r1, r0
 800c938:	4620      	mov	r0, r4
 800c93a:	f7f4 f965 	bl	8000c08 <__aeabi_fsub>
 800c93e:	4604      	mov	r4, r0
 800c940:	f7f4 fc36 	bl	80011b0 <__aeabi_f2iz>
 800c944:	4607      	mov	r7, r0
 800c946:	f7f4 fa15 	bl	8000d74 <__aeabi_i2f>
 800c94a:	4601      	mov	r1, r0
 800c94c:	4620      	mov	r0, r4
 800c94e:	f7f4 f95b 	bl	8000c08 <__aeabi_fsub>
 800c952:	2e00      	cmp	r6, #0
 800c954:	4680      	mov	r8, r0
 800c956:	4634      	mov	r4, r6
 800c958:	f340 816a 	ble.w	800cc30 <__kernel_rem_pio2f+0x450>
 800c95c:	1e69      	subs	r1, r5, #1
 800c95e:	ab0e      	add	r3, sp, #56	; 0x38
 800c960:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 800c964:	f1c6 0008 	rsb	r0, r6, #8
 800c968:	fa43 f200 	asr.w	r2, r3, r0
 800c96c:	fa02 f600 	lsl.w	r6, r2, r0
 800c970:	1b9e      	subs	r6, r3, r6
 800c972:	a80e      	add	r0, sp, #56	; 0x38
 800c974:	f1c4 0307 	rsb	r3, r4, #7
 800c978:	f840 6021 	str.w	r6, [r0, r1, lsl #2]
 800c97c:	4417      	add	r7, r2
 800c97e:	411e      	asrs	r6, r3
 800c980:	2e00      	cmp	r6, #0
 800c982:	dd2f      	ble.n	800c9e4 <__kernel_rem_pio2f+0x204>
 800c984:	2d00      	cmp	r5, #0
 800c986:	f107 0701 	add.w	r7, r7, #1
 800c98a:	f340 81f4 	ble.w	800cd76 <__kernel_rem_pio2f+0x596>
 800c98e:	2200      	movs	r2, #0
 800c990:	4614      	mov	r4, r2
 800c992:	a90d      	add	r1, sp, #52	; 0x34
 800c994:	e007      	b.n	800c9a6 <__kernel_rem_pio2f+0x1c6>
 800c996:	f5c3 7080 	rsb	r0, r3, #256	; 0x100
 800c99a:	b10b      	cbz	r3, 800c9a0 <__kernel_rem_pio2f+0x1c0>
 800c99c:	6008      	str	r0, [r1, #0]
 800c99e:	2401      	movs	r4, #1
 800c9a0:	3201      	adds	r2, #1
 800c9a2:	4295      	cmp	r5, r2
 800c9a4:	dd0b      	ble.n	800c9be <__kernel_rem_pio2f+0x1de>
 800c9a6:	f851 3f04 	ldr.w	r3, [r1, #4]!
 800c9aa:	2c00      	cmp	r4, #0
 800c9ac:	d0f3      	beq.n	800c996 <__kernel_rem_pio2f+0x1b6>
 800c9ae:	3201      	adds	r2, #1
 800c9b0:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 800c9b4:	4295      	cmp	r5, r2
 800c9b6:	600b      	str	r3, [r1, #0]
 800c9b8:	f04f 0401 	mov.w	r4, #1
 800c9bc:	dcf3      	bgt.n	800c9a6 <__kernel_rem_pio2f+0x1c6>
 800c9be:	9b06      	ldr	r3, [sp, #24]
 800c9c0:	2b00      	cmp	r3, #0
 800c9c2:	dd0d      	ble.n	800c9e0 <__kernel_rem_pio2f+0x200>
 800c9c4:	2b01      	cmp	r3, #1
 800c9c6:	f000 813a 	beq.w	800cc3e <__kernel_rem_pio2f+0x45e>
 800c9ca:	2b02      	cmp	r3, #2
 800c9cc:	d108      	bne.n	800c9e0 <__kernel_rem_pio2f+0x200>
 800c9ce:	1e6a      	subs	r2, r5, #1
 800c9d0:	ab0e      	add	r3, sp, #56	; 0x38
 800c9d2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800c9d6:	a90e      	add	r1, sp, #56	; 0x38
 800c9d8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800c9dc:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
 800c9e0:	2e02      	cmp	r6, #2
 800c9e2:	d07d      	beq.n	800cae0 <__kernel_rem_pio2f+0x300>
 800c9e4:	4640      	mov	r0, r8
 800c9e6:	2100      	movs	r1, #0
 800c9e8:	f7f4 fbae 	bl	8001148 <__aeabi_fcmpeq>
 800c9ec:	2800      	cmp	r0, #0
 800c9ee:	f000 8091 	beq.w	800cb14 <__kernel_rem_pio2f+0x334>
 800c9f2:	9b07      	ldr	r3, [sp, #28]
 800c9f4:	1e6c      	subs	r4, r5, #1
 800c9f6:	42a3      	cmp	r3, r4
 800c9f8:	dc0d      	bgt.n	800ca16 <__kernel_rem_pio2f+0x236>
 800c9fa:	9b02      	ldr	r3, [sp, #8]
 800c9fc:	aa0e      	add	r2, sp, #56	; 0x38
 800c9fe:	980d      	ldr	r0, [sp, #52]	; 0x34
 800ca00:	4413      	add	r3, r2
 800ca02:	2200      	movs	r2, #0
 800ca04:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 800ca08:	4283      	cmp	r3, r0
 800ca0a:	ea42 0201 	orr.w	r2, r2, r1
 800ca0e:	d1f9      	bne.n	800ca04 <__kernel_rem_pio2f+0x224>
 800ca10:	2a00      	cmp	r2, #0
 800ca12:	f040 8199 	bne.w	800cd48 <__kernel_rem_pio2f+0x568>
 800ca16:	9b07      	ldr	r3, [sp, #28]
 800ca18:	aa0e      	add	r2, sp, #56	; 0x38
 800ca1a:	3b01      	subs	r3, #1
 800ca1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800ca20:	2b00      	cmp	r3, #0
 800ca22:	f040 81a6 	bne.w	800cd72 <__kernel_rem_pio2f+0x592>
 800ca26:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800ca28:	2301      	movs	r3, #1
 800ca2a:	f852 1d04 	ldr.w	r1, [r2, #-4]!
 800ca2e:	3301      	adds	r3, #1
 800ca30:	2900      	cmp	r1, #0
 800ca32:	d0fa      	beq.n	800ca2a <__kernel_rem_pio2f+0x24a>
 800ca34:	18eb      	adds	r3, r5, r3
 800ca36:	461a      	mov	r2, r3
 800ca38:	9309      	str	r3, [sp, #36]	; 0x24
 800ca3a:	1c6b      	adds	r3, r5, #1
 800ca3c:	4293      	cmp	r3, r2
 800ca3e:	dc41      	bgt.n	800cac4 <__kernel_rem_pio2f+0x2e4>
 800ca40:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800ca42:	189e      	adds	r6, r3, r2
 800ca44:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800ca46:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800ca48:	eb05 0b03 	add.w	fp, r5, r3
 800ca4c:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
 800ca50:	1b55      	subs	r5, r2, r5
 800ca52:	9a69      	ldr	r2, [sp, #420]	; 0x1a4
 800ca54:	3e01      	subs	r6, #1
 800ca56:	eb02 0686 	add.w	r6, r2, r6, lsl #2
 800ca5a:	00aa      	lsls	r2, r5, #2
 800ca5c:	ea4f 038b 	mov.w	r3, fp, lsl #2
 800ca60:	9204      	str	r2, [sp, #16]
 800ca62:	aa22      	add	r2, sp, #136	; 0x88
 800ca64:	eb02 0903 	add.w	r9, r2, r3
 800ca68:	9305      	str	r3, [sp, #20]
 800ca6a:	9b02      	ldr	r3, [sp, #8]
 800ca6c:	aa4a      	add	r2, sp, #296	; 0x128
 800ca6e:	eb02 0803 	add.w	r8, r2, r3
 800ca72:	2500      	movs	r5, #0
 800ca74:	f856 0f04 	ldr.w	r0, [r6, #4]!
 800ca78:	f7f4 f97c 	bl	8000d74 <__aeabi_i2f>
 800ca7c:	9b01      	ldr	r3, [sp, #4]
 800ca7e:	f849 0b04 	str.w	r0, [r9], #4
 800ca82:	2b00      	cmp	r3, #0
 800ca84:	db20      	blt.n	800cac8 <__kernel_rem_pio2f+0x2e8>
 800ca86:	9a02      	ldr	r2, [sp, #8]
 800ca88:	9b05      	ldr	r3, [sp, #20]
 800ca8a:	18ac      	adds	r4, r5, r2
 800ca8c:	18eb      	adds	r3, r5, r3
 800ca8e:	aa22      	add	r2, sp, #136	; 0x88
 800ca90:	18d7      	adds	r7, r2, r3
 800ca92:	9b03      	ldr	r3, [sp, #12]
 800ca94:	f04f 0b00 	mov.w	fp, #0
 800ca98:	4414      	add	r4, r2
 800ca9a:	f1a3 0a04 	sub.w	sl, r3, #4
 800ca9e:	f857 0904 	ldr.w	r0, [r7], #-4
 800caa2:	f85a 1f04 	ldr.w	r1, [sl, #4]!
 800caa6:	f7f4 f9bb 	bl	8000e20 <__aeabi_fmul>
 800caaa:	4601      	mov	r1, r0
 800caac:	4658      	mov	r0, fp
 800caae:	f7f4 f8ad 	bl	8000c0c <__addsf3>
 800cab2:	42a7      	cmp	r7, r4
 800cab4:	4683      	mov	fp, r0
 800cab6:	d1f2      	bne.n	800ca9e <__kernel_rem_pio2f+0x2be>
 800cab8:	9b04      	ldr	r3, [sp, #16]
 800caba:	3504      	adds	r5, #4
 800cabc:	429d      	cmp	r5, r3
 800cabe:	f848 bf04 	str.w	fp, [r8, #4]!
 800cac2:	d1d7      	bne.n	800ca74 <__kernel_rem_pio2f+0x294>
 800cac4:	9d09      	ldr	r5, [sp, #36]	; 0x24
 800cac6:	e6fc      	b.n	800c8c2 <__kernel_rem_pio2f+0xe2>
 800cac8:	9b04      	ldr	r3, [sp, #16]
 800caca:	3504      	adds	r5, #4
 800cacc:	f04f 0b00 	mov.w	fp, #0
 800cad0:	429d      	cmp	r5, r3
 800cad2:	f848 bf04 	str.w	fp, [r8, #4]!
 800cad6:	d1cd      	bne.n	800ca74 <__kernel_rem_pio2f+0x294>
 800cad8:	e7f4      	b.n	800cac4 <__kernel_rem_pio2f+0x2e4>
 800cada:	bf00      	nop
 800cadc:	0800ece0 	.word	0x0800ece0
 800cae0:	4641      	mov	r1, r8
 800cae2:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800cae6:	f7f4 f88f 	bl	8000c08 <__aeabi_fsub>
 800caea:	4680      	mov	r8, r0
 800caec:	2c00      	cmp	r4, #0
 800caee:	f43f af79 	beq.w	800c9e4 <__kernel_rem_pio2f+0x204>
 800caf2:	9906      	ldr	r1, [sp, #24]
 800caf4:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800caf8:	f000 fbc2 	bl	800d280 <scalbnf>
 800cafc:	4601      	mov	r1, r0
 800cafe:	4640      	mov	r0, r8
 800cb00:	f7f4 f882 	bl	8000c08 <__aeabi_fsub>
 800cb04:	4680      	mov	r8, r0
 800cb06:	2100      	movs	r1, #0
 800cb08:	4640      	mov	r0, r8
 800cb0a:	f7f4 fb1d 	bl	8001148 <__aeabi_fcmpeq>
 800cb0e:	2800      	cmp	r0, #0
 800cb10:	f47f af6f 	bne.w	800c9f2 <__kernel_rem_pio2f+0x212>
 800cb14:	9b06      	ldr	r3, [sp, #24]
 800cb16:	4640      	mov	r0, r8
 800cb18:	4259      	negs	r1, r3
 800cb1a:	9702      	str	r7, [sp, #8]
 800cb1c:	f000 fbb0 	bl	800d280 <scalbnf>
 800cb20:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 800cb24:	4604      	mov	r4, r0
 800cb26:	f7f4 fb2d 	bl	8001184 <__aeabi_fcmpge>
 800cb2a:	2800      	cmp	r0, #0
 800cb2c:	f000 8187 	beq.w	800ce3e <__kernel_rem_pio2f+0x65e>
 800cb30:	f04f 516e 	mov.w	r1, #998244352	; 0x3b800000
 800cb34:	4620      	mov	r0, r4
 800cb36:	f7f4 f973 	bl	8000e20 <__aeabi_fmul>
 800cb3a:	f7f4 fb39 	bl	80011b0 <__aeabi_f2iz>
 800cb3e:	f7f4 f919 	bl	8000d74 <__aeabi_i2f>
 800cb42:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 800cb46:	4607      	mov	r7, r0
 800cb48:	f7f4 f96a 	bl	8000e20 <__aeabi_fmul>
 800cb4c:	4601      	mov	r1, r0
 800cb4e:	4620      	mov	r0, r4
 800cb50:	f7f4 f85a 	bl	8000c08 <__aeabi_fsub>
 800cb54:	f7f4 fb2c 	bl	80011b0 <__aeabi_f2iz>
 800cb58:	ab0e      	add	r3, sp, #56	; 0x38
 800cb5a:	f843 0025 	str.w	r0, [r3, r5, lsl #2]
 800cb5e:	4638      	mov	r0, r7
 800cb60:	f7f4 fb26 	bl	80011b0 <__aeabi_f2iz>
 800cb64:	9b06      	ldr	r3, [sp, #24]
 800cb66:	1c6c      	adds	r4, r5, #1
 800cb68:	3308      	adds	r3, #8
 800cb6a:	9306      	str	r3, [sp, #24]
 800cb6c:	ab0e      	add	r3, sp, #56	; 0x38
 800cb6e:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
 800cb72:	9906      	ldr	r1, [sp, #24]
 800cb74:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800cb78:	f000 fb82 	bl	800d280 <scalbnf>
 800cb7c:	2c00      	cmp	r4, #0
 800cb7e:	4607      	mov	r7, r0
 800cb80:	f2c0 80cb 	blt.w	800cd1a <__kernel_rem_pio2f+0x53a>
 800cb84:	1c63      	adds	r3, r4, #1
 800cb86:	009d      	lsls	r5, r3, #2
 800cb88:	9301      	str	r3, [sp, #4]
 800cb8a:	ab0e      	add	r3, sp, #56	; 0x38
 800cb8c:	eb03 0a05 	add.w	sl, r3, r5
 800cb90:	ab4a      	add	r3, sp, #296	; 0x128
 800cb92:	eb03 0905 	add.w	r9, r3, r5
 800cb96:	f85a 0d04 	ldr.w	r0, [sl, #-4]!
 800cb9a:	f7f4 f8eb 	bl	8000d74 <__aeabi_i2f>
 800cb9e:	4639      	mov	r1, r7
 800cba0:	f7f4 f93e 	bl	8000e20 <__aeabi_fmul>
 800cba4:	f04f 516e 	mov.w	r1, #998244352	; 0x3b800000
 800cba8:	f849 0d04 	str.w	r0, [r9, #-4]!
 800cbac:	4638      	mov	r0, r7
 800cbae:	f7f4 f937 	bl	8000e20 <__aeabi_fmul>
 800cbb2:	ab0e      	add	r3, sp, #56	; 0x38
 800cbb4:	459a      	cmp	sl, r3
 800cbb6:	4607      	mov	r7, r0
 800cbb8:	d1ed      	bne.n	800cb96 <__kernel_rem_pio2f+0x3b6>
 800cbba:	3d08      	subs	r5, #8
 800cbbc:	ab4a      	add	r3, sp, #296	; 0x128
 800cbbe:	f8dd a01c 	ldr.w	sl, [sp, #28]
 800cbc2:	f8dd b004 	ldr.w	fp, [sp, #4]
 800cbc6:	eb03 0905 	add.w	r9, r3, r5
 800cbca:	2700      	movs	r7, #0
 800cbcc:	9603      	str	r6, [sp, #12]
 800cbce:	9404      	str	r4, [sp, #16]
 800cbd0:	f1ba 0f00 	cmp.w	sl, #0
 800cbd4:	f2c0 809e 	blt.w	800cd14 <__kernel_rem_pio2f+0x534>
 800cbd8:	2f00      	cmp	r7, #0
 800cbda:	f2c0 809b 	blt.w	800cd14 <__kernel_rem_pio2f+0x534>
 800cbde:	4e9c      	ldr	r6, [pc, #624]	; (800ce50 <__kernel_rem_pio2f+0x670>)
 800cbe0:	464c      	mov	r4, r9
 800cbe2:	f04f 0800 	mov.w	r8, #0
 800cbe6:	2500      	movs	r5, #0
 800cbe8:	e001      	b.n	800cbee <__kernel_rem_pio2f+0x40e>
 800cbea:	42bd      	cmp	r5, r7
 800cbec:	dc0d      	bgt.n	800cc0a <__kernel_rem_pio2f+0x42a>
 800cbee:	f854 1f04 	ldr.w	r1, [r4, #4]!
 800cbf2:	f856 0b04 	ldr.w	r0, [r6], #4
 800cbf6:	f7f4 f913 	bl	8000e20 <__aeabi_fmul>
 800cbfa:	4601      	mov	r1, r0
 800cbfc:	4640      	mov	r0, r8
 800cbfe:	f7f4 f805 	bl	8000c0c <__addsf3>
 800cc02:	3501      	adds	r5, #1
 800cc04:	45aa      	cmp	sl, r5
 800cc06:	4680      	mov	r8, r0
 800cc08:	daef      	bge.n	800cbea <__kernel_rem_pio2f+0x40a>
 800cc0a:	ab5e      	add	r3, sp, #376	; 0x178
 800cc0c:	eb03 0387 	add.w	r3, r3, r7, lsl #2
 800cc10:	3701      	adds	r7, #1
 800cc12:	455f      	cmp	r7, fp
 800cc14:	f1a9 0904 	sub.w	r9, r9, #4
 800cc18:	f843 8ca0 	str.w	r8, [r3, #-160]
 800cc1c:	d1d8      	bne.n	800cbd0 <__kernel_rem_pio2f+0x3f0>
 800cc1e:	9b68      	ldr	r3, [sp, #416]	; 0x1a0
 800cc20:	9e03      	ldr	r6, [sp, #12]
 800cc22:	9c04      	ldr	r4, [sp, #16]
 800cc24:	2b03      	cmp	r3, #3
 800cc26:	d858      	bhi.n	800ccda <__kernel_rem_pio2f+0x4fa>
 800cc28:	e8df f003 	tbb	[pc, r3]
 800cc2c:	a732325d 	.word	0xa732325d
 800cc30:	d10f      	bne.n	800cc52 <__kernel_rem_pio2f+0x472>
 800cc32:	1e6b      	subs	r3, r5, #1
 800cc34:	aa0e      	add	r2, sp, #56	; 0x38
 800cc36:	f852 6023 	ldr.w	r6, [r2, r3, lsl #2]
 800cc3a:	1236      	asrs	r6, r6, #8
 800cc3c:	e6a0      	b.n	800c980 <__kernel_rem_pio2f+0x1a0>
 800cc3e:	1e6a      	subs	r2, r5, #1
 800cc40:	ab0e      	add	r3, sp, #56	; 0x38
 800cc42:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800cc46:	a90e      	add	r1, sp, #56	; 0x38
 800cc48:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800cc4c:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
 800cc50:	e6c6      	b.n	800c9e0 <__kernel_rem_pio2f+0x200>
 800cc52:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800cc56:	f7f4 fa95 	bl	8001184 <__aeabi_fcmpge>
 800cc5a:	b950      	cbnz	r0, 800cc72 <__kernel_rem_pio2f+0x492>
 800cc5c:	4606      	mov	r6, r0
 800cc5e:	e6c1      	b.n	800c9e4 <__kernel_rem_pio2f+0x204>
 800cc60:	3504      	adds	r5, #4
 800cc62:	f04f 0a00 	mov.w	sl, #0
 800cc66:	4545      	cmp	r5, r8
 800cc68:	f846 af04 	str.w	sl, [r6, #4]!
 800cc6c:	f47f adff 	bne.w	800c86e <__kernel_rem_pio2f+0x8e>
 800cc70:	e61b      	b.n	800c8aa <__kernel_rem_pio2f+0xca>
 800cc72:	2d00      	cmp	r5, #0
 800cc74:	f107 0701 	add.w	r7, r7, #1
 800cc78:	bfc8      	it	gt
 800cc7a:	2602      	movgt	r6, #2
 800cc7c:	f73f ae87 	bgt.w	800c98e <__kernel_rem_pio2f+0x1ae>
 800cc80:	4641      	mov	r1, r8
 800cc82:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800cc86:	f7f3 ffbf 	bl	8000c08 <__aeabi_fsub>
 800cc8a:	2602      	movs	r6, #2
 800cc8c:	4680      	mov	r8, r0
 800cc8e:	e6a9      	b.n	800c9e4 <__kernel_rem_pio2f+0x204>
 800cc90:	9b01      	ldr	r3, [sp, #4]
 800cc92:	ad36      	add	r5, sp, #216	; 0xd8
 800cc94:	eb05 0883 	add.w	r8, r5, r3, lsl #2
 800cc98:	2000      	movs	r0, #0
 800cc9a:	f858 1d04 	ldr.w	r1, [r8, #-4]!
 800cc9e:	f7f3 ffb5 	bl	8000c0c <__addsf3>
 800cca2:	45a8      	cmp	r8, r5
 800cca4:	d1f9      	bne.n	800cc9a <__kernel_rem_pio2f+0x4ba>
 800cca6:	2e00      	cmp	r6, #0
 800cca8:	d041      	beq.n	800cd2e <__kernel_rem_pio2f+0x54e>
 800ccaa:	9a08      	ldr	r2, [sp, #32]
 800ccac:	f100 4300 	add.w	r3, r0, #2147483648	; 0x80000000
 800ccb0:	4601      	mov	r1, r0
 800ccb2:	6013      	str	r3, [r2, #0]
 800ccb4:	9836      	ldr	r0, [sp, #216]	; 0xd8
 800ccb6:	f7f3 ffa7 	bl	8000c08 <__aeabi_fsub>
 800ccba:	2c00      	cmp	r4, #0
 800ccbc:	dd09      	ble.n	800ccd2 <__kernel_rem_pio2f+0x4f2>
 800ccbe:	af36      	add	r7, sp, #216	; 0xd8
 800ccc0:	2501      	movs	r5, #1
 800ccc2:	3501      	adds	r5, #1
 800ccc4:	f857 1f04 	ldr.w	r1, [r7, #4]!
 800ccc8:	f7f3 ffa0 	bl	8000c0c <__addsf3>
 800cccc:	42ac      	cmp	r4, r5
 800ccce:	daf8      	bge.n	800ccc2 <__kernel_rem_pio2f+0x4e2>
 800ccd0:	b10e      	cbz	r6, 800ccd6 <__kernel_rem_pio2f+0x4f6>
 800ccd2:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 800ccd6:	9b08      	ldr	r3, [sp, #32]
 800ccd8:	6058      	str	r0, [r3, #4]
 800ccda:	9b02      	ldr	r3, [sp, #8]
 800ccdc:	f003 0007 	and.w	r0, r3, #7
 800cce0:	b05f      	add	sp, #380	; 0x17c
 800cce2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800cce6:	9b01      	ldr	r3, [sp, #4]
 800cce8:	aa36      	add	r2, sp, #216	; 0xd8
 800ccea:	2000      	movs	r0, #0
 800ccec:	eb02 0883 	add.w	r8, r2, r3, lsl #2
 800ccf0:	3c01      	subs	r4, #1
 800ccf2:	f858 1d04 	ldr.w	r1, [r8, #-4]!
 800ccf6:	f7f3 ff89 	bl	8000c0c <__addsf3>
 800ccfa:	1c63      	adds	r3, r4, #1
 800ccfc:	d1f8      	bne.n	800ccf0 <__kernel_rem_pio2f+0x510>
 800ccfe:	b10e      	cbz	r6, 800cd04 <__kernel_rem_pio2f+0x524>
 800cd00:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 800cd04:	9b08      	ldr	r3, [sp, #32]
 800cd06:	6018      	str	r0, [r3, #0]
 800cd08:	9b02      	ldr	r3, [sp, #8]
 800cd0a:	f003 0007 	and.w	r0, r3, #7
 800cd0e:	b05f      	add	sp, #380	; 0x17c
 800cd10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800cd14:	f04f 0800 	mov.w	r8, #0
 800cd18:	e777      	b.n	800cc0a <__kernel_rem_pio2f+0x42a>
 800cd1a:	9b68      	ldr	r3, [sp, #416]	; 0x1a0
 800cd1c:	2b03      	cmp	r3, #3
 800cd1e:	d8dc      	bhi.n	800ccda <__kernel_rem_pio2f+0x4fa>
 800cd20:	e8df f003 	tbb	[pc, r3]
 800cd24:	87020210 	.word	0x87020210
 800cd28:	2000      	movs	r0, #0
 800cd2a:	2e00      	cmp	r6, #0
 800cd2c:	d1bd      	bne.n	800ccaa <__kernel_rem_pio2f+0x4ca>
 800cd2e:	9b08      	ldr	r3, [sp, #32]
 800cd30:	4601      	mov	r1, r0
 800cd32:	6018      	str	r0, [r3, #0]
 800cd34:	9836      	ldr	r0, [sp, #216]	; 0xd8
 800cd36:	f7f3 ff67 	bl	8000c08 <__aeabi_fsub>
 800cd3a:	2c00      	cmp	r4, #0
 800cd3c:	dcbf      	bgt.n	800ccbe <__kernel_rem_pio2f+0x4de>
 800cd3e:	9b08      	ldr	r3, [sp, #32]
 800cd40:	6058      	str	r0, [r3, #4]
 800cd42:	e7ca      	b.n	800ccda <__kernel_rem_pio2f+0x4fa>
 800cd44:	2000      	movs	r0, #0
 800cd46:	e7da      	b.n	800ccfe <__kernel_rem_pio2f+0x51e>
 800cd48:	9a06      	ldr	r2, [sp, #24]
 800cd4a:	ab0e      	add	r3, sp, #56	; 0x38
 800cd4c:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 800cd50:	3a08      	subs	r2, #8
 800cd52:	9702      	str	r7, [sp, #8]
 800cd54:	9206      	str	r2, [sp, #24]
 800cd56:	2b00      	cmp	r3, #0
 800cd58:	f47f af0b 	bne.w	800cb72 <__kernel_rem_pio2f+0x392>
 800cd5c:	ab0e      	add	r3, sp, #56	; 0x38
 800cd5e:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 800cd62:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 800cd66:	3c01      	subs	r4, #1
 800cd68:	3a08      	subs	r2, #8
 800cd6a:	2900      	cmp	r1, #0
 800cd6c:	d0f9      	beq.n	800cd62 <__kernel_rem_pio2f+0x582>
 800cd6e:	9206      	str	r2, [sp, #24]
 800cd70:	e6ff      	b.n	800cb72 <__kernel_rem_pio2f+0x392>
 800cd72:	2301      	movs	r3, #1
 800cd74:	e65e      	b.n	800ca34 <__kernel_rem_pio2f+0x254>
 800cd76:	2400      	movs	r4, #0
 800cd78:	e621      	b.n	800c9be <__kernel_rem_pio2f+0x1de>
 800cd7a:	2c00      	cmp	r4, #0
 800cd7c:	dd59      	ble.n	800ce32 <__kernel_rem_pio2f+0x652>
 800cd7e:	00a5      	lsls	r5, r4, #2
 800cd80:	ab5e      	add	r3, sp, #376	; 0x178
 800cd82:	442b      	add	r3, r5
 800cd84:	f10d 08d8 	add.w	r8, sp, #216	; 0xd8
 800cd88:	f853 9ca0 	ldr.w	r9, [r3, #-160]
 800cd8c:	eb08 0705 	add.w	r7, r8, r5
 800cd90:	f857 bd04 	ldr.w	fp, [r7, #-4]!
 800cd94:	4648      	mov	r0, r9
 800cd96:	4659      	mov	r1, fp
 800cd98:	f7f3 ff38 	bl	8000c0c <__addsf3>
 800cd9c:	4682      	mov	sl, r0
 800cd9e:	4658      	mov	r0, fp
 800cda0:	4651      	mov	r1, sl
 800cda2:	f7f3 ff31 	bl	8000c08 <__aeabi_fsub>
 800cda6:	4601      	mov	r1, r0
 800cda8:	4648      	mov	r0, r9
 800cdaa:	f7f3 ff2f 	bl	8000c0c <__addsf3>
 800cdae:	4547      	cmp	r7, r8
 800cdb0:	46d1      	mov	r9, sl
 800cdb2:	6078      	str	r0, [r7, #4]
 800cdb4:	f8c7 a000 	str.w	sl, [r7]
 800cdb8:	d1ea      	bne.n	800cd90 <__kernel_rem_pio2f+0x5b0>
 800cdba:	2c01      	cmp	r4, #1
 800cdbc:	dd39      	ble.n	800ce32 <__kernel_rem_pio2f+0x652>
 800cdbe:	ab5e      	add	r3, sp, #376	; 0x178
 800cdc0:	442b      	add	r3, r5
 800cdc2:	f853 4ca0 	ldr.w	r4, [r3, #-160]
 800cdc6:	eb08 0705 	add.w	r7, r8, r5
 800cdca:	f10d 0bdc 	add.w	fp, sp, #220	; 0xdc
 800cdce:	f857 ad04 	ldr.w	sl, [r7, #-4]!
 800cdd2:	4621      	mov	r1, r4
 800cdd4:	4650      	mov	r0, sl
 800cdd6:	f7f3 ff19 	bl	8000c0c <__addsf3>
 800cdda:	4681      	mov	r9, r0
 800cddc:	4650      	mov	r0, sl
 800cdde:	4649      	mov	r1, r9
 800cde0:	f7f3 ff12 	bl	8000c08 <__aeabi_fsub>
 800cde4:	4621      	mov	r1, r4
 800cde6:	f7f3 ff11 	bl	8000c0c <__addsf3>
 800cdea:	455f      	cmp	r7, fp
 800cdec:	464c      	mov	r4, r9
 800cdee:	6078      	str	r0, [r7, #4]
 800cdf0:	f8c7 9000 	str.w	r9, [r7]
 800cdf4:	d1eb      	bne.n	800cdce <__kernel_rem_pio2f+0x5ee>
 800cdf6:	3504      	adds	r5, #4
 800cdf8:	eb08 0405 	add.w	r4, r8, r5
 800cdfc:	2000      	movs	r0, #0
 800cdfe:	ad38      	add	r5, sp, #224	; 0xe0
 800ce00:	f854 1d04 	ldr.w	r1, [r4, #-4]!
 800ce04:	f7f3 ff02 	bl	8000c0c <__addsf3>
 800ce08:	42ac      	cmp	r4, r5
 800ce0a:	d1f9      	bne.n	800ce00 <__kernel_rem_pio2f+0x620>
 800ce0c:	b1a6      	cbz	r6, 800ce38 <__kernel_rem_pio2f+0x658>
 800ce0e:	9a36      	ldr	r2, [sp, #216]	; 0xd8
 800ce10:	9b37      	ldr	r3, [sp, #220]	; 0xdc
 800ce12:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 800ce16:	f102 4200 	add.w	r2, r2, #2147483648	; 0x80000000
 800ce1a:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 800ce1e:	9c08      	ldr	r4, [sp, #32]
 800ce20:	6063      	str	r3, [r4, #4]
 800ce22:	9b02      	ldr	r3, [sp, #8]
 800ce24:	60a0      	str	r0, [r4, #8]
 800ce26:	f003 0007 	and.w	r0, r3, #7
 800ce2a:	6022      	str	r2, [r4, #0]
 800ce2c:	b05f      	add	sp, #380	; 0x17c
 800ce2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ce32:	2000      	movs	r0, #0
 800ce34:	2e00      	cmp	r6, #0
 800ce36:	d1ea      	bne.n	800ce0e <__kernel_rem_pio2f+0x62e>
 800ce38:	9a36      	ldr	r2, [sp, #216]	; 0xd8
 800ce3a:	9b37      	ldr	r3, [sp, #220]	; 0xdc
 800ce3c:	e7ef      	b.n	800ce1e <__kernel_rem_pio2f+0x63e>
 800ce3e:	4620      	mov	r0, r4
 800ce40:	f7f4 f9b6 	bl	80011b0 <__aeabi_f2iz>
 800ce44:	ab0e      	add	r3, sp, #56	; 0x38
 800ce46:	462c      	mov	r4, r5
 800ce48:	f843 0025 	str.w	r0, [r3, r5, lsl #2]
 800ce4c:	e691      	b.n	800cb72 <__kernel_rem_pio2f+0x392>
 800ce4e:	bf00      	nop
 800ce50:	0800ecf0 	.word	0x0800ecf0
	...

0800ce60 <__kernel_sinf>:
 800ce60:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800ce64:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
 800ce68:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 800ce6c:	4604      	mov	r4, r0
 800ce6e:	460f      	mov	r7, r1
 800ce70:	4690      	mov	r8, r2
 800ce72:	da03      	bge.n	800ce7c <__kernel_sinf+0x1c>
 800ce74:	f7f4 f99c 	bl	80011b0 <__aeabi_f2iz>
 800ce78:	2800      	cmp	r0, #0
 800ce7a:	d057      	beq.n	800cf2c <__kernel_sinf+0xcc>
 800ce7c:	4621      	mov	r1, r4
 800ce7e:	4620      	mov	r0, r4
 800ce80:	f7f3 ffce 	bl	8000e20 <__aeabi_fmul>
 800ce84:	4621      	mov	r1, r4
 800ce86:	4605      	mov	r5, r0
 800ce88:	f7f3 ffca 	bl	8000e20 <__aeabi_fmul>
 800ce8c:	4929      	ldr	r1, [pc, #164]	; (800cf34 <__kernel_sinf+0xd4>)
 800ce8e:	4606      	mov	r6, r0
 800ce90:	4628      	mov	r0, r5
 800ce92:	f7f3 ffc5 	bl	8000e20 <__aeabi_fmul>
 800ce96:	4928      	ldr	r1, [pc, #160]	; (800cf38 <__kernel_sinf+0xd8>)
 800ce98:	f7f3 feb6 	bl	8000c08 <__aeabi_fsub>
 800ce9c:	4629      	mov	r1, r5
 800ce9e:	f7f3 ffbf 	bl	8000e20 <__aeabi_fmul>
 800cea2:	4926      	ldr	r1, [pc, #152]	; (800cf3c <__kernel_sinf+0xdc>)
 800cea4:	f7f3 feb2 	bl	8000c0c <__addsf3>
 800cea8:	4629      	mov	r1, r5
 800ceaa:	f7f3 ffb9 	bl	8000e20 <__aeabi_fmul>
 800ceae:	4924      	ldr	r1, [pc, #144]	; (800cf40 <__kernel_sinf+0xe0>)
 800ceb0:	f7f3 feaa 	bl	8000c08 <__aeabi_fsub>
 800ceb4:	4629      	mov	r1, r5
 800ceb6:	f7f3 ffb3 	bl	8000e20 <__aeabi_fmul>
 800ceba:	4922      	ldr	r1, [pc, #136]	; (800cf44 <__kernel_sinf+0xe4>)
 800cebc:	f7f3 fea6 	bl	8000c0c <__addsf3>
 800cec0:	4681      	mov	r9, r0
 800cec2:	f1b8 0f00 	cmp.w	r8, #0
 800cec6:	d022      	beq.n	800cf0e <__kernel_sinf+0xae>
 800cec8:	4638      	mov	r0, r7
 800ceca:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800cece:	f7f3 ffa7 	bl	8000e20 <__aeabi_fmul>
 800ced2:	4649      	mov	r1, r9
 800ced4:	4680      	mov	r8, r0
 800ced6:	4630      	mov	r0, r6
 800ced8:	f7f3 ffa2 	bl	8000e20 <__aeabi_fmul>
 800cedc:	4601      	mov	r1, r0
 800cede:	4640      	mov	r0, r8
 800cee0:	f7f3 fe92 	bl	8000c08 <__aeabi_fsub>
 800cee4:	4629      	mov	r1, r5
 800cee6:	f7f3 ff9b 	bl	8000e20 <__aeabi_fmul>
 800ceea:	4639      	mov	r1, r7
 800ceec:	f7f3 fe8c 	bl	8000c08 <__aeabi_fsub>
 800cef0:	4915      	ldr	r1, [pc, #84]	; (800cf48 <__kernel_sinf+0xe8>)
 800cef2:	4605      	mov	r5, r0
 800cef4:	4630      	mov	r0, r6
 800cef6:	f7f3 ff93 	bl	8000e20 <__aeabi_fmul>
 800cefa:	4601      	mov	r1, r0
 800cefc:	4628      	mov	r0, r5
 800cefe:	f7f3 fe85 	bl	8000c0c <__addsf3>
 800cf02:	4601      	mov	r1, r0
 800cf04:	4620      	mov	r0, r4
 800cf06:	f7f3 fe7f 	bl	8000c08 <__aeabi_fsub>
 800cf0a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800cf0e:	4649      	mov	r1, r9
 800cf10:	4628      	mov	r0, r5
 800cf12:	f7f3 ff85 	bl	8000e20 <__aeabi_fmul>
 800cf16:	490c      	ldr	r1, [pc, #48]	; (800cf48 <__kernel_sinf+0xe8>)
 800cf18:	f7f3 fe76 	bl	8000c08 <__aeabi_fsub>
 800cf1c:	4631      	mov	r1, r6
 800cf1e:	f7f3 ff7f 	bl	8000e20 <__aeabi_fmul>
 800cf22:	4621      	mov	r1, r4
 800cf24:	f7f3 fe72 	bl	8000c0c <__addsf3>
 800cf28:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800cf2c:	4620      	mov	r0, r4
 800cf2e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800cf32:	bf00      	nop
 800cf34:	2f2ec9d3 	.word	0x2f2ec9d3
 800cf38:	32d72f34 	.word	0x32d72f34
 800cf3c:	3638ef1b 	.word	0x3638ef1b
 800cf40:	39500d01 	.word	0x39500d01
 800cf44:	3c088889 	.word	0x3c088889
 800cf48:	3e2aaaab 	.word	0x3e2aaaab
 800cf4c:	00000000 	.word	0x00000000

0800cf50 <matherr>:
 800cf50:	2000      	movs	r0, #0
 800cf52:	4770      	bx	lr
	...

0800cf60 <nan>:
 800cf60:	2000      	movs	r0, #0
 800cf62:	4901      	ldr	r1, [pc, #4]	; (800cf68 <nan+0x8>)
 800cf64:	4770      	bx	lr
 800cf66:	bf00      	nop
 800cf68:	7ff80000 	.word	0x7ff80000
 800cf6c:	00000000 	.word	0x00000000

0800cf70 <atanf>:
 800cf70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800cf74:	f020 4500 	bic.w	r5, r0, #2147483648	; 0x80000000
 800cf78:	f1b5 4fa1 	cmp.w	r5, #1350565888	; 0x50800000
 800cf7c:	4604      	mov	r4, r0
 800cf7e:	4606      	mov	r6, r0
 800cf80:	db08      	blt.n	800cf94 <atanf+0x24>
 800cf82:	f1b5 4fff 	cmp.w	r5, #2139095040	; 0x7f800000
 800cf86:	dc6f      	bgt.n	800d068 <atanf+0xf8>
 800cf88:	2800      	cmp	r0, #0
 800cf8a:	f340 80a0 	ble.w	800d0ce <atanf+0x15e>
 800cf8e:	486f      	ldr	r0, [pc, #444]	; (800d14c <atanf+0x1dc>)
 800cf90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800cf94:	4b6e      	ldr	r3, [pc, #440]	; (800d150 <atanf+0x1e0>)
 800cf96:	429d      	cmp	r5, r3
 800cf98:	dc77      	bgt.n	800d08a <atanf+0x11a>
 800cf9a:	f1b5 5f44 	cmp.w	r5, #822083584	; 0x31000000
 800cf9e:	db68      	blt.n	800d072 <atanf+0x102>
 800cfa0:	f04f 37ff 	mov.w	r7, #4294967295
 800cfa4:	4621      	mov	r1, r4
 800cfa6:	4620      	mov	r0, r4
 800cfa8:	f7f3 ff3a 	bl	8000e20 <__aeabi_fmul>
 800cfac:	4601      	mov	r1, r0
 800cfae:	4680      	mov	r8, r0
 800cfb0:	f7f3 ff36 	bl	8000e20 <__aeabi_fmul>
 800cfb4:	4605      	mov	r5, r0
 800cfb6:	4967      	ldr	r1, [pc, #412]	; (800d154 <atanf+0x1e4>)
 800cfb8:	f7f3 ff32 	bl	8000e20 <__aeabi_fmul>
 800cfbc:	4966      	ldr	r1, [pc, #408]	; (800d158 <atanf+0x1e8>)
 800cfbe:	f7f3 fe25 	bl	8000c0c <__addsf3>
 800cfc2:	4629      	mov	r1, r5
 800cfc4:	f7f3 ff2c 	bl	8000e20 <__aeabi_fmul>
 800cfc8:	4964      	ldr	r1, [pc, #400]	; (800d15c <atanf+0x1ec>)
 800cfca:	f7f3 fe1f 	bl	8000c0c <__addsf3>
 800cfce:	4629      	mov	r1, r5
 800cfd0:	f7f3 ff26 	bl	8000e20 <__aeabi_fmul>
 800cfd4:	4962      	ldr	r1, [pc, #392]	; (800d160 <atanf+0x1f0>)
 800cfd6:	f7f3 fe19 	bl	8000c0c <__addsf3>
 800cfda:	4629      	mov	r1, r5
 800cfdc:	f7f3 ff20 	bl	8000e20 <__aeabi_fmul>
 800cfe0:	4960      	ldr	r1, [pc, #384]	; (800d164 <atanf+0x1f4>)
 800cfe2:	f7f3 fe13 	bl	8000c0c <__addsf3>
 800cfe6:	4629      	mov	r1, r5
 800cfe8:	f7f3 ff1a 	bl	8000e20 <__aeabi_fmul>
 800cfec:	495e      	ldr	r1, [pc, #376]	; (800d168 <atanf+0x1f8>)
 800cfee:	f7f3 fe0d 	bl	8000c0c <__addsf3>
 800cff2:	4641      	mov	r1, r8
 800cff4:	f7f3 ff14 	bl	8000e20 <__aeabi_fmul>
 800cff8:	495c      	ldr	r1, [pc, #368]	; (800d16c <atanf+0x1fc>)
 800cffa:	4680      	mov	r8, r0
 800cffc:	4628      	mov	r0, r5
 800cffe:	f7f3 ff0f 	bl	8000e20 <__aeabi_fmul>
 800d002:	495b      	ldr	r1, [pc, #364]	; (800d170 <atanf+0x200>)
 800d004:	f7f3 fe00 	bl	8000c08 <__aeabi_fsub>
 800d008:	4629      	mov	r1, r5
 800d00a:	f7f3 ff09 	bl	8000e20 <__aeabi_fmul>
 800d00e:	4959      	ldr	r1, [pc, #356]	; (800d174 <atanf+0x204>)
 800d010:	f7f3 fdfa 	bl	8000c08 <__aeabi_fsub>
 800d014:	4629      	mov	r1, r5
 800d016:	f7f3 ff03 	bl	8000e20 <__aeabi_fmul>
 800d01a:	4957      	ldr	r1, [pc, #348]	; (800d178 <atanf+0x208>)
 800d01c:	f7f3 fdf4 	bl	8000c08 <__aeabi_fsub>
 800d020:	4629      	mov	r1, r5
 800d022:	f7f3 fefd 	bl	8000e20 <__aeabi_fmul>
 800d026:	4955      	ldr	r1, [pc, #340]	; (800d17c <atanf+0x20c>)
 800d028:	f7f3 fdee 	bl	8000c08 <__aeabi_fsub>
 800d02c:	4629      	mov	r1, r5
 800d02e:	f7f3 fef7 	bl	8000e20 <__aeabi_fmul>
 800d032:	1c7b      	adds	r3, r7, #1
 800d034:	4601      	mov	r1, r0
 800d036:	4640      	mov	r0, r8
 800d038:	d04c      	beq.n	800d0d4 <atanf+0x164>
 800d03a:	f7f3 fde7 	bl	8000c0c <__addsf3>
 800d03e:	4621      	mov	r1, r4
 800d040:	f7f3 feee 	bl	8000e20 <__aeabi_fmul>
 800d044:	4b4e      	ldr	r3, [pc, #312]	; (800d180 <atanf+0x210>)
 800d046:	4d4f      	ldr	r5, [pc, #316]	; (800d184 <atanf+0x214>)
 800d048:	f853 1027 	ldr.w	r1, [r3, r7, lsl #2]
 800d04c:	f7f3 fddc 	bl	8000c08 <__aeabi_fsub>
 800d050:	4621      	mov	r1, r4
 800d052:	f7f3 fdd9 	bl	8000c08 <__aeabi_fsub>
 800d056:	4601      	mov	r1, r0
 800d058:	f855 0027 	ldr.w	r0, [r5, r7, lsl #2]
 800d05c:	f7f3 fdd4 	bl	8000c08 <__aeabi_fsub>
 800d060:	2e00      	cmp	r6, #0
 800d062:	db30      	blt.n	800d0c6 <atanf+0x156>
 800d064:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d068:	4601      	mov	r1, r0
 800d06a:	f7f3 fdcf 	bl	8000c0c <__addsf3>
 800d06e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d072:	4945      	ldr	r1, [pc, #276]	; (800d188 <atanf+0x218>)
 800d074:	f7f3 fdca 	bl	8000c0c <__addsf3>
 800d078:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800d07c:	f7f4 f88c 	bl	8001198 <__aeabi_fcmpgt>
 800d080:	2800      	cmp	r0, #0
 800d082:	d08d      	beq.n	800cfa0 <atanf+0x30>
 800d084:	4620      	mov	r0, r4
 800d086:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d08a:	f000 f889 	bl	800d1a0 <fabsf>
 800d08e:	4b3f      	ldr	r3, [pc, #252]	; (800d18c <atanf+0x21c>)
 800d090:	4604      	mov	r4, r0
 800d092:	429d      	cmp	r5, r3
 800d094:	dc29      	bgt.n	800d0ea <atanf+0x17a>
 800d096:	f5a3 03d0 	sub.w	r3, r3, #6815744	; 0x680000
 800d09a:	429d      	cmp	r5, r3
 800d09c:	dc44      	bgt.n	800d128 <atanf+0x1b8>
 800d09e:	4601      	mov	r1, r0
 800d0a0:	f7f3 fdb4 	bl	8000c0c <__addsf3>
 800d0a4:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800d0a8:	f7f3 fdae 	bl	8000c08 <__aeabi_fsub>
 800d0ac:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 800d0b0:	4605      	mov	r5, r0
 800d0b2:	4620      	mov	r0, r4
 800d0b4:	f7f3 fdaa 	bl	8000c0c <__addsf3>
 800d0b8:	4601      	mov	r1, r0
 800d0ba:	4628      	mov	r0, r5
 800d0bc:	f7f3 ff64 	bl	8000f88 <__aeabi_fdiv>
 800d0c0:	2700      	movs	r7, #0
 800d0c2:	4604      	mov	r4, r0
 800d0c4:	e76e      	b.n	800cfa4 <atanf+0x34>
 800d0c6:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 800d0ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d0ce:	4830      	ldr	r0, [pc, #192]	; (800d190 <atanf+0x220>)
 800d0d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d0d4:	f7f3 fd9a 	bl	8000c0c <__addsf3>
 800d0d8:	4621      	mov	r1, r4
 800d0da:	f7f3 fea1 	bl	8000e20 <__aeabi_fmul>
 800d0de:	4601      	mov	r1, r0
 800d0e0:	4620      	mov	r0, r4
 800d0e2:	f7f3 fd91 	bl	8000c08 <__aeabi_fsub>
 800d0e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d0ea:	4b2a      	ldr	r3, [pc, #168]	; (800d194 <atanf+0x224>)
 800d0ec:	429d      	cmp	r5, r3
 800d0ee:	dc14      	bgt.n	800d11a <atanf+0x1aa>
 800d0f0:	f04f 517f 	mov.w	r1, #1069547520	; 0x3fc00000
 800d0f4:	f7f3 fd88 	bl	8000c08 <__aeabi_fsub>
 800d0f8:	f04f 517f 	mov.w	r1, #1069547520	; 0x3fc00000
 800d0fc:	4605      	mov	r5, r0
 800d0fe:	4620      	mov	r0, r4
 800d100:	f7f3 fe8e 	bl	8000e20 <__aeabi_fmul>
 800d104:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800d108:	f7f3 fd80 	bl	8000c0c <__addsf3>
 800d10c:	4601      	mov	r1, r0
 800d10e:	4628      	mov	r0, r5
 800d110:	f7f3 ff3a 	bl	8000f88 <__aeabi_fdiv>
 800d114:	2702      	movs	r7, #2
 800d116:	4604      	mov	r4, r0
 800d118:	e744      	b.n	800cfa4 <atanf+0x34>
 800d11a:	4601      	mov	r1, r0
 800d11c:	481e      	ldr	r0, [pc, #120]	; (800d198 <atanf+0x228>)
 800d11e:	f7f3 ff33 	bl	8000f88 <__aeabi_fdiv>
 800d122:	2703      	movs	r7, #3
 800d124:	4604      	mov	r4, r0
 800d126:	e73d      	b.n	800cfa4 <atanf+0x34>
 800d128:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800d12c:	f7f3 fd6c 	bl	8000c08 <__aeabi_fsub>
 800d130:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800d134:	4605      	mov	r5, r0
 800d136:	4620      	mov	r0, r4
 800d138:	f7f3 fd68 	bl	8000c0c <__addsf3>
 800d13c:	4601      	mov	r1, r0
 800d13e:	4628      	mov	r0, r5
 800d140:	f7f3 ff22 	bl	8000f88 <__aeabi_fdiv>
 800d144:	2701      	movs	r7, #1
 800d146:	4604      	mov	r4, r0
 800d148:	e72c      	b.n	800cfa4 <atanf+0x34>
 800d14a:	bf00      	nop
 800d14c:	3fc90fdb 	.word	0x3fc90fdb
 800d150:	3edfffff 	.word	0x3edfffff
 800d154:	3c8569d7 	.word	0x3c8569d7
 800d158:	3d4bda59 	.word	0x3d4bda59
 800d15c:	3d886b35 	.word	0x3d886b35
 800d160:	3dba2e6e 	.word	0x3dba2e6e
 800d164:	3e124925 	.word	0x3e124925
 800d168:	3eaaaaab 	.word	0x3eaaaaab
 800d16c:	bd15a221 	.word	0xbd15a221
 800d170:	3d6ef16b 	.word	0x3d6ef16b
 800d174:	3d9d8795 	.word	0x3d9d8795
 800d178:	3de38e38 	.word	0x3de38e38
 800d17c:	3e4ccccd 	.word	0x3e4ccccd
 800d180:	0800ed20 	.word	0x0800ed20
 800d184:	0800ed30 	.word	0x0800ed30
 800d188:	7149f2ca 	.word	0x7149f2ca
 800d18c:	3f97ffff 	.word	0x3f97ffff
 800d190:	bfc90fdb 	.word	0xbfc90fdb
 800d194:	401bffff 	.word	0x401bffff
 800d198:	bf800000 	.word	0xbf800000
 800d19c:	00000000 	.word	0x00000000

0800d1a0 <fabsf>:
 800d1a0:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 800d1a4:	4770      	bx	lr
 800d1a6:	bf00      	nop
	...

0800d1b0 <floorf>:
 800d1b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d1b4:	f020 4700 	bic.w	r7, r0, #2147483648	; 0x80000000
 800d1b8:	0dfc      	lsrs	r4, r7, #23
 800d1ba:	3c7f      	subs	r4, #127	; 0x7f
 800d1bc:	2c16      	cmp	r4, #22
 800d1be:	4605      	mov	r5, r0
 800d1c0:	dc13      	bgt.n	800d1ea <floorf+0x3a>
 800d1c2:	2c00      	cmp	r4, #0
 800d1c4:	4680      	mov	r8, r0
 800d1c6:	db1b      	blt.n	800d200 <floorf+0x50>
 800d1c8:	4f19      	ldr	r7, [pc, #100]	; (800d230 <floorf+0x80>)
 800d1ca:	4127      	asrs	r7, r4
 800d1cc:	4207      	tst	r7, r0
 800d1ce:	d014      	beq.n	800d1fa <floorf+0x4a>
 800d1d0:	4918      	ldr	r1, [pc, #96]	; (800d234 <floorf+0x84>)
 800d1d2:	f7f3 fd1b 	bl	8000c0c <__addsf3>
 800d1d6:	2100      	movs	r1, #0
 800d1d8:	f7f3 ffde 	bl	8001198 <__aeabi_fcmpgt>
 800d1dc:	b168      	cbz	r0, 800d1fa <floorf+0x4a>
 800d1de:	2d00      	cmp	r5, #0
 800d1e0:	db1b      	blt.n	800d21a <floorf+0x6a>
 800d1e2:	ea28 0007 	bic.w	r0, r8, r7
 800d1e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d1ea:	f1b7 4fff 	cmp.w	r7, #2139095040	; 0x7f800000
 800d1ee:	d304      	bcc.n	800d1fa <floorf+0x4a>
 800d1f0:	4601      	mov	r1, r0
 800d1f2:	f7f3 fd0b 	bl	8000c0c <__addsf3>
 800d1f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d1fa:	4628      	mov	r0, r5
 800d1fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d200:	490c      	ldr	r1, [pc, #48]	; (800d234 <floorf+0x84>)
 800d202:	f7f3 fd03 	bl	8000c0c <__addsf3>
 800d206:	2100      	movs	r1, #0
 800d208:	f7f3 ffc6 	bl	8001198 <__aeabi_fcmpgt>
 800d20c:	2800      	cmp	r0, #0
 800d20e:	d0f4      	beq.n	800d1fa <floorf+0x4a>
 800d210:	2d00      	cmp	r5, #0
 800d212:	db07      	blt.n	800d224 <floorf+0x74>
 800d214:	2000      	movs	r0, #0
 800d216:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d21a:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
 800d21e:	4123      	asrs	r3, r4
 800d220:	4498      	add	r8, r3
 800d222:	e7de      	b.n	800d1e2 <floorf+0x32>
 800d224:	2f00      	cmp	r7, #0
 800d226:	d0e8      	beq.n	800d1fa <floorf+0x4a>
 800d228:	4803      	ldr	r0, [pc, #12]	; (800d238 <floorf+0x88>)
 800d22a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d22e:	bf00      	nop
 800d230:	007fffff 	.word	0x007fffff
 800d234:	7149f2ca 	.word	0x7149f2ca
 800d238:	bf800000 	.word	0xbf800000
 800d23c:	00000000 	.word	0x00000000

0800d240 <__fpclassifyf>:
 800d240:	f030 4000 	bics.w	r0, r0, #2147483648	; 0x80000000
 800d244:	d101      	bne.n	800d24a <__fpclassifyf+0xa>
 800d246:	2002      	movs	r0, #2
 800d248:	4770      	bx	lr
 800d24a:	f5a0 0300 	sub.w	r3, r0, #8388608	; 0x800000
 800d24e:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
 800d252:	d201      	bcs.n	800d258 <__fpclassifyf+0x18>
 800d254:	2004      	movs	r0, #4
 800d256:	4770      	bx	lr
 800d258:	4b05      	ldr	r3, [pc, #20]	; (800d270 <__fpclassifyf+0x30>)
 800d25a:	1e42      	subs	r2, r0, #1
 800d25c:	429a      	cmp	r2, r3
 800d25e:	d801      	bhi.n	800d264 <__fpclassifyf+0x24>
 800d260:	2003      	movs	r0, #3
 800d262:	4770      	bx	lr
 800d264:	f1a0 40ff 	sub.w	r0, r0, #2139095040	; 0x7f800000
 800d268:	fab0 f080 	clz	r0, r0
 800d26c:	0940      	lsrs	r0, r0, #5
 800d26e:	4770      	bx	lr
 800d270:	007ffffe 	.word	0x007ffffe
	...

0800d280 <scalbnf>:
 800d280:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 800d284:	b538      	push	{r3, r4, r5, lr}
 800d286:	4603      	mov	r3, r0
 800d288:	4604      	mov	r4, r0
 800d28a:	d015      	beq.n	800d2b8 <scalbnf+0x38>
 800d28c:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 800d290:	d20e      	bcs.n	800d2b0 <scalbnf+0x30>
 800d292:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 800d296:	460d      	mov	r5, r1
 800d298:	d30f      	bcc.n	800d2ba <scalbnf+0x3a>
 800d29a:	0dd2      	lsrs	r2, r2, #23
 800d29c:	442a      	add	r2, r5
 800d29e:	2afe      	cmp	r2, #254	; 0xfe
 800d2a0:	dc2e      	bgt.n	800d300 <scalbnf+0x80>
 800d2a2:	2a00      	cmp	r2, #0
 800d2a4:	dd1d      	ble.n	800d2e2 <scalbnf+0x62>
 800d2a6:	f024 44ff 	bic.w	r4, r4, #2139095040	; 0x7f800000
 800d2aa:	ea44 50c2 	orr.w	r0, r4, r2, lsl #23
 800d2ae:	bd38      	pop	{r3, r4, r5, pc}
 800d2b0:	4601      	mov	r1, r0
 800d2b2:	f7f3 fcab 	bl	8000c0c <__addsf3>
 800d2b6:	bd38      	pop	{r3, r4, r5, pc}
 800d2b8:	bd38      	pop	{r3, r4, r5, pc}
 800d2ba:	f04f 4198 	mov.w	r1, #1275068416	; 0x4c000000
 800d2be:	f7f3 fdaf 	bl	8000e20 <__aeabi_fmul>
 800d2c2:	4a18      	ldr	r2, [pc, #96]	; (800d324 <scalbnf+0xa4>)
 800d2c4:	4603      	mov	r3, r0
 800d2c6:	4295      	cmp	r5, r2
 800d2c8:	db07      	blt.n	800d2da <scalbnf+0x5a>
 800d2ca:	f3c0 52c7 	ubfx	r2, r0, #23, #8
 800d2ce:	4604      	mov	r4, r0
 800d2d0:	3a19      	subs	r2, #25
 800d2d2:	e7e3      	b.n	800d29c <scalbnf+0x1c>
 800d2d4:	4814      	ldr	r0, [pc, #80]	; (800d328 <scalbnf+0xa8>)
 800d2d6:	f000 f82b 	bl	800d330 <copysignf>
 800d2da:	4913      	ldr	r1, [pc, #76]	; (800d328 <scalbnf+0xa8>)
 800d2dc:	f7f3 fda0 	bl	8000e20 <__aeabi_fmul>
 800d2e0:	bd38      	pop	{r3, r4, r5, pc}
 800d2e2:	f112 0f16 	cmn.w	r2, #22
 800d2e6:	da13      	bge.n	800d310 <scalbnf+0x90>
 800d2e8:	f24c 3250 	movw	r2, #50000	; 0xc350
 800d2ec:	4295      	cmp	r5, r2
 800d2ee:	4619      	mov	r1, r3
 800d2f0:	ddf0      	ble.n	800d2d4 <scalbnf+0x54>
 800d2f2:	480e      	ldr	r0, [pc, #56]	; (800d32c <scalbnf+0xac>)
 800d2f4:	f000 f81c 	bl	800d330 <copysignf>
 800d2f8:	490c      	ldr	r1, [pc, #48]	; (800d32c <scalbnf+0xac>)
 800d2fa:	f7f3 fd91 	bl	8000e20 <__aeabi_fmul>
 800d2fe:	bd38      	pop	{r3, r4, r5, pc}
 800d300:	4619      	mov	r1, r3
 800d302:	480a      	ldr	r0, [pc, #40]	; (800d32c <scalbnf+0xac>)
 800d304:	f000 f814 	bl	800d330 <copysignf>
 800d308:	4908      	ldr	r1, [pc, #32]	; (800d32c <scalbnf+0xac>)
 800d30a:	f7f3 fd89 	bl	8000e20 <__aeabi_fmul>
 800d30e:	bd38      	pop	{r3, r4, r5, pc}
 800d310:	3219      	adds	r2, #25
 800d312:	f024 40ff 	bic.w	r0, r4, #2139095040	; 0x7f800000
 800d316:	ea40 50c2 	orr.w	r0, r0, r2, lsl #23
 800d31a:	f04f 514c 	mov.w	r1, #855638016	; 0x33000000
 800d31e:	f7f3 fd7f 	bl	8000e20 <__aeabi_fmul>
 800d322:	bd38      	pop	{r3, r4, r5, pc}
 800d324:	ffff3cb0 	.word	0xffff3cb0
 800d328:	0da24260 	.word	0x0da24260
 800d32c:	7149f2ca 	.word	0x7149f2ca

0800d330 <copysignf>:
 800d330:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800d334:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 800d338:	4308      	orrs	r0, r1
 800d33a:	4770      	bx	lr
 800d33c:	0000      	movs	r0, r0
	...

0800d340 <__errno>:
 800d340:	4b01      	ldr	r3, [pc, #4]	; (800d348 <__errno+0x8>)
 800d342:	6818      	ldr	r0, [r3, #0]
 800d344:	4770      	bx	lr
 800d346:	bf00      	nop
 800d348:	20001158 	.word	0x20001158
 800d34c:	00000000 	.word	0x00000000

0800d350 <memset>:
 800d350:	b470      	push	{r4, r5, r6}
 800d352:	0784      	lsls	r4, r0, #30
 800d354:	d046      	beq.n	800d3e4 <memset+0x94>
 800d356:	1e54      	subs	r4, r2, #1
 800d358:	2a00      	cmp	r2, #0
 800d35a:	d041      	beq.n	800d3e0 <memset+0x90>
 800d35c:	b2cd      	uxtb	r5, r1
 800d35e:	4603      	mov	r3, r0
 800d360:	e002      	b.n	800d368 <memset+0x18>
 800d362:	1e62      	subs	r2, r4, #1
 800d364:	b3e4      	cbz	r4, 800d3e0 <memset+0x90>
 800d366:	4614      	mov	r4, r2
 800d368:	f803 5b01 	strb.w	r5, [r3], #1
 800d36c:	079a      	lsls	r2, r3, #30
 800d36e:	d1f8      	bne.n	800d362 <memset+0x12>
 800d370:	2c03      	cmp	r4, #3
 800d372:	d92e      	bls.n	800d3d2 <memset+0x82>
 800d374:	b2cd      	uxtb	r5, r1
 800d376:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800d37a:	2c0f      	cmp	r4, #15
 800d37c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 800d380:	d919      	bls.n	800d3b6 <memset+0x66>
 800d382:	4626      	mov	r6, r4
 800d384:	f103 0210 	add.w	r2, r3, #16
 800d388:	3e10      	subs	r6, #16
 800d38a:	2e0f      	cmp	r6, #15
 800d38c:	f842 5c10 	str.w	r5, [r2, #-16]
 800d390:	f842 5c0c 	str.w	r5, [r2, #-12]
 800d394:	f842 5c08 	str.w	r5, [r2, #-8]
 800d398:	f842 5c04 	str.w	r5, [r2, #-4]
 800d39c:	f102 0210 	add.w	r2, r2, #16
 800d3a0:	d8f2      	bhi.n	800d388 <memset+0x38>
 800d3a2:	f1a4 0210 	sub.w	r2, r4, #16
 800d3a6:	f022 020f 	bic.w	r2, r2, #15
 800d3aa:	f004 040f 	and.w	r4, r4, #15
 800d3ae:	3210      	adds	r2, #16
 800d3b0:	2c03      	cmp	r4, #3
 800d3b2:	4413      	add	r3, r2
 800d3b4:	d90d      	bls.n	800d3d2 <memset+0x82>
 800d3b6:	461e      	mov	r6, r3
 800d3b8:	4622      	mov	r2, r4
 800d3ba:	3a04      	subs	r2, #4
 800d3bc:	2a03      	cmp	r2, #3
 800d3be:	f846 5b04 	str.w	r5, [r6], #4
 800d3c2:	d8fa      	bhi.n	800d3ba <memset+0x6a>
 800d3c4:	1f22      	subs	r2, r4, #4
 800d3c6:	f022 0203 	bic.w	r2, r2, #3
 800d3ca:	3204      	adds	r2, #4
 800d3cc:	4413      	add	r3, r2
 800d3ce:	f004 0403 	and.w	r4, r4, #3
 800d3d2:	b12c      	cbz	r4, 800d3e0 <memset+0x90>
 800d3d4:	b2c9      	uxtb	r1, r1
 800d3d6:	441c      	add	r4, r3
 800d3d8:	f803 1b01 	strb.w	r1, [r3], #1
 800d3dc:	42a3      	cmp	r3, r4
 800d3de:	d1fb      	bne.n	800d3d8 <memset+0x88>
 800d3e0:	bc70      	pop	{r4, r5, r6}
 800d3e2:	4770      	bx	lr
 800d3e4:	4614      	mov	r4, r2
 800d3e6:	4603      	mov	r3, r0
 800d3e8:	e7c2      	b.n	800d370 <memset+0x20>
 800d3ea:	bf00      	nop
 800d3ec:	0000      	movs	r0, r0
	...

0800d3f0 <strlen>:
 800d3f0:	f020 0103 	bic.w	r1, r0, #3
 800d3f4:	f010 0003 	ands.w	r0, r0, #3
 800d3f8:	f1c0 0000 	rsb	r0, r0, #0
 800d3fc:	f851 3b04 	ldr.w	r3, [r1], #4
 800d400:	f100 0c04 	add.w	ip, r0, #4
 800d404:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 800d408:	f06f 0200 	mvn.w	r2, #0
 800d40c:	bf1c      	itt	ne
 800d40e:	fa22 f20c 	lsrne.w	r2, r2, ip
 800d412:	4313      	orrne	r3, r2
 800d414:	f04f 0c01 	mov.w	ip, #1
 800d418:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 800d41c:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 800d420:	eba3 020c 	sub.w	r2, r3, ip
 800d424:	ea22 0203 	bic.w	r2, r2, r3
 800d428:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 800d42c:	bf04      	itt	eq
 800d42e:	f851 3b04 	ldreq.w	r3, [r1], #4
 800d432:	3004      	addeq	r0, #4
 800d434:	d0f4      	beq.n	800d420 <strlen+0x30>
 800d436:	f1c2 0100 	rsb	r1, r2, #0
 800d43a:	ea02 0201 	and.w	r2, r2, r1
 800d43e:	fab2 f282 	clz	r2, r2
 800d442:	f1c2 021f 	rsb	r2, r2, #31
 800d446:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 800d44a:	4770      	bx	lr
 800d44c:	0000      	movs	r0, r0
	...

0800d450 <strpbrk>:
 800d450:	b430      	push	{r4, r5}
 800d452:	7804      	ldrb	r4, [r0, #0]
 800d454:	b1ec      	cbz	r4, 800d492 <strpbrk+0x42>
 800d456:	780d      	ldrb	r5, [r1, #0]
 800d458:	b1ad      	cbz	r5, 800d486 <strpbrk+0x36>
 800d45a:	42ac      	cmp	r4, r5
 800d45c:	d00e      	beq.n	800d47c <strpbrk+0x2c>
 800d45e:	460a      	mov	r2, r1
 800d460:	e001      	b.n	800d466 <strpbrk+0x16>
 800d462:	429c      	cmp	r4, r3
 800d464:	d009      	beq.n	800d47a <strpbrk+0x2a>
 800d466:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800d46a:	2b00      	cmp	r3, #0
 800d46c:	d1f9      	bne.n	800d462 <strpbrk+0x12>
 800d46e:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 800d472:	2c00      	cmp	r4, #0
 800d474:	d1f0      	bne.n	800d458 <strpbrk+0x8>
 800d476:	7815      	ldrb	r5, [r2, #0]
 800d478:	e000      	b.n	800d47c <strpbrk+0x2c>
 800d47a:	4625      	mov	r5, r4
 800d47c:	2d00      	cmp	r5, #0
 800d47e:	bf08      	it	eq
 800d480:	2000      	moveq	r0, #0
 800d482:	bc30      	pop	{r4, r5}
 800d484:	4770      	bx	lr
 800d486:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 800d48a:	460a      	mov	r2, r1
 800d48c:	2c00      	cmp	r4, #0
 800d48e:	d1e3      	bne.n	800d458 <strpbrk+0x8>
 800d490:	e7f1      	b.n	800d476 <strpbrk+0x26>
 800d492:	4620      	mov	r0, r4
 800d494:	bc30      	pop	{r4, r5}
 800d496:	4770      	bx	lr
	...

0800d4a0 <strspn>:
 800d4a0:	b470      	push	{r4, r5, r6}
 800d4a2:	7804      	ldrb	r4, [r0, #0]
 800d4a4:	b1a4      	cbz	r4, 800d4d0 <strspn+0x30>
 800d4a6:	4605      	mov	r5, r0
 800d4a8:	780e      	ldrb	r6, [r1, #0]
 800d4aa:	b14e      	cbz	r6, 800d4c0 <strspn+0x20>
 800d4ac:	42b4      	cmp	r4, r6
 800d4ae:	d00a      	beq.n	800d4c6 <strspn+0x26>
 800d4b0:	460a      	mov	r2, r1
 800d4b2:	e001      	b.n	800d4b8 <strspn+0x18>
 800d4b4:	429c      	cmp	r4, r3
 800d4b6:	d006      	beq.n	800d4c6 <strspn+0x26>
 800d4b8:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800d4bc:	2b00      	cmp	r3, #0
 800d4be:	d1f9      	bne.n	800d4b4 <strspn+0x14>
 800d4c0:	1a28      	subs	r0, r5, r0
 800d4c2:	bc70      	pop	{r4, r5, r6}
 800d4c4:	4770      	bx	lr
 800d4c6:	f815 4f01 	ldrb.w	r4, [r5, #1]!
 800d4ca:	2c00      	cmp	r4, #0
 800d4cc:	d1ed      	bne.n	800d4aa <strspn+0xa>
 800d4ce:	e7f7      	b.n	800d4c0 <strspn+0x20>
 800d4d0:	4620      	mov	r0, r4
 800d4d2:	e7f6      	b.n	800d4c2 <strspn+0x22>
	...

0800d4e0 <ram_areas>:
 800d4e0:	f69c 0800 30d0 2000 30d0 2000 30d0 2000     .....0. .0. .0. 
 800d4f0:	f69c 0800 0000 0000 0000 0000 0000 0000     ................
 800d500:	f69c 0800 0000 0000 0000 0000 0000 0000     ................
 800d510:	f69c 0800 0000 0000 0000 0000 0000 0000     ................
 800d520:	f69c 0800 0000 0000 0000 0000 0000 0000     ................
 800d530:	f69c 0800 0000 0000 0000 0000 0000 0000     ................
 800d540:	f69c 0800 0000 0000 0000 0000 0000 0000     ................
 800d550:	f69c 0800 0000 0000 0000 0000 0000 0000     ................

0800d560 <vmt>:
 800d560:	3741 0800 3721 0800 3781 0800 3761 0800     A7..!7...7..a7..
 800d570:	3771 0800 3751 0800 3731 0800 3711 0800     q7..Q7..17...7..

0800d580 <vmt>:
 800d580:	39d1 0800 39b1 0800 3931 0800 38f1 0800     .9...9..19...8..
 800d590:	3911 0800 38d1 0800 38b1 0800 3891 0800     .9...8...8...8..

0800d5a0 <zero_status>:
	...

0800d5b0 <active_status>:
	...

0800d5c0 <halted_status>:
 800d5c0:	0001 0000 0000 0000 0000 0000 0000 0000     ................

0800d5d0 <_stm32_dma_streams>:
 800d5d0:	0000 4002 0008 4002 0001 0000 0000 0000     ...@...@........
 800d5e0:	0000 000b 0000 4002 001c 4002 0002 0000     .......@...@....
 800d5f0:	0000 0000 0104 000c 0000 4002 0030 4002     ...........@0..@
 800d600:	0004 0000 0000 0000 0208 000d 0000 4002     ...............@
 800d610:	0044 4002 0008 0000 0000 0000 030c 000e     D..@............
 800d620:	0000 4002 0058 4002 0010 0000 0000 0000     ...@X..@........
 800d630:	0410 000f 0000 4002 006c 4002 0020 0000     .......@l..@ ...
 800d640:	0000 0000 0514 0010 0000 4002 0080 4002     ...........@...@
 800d650:	0040 0000 0000 0000 0618 0011 0400 4002     @..............@
 800d660:	0408 4002 0080 0000 0000 0000 0700 0038     ...@..........8.
 800d670:	0400 4002 041c 4002 0100 0000 0000 0000     ...@...@........
 800d680:	0804 0039 0400 4002 0430 4002 0200 0000     ..9....@0..@....
 800d690:	0000 0000 0908 003a 0400 4002 0444 4002     ......:....@D..@
 800d6a0:	0c00 0000 0000 0000 0a0c 003b 0400 4002     ..........;....@
 800d6b0:	0458 4002 0c00 0000 0000 0000 0b10 003b     X..@..........;.

0800d6c0 <cfgtab.7063>:
 800d6c0:	0204 0804 0008 0703 0808 0808 0808 0808     ................
 800d6d0:	0f0b 0000 0000 0000 0000 0000 0000 0000     ................
 800d6e0:	4d44 2041 6166 6c69 7275 0065 0000 0000     DMA failure.....

0800d6f0 <default_config>:
 800d6f0:	e100 0000 0000 4000 0000 0000 0000 0000     .......@........

0800d700 <ep0config>:
 800d700:	0000 0000 3e41 0800 4151 0800 4201 0800     ....A>..QA...B..
 800d710:	0040 0040 15c4 2000 15c4 2000 0001 0000     @.@.... ... ....
 800d720:	15d4 2000 0000 0000 0000 0000 0000 0000     ... ............

0800d730 <pal_default_config>:
 800d730:	ffff ffff aaaa aa08 4000 a884 ffff ffff     .........@......
 800d740:	48aa ff24 ffaa 8822 ffff ffff 8000 aa88     .H$...".........
 800d750:	4aaa 8888 ffff ffff 8844 8888 8888 8888     .J......D.......
 800d760:	ffff ffff 8888 8888 8888 8888 ffff ffff     ................
 800d770:	8888 8888 8888 8888 ffff ffff 8888 8888     ................
 800d780:	8888 8888 0000 0000 0000 0000 0000 0000     ................

0800d790 <wa>:
 800d790:	15f8 2000 1738 2000 1878 2000 19b8 2000     ... 8.. x.. ... 
 800d7a0:	1af8 2000 0000 0000 0000 0000 0000 0000     ... ............

0800d7b0 <patterns>:
 800d7b0:	dfe0 0800 da20 0800 db00 0800 dc70 0800     .... .......p...
 800d7c0:	dcd0 0800 dce0 0800 dd20 0800 ddd0 0800     ........ .......
 800d7d0:	de40 0800 def0 0800 df50 0800 e000 0800     @.......P.......
	...
 800d7f0:	2a2a 202a 654b 6e72 6c65 203a 2020 2020     *** Kernel:     
 800d800:	2020 0000 2a2a 202a 6f43 706d 6c69 6465       ..*** Compiled
 800d810:	203a 2020 2020 0000 2a2a 202a 6f43 706d     :     ..*** Comp
 800d820:	6c69 7265 203a 2020 2020 0000 2a2a 202a     iler:     ..*** 
 800d830:	7241 6863 7469 6365 7574 6572 203a 0000     Architecture: ..
 800d840:	2a2a 202a 6f43 6572 5620 7261 6169 746e     *** Core Variant
 800d850:	203a 0000 2a2a 202a 6f50 7472 4920 666e     : ..*** Port Inf
 800d860:	3a6f 2020 2020 0000 2a2a 202a 6c50 7461     o:    ..*** Plat
 800d870:	6f66 6d72 203a 2020 2020 0000 2a2a 202a     form:     ..*** 
 800d880:	6554 7473 4220 616f 6472 203a 2020 0000     Test Board:   ..
 800d890:	2d2d 202d 6554 7473 4320 7361 2065 0000     --- Test Case ..
 800d8a0:	2820 0000 2d2d 202d 6552 7573 746c 203a      (..--- Result: 
 800d8b0:	4146 4c49 5255 2045 2328 0000 5b20 0000     FAILURE (#.. [..
 800d8c0:	6946 616e 206c 6572 7573 746c 203a 0000     Final result: ..
 800d8d0:	2a2a 202a 6843 6269 4f69 2f53 5452 7420     *** ChibiOS/RT t
 800d8e0:	7365 2074 7573 7469 0065 0000 2a2a 002a     est suite...***.
 800d8f0:	0029 0000 295d 0000 2d2d 202d 6552 7573     )...])..--- Resu
 800d900:	746c 203a 5553 4343 5345 0053 4146 4c49     lt: SUCCESS.FAIL
 800d910:	5255 0045 2e33 2e31 0034 0000 6f4e 2076     URE.3.1.4...Nov 
 800d920:	3031 3220 3130 2036 202d 3930 313a 3a37     10 2016 - 09:17:
 800d930:	3132 0000 4347 2043 2e34 2e39 2033 3032     21..GCC 4.9.3 20
 800d940:	3531 3530 3932 2820 6572 656c 7361 2965     150529 (release)
 800d950:	5b20 5241 2f4d 6d65 6562 6464 6465 342d      [ARM/embedded-4
 800d960:	395f 622d 6172 636e 2068 6572 6976 6973     _9-branch revisi
 800d970:	6e6f 3220 3432 3832 5d38 0000 5241 764d     on 224288]..ARMv
 800d980:	2d37 004d 6f43 7472 7865 4d2d 0033 0000     7-M.Cortex-M3...
 800d990:	6441 6176 636e 6465 6b20 7265 656e 206c     Advanced kernel 
 800d9a0:	6f6d 6564 0000 0000 5453 334d 4632 3031     mode....STM32F10
 800d9b0:	2078 6550 6672 726f 616d 636e 2065 694c     x Performance Li
 800d9c0:	656e 4820 6769 2068 6544 736e 7469 0079     ne High Density.
 800d9d0:	7453 726f 336d 2032 3176 332e 0031 0000     Storm32 v1.31...

0800d9e0 <testthd1>:
 800d9e0:	daa0 0800 0000 0000 0000 0000 6281 0800     .............b..

0800d9f0 <testthd2>:
 800d9f0:	da84 0800 0000 0000 0000 0000 6361 0800     ............ac..

0800da00 <testthd3>:
 800da00:	da68 0800 0000 0000 0000 0000 6441 0800     h...........Ad..

0800da10 <testthd4>:
 800da10:	da58 0800 0000 0000 0000 0000 6571 0800     X...........qe..

0800da20 <patternthd>:
 800da20:	d9e0 0800 d9f0 0800 da00 0800 da10 0800     ................
	...
 800da40:	0044 0000 0043 0000 0042 0000 0041 0000     D...C...B...A...
 800da50:	4241 4443 0045 0000 6854 6572 6461 2c73     ABCDE...Threads,
 800da60:	6420 6c65 7961 0073 6854 6572 6461 2c73      delays.Threads,
 800da70:	7020 6972 726f 7469 2079 6863 6e61 6567      priority change
 800da80:	0000 0000 6854 6572 6461 2c73 6520 716e     ....Threads, enq
 800da90:	6575 6975 676e 7420 7365 2074 3223 0000     ueuing test #2..
 800daa0:	6854 6572 6461 2c73 6520 716e 6575 6975     Threads, enqueui
 800dab0:	676e 7420 7365 2074 3123 0000 0000 0000     ng test #1......

0800dac0 <testsem1>:
 800dac0:	db78 0800 67d1 0800 0000 0000 6631 0800     x....g......1f..

0800dad0 <testsem2>:
 800dad0:	db64 0800 67e1 0800 0000 0000 6831 0800     d....g......1h..

0800dae0 <testsem3>:
 800dae0:	db44 0800 67f1 0800 0000 0000 6991 0800     D....g.......i..

0800daf0 <testsem4>:
 800daf0:	db20 0800 0000 0000 0000 0000 6a61 0800      ...........aj..

0800db00 <patternsem>:
 800db00:	dac0 0800 dad0 0800 dae0 0800 daf0 0800     ................
	...
 800db20:	6942 616e 7972 5320 6d65 7061 6f68 6572     Binary Semaphore
 800db30:	2c73 6620 6e75 7463 6f69 616e 696c 7974     s, functionality
 800db40:	0000 0000 6553 616d 6870 726f 7365 202c     ....Semaphores, 
 800db50:	7461 6d6f 6369 7320 6769 616e 2d6c 6177     atomic signal-wa
 800db60:	7469 0000 6553 616d 6870 726f 7365 202c     it..Semaphores, 
 800db70:	6974 656d 756f 0074 6553 616d 6870 726f     timeout.Semaphor
 800db80:	7365 202c 6e65 7571 7565 6e69 0067 0000     es, enqueuing...

0800db90 <testmtx5>:
 800db90:	dc18 0800 6d01 0800 0000 0000 6fb1 0800     .....m.......o..

0800dba0 <testmtx6>:
 800dba0:	dc00 0800 7191 0800 0000 0000 7071 0800     .....q......qp..

0800dbb0 <testmtx7>:
 800dbb0:	dbe8 0800 71b1 0800 0000 0000 7201 0800     .....q.......r..

0800dbc0 <testmtx8>:
 800dbc0:	dbd4 0800 71d1 0800 0000 0000 72c1 0800     .....q.......r..
 800dbd0:	4241 0043 6f43 646e 6156 2c72 6220 6f6f     ABC.CondVar, boo
 800dbe0:	7473 7420 7365 0074 6f43 646e 6156 2c72     st test.CondVar,
 800dbf0:	6220 6f72 6461 6163 7473 7420 7365 0074      broadcast test.
 800dc00:	6f43 646e 6156 2c72 7320 6769 616e 206c     CondVar, signal 
 800dc10:	6574 7473 0000 0000 754d 6574 6578 2c73     test....Mutexes,
 800dc20:	7320 6174 7574 0073 754d 6574 6578 2c73      status.Mutexes,
 800dc30:	7020 6972 726f 7469 2079 6572 7574 6e72      priority return
 800dc40:	0000 0000 754d 6574 6578 2c73 7020 6972     ....Mutexes, pri
 800dc50:	726f 7469 2079 6e65 7571 7565 6e69 2067     ority enqueuing 
 800dc60:	6574 7473 0000 0000 0000 0000 0000 0000     test............

0800dc70 <patternmtx>:
 800dc70:	dc90 0800 dca0 0800 db90 0800 dba0 0800     ................
 800dc80:	dbb0 0800 dbc0 0800 0000 0000 0000 0000     ................

0800dc90 <testmtx1>:
 800dc90:	dc44 0800 6cd1 0800 0000 0000 6bb1 0800     D....l.......k..

0800dca0 <testmtx4>:
 800dca0:	dc28 0800 6ce1 0800 0000 0000 6d51 0800     (....l......Qm..

0800dcb0 <testmsg1>:
 800dcb0:	dcc0 0800 0000 0000 0000 0000 73a1 0800     .............s..
 800dcc0:	654d 7373 6761 7365 202c 6f6c 706f 0000     Messages, loop..

0800dcd0 <patternmsg>:
 800dcd0:	dcb0 0800 0000 0000 0000 0000 0000 0000     ................

0800dce0 <patternmbox>:
 800dce0:	dd10 0800 0000 0000 0000 0000 0000 0000     ................
 800dcf0:	614d 6c69 6f62 6578 2c73 7120 6575 6975     Mailboxes, queui
 800dd00:	676e 6120 646e 7420 6d69 6f65 7475 0073     ng and timeouts.

0800dd10 <testmbox1>:
 800dd10:	dcf0 0800 7a11 0800 0000 0000 7441 0800     .....z......At..

0800dd20 <patternevt>:
 800dd20:	dda0 0800 dd30 0800 ddc0 0800 0000 0000     ....0...........

0800dd30 <testevt2>:
 800dd30:	dd54 0800 7b01 0800 0000 0000 7b21 0800     T....{......!{..
 800dd40:	7645 6e65 7374 202c 6974 656d 756f 7374     Events, timeouts
 800dd50:	0000 0000 7645 6e65 7374 202c 6177 7469     ....Events, wait
 800dd60:	6120 646e 6220 6f72 6461 6163 7473 0000      and broadcast..
 800dd70:	7645 6e65 7374 202c 6572 6967 7473 6172     Events, registra
 800dd80:	6974 6e6f 6120 646e 6420 7369 6170 6374     tion and dispatc
 800dd90:	0068 0000 0000 0000 0000 0000 0000 0000     h...............

0800dda0 <testevt1>:
 800dda0:	dd70 0800 7af1 0800 0000 0000 7a61 0800     p....z......az..

0800ddb0 <evhndl>:
 800ddb0:	7a51 0800 7a41 0800 7a31 0800 0000 0000     Qz..Az..1z......

0800ddc0 <testevt3>:
 800ddc0:	dd40 0800 7b11 0800 0000 0000 7e11 0800     @....{.......~..

0800ddd0 <patternheap>:
 800ddd0:	de10 0800 0000 0000 0000 0000 0000 0000     ................
 800dde0:	6548 7061 202c 6c61 6f6c 6163 6974 6e6f     Heap, allocation
 800ddf0:	6120 646e 6620 6172 6d67 6e65 6174 6974      and fragmentati
 800de00:	6e6f 7420 7365 0074 0000 0000 0000 0000     on test.........

0800de10 <testheap1>:
 800de10:	dde0 0800 8101 0800 0000 0000 7eb1 0800     .............~..
 800de20:	654d 6f6d 7972 5020 6f6f 736c 202c 7571     Memory Pools, qu
 800de30:	7565 2f65 6564 7571 7565 0065 0000 0000     eue/dequeue.....

0800de40 <patternpools>:
 800de40:	de50 0800 0000 0000 0000 0000 0000 0000     P...............

0800de50 <testpools1>:
 800de50:	de20 0800 8131 0800 0000 0000 8141 0800      ...1.......A...

0800de60 <testdyn1>:
 800de60:	debc 0800 8311 0800 0000 0000 8201 0800     ................

0800de70 <testdyn2>:
 800de70:	de8c 0800 8431 0800 0000 0000 8331 0800     ....1.......1...
 800de80:	4241 0000 4241 4443 0000 0000 7944 616e     AB..ABCD....Dyna
 800de90:	696d 2063 5041 7349 202c 6874 6572 6461     mic APIs, thread
 800dea0:	2073 7263 6165 6974 6e6f 6620 6f72 206d     s creation from 
 800deb0:	656d 6f6d 7972 7020 6f6f 006c 7944 616e     memory pool.Dyna
 800dec0:	696d 2063 5041 7349 202c 6874 6572 6461     mic APIs, thread
 800ded0:	2073 7263 6165 6974 6e6f 6620 6f72 206d     s creation from 
 800dee0:	6568 7061 0000 0000 0000 0000 0000 0000     heap............

0800def0 <patterndyn>:
 800def0:	de60 0800 de70 0800 0000 0000 0000 0000     `...p...........

0800df00 <testqueues1>:
 800df00:	df38 0800 8461 0800 0000 0000 84d1 0800     8...a...........

0800df10 <testqueues2>:
 800df10:	df20 0800 84a1 0800 0000 0000 8741 0800      ...........A...
 800df20:	7551 7565 7365 202c 756f 7074 7475 7120     Queues, output q
 800df30:	6575 6575 0073 0000 7551 7565 7365 202c     ueues...Queues, 
 800df40:	6e69 7570 2074 7571 7565 7365 0000 0000     input queues....

0800df50 <patternqueues>:
 800df50:	df00 0800 df10 0800 0000 0000 0000 0000     ................

0800df60 <testsys1>:
 800df60:	dfc0 0800 0000 0000 0000 0000 8a51 0800     ............Q...

0800df70 <testsys2>:
 800df70:	dfa4 0800 0000 0000 0000 0000 8981 0800     ................

0800df80 <testsys3>:
 800df80:	df90 0800 0000 0000 0000 0000 89c1 0800     ................
 800df90:	7953 7473 6d65 202c 6e69 6574 7267 7469     System, integrit
 800dfa0:	0079 0000 7953 7473 6d65 202c 6e69 6574     y...System, inte
 800dfb0:	7272 7075 7374 6820 6e61 6c64 6e69 0067     rrupts handling.
 800dfc0:	7953 7473 6d65 202c 7263 7469 6369 6c61     System, critical
 800dfd0:	7a20 6e6f 7365 0000 0000 0000 0000 0000      zones..........

0800dfe0 <patternsys>:
 800dfe0:	df60 0800 df70 0800 df80 0800 0000 0000     `...p...........

0800dff0 <testbmk8>:
 800dff0:	e250 0800 0000 0000 0000 0000 9161 0800     P...........a...

0800e000 <patternbmk>:
 800e000:	e360 0800 e040 0800 e070 0800 e060 0800     `...@...p...`...
 800e010:	e3a0 0800 e3b0 0800 e3c0 0800 dff0 0800     ................
 800e020:	e350 0800 e050 0800 e370 0800 e380 0800     P...P...p.......
 800e030:	e390 0800 0000 0000 0000 0000 0000 0000     ................

0800e040 <testbmk2>:
 800e040:	e318 0800 0000 0000 0000 0000 8d41 0800     ............A...

0800e050 <testbmk10>:
 800e050:	e208 0800 0000 0000 0000 0000 9321 0800     ............!...

0800e060 <testbmk4>:
 800e060:	e2e4 0800 0000 0000 0000 0000 8ea1 0800     ................

0800e070 <testbmk3>:
 800e070:	e300 0800 0000 0000 0000 0000 8db1 0800     ................
 800e080:	2d2d 202d 7953 7473 6d65 203a 0000 0000     --- System: ....
 800e090:	6220 7479 7365 0000 2d2d 202d 6854 6572      bytes..--- Thre
 800e0a0:	6461 203a 0000 0000 2d2d 202d 6954 656d     ad: ....--- Time
 800e0b0:	2072 203a 0000 0000 2d2d 202d 6553 616d     r : ....--- Sema
 800e0c0:	6870 203a 0000 0000 2d2d 202d 7645 6e65     ph: ....--- Even
 800e0d0:	5374 203a 0000 0000 2d2d 202d 7645 6e65     tS: ....--- Even
 800e0e0:	4c74 203a 0000 0000 2d2d 202d 754d 6574     tL: ....--- Mute
 800e0f0:	2078 203a 0000 0000 2d2d 202d 6f43 646e     x : ....--- Cond
 800e100:	2e56 203a 0000 0000 2d2d 202d 7551 7565     V.: ....--- Queu
 800e110:	2065 203a 0000 0000 2d2d 202d 614d 6c69     e : ....--- Mail
 800e120:	2e42 203a 0000 0000 2d2d 202d 6353 726f     B.: ....--- Scor
 800e130:	2065 203a 0000 0000 7420 7268 6165 7364     e : .... threads
 800e140:	532f 0000 6d20 6773 2f73 2c53 0020 0000     /S.. msgs/S, ...
 800e150:	6320 7874 7773 2f63 0053 0000 7220 7365      ctxswc/S... res
 800e160:	6863 6465 6c75 7365 532f 202c 0000 0000     chedules/S, ....
 800e170:	6220 7479 7365 532f 0000 0000 7420 6d69      bytes/S.... tim
 800e180:	7265 2f73 0053 0000 7720 6961 2b74 6973     ers/S... wait+si
 800e190:	6e67 6c61 532f 0000 6c20 636f 2b6b 6e75     gnal/S.. lock+un
 800e1a0:	6f6c 6b63 532f 0000 6542 636e 6d68 7261     lock/S..Benchmar
 800e1b0:	2c6b 5220 4d41 6620 6f6f 7074 6972 746e     k, RAM footprint
 800e1c0:	0000 0000 6542 636e 6d68 7261 2c6b 6d20     ....Benchmark, m
 800e1d0:	7475 7865 7365 6c20 636f 2f6b 6e75 6f6c     utexes lock/unlo
 800e1e0:	6b63 0000 6542 636e 6d68 7261 2c6b 7320     ck..Benchmark, s
 800e1f0:	6d65 7061 6f68 6572 2073 6177 7469 732f     emaphores wait/s
 800e200:	6769 616e 006c 0000 6542 636e 6d68 7261     ignal...Benchmar
 800e210:	2c6b 7620 7269 7574 6c61 7420 6d69 7265     k, virtual timer
 800e220:	2073 6573 2f74 6572 6573 0074 6542 636e     s set/reset.Benc
 800e230:	6d68 7261 2c6b 4920 4f2f 5120 6575 6575     hmark, I/O Queue
 800e240:	2073 6874 6f72 6775 7068 7475 0000 0000     s throughput....
 800e250:	6542 636e 6d68 7261 2c6b 7220 756f 646e     Benchmark, round
 800e260:	7220 626f 6e69 6320 6e6f 6574 7478 7320      robin context s
 800e270:	6977 6374 6968 676e 0000 0000 6542 636e     witching....Benc
 800e280:	6d68 7261 2c6b 6d20 7361 2073 6572 6373     hmark, mass resc
 800e290:	6568 7564 656c 202c 2035 6874 6572 6461     hedule, 5 thread
 800e2a0:	0073 0000 6542 636e 6d68 7261 2c6b 7420     s...Benchmark, t
 800e2b0:	7268 6165 7364 202c 7263 6165 6574 6f20     hreads, create o
 800e2c0:	6c6e 0079 6542 636e 6d68 7261 2c6b 7420     nly.Benchmark, t
 800e2d0:	7268 6165 7364 202c 7566 6c6c 6320 6379     hreads, full cyc
 800e2e0:	656c 0000 6542 636e 6d68 7261 2c6b 6320     le..Benchmark, c
 800e2f0:	6e6f 6574 7478 7320 6977 6374 0068 0000     ontext switch...
 800e300:	6542 636e 6d68 7261 2c6b 6d20 7365 6173     Benchmark, messa
 800e310:	6567 2073 3323 0000 6542 636e 6d68 7261     ges #3..Benchmar
 800e320:	2c6b 6d20 7365 6173 6567 2073 3223 0000     k, messages #2..
 800e330:	6542 636e 6d68 7261 2c6b 6d20 7365 6173     Benchmark, messa
 800e340:	6567 2073 3123 0000 0000 0000 0000 0000     ges #1..........

0800e350 <testbmk9>:
 800e350:	e22c 0800 0000 0000 0000 0000 9271 0800     ,...........q...

0800e360 <testbmk1>:
 800e360:	e330 0800 0000 0000 0000 0000 8cd1 0800     0...............

0800e370 <testbmk11>:
 800e370:	e1e4 0800 9151 0800 0000 0000 93a1 0800     ....Q...........

0800e380 <testbmk12>:
 800e380:	e1c4 0800 9481 0800 0000 0000 9411 0800     ................

0800e390 <testbmk13>:
 800e390:	e1a8 0800 0000 0000 0000 0000 8b11 0800     ................

0800e3a0 <testbmk5>:
 800e3a0:	e2c4 0800 0000 0000 0000 0000 8f91 0800     ................

0800e3b0 <testbmk6>:
 800e3b0:	e2a4 0800 0000 0000 0000 0000 8c21 0800     ............!...

0800e3c0 <testbmk7>:
 800e3c0:	e27c 0800 9141 0800 0000 0000 9011 0800     |...A...........
 800e3d0:	7355 6761 3a65 2520 0d73 000a 7973 7473     Usage: %s...syst
 800e3e0:	6d69 0065 6c25 0d75 000a 0000 6e69 6f66     ime.%lu.....info
 800e3f0:	0000 0000 654b 6e72 6c65 203a 2020 2020     ....Kernel:     
 800e400:	2020 7325 0a0d 0000 6f43 706d 6c69 7265       %s....Compiler
 800e410:	203a 2020 2020 7325 0a0d 0000 7241 6863     :     %s....Arch
 800e420:	7469 6365 7574 6572 203a 7325 0a0d 0000     itecture: %s....
 800e430:	6f43 6572 5620 7261 6169 746e 203a 7325     Core Variant: %s
 800e440:	0a0d 0000 6f50 7472 4920 666e 3a6f 2020     ....Port Info:  
 800e450:	2020 7325 0a0d 0000 6c50 7461 6f66 6d72       %s....Platform
 800e460:	203a 2020 2020 7325 0a0d 0000 6f42 7261     :     %s....Boar
 800e470:	3a64 2020 2020 2020 2020 7325 0a0d 0000     d:        %s....
 800e480:	7542 6c69 2064 6974 656d 203a 2020 7325     Build time:   %s
 800e490:	7325 7325 0a0d 0000 6f4e 2076 3031 3220     %s%s....Nov 10 2
 800e4a0:	3130 0036 2d20 0020 3930 313a 3a37 3332     016. - .09:17:23
 800e4b0:	0000 0000 0920 0000 445e 0000 0a0d 6843     .... ...^D....Ch
 800e4c0:	6269 4f69 2f53 5452 5320 6568 6c6c 0a0d     ibiOS/RT Shell..
 800e4d0:	0000 0000 6863 203e 0000 0000 0a0d 6f6c     ....ch> ......lo
 800e4e0:	6f67 7475 0000 0000 6f74 206f 616d 796e     gout....too many
 800e4f0:	6120 6772 6d75 6e65 7374 0a0d 0000 0000      arguments......
 800e500:	7865 7469 0000 0000 6568 706c 0000 0000     exit....help....
 800e510:	6f43 6d6d 6e61 7364 203a 6568 706c 6520     Commands: help e
 800e520:	6978 2074 0000 0000 7325 0020 7325 0000     xit ....%s .%s..
 800e530:	3f20 0a0d 0000 0000 0000 0000 0000 0000      ?..............
 800e540:	6e28 6c75 296c 0000 0000 0000 0000 0000     (null)..........

0800e550 <pow10>:
 800e550:	000a 0000 0064 0000 03e8 0000 2710 0000     ....d........'..
 800e560:	86a0 0001 4240 000f 9680 0098 e100 05f5     ....@B..........
 800e570:	ca00 3b9a 0000 0000 0000 0000 0000 0000     ...;............

0800e580 <i2cfg_d2>:
 800e580:	0001 0000 1a80 0006 0002 0000 0000 0000     ................

0800e590 <shell_cfg1>:
 800e590:	2bc0 2000 e5a0 0800 0000 0000 0000 0000     .+. ............

0800e5a0 <commands>:
 800e5a0:	e6ac 0800 af61 0800 e6b0 0800 ad41 0800     ....a.......A...
 800e5b0:	dc60 0800 af11 0800 e6b8 0800 aec1 0800     `...............
	...
 800e5d0:	3269 6363 6363 0a63 0000 0000 7220 7365     i2ccccc..... res
 800e5e0:	6174 7472 6920 6332 000a 0000 0a0d 730a     tart i2c.......s
 800e5f0:	6f74 7070 6465 0a0d 0000 0000 7355 6761     topped......Usag
 800e600:	3a65 7720 6972 6574 0a0d 0000 7355 6761     e: write....Usag
 800e610:	3a65 7420 7365 0d74 000a 0000 756f 2074     e: test.....out 
 800e620:	666f 6d20 6d65 726f 0d79 000a 7355 6761     of memory...Usag
 800e630:	3a65 6d20 6d65 0a0d 0000 0000 6f63 6572     e: mem......core
 800e640:	6620 6572 2065 656d 6f6d 7972 3a20 2520      free memory : %
 800e650:	2075 7962 6574 0d73 000a 0000 6568 7061     u bytes.....heap
 800e660:	6620 6172 6d67 6e65 7374 2020 3a20 2520      fragments   : %
 800e670:	0d75 000a 6568 7061 6620 6572 2065 6f74     u...heap free to
 800e680:	6174 206c 3a20 2520 2075 7962 6574 0d73     tal  : %u bytes.
 800e690:	000a 0000 6170 696d 6365 4f20 0a4b 0000     ....pamiec OK...
 800e6a0:	6170 696d 6365 5a20 454c 000a 656d 006d     pamiec ZLE..mem.
 800e6b0:	6874 6572 6461 0073 7277 7469 0065 0000     threads.write...
 800e6c0:	4949 3649 3530 2030 6e69 7469 000a 0000     III6050 init....
 800e6d0:	4949 3649 3530 2030 6f6e 2074 4b4f 000a     III6050 not OK..
 800e6e0:	3a45 706d 3675 3530 6930 742d 3178 0000     E:mpu6050i-tx1..
 800e6f0:	4949 3649 3530 2030 6f6e 2074 4b4f 0a32     III6050 not OK2.
 800e700:	0000 0000 3a45 706d 3675 3530 6930 722d     ....E:mpu6050i-r
 800e710:	7473 0000 3a45 706d 3675 3530 6930 632d     st..E:mpu6050i-c
 800e720:	6766 0000 3a45 706d 3675 3530 6730 646e     fg..E:mpu6050gnd
 800e730:	0000 0000 2567 2044 0000 0000 2567 0d44     ....g%D ....g%D.
	...

0800e750 <ep1config>:
 800e750:	0002 0000 0000 0000 3b11 0800 3ba1 0800     .........;...;..
 800e760:	0040 0040 3048 2000 3058 2000 0001 0000     @.@.H0. X0. ....
	...

0800e780 <vcom_configuration_descriptor>:
 800e780:	0043 0000 e7d0 0800 0000 0000 0000 0000     C...............

0800e790 <ep2config>:
 800e790:	0003 0000 0000 0000 3be1 0800 0000 0000     .........;......
 800e7a0:	0010 0000 2bb0 2000 0000 0000 0001 0000     .....+. ........
	...

0800e7c0 <usbcfg>:
 800e7c0:	b9c1 0800 b991 0800 3ad1 0800 0000 0000     .........:......

0800e7d0 <vcom_configuration_descriptor_data>:
 800e7d0:	0209 0043 0102 c000 0932 0004 0100 0202     ..C.....2.......
 800e7e0:	0001 2405 1000 0501 0124 0100 2404 0202     ...$....$....$..
 800e7f0:	2405 0006 0701 8205 0803 ff00 0409 0001     .$..............
 800e800:	0a02 0000 0700 0105 4002 0000 0507 0281     .........@......
 800e810:	0040 0000 0000 0000 0000 0000 0000 0000     @...............

0800e820 <vcom_device_descriptor_data>:
 800e820:	0112 0110 0002 4000 0483 5740 0200 0201     .......@..@W....
 800e830:	0103 0000 0000 0000 0000 0000 0000 0000     ................

0800e840 <vcom_string0>:
 800e840:	0304 0409 0000 0000 0000 0000 0000 0000     ................

0800e850 <vcom_string1>:
 800e850:	0326 0053 0054 004d 0069 0063 0072 006f     &.S.T.M.i.c.r.o.
 800e860:	0065 006c 0065 0063 0074 0072 006f 006e     e.l.e.c.t.r.o.n.
 800e870:	0069 0063 0073 0000 0000 0000 0000 0000     i.c.s...........

0800e880 <vcom_string2>:
 800e880:	0338 0043 0068 0069 0062 0069 004f 0053     8.C.h.i.b.i.O.S.
 800e890:	002f 0052 0054 0020 0056 0069 0072 0074     /.R.T. .V.i.r.t.
 800e8a0:	0075 0061 006c 0020 0043 004f 004d 0020     u.a.l. .C.O.M. .
 800e8b0:	0050 006f 0072 0074 0000 0000 0000 0000     P.o.r.t.........

0800e8c0 <vcom_string3>:
 800e8c0:	0308 0033 0031 0034 0000 0000 0000 0000     ..3.1.4.........

0800e8d0 <vcom_strings>:
 800e8d0:	0004 0000 e840 0800 0026 0000 e850 0800     ....@...&...P...
 800e8e0:	0038 0000 e880 0800 0008 0000 e8c0 0800     8...............

0800e8f0 <serusbcfg>:
 800e8f0:	153c 2000 0101 0002 0000 0000 0000 0000     <.. ............

0800e900 <vcom_device_descriptor>:
 800e900:	0012 0000 e820 0800 0000 0000 0000 0000     .... ...........
 800e910:	7361 6e69 0066 0000 0000 0000 0000 0000     asinf...........
 800e920:	6d66 646f 0066 0000 0000 0000 0000 0000     fmodf...........

0800e930 <Zero>:
 800e930:	0000 0000 0000 8000 0000 0000 0000 0000     ................

0800e940 <npio2_hw>:
 800e940:	0f00 3fc9 0f00 4049 cb00 4096 0f00 40c9     ...?..I@...@...@
 800e950:	5300 40fb cb00 4116 ed00 412f 0f00 4149     .S.@...A../A..IA
 800e960:	3100 4162 5300 417b 3a00 418a cb00 4196     .1bA.S{A.:.A...A
 800e970:	5c00 41a3 ed00 41af 7e00 41bc 0f00 41c9     .\.A...A.~.A...A
 800e980:	a000 41d5 3100 41e2 c200 41ee 5300 41fb     ...A.1.A...A.S.A
 800e990:	f200 4203 3a00 420a 8300 4210 cb00 4216     ...B.:.B...B...B
 800e9a0:	1400 421d 5c00 4223 a500 4229 ed00 422f     ...B.\#B..)B../B
 800e9b0:	3600 4236 7e00 423c c700 4242 0f00 4249     .66B.~<B..BB..IB

0800e9c0 <two_over_pi>:
 800e9c0:	00a2 0000 00f9 0000 0083 0000 006e 0000     ............n...
 800e9d0:	004e 0000 0044 0000 0015 0000 0029 0000     N...D.......)...
 800e9e0:	00fc 0000 0027 0000 0057 0000 00d1 0000     ....'...W.......
 800e9f0:	00f5 0000 0034 0000 00dd 0000 00c0 0000     ....4...........
 800ea00:	00db 0000 0062 0000 0095 0000 0099 0000     ....b...........
 800ea10:	003c 0000 0043 0000 0090 0000 0041 0000     <...C.......A...
 800ea20:	00fe 0000 0051 0000 0063 0000 00ab 0000     ....Q...c.......
 800ea30:	00de 0000 00bb 0000 00c5 0000 0061 0000     ............a...
 800ea40:	00b7 0000 0024 0000 006e 0000 003a 0000     ....$...n...:...
 800ea50:	0042 0000 004d 0000 00d2 0000 00e0 0000     B...M...........
 800ea60:	0006 0000 0049 0000 002e 0000 00ea 0000     ....I...........
 800ea70:	0009 0000 00d1 0000 0092 0000 001c 0000     ................
 800ea80:	00fe 0000 001d 0000 00eb 0000 001c 0000     ................
 800ea90:	00b1 0000 0029 0000 00a7 0000 003e 0000     ....).......>...
 800eaa0:	00e8 0000 0082 0000 0035 0000 00f5 0000     ........5.......
 800eab0:	002e 0000 00bb 0000 0044 0000 0084 0000     ........D.......
 800eac0:	00e9 0000 009c 0000 0070 0000 0026 0000     ........p...&...
 800ead0:	00b4 0000 005f 0000 007e 0000 0041 0000     ...._...~...A...
 800eae0:	0039 0000 0091 0000 00d6 0000 0039 0000     9...........9...
 800eaf0:	0083 0000 0053 0000 0039 0000 00f4 0000     ....S...9.......
 800eb00:	009c 0000 0084 0000 005f 0000 008b 0000     ........_.......
 800eb10:	00bd 0000 00f9 0000 0028 0000 003b 0000     ........(...;...
 800eb20:	001f 0000 00f8 0000 0097 0000 00ff 0000     ................
 800eb30:	00de 0000 0005 0000 0098 0000 000f 0000     ................
 800eb40:	00ef 0000 002f 0000 0011 0000 008b 0000     ..../...........
 800eb50:	005a 0000 000a 0000 006d 0000 001f 0000     Z.......m.......
 800eb60:	006d 0000 0036 0000 007e 0000 00cf 0000     m...6...~.......
 800eb70:	0027 0000 00cb 0000 0009 0000 00b7 0000     '...............
 800eb80:	004f 0000 0046 0000 003f 0000 0066 0000     O...F...?...f...
 800eb90:	009e 0000 005f 0000 00ea 0000 002d 0000     ...._.......-...
 800eba0:	0075 0000 0027 0000 00ba 0000 00c7 0000     u...'...........
 800ebb0:	00eb 0000 00e5 0000 00f1 0000 007b 0000     ............{...
 800ebc0:	003d 0000 0007 0000 0039 0000 00f7 0000     =.......9.......
 800ebd0:	008a 0000 0052 0000 0092 0000 00ea 0000     ....R...........
 800ebe0:	006b 0000 00fb 0000 005f 0000 00b1 0000     k......._.......
 800ebf0:	001f 0000 008d 0000 005d 0000 0008 0000     ........].......
 800ec00:	0056 0000 0003 0000 0030 0000 0046 0000     V.......0...F...
 800ec10:	00fc 0000 007b 0000 006b 0000 00ab 0000     ....{...k.......
 800ec20:	00f0 0000 00cf 0000 00bc 0000 0020 0000     ............ ...
 800ec30:	009a 0000 00f4 0000 0036 0000 001d 0000     ........6.......
 800ec40:	00a9 0000 00e3 0000 0091 0000 0061 0000     ............a...
 800ec50:	005e 0000 00e6 0000 001b 0000 0008 0000     ^...............
 800ec60:	0065 0000 0099 0000 0085 0000 005f 0000     e..........._...
 800ec70:	0014 0000 00a0 0000 0068 0000 0040 0000     ........h...@...
 800ec80:	008d 0000 00ff 0000 00d8 0000 0080 0000     ................
 800ec90:	004d 0000 0073 0000 0027 0000 0031 0000     M...s...'...1...
 800eca0:	0006 0000 0006 0000 0015 0000 0056 0000     ............V...
 800ecb0:	00ca 0000 0073 0000 00a8 0000 00c9 0000     ....s...........
 800ecc0:	0060 0000 00e2 0000 007b 0000 00c0 0000     `.......{.......
 800ecd0:	008c 0000 006b 0000 0000 0000 0000 0000     ....k...........

0800ece0 <init_jk>:
 800ece0:	0004 0000 0007 0000 0009 0000 0000 0000     ................

0800ecf0 <PIo2>:
 800ecf0:	0000 3fc9 0000 39f0 0000 37da 0000 33a2     ...?...9...7...3
 800ed00:	0000 2e84 0000 2b50 0000 27c2 0000 22d0     ......P+...'..."
 800ed10:	0000 1fc4 0000 1bc6 0000 1744 0000 0000     ..........D.....

0800ed20 <atanlo>:
 800ed20:	3769 31ac 2168 3322 0fb4 3314 2168 33a2     i7.1h!"3...3h!.3

0800ed30 <atanhi>:
 800ed30:	6338 3eed 0fda 3f49 985e 3f7b 0fda 3fc9     8c.>..I?^.{?...?
